{"meta":{"version":1,"warehouse":"3.0.2"},"models":{"Asset":[{"_id":"source/myDoc/L2Dwidget.min.js","path":"myDoc/L2Dwidget.min.js","modified":1,"renderable":0},{"_id":"source/myDoc/waifu.css","path":"myDoc/waifu.css","modified":1,"renderable":0},{"_id":"source/myDoc/index.html","path":"myDoc/index.html","modified":1,"renderable":0},{"_id":"source/myDoc/waifu-tips.js","path":"myDoc/waifu-tips.js","modified":1,"renderable":0},{"_id":"themes/yilia-plus/source/main.a5fda8.js","path":"main.a5fda8.js","modified":1,"renderable":1},{"_id":"themes/yilia-plus/source/slider.27463f.js","path":"slider.27463f.js","modified":1,"renderable":1},{"_id":"themes/yilia-plus/source/main.a5fda8.css","path":"main.a5fda8.css","modified":1,"renderable":1},{"_id":"source/myDoc/live2d.js","path":"myDoc/live2d.js","modified":1,"renderable":0},{"_id":"themes/yilia-plus/source/fonts/default-skin.b257fa.svg","path":"fonts/default-skin.b257fa.svg","modified":1,"renderable":1},{"_id":"themes/yilia-plus/source/fonts/fonteditor.3da1ef.woff","path":"fonts/fonteditor.3da1ef.woff","modified":1,"renderable":1},{"_id":"themes/yilia-plus/source/fonts/fonteditor.86c132.eot","path":"fonts/fonteditor.86c132.eot","modified":1,"renderable":1},{"_id":"themes/yilia-plus/source/fonts/tooltip.4004ff.svg","path":"fonts/tooltip.4004ff.svg","modified":1,"renderable":1},{"_id":"themes/yilia-plus/source/fonts/fonteditor.fe4d8a.ttf","path":"fonts/fonteditor.fe4d8a.ttf","modified":1,"renderable":1},{"_id":"themes/yilia-plus/source/fonts/fonteditor.3e0d4a.svg","path":"fonts/fonteditor.3e0d4a.svg","modified":1,"renderable":1},{"_id":"themes/yilia-plus/source/img/favicon.ico","path":"img/favicon.ico","modified":1,"renderable":1},{"_id":"themes/yilia-plus/source/img/biubiubiu.gif","path":"img/biubiubiu.gif","modified":1,"renderable":1},{"_id":"themes/yilia-plus/source/fonts/fonteditor.bbc4b5.woff2","path":"fonts/fonteditor.bbc4b5.woff2","modified":1,"renderable":1},{"_id":"themes/yilia-plus/source/img/forkme.png","path":"img/forkme.png","modified":1,"renderable":1},{"_id":"themes/yilia-plus/source/img/scrollbar_arrow.png","path":"img/scrollbar_arrow.png","modified":1,"renderable":1},{"_id":"themes/yilia-plus/source/img/gitee.svg","path":"img/gitee.svg","modified":1,"renderable":1},{"_id":"themes/yilia-plus/source/img/preloader.gif","path":"img/preloader.gif","modified":1,"renderable":1},{"_id":"themes/yilia-plus/source/img/touming.jpg","path":"img/touming.jpg","modified":1,"renderable":1},{"_id":"themes/yilia-plus/source/lib/busuanzi.pure.js","path":"lib/busuanzi.pure.js","modified":1,"renderable":1},{"_id":"themes/yilia-plus/source/lib/clickLove.js","path":"lib/clickLove.js","modified":1,"renderable":1},{"_id":"themes/yilia-plus/source/lib/default.css","path":"lib/default.css","modified":1,"renderable":1},{"_id":"themes/yilia-plus/source/img/default-skin.png","path":"img/default-skin.png","modified":1,"renderable":1},{"_id":"themes/yilia-plus/source/lib/gitment.css","path":"lib/gitment.css","modified":1,"renderable":1},{"_id":"themes/yilia-plus/source/lib/oauthcallback.browser.js","path":"lib/oauthcallback.browser.js","modified":1,"renderable":1},{"_id":"themes/yilia-plus/source/lib/snow.js","path":"lib/snow.js","modified":1,"renderable":1},{"_id":"themes/yilia-plus/source/mobile.a2c207.js","path":"mobile.a2c207.js","modified":1,"renderable":1},{"_id":"themes/yilia-plus/source/gitment/APlayer.min.js","path":"gitment/APlayer.min.js","modified":1,"renderable":1},{"_id":"themes/yilia-plus/source/img/touxiang.jpg","path":"img/touxiang.jpg","modified":1,"renderable":1},{"_id":"themes/yilia-plus/source/lib/gitment.js.bak","path":"lib/gitment.js.bak","modified":1,"renderable":1},{"_id":"themes/yilia-plus/source/lib/pace.min.js","path":"lib/pace.min.js","modified":1,"renderable":1},{"_id":"themes/yilia-plus/source/lib/jquery-2.1.4.min.js","path":"lib/jquery-2.1.4.min.js","modified":1,"renderable":1},{"_id":"themes/yilia-plus/source/lib/gitment.js","path":"lib/gitment.js","modified":1,"renderable":1},{"_id":"themes/yilia-plus/source/lib/gitment.js.bak2","path":"lib/gitment.js.bak2","modified":1,"renderable":1},{"_id":"themes/yilia-plus/source/live2d_models/hijiki/package-lock.json","path":"live2d_models/hijiki/package-lock.json","modified":1,"renderable":1},{"_id":"themes/yilia-plus/source/live2d_models/hijiki/package.json","path":"live2d_models/hijiki/package.json","modified":1,"renderable":1},{"_id":"themes/yilia-plus/source/plugins/TweenMax/HoverImg.js","path":"plugins/TweenMax/HoverImg.js","modified":1,"renderable":1},{"_id":"themes/yilia-plus/source/plugins/TweenMax/charming.min.js","path":"plugins/TweenMax/charming.min.js","modified":1,"renderable":1},{"_id":"themes/yilia-plus/source/plugins/ribbon.js/ribbon.js","path":"plugins/ribbon.js/ribbon.js","modified":1,"renderable":1},{"_id":"themes/yilia-plus/source/plugins/live2d-widget.js/L2Dwidget.min.js","path":"plugins/live2d-widget.js/L2Dwidget.min.js","modified":1,"renderable":1},{"_id":"themes/yilia-plus/source/plugins/live2d-widget.js/manifest.json","path":"plugins/live2d-widget.js/manifest.json","modified":1,"renderable":1},{"_id":"themes/yilia-plus/source/plugins/activate-power-mode/activate-power-mode.js","path":"plugins/activate-power-mode/activate-power-mode.js","modified":1,"renderable":1},{"_id":"themes/yilia-plus/source/live2d_models/hijiki/assets/hijiki.model.json","path":"live2d_models/hijiki/assets/hijiki.model.json","modified":1,"renderable":1},{"_id":"themes/yilia-plus/source/live2d_models/hijiki/assets/hijiki.pose.json","path":"live2d_models/hijiki/assets/hijiki.pose.json","modified":1,"renderable":1},{"_id":"themes/yilia-plus/source/plugins/TweenMax/TweenMax.min.js","path":"plugins/TweenMax/TweenMax.min.js","modified":1,"renderable":1},{"_id":"themes/yilia-plus/source/plugins/ribbon.js/ribbon.min.js","path":"plugins/ribbon.js/ribbon.min.js","modified":1,"renderable":1},{"_id":"themes/yilia-plus/source/plugins/ribbon.js/demo/index.html","path":"plugins/ribbon.js/demo/index.html","modified":1,"renderable":1},{"_id":"themes/yilia-plus/source/plugins/live2d-widget.js/L2Dwidget.0.min.js","path":"plugins/live2d-widget.js/L2Dwidget.0.min.js","modified":1,"renderable":1},{"_id":"themes/yilia-plus/source/plugins/live2d-widget.js/L2Dwidget.common.js","path":"plugins/live2d-widget.js/L2Dwidget.common.js","modified":1,"renderable":1},{"_id":"themes/yilia-plus/source/live2d_models/hijiki/assets/mtn/00_idle.mtn","path":"live2d_models/hijiki/assets/mtn/00_idle.mtn","modified":1,"renderable":1},{"_id":"themes/yilia-plus/source/live2d_models/hijiki/assets/mtn/03.mtn","path":"live2d_models/hijiki/assets/mtn/03.mtn","modified":1,"renderable":1},{"_id":"themes/yilia-plus/source/live2d_models/hijiki/assets/mtn/02.mtn","path":"live2d_models/hijiki/assets/mtn/02.mtn","modified":1,"renderable":1},{"_id":"themes/yilia-plus/source/live2d_models/hijiki/assets/mtn/04.mtn","path":"live2d_models/hijiki/assets/mtn/04.mtn","modified":1,"renderable":1},{"_id":"themes/yilia-plus/source/live2d_models/hijiki/assets/mtn/01.mtn","path":"live2d_models/hijiki/assets/mtn/01.mtn","modified":1,"renderable":1},{"_id":"themes/yilia-plus/source/live2d_models/hijiki/assets/mtn/06.mtn","path":"live2d_models/hijiki/assets/mtn/06.mtn","modified":1,"renderable":1},{"_id":"themes/yilia-plus/source/plugins/live2d-widget.js/L2Dwidget.min.js.map","path":"plugins/live2d-widget.js/L2Dwidget.min.js.map","modified":1,"renderable":1},{"_id":"themes/yilia-plus/source/live2d_models/hijiki/assets/mtn/08.mtn","path":"live2d_models/hijiki/assets/mtn/08.mtn","modified":1,"renderable":1},{"_id":"themes/yilia-plus/source/live2d_models/hijiki/assets/mtn/05.mtn","path":"live2d_models/hijiki/assets/mtn/05.mtn","modified":1,"renderable":1},{"_id":"themes/yilia-plus/source/lib/giteement.browser.js","path":"lib/giteement.browser.js","modified":1,"renderable":1},{"_id":"themes/yilia-plus/source/live2d_models/hijiki/assets/moc/hijiki.moc","path":"live2d_models/hijiki/assets/moc/hijiki.moc","modified":1,"renderable":1},{"_id":"themes/yilia-plus/source/live2d_models/hijiki/assets/moc/hijiki.2048/texture_00.png","path":"live2d_models/hijiki/assets/moc/hijiki.2048/texture_00.png","modified":1,"renderable":1},{"_id":"themes/yilia-plus/source/plugins/live2d-widget.js/L2Dwidget.common.js.map","path":"plugins/live2d-widget.js/L2Dwidget.common.js.map","modified":1,"renderable":1},{"_id":"themes/yilia-plus/source/live2d_models/hijiki/assets/mtn/07.mtn","path":"live2d_models/hijiki/assets/mtn/07.mtn","modified":1,"renderable":1},{"_id":"themes/yilia-plus/source/plugins/live2d-widget.js/L2Dwidget.0.min.js.map","path":"plugins/live2d-widget.js/L2Dwidget.0.min.js.map","modified":1,"renderable":1},{"_id":"themes/yilia-plus/source/img/tianping.png","path":"img/tianping.png","modified":1,"renderable":1},{"_id":"themes/yilia-plus/source/img/xiaoniao.gif","path":"img/xiaoniao.gif","modified":1,"renderable":1}],"Cache":[{"_id":"themes/yilia-plus/.babelrc","hash":"db600d40e93e6d8023737a65d58d3be7370e5e30","modified":1597377597722},{"_id":"themes/yilia-plus/.editorconfig","hash":"daaa8757fac18f8735fadd0a37a42c06f421ca14","modified":1597377597734},{"_id":"themes/yilia-plus/.eslintignore","hash":"ed9d8911ca08c3dd5072c48dd0be4d06f8897730","modified":1597377597735},{"_id":"themes/yilia-plus/.gitattributes","hash":"758cfbecfa7919e99abddf3297f37cde7e3d8d4e","modified":1597377597736},{"_id":"themes/yilia-plus/.eslintrc.js","hash":"303d25adf02ad65720e537a16a4a137d14bb755f","modified":1597377597736},{"_id":"themes/yilia-plus/LICENSE","hash":"4bd4037a0093c20bfdfb637b93758402ca188d14","modified":1597377597757},{"_id":"themes/yilia-plus/package.json","hash":"5e331f908aa02adf7f8c539e6a39639d0bc57de4","modified":1597377597833},{"_id":"themes/yilia-plus/README.md","hash":"3bba4f2de1844af57177d62fb8caeeee3c3ad75b","modified":1597377597758},{"_id":"themes/yilia-plus/_config.yml","hash":"a526ed54d9fe7becb68516e275eafa55930c27fa","modified":1597648677030},{"_id":"themes/yilia-plus/webpack.config.js","hash":"08f653daa4794a76d5ff2011751593a5102e21aa","modified":1597377599385},{"_id":"source/404/404.html","hash":"721121e4155f2a86f7900481db6fcdb5ee077923","modified":1575637208700},{"_id":"themes/yilia-plus/.gitignore","hash":"d3c90b2c5dc143514f095ca3b98b10c1a8dfee9e","modified":1597377597755},{"_id":"source/_posts/Django操作补充.md","hash":"d22a1f2bb0f17ae1ccd5ecb7c3134675d20a74bb","modified":1601453408881},{"_id":"source/_posts/Docker基础操作.md","hash":"a8d24d146344f8b793c31941fe961fc44c3a32c0","modified":1601453057914},{"_id":"source/_posts/Flask和Django.md","hash":"7b0d1e37c90a605c415d2f68037c0448abf8d66b","modified":1601451890104},{"_id":"source/_posts/Linux基础命令.md","hash":"15618a3a37b5b8c1850ba638ab35f8f0a02e8c71","modified":1597130154365},{"_id":"source/_posts/ES基本操作.md","hash":"75563621104249130c39d4988fbc99c02aeb5f30","modified":1599212445625},{"_id":"source/_posts/Python操作Excel文件.md","hash":"12ee215851acc29eaa218a7c7ed98a08282b48a5","modified":1597130165465},{"_id":"source/_posts/MongDB.md","hash":"6d2df473925251722517c93be5a058edeaadbbb6","modified":1597130159653},{"_id":"source/_posts/Python补充.md","hash":"d3413d6378f19851fe0232929813d907e37d2d44","modified":1601455518861},{"_id":"source/_posts/MySQL操作.md","hash":"2a537e3044ae6dffde50bcb3e3467da9b69425bd","modified":1601449937546},{"_id":"source/_posts/Redis操作.md","hash":"65697a1521ac14c41d4cdd27925777abb297b5f5","modified":1601451933652},{"_id":"source/_posts/Python高并发场景.md","hash":"af43539d509adf8353f88dfce1e2786a2de6239c","modified":1601453043601},{"_id":"source/_posts/有趣的小网站.md","hash":"fee647989f970a60abebd39bdabda0e1cf40a9a8","modified":1601178340767},{"_id":"source/_posts/测试.md","hash":"d85c6e7e8b08b324971c61b24363d43003e8f4fd","modified":1597130129651},{"_id":"source/_posts/版本控制管理工具使用.md","hash":"ace72d58217fc6c2b8e0f507f39755f25bb47764","modified":1601448595009},{"_id":"source/_posts/部署相关.md","hash":"5eb273d00da678d9b295e7ce320187531ee5b71a","modified":1601453219477},{"_id":"source/_posts/Python数据结构与算法.md","hash":"a94174c855825e3b7a3fa0d452edc32483e09b6f","modified":1601453063425},{"_id":"source/_posts/网络通信概括.md","hash":"ec5bd659460871e7c7a5d3c7a9699a5770677ef9","modified":1601453050866},{"_id":"source/myDoc/L2Dwidget.min.js","hash":"3d0f66a5e3c2d29f88f07b7782d70a39bd852f13","modified":1571717384809},{"_id":"source/myDoc/waifu.css","hash":"4b9801075ba22df07255d3a6f426f82097823f34","modified":1533541841936},{"_id":"themes/yilia-plus/.github/FUNDING.yml","hash":"34a38fce670144b56c744c233dae795715376669","modified":1597377597736},{"_id":"source/myDoc/index.html","hash":"243d6e11c2ef7fd39f1240d470f6a65d60971b3b","modified":1588249310484},{"_id":"source/_posts/总汇.md","hash":"2fcdf6d5e0618d390eeaf1aafd592bc6a430b45b","modified":1601453448879},{"_id":"themes/yilia-plus/.github/ISSUE_TEMPLATE.md","hash":"1c0b35655edb49c4600948d5b04a3fc12965516c","modified":1597377597737},{"_id":"themes/yilia-plus/examples/index.html","hash":"e8b56b7ca7e3f7bcf51060b78c011a91014d2ce0","modified":1597377597768},{"_id":"themes/yilia-plus/.github/PULL_REQUEST_TEMPLATE.md","hash":"73dc6370aa19e656b5bd2b1e228a825a257e570e","modified":1597377597754},{"_id":"themes/yilia-plus/layout/archive.ejs","hash":"2703b07cc8ac64ae46d1d263f4653013c7e1666b","modified":1597377597808},{"_id":"themes/yilia-plus/layout/category.ejs","hash":"765426a9c8236828dc34759e604cc2c52292835a","modified":1597377597808},{"_id":"themes/yilia-plus/layout/index.ejs","hash":"5ef42c7cc4556048579c5ab9aa95bf81caa4f09c","modified":1597377597809},{"_id":"themes/yilia-plus/layout/page.ejs","hash":"7d80e4e36b14d30a7cd2ac1f61376d9ebf264e8b","modified":1597377597809},{"_id":"themes/yilia-plus/.vscode/settings.json","hash":"0f536a72f302812f9add043f0dc128ccfd657347","modified":1597377597756},{"_id":"themes/yilia-plus/layout/tag.ejs","hash":"eaa7b4ccb2ca7befb90142e4e68995fb1ea68b2e","modified":1597377597830},{"_id":"themes/yilia-plus/scripts/default_config.js","hash":"6b057e793003ad025690e03a7524a7c7d8d81ad2","modified":1597377597833},{"_id":"themes/yilia-plus/scripts/yilia_plus_log.js","hash":"954041c88b15f471c87ca1f8595eed2bd2a2c693","modified":1597377597838},{"_id":"themes/yilia-plus/source-src/css.ejs","hash":"c6a8a27b9d678271aac3ca0661409c9e9d703097","modified":1597377597838},{"_id":"themes/yilia-plus/layout/layout.ejs","hash":"99d66924ea851ccc020e4b4a55f13127df9b4f26","modified":1597377597809},{"_id":"themes/yilia-plus/layout/post.ejs","hash":"7d80e4e36b14d30a7cd2ac1f61376d9ebf264e8b","modified":1597377597830},{"_id":"themes/yilia-plus/languages/en.yml","hash":"5b7e0730101edd49167f9c09c93279ad745b2098","modified":1597377597769},{"_id":"themes/yilia-plus/languages/fr.yml","hash":"b4be1c1592a72012e48df2b3ec41cc9685573e50","modified":1597377597769},{"_id":"themes/yilia-plus/languages/nl.yml","hash":"3d82ec703d0b3287739d7cb4750a715ae83bfcb3","modified":1597377597770},{"_id":"themes/yilia-plus/languages/no.yml","hash":"ddf2035e920a5ecb9076138c184257d9f51896a7","modified":1597377597770},{"_id":"themes/yilia-plus/languages/ru.yml","hash":"2a476b4c6e04900914c81378941640ac5d58a1f0","modified":1597377597771},{"_id":"source/myDoc/waifu-tips.js","hash":"a3f6bb54eb70cc7f63ef4c74fe198d39ca460d5c","modified":1533541952653},{"_id":"themes/yilia-plus/languages/zh-CN.yml","hash":"af81d39fd3422cdb118165461f231b2429a09d6c","modified":1597377597771},{"_id":"themes/yilia-plus/languages/default.yml","hash":"af81d39fd3422cdb118165461f231b2429a09d6c","modified":1597377597769},{"_id":"themes/yilia-plus/source-src/script.ejs","hash":"b886ac88de6e49e2a359082c4bf8818bd74f14d9","modified":1597377597919},{"_id":"themes/yilia-plus/languages/zh-Hans.yml","hash":"3d62bb14cc58cce82a8e05ca4bcb3813902c92d8","modified":1597377597771},{"_id":"themes/yilia-plus/languages/zh-tw.yml","hash":"6663e4b0affd13320af416a765b4e7f88b55b8be","modified":1597377597772},{"_id":"themes/yilia-plus/source/main.a5fda8.js","hash":"2a93367d542d0d44c1eed6bd9f40862f20444057","modified":1597377599341},{"_id":"themes/yilia-plus/layout/_partial/toc.ejs","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1597377597807},{"_id":"themes/yilia-plus/source/slider.27463f.js","hash":"9352a3fd9feb0ca8db2fdf7dac80cf26d18c2eda","modified":1597377599384},{"_id":"themes/yilia-plus/.github/ISSUE_TEMPLATE/bug_report.md","hash":"ad2aabc52186d1589099e43d985909932170adad","modified":1597377597737},{"_id":"themes/yilia-plus/.github/ISSUE_TEMPLATE/feature-request-improvement.md","hash":"bf81e1b40d61f8d63c7f15d69e0f0a0806bdb925","modified":1597377597738},{"_id":"themes/yilia-plus/.github/ISSUE_TEMPLATE/other.md","hash":"9718fd73a3cf2f011e2eb2cd07f0ea40d012b590","modified":1597377597738},{"_id":"themes/yilia-plus/.github/ISSUE_TEMPLATE/question-help.md","hash":"4688da2356f1cd51787721c890358e167af7329f","modified":1597377597739},{"_id":"themes/yilia-plus/examples/images/qrcode.png","hash":"061607c067991f03bab78904fdba6e8b4bc174b0","modified":1597377597763},{"_id":"themes/yilia-plus/layout/_partial/activate-power-mode.ejs","hash":"45b8a294251185c041a645eb974bfd552bb283d4","modified":1597377597773},{"_id":"themes/yilia-plus/layout/_partial/after-footer.ejs","hash":"5d4ce98ba7fc0262a2878b0f52f37c3c6496410c","modified":1597377597773},{"_id":"themes/yilia-plus/layout/_partial/archive.ejs","hash":"a4eacc2bc1278095a0ef99f904b0634c78f980eb","modified":1597377597774},{"_id":"themes/yilia-plus/layout/_partial/archive-post.ejs","hash":"edc0154b30a4127acda10297bec6aacf754b4ac4","modified":1597377597773},{"_id":"themes/yilia-plus/layout/_partial/aside.ejs","hash":"751e5deab5365348be5243688b419c82d337ab9a","modified":1597377597775},{"_id":"themes/yilia-plus/source/main.a5fda8.css","hash":"68f2090055117ca9c4eeb94be115896967ebf090","modified":1597647396732},{"_id":"themes/yilia-plus/layout/_partial/baidu-analytics.ejs","hash":"155327c23607f69989b58845f24d842a54e504b8","modified":1597377597775},{"_id":"themes/yilia-plus/examples/images/weixin.png","hash":"a1201bdc06e1467fea1f78cd56d8af45fdcfd5c0","modified":1597377597767},{"_id":"themes/yilia-plus/layout/_partial/article.ejs","hash":"6145c6b85436ef8bcf50a077a952008b33076731","modified":1597641522192},{"_id":"themes/yilia-plus/layout/_partial/background.ejs","hash":"ac8968f04ece57e132189daffb3f4b5aeb182722","modified":1597377597775},{"_id":"themes/yilia-plus/layout/_partial/google-analytics.ejs","hash":"3a23d6ae48305c9f1b5c400da780288c2425254b","modified":1597377597776},{"_id":"themes/yilia-plus/layout/_partial/footer.ejs","hash":"67f36ce6694ee1485f9728f8bef4f23d7de177b0","modified":1597377597776},{"_id":"themes/yilia-plus/layout/_partial/baidu-push.ejs","hash":"d2c68b78e246d0bdd831d5bbc291cad168fd7ff7","modified":1597377597776},{"_id":"themes/yilia-plus/layout/_partial/css.ejs","hash":"225df7b951ff4c89bd7a0b2e4d6d2049cf99d012","modified":1597377597776},{"_id":"themes/yilia-plus/layout/_partial/head.ejs","hash":"f43ae0ec9fff66695830add6fc381e9e7ef1e296","modified":1597377597777},{"_id":"themes/yilia-plus/layout/_partial/header.ejs","hash":"108a7425765d68f64dd0f5fb4d3dd1a4e766a341","modified":1597377597777},{"_id":"themes/yilia-plus/layout/_partial/mathjax.ejs","hash":"8609596b62c4412d260f54f8d604d6da6e709887","modified":1597377597778},{"_id":"themes/yilia-plus/layout/_partial/hover-effect.ejs","hash":"eecc81afad47a708056870500660f1228f2a301f","modified":1597377597777},{"_id":"themes/yilia-plus/layout/_partial/live2d-widget.ejs","hash":"e232fbbbd7cd060d7eb426c653302c5b99ac6d5f","modified":1597641561472},{"_id":"themes/yilia-plus/layout/_partial/tab-title-change.ejs","hash":"2fbf0ac7d95593c2e656a010e7d1136194070f4c","modified":1597377597807},{"_id":"themes/yilia-plus/layout/_partial/mobile-nav.ejs","hash":"ec85be77eb0ae60ac95a9562d9525567d7774e4a","modified":1597377597779},{"_id":"themes/yilia-plus/layout/_partial/viewer.ejs","hash":"cc1c39903aed0a0601d104238d2bbd13ad2a36f3","modified":1597377597808},{"_id":"themes/yilia-plus/package-lock.json","hash":"500c6a03610d348966f042be53102458d56601b8","modified":1597377597833},{"_id":"themes/yilia-plus/scripts/filters/index.js","hash":"e0c3b821ecd1cb614569282fb4f6e6f555545f8b","modified":1597377597834},{"_id":"themes/yilia-plus/scripts/filters/meta_generator.js","hash":"a1279b521b82c33a9747fc10013d363eed06f0f3","modified":1597377597835},{"_id":"themes/yilia-plus/scripts/helpers/wordcount.js","hash":"2014b5c5053ad737887b61014a045cc1b08799cd","modified":1597377597835},{"_id":"themes/yilia-plus/scripts/helpers/yilia-plus-vendors.js","hash":"a1d72be30b08c5d03226f6b8360afa19f56df8a1","modified":1597377597836},{"_id":"themes/yilia-plus/scripts/lib/core.js","hash":"00509e97554914e5b0a20e0843dc90bcf53461aa","modified":1597377597836},{"_id":"themes/yilia-plus/source-src/js/Q.js","hash":"e56d9710afa79b31ca6b9fbd845f6d1895f5214b","modified":1597377597896},{"_id":"themes/yilia-plus/layout/_partial/left-col.ejs","hash":"47048d07d61e67ddad19b53635037c008b8ab28a","modified":1597647761701},{"_id":"themes/yilia-plus/layout/_partial/tools.ejs","hash":"a9277c8c665a404c3c9547f1dc1669ccf0737314","modified":1597377597807},{"_id":"themes/yilia-plus/source-src/js/aside.js","hash":"3cd3aa6fd80ee0d2717a5cbb805777e5582ec1eb","modified":1597377597897},{"_id":"themes/yilia-plus/source-src/js/browser.js","hash":"e91e59c0cea4b29276735260eff59d2a9dbc30b8","modified":1597377597897},{"_id":"themes/yilia-plus/source-src/js/fix.js","hash":"9a6f634078b4d4a91783fca809fda34785dc8b84","modified":1597377597898},{"_id":"themes/yilia-plus/source-src/js/main.js","hash":"e8980b7daf1ab77b1f4c74c576ce06331c34f784","modified":1597377597898},{"_id":"themes/yilia-plus/source-src/js/anm.js","hash":"2603a975b97619b1d5ed3babdecf44691ccd5a97","modified":1597377597897},{"_id":"themes/yilia-plus/source-src/js/mobile.js","hash":"46f22cd3a993897aca51c1d494afeab28e2b2072","modified":1597377597915},{"_id":"themes/yilia-plus/source-src/js/share.js","hash":"d76a873435367fc8e2bca8c91fe198f88199c900","modified":1597377597917},{"_id":"themes/yilia-plus/source-src/js/util.js","hash":"4809dac6af821f9da41b4a434b4f2c0fea09d508","modified":1597377597918},{"_id":"themes/yilia-plus/source-src/js/slider.js","hash":"a9d16e87200336af1231b33c79e69465dc0d2e65","modified":1597377597917},{"_id":"themes/yilia-plus/source-src/js/viewer.js","hash":"aeb3c1cc4d556279768756d0a255ac7c52c4d2c8","modified":1597377597918},{"_id":"themes/yilia-plus/source-src/css/_core.scss","hash":"be6c986efe3912378d7c8aafdc305a5d01d190a1","modified":1597377597839},{"_id":"themes/yilia-plus/source-src/css/_function.scss","hash":"ce227b6f5a9af194fd5d455200630f32c05e151f","modified":1597377597839},{"_id":"themes/yilia-plus/source-src/css/archive.scss","hash":"eaa79e2f10ca713043f704feaafa001e1a339e50","modified":1597377597839},{"_id":"themes/yilia-plus/source-src/css/article-main.scss","hash":"6e6fd3ed5b906cbbe8345c3834ce645ade5a88a7","modified":1597377597840},{"_id":"themes/yilia-plus/source-src/css/aside.scss","hash":"353587950797f62e2f808e0f9183f82a0a4228d4","modified":1597377597841},{"_id":"themes/yilia-plus/source-src/css/comment.scss","hash":"ada82b79907fde047bd415c9687917c6bc97b1d6","modified":1597377597841},{"_id":"themes/yilia-plus/source-src/css/declare.scss","hash":"139b7fd4949ba829e75595af3797998c628a87c8","modified":1597377597845},{"_id":"themes/yilia-plus/source-src/css/article-inner.scss","hash":"a3de420ab47fe0c0de4cb1857f8f041abc7a3737","modified":1597377597840},{"_id":"themes/yilia-plus/source-src/css/footer.scss","hash":"c435c8f5e79ee0eee8b0a1343c9ded2bf65e7570","modified":1597377597869},{"_id":"themes/yilia-plus/source-src/css/global.scss","hash":"f2785f59e80665805eec730034fe284329a1343a","modified":1597377597870},{"_id":"themes/yilia-plus/source-src/css/article.scss","hash":"49602a18b080df6f23d616d49b84a4ba905579de","modified":1597377597840},{"_id":"themes/yilia-plus/source-src/css/highlight.scss","hash":"b9195a58b3f554df0a1f9a687deb79edc570b731","modified":1597377597870},{"_id":"themes/yilia-plus/source-src/css/hover-reveal.scss","hash":"2bdab19d10e9ca5805ed1c7a73873bf800a1f6a9","modified":1597377597871},{"_id":"themes/yilia-plus/source-src/css/grid.scss","hash":"22c2ed05bd6ad48b1b538b0352c768674cd41a5f","modified":1597377597870},{"_id":"themes/yilia-plus/source-src/css/left.scss","hash":"8d48e1e96a97da533701c67f9ad925fb39edd39d","modified":1597377597873},{"_id":"themes/yilia-plus/source-src/css/main.scss","hash":"9611a762cf9ade760f69f7d456d7958189f2b0fd","modified":1597377597873},{"_id":"themes/yilia-plus/source-src/css/fonts.scss","hash":"40da5972f7876205ed71b7ed9d6646fda2680de8","modified":1597377597845},{"_id":"themes/yilia-plus/source-src/css/mobile.scss","hash":"e0e15f38b817df33144b87693f649b7419ca1e9d","modified":1597377597874},{"_id":"themes/yilia-plus/source-src/css/page.scss","hash":"4dbb348eea97c90320570d3acc12e18fbc7a98c5","modified":1597377597874},{"_id":"themes/yilia-plus/source-src/css/mobile-slider.scss","hash":"965781f40abb61930492f8937b5c4e4350a4a036","modified":1597377597874},{"_id":"themes/yilia-plus/source-src/css/reward.scss","hash":"87a8204da798cf240ab36dfa73dbb8638831c8a0","modified":1597377597875},{"_id":"themes/yilia-plus/source-src/css/scroll.scss","hash":"c94080252044b76c5af419067003fbfcc55997e9","modified":1597377597875},{"_id":"themes/yilia-plus/source-src/css/tags-cloud.scss","hash":"a292581f6ffe0128f2717a4aa0bb406b54818645","modified":1597377597876},{"_id":"themes/yilia-plus/source-src/css/tags.scss","hash":"5e4caea3c35a2c1bdea73f6308a42a2f550da521","modified":1597377597894},{"_id":"themes/yilia-plus/source-src/css/tools.scss","hash":"0e025eb1324fdb5ff1d409e0c392c96dd64a6ef7","modified":1597377597895},{"_id":"themes/yilia-plus/source-src/css/tooltip.scss","hash":"3a46ef562a15c85c80e862ccdaa6bfa8d599af35","modified":1597377597895},{"_id":"source/myDoc/live2d.js","hash":"09a1874e440b54920b19793395eb85c2261c99a5","modified":1533541841905},{"_id":"themes/yilia-plus/source/fonts/default-skin.b257fa.svg","hash":"2ac727c9e092331d35cce95af209ccfac6d4c7c7","modified":1597377597920},{"_id":"themes/yilia-plus/source-src/css/share.scss","hash":"10599fdf0be5378cf91ceeedba9b513e852b96d3","modified":1597377597875},{"_id":"themes/yilia-plus/source-src/css/social.scss","hash":"26fbd2975dd0405d359fd581e0bc18138cddba42","modified":1597377597875},{"_id":"themes/yilia-plus/source/fonts/fonteditor.3da1ef.woff","hash":"5a945ddf318d3ca68d0a1e8695b23287ff7e9816","modified":1597377597920},{"_id":"themes/yilia-plus/source-src/css/article-nav.scss","hash":"6a2a17073f7f53f2b0e43b2c5873ade4b64eabe1","modified":1597377597840},{"_id":"themes/yilia-plus/source/fonts/fonteditor.86c132.eot","hash":"c29905356fb2116a454a262d6f15cdeb593a6cec","modified":1597377597921},{"_id":"themes/yilia-plus/source/fonts/tooltip.4004ff.svg","hash":"397fe4b1093bf9b62457dac48aa15dac06b54a3c","modified":1597377597923},{"_id":"themes/yilia-plus/source/fonts/fonteditor.fe4d8a.ttf","hash":"95d1a4991df9ce15562ff0344b318b5fc5f9ab70","modified":1597377597922},{"_id":"themes/yilia-plus/source/fonts/fonteditor.3e0d4a.svg","hash":"de1fbf8378d1966d43bf620b8acd6bf900a15a73","modified":1597377597921},{"_id":"themes/yilia-plus/source/img/favicon.ico","hash":"58e7d4842c8853b33fc6491af69bd14a659077ef","modified":1597385309817},{"_id":"themes/yilia-plus/source/img/biubiubiu.gif","hash":"cccda381f96abe91b4d698da793abd6496466d3d","modified":1597377597925},{"_id":"themes/yilia-plus/source/fonts/fonteditor.bbc4b5.woff2","hash":"c748dc092f066f7e12626c801d416e64b95dacea","modified":1597377597921},{"_id":"themes/yilia-plus/source/img/forkme.png","hash":"b43e6e18b84edc40636204aa0eb9f266ef54a4e7","modified":1597377597926},{"_id":"themes/yilia-plus/source/img/scrollbar_arrow.png","hash":"d64a33c4ddfbdb89deeb6f4e3d36eb84dc4777c0","modified":1597377597928},{"_id":"themes/yilia-plus/source/img/gitee.svg","hash":"5eda5e779b8407430aa53f3c6c38bd0ecc04b003","modified":1597377597927},{"_id":"themes/yilia-plus/source/img/preloader.gif","hash":"6342367c93c82da1b9c620e97c84a389cc43d96d","modified":1597377597927},{"_id":"themes/yilia-plus/source/img/touming.jpg","hash":"e919d05796d750ecbf31dec99a7059ebf565b84c","modified":1597385482324},{"_id":"themes/yilia-plus/source/lib/busuanzi.pure.js","hash":"f54c44e2b30e551540b83640dd8c5ff266e157d5","modified":1597377597929},{"_id":"themes/yilia-plus/source/lib/clickLove.js","hash":"a35dfb7ff19796c005ee30b55fd95e39d6d59a89","modified":1597377597930},{"_id":"themes/yilia-plus/source/lib/default.css","hash":"c9c344d5c98cc90b5583865e71726bab1046cdeb","modified":1597377597930},{"_id":"themes/yilia-plus/source/img/default-skin.png","hash":"ed95a8e40a2c3478c5915376acb8e5f33677f24d","modified":1597377597926},{"_id":"themes/yilia-plus/source/lib/gitment.css","hash":"cb2e0be2c7ebbcc3e756340c811864115bf0ec56","modified":1597377597933},{"_id":"themes/yilia-plus/source/lib/oauthcallback.browser.js","hash":"989b9e2638336461a9911ebf60e9a839819dd11f","modified":1597377597939},{"_id":"themes/yilia-plus/source/lib/snow.js","hash":"e64ca5217bb2f11257a8b212b8868ee9331ef0eb","modified":1597377597939},{"_id":"themes/yilia-plus/source/mobile.a2c207.js","hash":"0d1885cbba171fdfd90729ef109d81c650def7a1","modified":1597377599344},{"_id":"themes/yilia-plus/examples/images/alipay.jpeg","hash":"7eb57147bd42d499f8ef0351d46673158b209f75","modified":1597377597763},{"_id":"themes/yilia-plus/source/gitment/APlayer.min.js","hash":"b2ab8c0b6a50e884240d80c1a12435b1efc718f3","modified":1597377597923},{"_id":"themes/yilia-plus/source/img/touxiang.jpg","hash":"321665a791d5be06342a8bbe2ea8f129b5dbb1a2","modified":1597385266743},{"_id":"themes/yilia-plus/source/lib/gitment.js.bak","hash":"ded86ac10cc79a7d28e2ea44778e792cef6c3470","modified":1597377597935},{"_id":"themes/yilia-plus/layout/_partial/post/category.ejs","hash":"e777cbf959b11c4dfda649c562799899b90ab4a3","modified":1597377597779},{"_id":"themes/yilia-plus/layout/_partial/post/changyan.ejs","hash":"086c8a88fd3bcae7ec13258df58e25d6354af2fa","modified":1597377597780},{"_id":"themes/yilia-plus/layout/_partial/post/date.ejs","hash":"3550029e3eb23b6ce9fd68c85fa73d64c2d6c653","modified":1597377597780},{"_id":"themes/yilia-plus/source/lib/pace.min.js","hash":"8aaa675f577d5501f5f22d5ccb07c2b76310b690","modified":1597377597939},{"_id":"themes/yilia-plus/layout/_partial/post/giteement.ejs","hash":"063126e745534ddca7801a7a3f60fcee61fcad2f","modified":1597377597780},{"_id":"themes/yilia-plus/layout/_partial/post/gitment.ejs","hash":"263bb5b60117bbefac0e74a761955cfb4026bc76","modified":1597377597781},{"_id":"themes/yilia-plus/layout/_partial/post/nav.ejs","hash":"b6a97043f9ec37e571aacacfedcda1d4d75e3c7c","modified":1597377597804},{"_id":"themes/yilia-plus/layout/_partial/post/tag.ejs","hash":"2c4e4ca36c9bb4318506c38aca7127f1f44d827f","modified":1597377597805},{"_id":"themes/yilia-plus/layout/_partial/post/title.ejs","hash":"c780794886a8a5b0dba633e06cd4eb7b6dceb783","modified":1597377597805},{"_id":"themes/yilia-plus/layout/_partial/post/word.ejs","hash":"dcfdc5eba0ac42ec469be6447e1be5f7ef5c0819","modified":1597377597806},{"_id":"themes/yilia-plus/layout/_partial/script.ejs","hash":"3d93a530038eb6445e59e605a3ac5e2b3f81e64b","modified":1597377597806},{"_id":"themes/yilia-plus/layout/_partial/post/share.ejs","hash":"3591d3fdd846d7ad88d8e110848614803026f1da","modified":1597377597805},{"_id":"themes/yilia-plus/source-src/css/core/_animation.scss","hash":"8b4b490f55a3258cf805d787c446ab6c6625c181","modified":1597377597842},{"_id":"themes/yilia-plus/source-src/css/core/_media-queries.scss","hash":"a3ec98ef49ba21740392098e353ea0d22f2afafa","modified":1597377597843},{"_id":"themes/yilia-plus/source-src/css/core/_variables.scss","hash":"bbf1bd784a6dd76dde57ea18a3532bc0f04ae690","modified":1597377597845},{"_id":"themes/yilia-plus/source-src/css/fonts/fonteditor.eot","hash":"c29905356fb2116a454a262d6f15cdeb593a6cec","modified":1597377597850},{"_id":"themes/yilia-plus/source-src/css/fonts/fonteditor.svg","hash":"de1fbf8378d1966d43bf620b8acd6bf900a15a73","modified":1597377597850},{"_id":"themes/yilia-plus/source-src/css/core/_reset.scss","hash":"cb4eab3a999a5de601f346254442480a64bc4f68","modified":1597377597844},{"_id":"themes/yilia-plus/source-src/css/fonts/fonteditor.ttf","hash":"95d1a4991df9ce15562ff0344b318b5fc5f9ab70","modified":1597377597851},{"_id":"themes/yilia-plus/source-src/css/core/_mixin.scss","hash":"3b764eeb59c0d42100bcde9999056a310cb9ee77","modified":1597377597843},{"_id":"themes/yilia-plus/source/lib/jquery-2.1.4.min.js","hash":"1327f754ff87d26bced46568543207e9df190aaa","modified":1597377597938},{"_id":"themes/yilia-plus/source-src/css/img/checkered-pattern.png","hash":"049262fa0886989d750637b264bed34ab51c23c8","modified":1597377597871},{"_id":"themes/yilia-plus/layout/_partial/post/valine.ejs","hash":"0736239e0df4bc1fab23f088d46e05c6b24417c4","modified":1597395583598},{"_id":"themes/yilia-plus/source-src/css/img/tooltip.svg","hash":"397fe4b1093bf9b62457dac48aa15dac06b54a3c","modified":1597377597872},{"_id":"themes/yilia-plus/source/lib/gitment.js","hash":"6efab6ebe558a6cab0e0004a737e3f739d614d5e","modified":1597377597935},{"_id":"themes/yilia-plus/source/lib/gitment.js.bak2","hash":"8065a9364e25414c6a37d4be181f1c6052c4d590","modified":1597377597937},{"_id":"themes/yilia-plus/examples/images/Yilia-plus.png","hash":"23884fe970ec806b05511288f52cd576f5ac1fff","modified":1597377597762},{"_id":"themes/yilia-plus/source/live2d_models/hijiki/.gitignore","hash":"a5a49e4d5dfb97857856eb6b0cdb2c93a387718f","modified":1597377598263},{"_id":"themes/yilia-plus/source/live2d_models/hijiki/package-lock.json","hash":"4cada5114eba9ebcb15d28b4f8b283c8a1381cfc","modified":1597377598274},{"_id":"themes/yilia-plus/source/live2d_models/hijiki/package.json","hash":"dcdb3a8e061ce390eb60c4a7322cb2faf12de182","modified":1597377598275},{"_id":"themes/yilia-plus/examples/images/web.png","hash":"9748de6b01c6b044c421d548993b1024abeb8b0c","modified":1597377597765},{"_id":"themes/yilia-plus/source-src/css/fonts/fonteditor.woff","hash":"5a945ddf318d3ca68d0a1e8695b23287ff7e9816","modified":1597377597852},{"_id":"themes/yilia-plus/source/plugins/TweenMax/HoverImg.js","hash":"b1c7e1357556002f711a792fac71ac61519c90e0","modified":1597377599346},{"_id":"themes/yilia-plus/source-src/css/img/scrollbar_arrow.png","hash":"d64a33c4ddfbdb89deeb6f4e3d36eb84dc4777c0","modified":1597377597872},{"_id":"themes/yilia-plus/source-src/css/fonts/fonteditor.woff2","hash":"c748dc092f066f7e12626c801d416e64b95dacea","modified":1597377597852},{"_id":"themes/yilia-plus/source/plugins/TweenMax/charming.min.js","hash":"26534e6a69842166331733e6343f083b5d94afdd","modified":1597377599349},{"_id":"themes/yilia-plus/source/plugins/ribbon.js/ribbon.js","hash":"62ff1ba692f3153d0288c514c42c6c92cc17e9b6","modified":1597377599381},{"_id":"themes/yilia-plus/source/plugins/live2d-widget.js/L2Dwidget.min.js","hash":"ea13512df765f9cb10f96870b8ad3f1c23d14e32","modified":1597377599374},{"_id":"themes/yilia-plus/source/plugins/live2d-widget.js/manifest.json","hash":"a2b43740af056dc5ccf5348f294fc6f7401b49b8","modified":1597377599377},{"_id":"themes/yilia-plus/source/plugins/activate-power-mode/activate-power-mode.js","hash":"4352d265479b9f5ca567e5143150f4a3c24e200d","modified":1597377599351},{"_id":"themes/yilia-plus/source-src/css/fonts/bak/fonts.scss","hash":"db395b79fd10912d95a53af80e38019b3c75e207","modified":1597377597846},{"_id":"themes/yilia-plus/source-src/css/fonts/bak/iconfont.eot","hash":"bc8c5e88f4994a852041b4d83f126d9c4d419b4a","modified":1597377597846},{"_id":"themes/yilia-plus/source-src/css/fonts/bak/iconfont.svg","hash":"75767c904d483d9b93469afb6b92bb6bdface639","modified":1597377597847},{"_id":"themes/yilia-plus/source-src/css/fonts/bak/iconfont.woff","hash":"aa9672cb097f7fd73ae5a03bcd3d9d726935bc0a","modified":1597377597849},{"_id":"themes/yilia-plus/source/live2d_models/hijiki/assets/hijiki.model.json","hash":"feff43bf7498d213982c3736c2c029664e4bcbd2","modified":1597377598264},{"_id":"themes/yilia-plus/source/live2d_models/hijiki/assets/hijiki.pose.json","hash":"81438bf69b32c7c11e311b4fe043730cdc7b7ec2","modified":1597377598264},{"_id":"themes/yilia-plus/source/plugins/TweenMax/TweenMax.min.js","hash":"1079921a545c4726cde7a043350a4e3da3dde80f","modified":1597377599348},{"_id":"themes/yilia-plus/source/plugins/ribbon.js/ribbon.min.js","hash":"e6136a6243e04faca95844f47c21b070ade3661a","modified":1597377599382},{"_id":"themes/yilia-plus/source/plugins/ribbon.js/demo/index.html","hash":"f3642f2c6a53e0dbbd4a493c7aeaa677508d21bc","modified":1597377599379},{"_id":"themes/yilia-plus/source-src/css/fonts/yilia-plus/fonteditor.eot","hash":"de1e6a237496055048752b719dbbb4872bf6aaa9","modified":1597377597853},{"_id":"themes/yilia-plus/source-src/css/fonts/yilia-plus/fonteditor.svg","hash":"c65b80c65e6042a778011798a4e60832ed424c92","modified":1597377597853},{"_id":"themes/yilia-plus/source-src/css/fonts/bak/iconfont.ttf","hash":"f342ac8bf4d937f42a7d6a0032ad267ab47eb7f2","modified":1597377597848},{"_id":"themes/yilia-plus/source/plugins/live2d-widget.js/L2Dwidget.0.min.js","hash":"483c29206ea8370f6e700cb9c0f10836d97f68ac","modified":1597377599354},{"_id":"themes/yilia-plus/source/plugins/live2d-widget.js/L2Dwidget.common.js","hash":"053bf325dfd46b3f3b470079d9e9e43313be6eeb","modified":1597377599368},{"_id":"themes/yilia-plus/source-src/css/fonts/yilia-plus/fonteditor.ttf","hash":"eab3ed2ad51d365b48c647a4ab0fae7e5a8368a1","modified":1597377597868},{"_id":"themes/yilia-plus/source-src/css/fonts/yilia-plus/fonteditor.woff","hash":"555d609b08a87cee313fa64ce4677cc90aa9512d","modified":1597377597869},{"_id":"themes/yilia-plus/source/live2d_models/hijiki/assets/mtn/00_idle.mtn","hash":"b224c60e463b9f71ddbfc0c720e430496c175f4f","modified":1597377598269},{"_id":"themes/yilia-plus/source/live2d_models/hijiki/assets/mtn/03.mtn","hash":"f900737c7a98441cbb2e05255427e6260e19ae68","modified":1597377598271},{"_id":"themes/yilia-plus/source/live2d_models/hijiki/assets/mtn/02.mtn","hash":"7eafc52edc73b7cb80ae70d34b43c6ac778fa47b","modified":1597377598270},{"_id":"themes/yilia-plus/source/live2d_models/hijiki/assets/mtn/04.mtn","hash":"c7a25d3c5d783639bae18db2f3cd284b819c3c85","modified":1597377598271},{"_id":"themes/yilia-plus/source/live2d_models/hijiki/assets/mtn/01.mtn","hash":"fb550833ae22c9954c3e01df37ed29b2d61700f2","modified":1597377598270},{"_id":"themes/yilia-plus/source/live2d_models/hijiki/assets/mtn/06.mtn","hash":"ad404bd852d276cdd3d054c953e23f90e4e45ae1","modified":1597377598271},{"_id":"themes/yilia-plus/source/plugins/live2d-widget.js/L2Dwidget.min.js.map","hash":"75322ae0754f0580c0fb5ce9176ab72ce4009903","modified":1597377599377},{"_id":"themes/yilia-plus/source/live2d_models/hijiki/assets/mtn/08.mtn","hash":"4411c7651ff65195b113d95e7d5ebef8a59a37d9","modified":1597377598274},{"_id":"themes/yilia-plus/source/live2d_models/hijiki/assets/mtn/05.mtn","hash":"dd20ad24b5d1830a5d44b9bccb28f922eea5e0e5","modified":1597377598271},{"_id":"themes/yilia-plus/source/lib/giteement.browser.js","hash":"824925ebd507d6b6fe3005f6c90c64809638456b","modified":1597377597933},{"_id":"themes/yilia-plus/source/live2d_models/hijiki/assets/moc/hijiki.moc","hash":"44289e62545a7046e0f5231103a851750b78524e","modified":1597377598269},{"_id":"themes/yilia-plus/source/live2d_models/hijiki/assets/moc/hijiki.2048/texture_00.png","hash":"66464e0d96439695b5542c5e2f5be60739c29999","modified":1597377598266},{"_id":"themes/yilia-plus/source/plugins/live2d-widget.js/L2Dwidget.common.js.map","hash":"8de60ae490ab3d62c91c8ce60a256079b6afd3d8","modified":1597377599373},{"_id":"themes/yilia-plus/source/live2d_models/hijiki/assets/mtn/07.mtn","hash":"b7f2e3a9fa4f3ffbb6e64a08f8d9f45ca1868ffb","modified":1597377598273},{"_id":"themes/yilia-plus/source/plugins/live2d-widget.js/L2Dwidget.0.min.js.map","hash":"3b3a7076b747b092d6e48f42a8a3497aa21280ee","modified":1597377599364},{"_id":"themes/yilia-plus/source/img/tianping.png","hash":"b351ad922d937c8c0c80f46e0ce3438f1918b0c6","modified":1597639361424},{"_id":"themes/yilia-plus/source/img/xiaoniao.gif","hash":"471319edf40b3b133a0160cda99b51b119668432","modified":1597627953115},{"_id":"public/content.json","hash":"5f30ae549833af881989a2a0cd3f2072665eb2ec","modified":1601455558848},{"_id":"public/404.html","hash":"9bacc6288c9f03ea6723f6fb02edebc636e47238","modified":1601455558848},{"_id":"public/2020/09/30/Python补充/index.html","hash":"0bb16b37e8f0f78fdc010860975d3c39740fd24b","modified":1601455558848},{"_id":"public/2020/09/30/部署相关/index.html","hash":"b65b862a7c06a70e1b239bb6093874b588a47c39","modified":1601455558848},{"_id":"public/2020/09/30/Django操作补充/index.html","hash":"3de4f06afc33ad3fbf7a77d83b508fae18c885a3","modified":1601455558848},{"_id":"public/2020/09/30/Python数据结构与算法/index.html","hash":"93ac40b8472cabd566d43b3f0f3363666f47b054","modified":1601455558848},{"_id":"public/2020/09/30/Docker基础操作/index.html","hash":"0c1488e46e6d8e3e2ae8ba692f83f5c77365692f","modified":1601455558848},{"_id":"public/2020/09/30/网络通信概括/index.html","hash":"1ec98a55c99ecbd9bcc669a05d361b171a400c68","modified":1601455558848},{"_id":"public/2020/09/30/Python高并发场景/index.html","hash":"18fcd77936ef5a5bd5f8f12c761c2239f117ded4","modified":1601455558848},{"_id":"public/2020/09/30/版本控制管理工具使用/index.html","hash":"3067d4d25d1bdafc67bae68d4d5a47872bc1f7e4","modified":1601455558848},{"_id":"public/2020/09/30/MySQL操作/index.html","hash":"fc0dc1cec01a4735a50557e78e9d890562fce7cf","modified":1601455558848},{"_id":"public/2020/09/30/Redis操作/index.html","hash":"c21991a3ed0f74153e0136ad793c732c110ca7e4","modified":1601455558848},{"_id":"public/2020/09/30/Flask和Django/index.html","hash":"e59ff4e851078fa204cea732b995edbb4d944c61","modified":1601455558848},{"_id":"public/2020/07/11/Python操作Excel文件/index.html","hash":"55c169b76839985a801d6d2087b51a0f77b8838e","modified":1601455558848},{"_id":"public/2020/07/11/ES基本操作/index.html","hash":"ee7b8d25ff1a52ab932e4270a5e4683cbdc2ee37","modified":1601455558848},{"_id":"public/2020/07/11/有趣的小网站/index.html","hash":"9270cc3f67ced5ccc4e0a61959a978fbcee87f73","modified":1601455558848},{"_id":"public/2020/05/03/测试/index.html","hash":"b3c1ba2ac50f22235cff49ecb299116b96e5bdce","modified":1601455558848},{"_id":"public/2020/05/03/MongDB/index.html","hash":"ee882ebec29cac6353c7a2f725f0105251aa1714","modified":1601455558848},{"_id":"public/2020/02/28/总汇/index.html","hash":"a22f561931436f8a653b44c270b503dbe3b394e4","modified":1601455558848},{"_id":"public/2019/12/02/Linux基础命令/index.html","hash":"6abdde67dbbca4e35d59ebf7692d62b5014104bc","modified":1601455558848},{"_id":"public/archives/index.html","hash":"d0d0350b46d2c33d5b736e4ab1aaf5fa0d62cfa3","modified":1601455558848},{"_id":"public/archives/page/2/index.html","hash":"f8107991db8de32408fbcd14273c285c4768aff8","modified":1601455558848},{"_id":"public/archives/2019/index.html","hash":"338f77597d33942ae069c3ccb5855bb1e6df049f","modified":1601455558848},{"_id":"public/archives/2019/12/index.html","hash":"3a4118e0e4e2caf81e890f717d5f15bb024ea2aa","modified":1601455558848},{"_id":"public/archives/2020/page/2/index.html","hash":"a66be6e9fb0d0641857e2184c514b064728dafe3","modified":1601455558848},{"_id":"public/archives/2020/index.html","hash":"2e570cec455421e7ee4088f28640a09589288ecc","modified":1601455558848},{"_id":"public/archives/2020/02/index.html","hash":"b4b344150d6d455c8e9ddde61c7f9d886d8f8b98","modified":1601455558848},{"_id":"public/archives/2020/05/index.html","hash":"e44908a4c2b348ca3484b82a223ad1a8a92bd802","modified":1601455558848},{"_id":"public/archives/2020/07/index.html","hash":"603c071bce53c4319d85ac1aa1f84c29fe394afc","modified":1601455558848},{"_id":"public/archives/2020/09/index.html","hash":"cfa817d7d2aeabd7513b002e39a0855b5ac905c1","modified":1601455558848},{"_id":"public/archives/2020/09/page/2/index.html","hash":"8f36649d5a93ac4099a75d80975cc6e87a003a56","modified":1601455558848},{"_id":"public/index.html","hash":"551d32e13f233314775843863850c26c1445312b","modified":1601455558848},{"_id":"public/page/2/index.html","hash":"d874a1131f44c2c641d45fd2cb83f1a3975b9bc7","modified":1601455558848},{"_id":"public/tags/Python/index.html","hash":"1f34333eeb407997b9eab44704415d49a794a696","modified":1601455558848},{"_id":"public/tags/tool/index.html","hash":"93096193cdc468ca46edf6db918741b1b7f66005","modified":1601455558848},{"_id":"public/tags/Web/index.html","hash":"ea2dc6612c9e6160a67aa48fbac4a8e615a296c7","modified":1601455558848},{"_id":"public/tags/Linux/index.html","hash":"d11d2bacd74fcfdc8cb9ca5b4b5eac1a476e6871","modified":1601455558848},{"_id":"public/tags/ES/index.html","hash":"3997cf81d6982813862ea1770ea391a7e60c0fe6","modified":1601455558848},{"_id":"public/tags/NoSQL/index.html","hash":"bac4f45229a4664f4544d917d13e625003e1cf7e","modified":1601455558848},{"_id":"public/tags/Luck/index.html","hash":"45c147f82437e2f96c879b7f84e624d689579d03","modified":1601455558848},{"_id":"public/tags/SQL/index.html","hash":"2e865b6e272ef618de63a035db207e783120257f","modified":1601455558848},{"_id":"public/tags/web/index.html","hash":"956b32363c2ec4540b0eb88a2eff1631c1906227","modified":1601455558848},{"_id":"public/tags/测试/index.html","hash":"fbb235daa4bd469d7ae7bf45821b6385b22e9f90","modified":1601455558848},{"_id":"public/myDoc/L2Dwidget.min.js","hash":"3d0f66a5e3c2d29f88f07b7782d70a39bd852f13","modified":1601455558848},{"_id":"public/myDoc/index.html","hash":"243d6e11c2ef7fd39f1240d470f6a65d60971b3b","modified":1601455558848},{"_id":"public/myDoc/waifu.css","hash":"4b9801075ba22df07255d3a6f426f82097823f34","modified":1601455558848},{"_id":"public/myDoc/waifu-tips.js","hash":"a3f6bb54eb70cc7f63ef4c74fe198d39ca460d5c","modified":1601455558848},{"_id":"public/fonts/default-skin.b257fa.svg","hash":"2ac727c9e092331d35cce95af209ccfac6d4c7c7","modified":1601455558848},{"_id":"public/fonts/fonteditor.3da1ef.woff","hash":"5a945ddf318d3ca68d0a1e8695b23287ff7e9816","modified":1601455558848},{"_id":"public/fonts/tooltip.4004ff.svg","hash":"397fe4b1093bf9b62457dac48aa15dac06b54a3c","modified":1601455558848},{"_id":"public/fonts/fonteditor.86c132.eot","hash":"c29905356fb2116a454a262d6f15cdeb593a6cec","modified":1601455558848},{"_id":"public/fonts/fonteditor.fe4d8a.ttf","hash":"95d1a4991df9ce15562ff0344b318b5fc5f9ab70","modified":1601455558848},{"_id":"public/fonts/fonteditor.3e0d4a.svg","hash":"de1fbf8378d1966d43bf620b8acd6bf900a15a73","modified":1601455558848},{"_id":"public/img/favicon.ico","hash":"58e7d4842c8853b33fc6491af69bd14a659077ef","modified":1601455558848},{"_id":"public/img/biubiubiu.gif","hash":"cccda381f96abe91b4d698da793abd6496466d3d","modified":1601455558848},{"_id":"public/img/forkme.png","hash":"b43e6e18b84edc40636204aa0eb9f266ef54a4e7","modified":1601455558848},{"_id":"public/fonts/fonteditor.bbc4b5.woff2","hash":"c748dc092f066f7e12626c801d416e64b95dacea","modified":1601455558848},{"_id":"public/img/scrollbar_arrow.png","hash":"d64a33c4ddfbdb89deeb6f4e3d36eb84dc4777c0","modified":1601455558848},{"_id":"public/img/gitee.svg","hash":"5eda5e779b8407430aa53f3c6c38bd0ecc04b003","modified":1601455558848},{"_id":"public/img/preloader.gif","hash":"6342367c93c82da1b9c620e97c84a389cc43d96d","modified":1601455558848},{"_id":"public/img/touming.jpg","hash":"e919d05796d750ecbf31dec99a7059ebf565b84c","modified":1601455558848},{"_id":"public/img/default-skin.png","hash":"ed95a8e40a2c3478c5915376acb8e5f33677f24d","modified":1601455558848},{"_id":"public/live2d_models/hijiki/assets/mtn/00_idle.mtn","hash":"b224c60e463b9f71ddbfc0c720e430496c175f4f","modified":1601455558848},{"_id":"public/live2d_models/hijiki/assets/mtn/03.mtn","hash":"f900737c7a98441cbb2e05255427e6260e19ae68","modified":1601455558848},{"_id":"public/live2d_models/hijiki/assets/mtn/02.mtn","hash":"7eafc52edc73b7cb80ae70d34b43c6ac778fa47b","modified":1601455558848},{"_id":"public/live2d_models/hijiki/assets/mtn/04.mtn","hash":"c7a25d3c5d783639bae18db2f3cd284b819c3c85","modified":1601455558848},{"_id":"public/live2d_models/hijiki/assets/mtn/01.mtn","hash":"fb550833ae22c9954c3e01df37ed29b2d61700f2","modified":1601455558848},{"_id":"public/live2d_models/hijiki/assets/mtn/06.mtn","hash":"ad404bd852d276cdd3d054c953e23f90e4e45ae1","modified":1601455558848},{"_id":"public/live2d_models/hijiki/assets/mtn/08.mtn","hash":"4411c7651ff65195b113d95e7d5ebef8a59a37d9","modified":1601455558848},{"_id":"public/live2d_models/hijiki/assets/mtn/05.mtn","hash":"dd20ad24b5d1830a5d44b9bccb28f922eea5e0e5","modified":1601455558848},{"_id":"public/live2d_models/hijiki/assets/mtn/07.mtn","hash":"b7f2e3a9fa4f3ffbb6e64a08f8d9f45ca1868ffb","modified":1601455558848},{"_id":"public/live2dw/lib/L2Dwidget.min.js","hash":"5f1a807437cc723bcadc3791d37add5ceed566a2","modified":1601455558848},{"_id":"public/img/touxiang.jpg","hash":"321665a791d5be06342a8bbe2ea8f129b5dbb1a2","modified":1601455558848},{"_id":"public/lib/gitment.js.bak","hash":"ded86ac10cc79a7d28e2ea44778e792cef6c3470","modified":1601455558848},{"_id":"public/plugins/live2d-widget.js/L2Dwidget.min.js.map","hash":"75322ae0754f0580c0fb5ce9176ab72ce4009903","modified":1601455558848},{"_id":"public/lib/clickLove.js","hash":"9e8e79d69ad8338761272f86fe5cad0ad5e503cc","modified":1601455558848},{"_id":"public/lib/default.css","hash":"c9c344d5c98cc90b5583865e71726bab1046cdeb","modified":1601455558848},{"_id":"public/lib/busuanzi.pure.js","hash":"f54c44e2b30e551540b83640dd8c5ff266e157d5","modified":1601455558848},{"_id":"public/lib/snow.js","hash":"12ed5d697aa8a337064a1827ea94c0652c36b4e5","modified":1601455558848},{"_id":"public/lib/gitment.css","hash":"cb2e0be2c7ebbcc3e756340c811864115bf0ec56","modified":1601455558848},{"_id":"public/lib/oauthcallback.browser.js","hash":"989b9e2638336461a9911ebf60e9a839819dd11f","modified":1601455558848},{"_id":"public/lib/pace.min.js","hash":"9944dfb7814b911090e96446cea4d36e2b487234","modified":1601455558848},{"_id":"public/live2d_models/hijiki/package-lock.json","hash":"985ee74389f276692c88f3b039fcc632dc73819d","modified":1601455558848},{"_id":"public/live2d_models/hijiki/package.json","hash":"8f82d1cf92106d059f3a619910e5cc83bb6044d0","modified":1601455558848},{"_id":"public/plugins/TweenMax/HoverImg.js","hash":"ecc51aed76c22ca181870d4ba47765c0598e3a1b","modified":1601455558848},{"_id":"public/plugins/TweenMax/charming.min.js","hash":"0b11f943ec562c9031be07203058650eee74d73d","modified":1601455558848},{"_id":"public/plugins/ribbon.js/ribbon.js","hash":"65b1a8f12d04b15d7ed6eeb9d11dec760a799c5f","modified":1601455558848},{"_id":"public/plugins/live2d-widget.js/manifest.json","hash":"d3c86ddfd62f3560e306910369745116005f3892","modified":1601455558848},{"_id":"public/live2d_models/hijiki/assets/hijiki.model.json","hash":"feff43bf7498d213982c3736c2c029664e4bcbd2","modified":1601455558848},{"_id":"public/plugins/activate-power-mode/activate-power-mode.js","hash":"8161c7d2b8fd7fa407db3c3429edd8d19f82ae81","modified":1601455558848},{"_id":"public/live2d_models/hijiki/assets/hijiki.pose.json","hash":"81438bf69b32c7c11e311b4fe043730cdc7b7ec2","modified":1601455558848},{"_id":"public/plugins/ribbon.js/ribbon.min.js","hash":"3c8e4d717ca107f3723def1795c8ed62a5f1a8d0","modified":1601455558848},{"_id":"public/plugins/ribbon.js/demo/index.html","hash":"0a3ba4e5f245a96be24d5f529b8567e82e120766","modified":1601455558848},{"_id":"public/main.a5fda8.js","hash":"f8fde8b462ec0fbe1e5a231b9bd871241eacdc17","modified":1601455558848},{"_id":"public/slider.27463f.js","hash":"75db7fcc216082f7363c098fe81c3cbd5e3c87de","modified":1601455558848},{"_id":"public/main.a5fda8.css","hash":"58ee2cfe0bb700bd942588922eb62e10dd2e8194","modified":1601455558848},{"_id":"public/mobile.a2c207.js","hash":"448860f4e30351fada95db9c974e68b372182656","modified":1601455558848},{"_id":"public/lib/jquery-2.1.4.min.js","hash":"43dc554608df885a59ddeece1598c6ace434d747","modified":1601455558848},{"_id":"public/gitment/APlayer.min.js","hash":"9f131b6ca3b89e52545a279356b79530bbb52a64","modified":1601455558848},{"_id":"public/lib/gitment.js","hash":"d1dd326c7b21f36ad78d55c451a1f0bbb13d201c","modified":1601455558848},{"_id":"public/plugins/live2d-widget.js/L2Dwidget.min.js","hash":"189df71cee9f1273f134fd78114c72c69b5a44c1","modified":1601455558848},{"_id":"public/plugins/TweenMax/TweenMax.min.js","hash":"8598fc6507e8948a0f99a61bb1dc345ecc1e1f6f","modified":1601455558848},{"_id":"public/plugins/live2d-widget.js/L2Dwidget.0.min.js","hash":"3cfe69c7d1bf48ba529e243f3892f7919d57ccc0","modified":1601455558848},{"_id":"public/plugins/live2d-widget.js/L2Dwidget.common.js","hash":"b6a9fa8908ce9b64fe27b632935219eb10fd9283","modified":1601455558848},{"_id":"public/lib/giteement.browser.js","hash":"824925ebd507d6b6fe3005f6c90c64809638456b","modified":1601455558848},{"_id":"public/myDoc/live2d.js","hash":"09a1874e440b54920b19793395eb85c2261c99a5","modified":1601455558848},{"_id":"public/lib/gitment.js.bak2","hash":"8065a9364e25414c6a37d4be181f1c6052c4d590","modified":1601455558848},{"_id":"public/live2d_models/hijiki/assets/moc/hijiki.moc","hash":"44289e62545a7046e0f5231103a851750b78524e","modified":1601455558848},{"_id":"public/live2dw/lib/L2Dwidget.0.min.js","hash":"35bb5b588b6de25c9be2dd51d3fd331feafac02d","modified":1601455558848},{"_id":"public/live2dw/lib/L2Dwidget.min.js.map","hash":"3290fe2df45f065b51a1cd7b24ec325cbf9bb5ce","modified":1601455558848},{"_id":"public/live2d_models/hijiki/assets/moc/hijiki.2048/texture_00.png","hash":"66464e0d96439695b5542c5e2f5be60739c29999","modified":1601455558848},{"_id":"public/plugins/live2d-widget.js/L2Dwidget.0.min.js.map","hash":"3b3a7076b747b092d6e48f42a8a3497aa21280ee","modified":1601455558848},{"_id":"public/live2dw/lib/L2Dwidget.0.min.js.map","hash":"35e71cc2a130199efb167b9a06939576602f0d75","modified":1601455558848},{"_id":"public/plugins/live2d-widget.js/L2Dwidget.common.js.map","hash":"8de60ae490ab3d62c91c8ce60a256079b6afd3d8","modified":1601455558848},{"_id":"public/img/tianping.png","hash":"b351ad922d937c8c0c80f46e0ce3438f1918b0c6","modified":1601455558848},{"_id":"public/img/xiaoniao.gif","hash":"471319edf40b3b133a0160cda99b51b119668432","modified":1601455558848}],"Category":[],"Data":[],"Page":[{"title":"404 Not Found：该页无法显示","toc":false,"comments":0,"_content":"<!DOCTYPE html>\n<html>\n    <head>\n         <meta charset=\"UTF-8\" />\n         <title>404</title>                                                                                                                                        \n    </head>\n    <body>\n         <script type=\"text/javascript\" src=\"//qzonestyle.gtimg.cn/qzone/hybrid/app/404/search_children.js\" homePageName=\"返回首页\" homePageUrl=\"https://lswgg.github.io\"></script>\n\t</body>\n</html>","source":"404/404.html","raw":"---\ntitle: 404 Not Found：该页无法显示\ntoc: false\ncomments: false\npermalink: /404\n---\n<!DOCTYPE html>\n<html>\n    <head>\n         <meta charset=\"UTF-8\" />\n         <title>404</title>                                                                                                                                        \n    </head>\n    <body>\n         <script type=\"text/javascript\" src=\"//qzonestyle.gtimg.cn/qzone/hybrid/app/404/search_children.js\" homePageName=\"返回首页\" homePageUrl=\"https://lswgg.github.io\"></script>\n\t</body>\n</html>","date":"2020-08-11T01:11:25.684Z","updated":"2019-12-06T13:00:08.700Z","path":"/404.html","layout":"page","_id":"ckfp5ake80000n8jh3uube76i","content":"<!DOCTYPE html>\n<html>\n    <head>\n         <meta charset=\"UTF-8\" />\n         <title>404</title>\n  <meta name=\"generator\" content=\"hexo-theme-yilia-plus\">                                                                                                                                        \n    </head>\n    <body>\n         <script type=\"text/javascript\" src=\"//qzonestyle.gtimg.cn/qzone/hybrid/app/404/search_children.js\" homePageName=\"返回首页\" homePageUrl=\"https://lswgg.github.io\"></script>\n\t<script src=\"/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05\"></script><script>L2Dwidget.init({\"log\":false,\"pluginJsPath\":\"lib/\",\"pluginModelPath\":\"assets/\",\"pluginRootPath\":\"live2dw/\",\"tagMode\":false});</script></body>\n</html>","site":{"data":{}},"excerpt":"","more":"<!DOCTYPE html>\n<html>\n    <head>\n         <meta charset=\"UTF-8\" />\n         <title>404</title>\n  <meta name=\"generator\" content=\"hexo-theme-yilia-plus\">                                                                                                                                        \n    </head>\n    <body>\n         <script type=\"text/javascript\" src=\"//qzonestyle.gtimg.cn/qzone/hybrid/app/404/search_children.js\" homePageName=\"返回首页\" homePageUrl=\"https://lswgg.github.io\"></script>\n\t<script src=\"/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05\"></script><script>L2Dwidget.init({\"log\":false,\"pluginJsPath\":\"lib/\",\"pluginModelPath\":\"assets/\",\"pluginRootPath\":\"live2dw/\",\"tagMode\":false});</script></body>\n</html>"}],"Post":[{"title":"Django补充","date":"2020-09-30T03:40:58.000Z","top":0,"_content":"\n## 静态化与缓存的主要区别\n\n- 静态化：将数据静态化到页面，客户端访问时不查询数据库，存储与硬盘\n- 缓存：将数据存储于服务器内存\n\n<!--more-->\n\n## 定时任务的原理\n\n- 由**crond守护进程**和**crontab文件（任务表）**组成\n\n- 守护进程在系统启动时由init进程启动，受init监视，如果它挂了，init会重启它守护进程每分钟唤醒一次，通过检查crontab文件判断需要做什么\n\n  ```bash\n  # 添加定时任务到系统中\n  $ python manage.py crontab add\n  \n  # 显示已激活的定时任务\n  $ python manage.py crontab show\n  \n  # 移除定时任务\n  $ python manage.py crontab remove\n  ```\n\n## 支付宝接入\n\n- Python支付宝SDK：https://github.com/fzlee/alipay/blob/master/README.zh-hans.md ","source":"_posts/Django操作补充.md","raw":"---\ntitle: Django补充\ndate: 2020-09-30 11:40:58\ntags: Python\ntop: 0\n---\n\n## 静态化与缓存的主要区别\n\n- 静态化：将数据静态化到页面，客户端访问时不查询数据库，存储与硬盘\n- 缓存：将数据存储于服务器内存\n\n<!--more-->\n\n## 定时任务的原理\n\n- 由**crond守护进程**和**crontab文件（任务表）**组成\n\n- 守护进程在系统启动时由init进程启动，受init监视，如果它挂了，init会重启它守护进程每分钟唤醒一次，通过检查crontab文件判断需要做什么\n\n  ```bash\n  # 添加定时任务到系统中\n  $ python manage.py crontab add\n  \n  # 显示已激活的定时任务\n  $ python manage.py crontab show\n  \n  # 移除定时任务\n  $ python manage.py crontab remove\n  ```\n\n## 支付宝接入\n\n- Python支付宝SDK：https://github.com/fzlee/alipay/blob/master/README.zh-hans.md ","slug":"Django操作补充","published":1,"updated":"2020-09-30T08:10:08.881Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckfp5akee0001n8jhhqxb4qbx","content":"<h2 id=\"静态化与缓存的主要区别\"><a href=\"#静态化与缓存的主要区别\" class=\"headerlink\" title=\"静态化与缓存的主要区别\"></a>静态化与缓存的主要区别</h2><ul>\n<li>静态化：将数据静态化到页面，客户端访问时不查询数据库，存储与硬盘</li>\n<li>缓存：将数据存储于服务器内存</li>\n</ul>\n<a id=\"more\"></a>\n\n<h2 id=\"定时任务的原理\"><a href=\"#定时任务的原理\" class=\"headerlink\" title=\"定时任务的原理\"></a>定时任务的原理</h2><ul>\n<li><p>由<strong>crond守护进程</strong>和<strong>crontab文件（任务表）</strong>组成</p>\n</li>\n<li><p>守护进程在系统启动时由init进程启动，受init监视，如果它挂了，init会重启它守护进程每分钟唤醒一次，通过检查crontab文件判断需要做什么</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 添加定时任务到系统中</span></span><br><span class=\"line\">$ python manage.py crontab add</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 显示已激活的定时任务</span></span><br><span class=\"line\">$ python manage.py crontab show</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 移除定时任务</span></span><br><span class=\"line\">$ python manage.py crontab remove</span><br></pre></td></tr></table></figure>\n\n</li>\n</ul>\n<h2 id=\"支付宝接入\"><a href=\"#支付宝接入\" class=\"headerlink\" title=\"支付宝接入\"></a>支付宝接入</h2><ul>\n<li>Python支付宝SDK：<a href=\"https://github.com/fzlee/alipay/blob/master/README.zh-hans.md\" target=\"_blank\" rel=\"noopener\">https://github.com/fzlee/alipay/blob/master/README.zh-hans.md</a> </li>\n</ul>\n","site":{"data":{}},"excerpt":"<h2 id=\"静态化与缓存的主要区别\"><a href=\"#静态化与缓存的主要区别\" class=\"headerlink\" title=\"静态化与缓存的主要区别\"></a>静态化与缓存的主要区别</h2><ul>\n<li>静态化：将数据静态化到页面，客户端访问时不查询数据库，存储与硬盘</li>\n<li>缓存：将数据存储于服务器内存</li>\n</ul>","more":"<h2 id=\"定时任务的原理\"><a href=\"#定时任务的原理\" class=\"headerlink\" title=\"定时任务的原理\"></a>定时任务的原理</h2><ul>\n<li><p>由<strong>crond守护进程</strong>和<strong>crontab文件（任务表）</strong>组成</p>\n</li>\n<li><p>守护进程在系统启动时由init进程启动，受init监视，如果它挂了，init会重启它守护进程每分钟唤醒一次，通过检查crontab文件判断需要做什么</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 添加定时任务到系统中</span></span><br><span class=\"line\">$ python manage.py crontab add</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 显示已激活的定时任务</span></span><br><span class=\"line\">$ python manage.py crontab show</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 移除定时任务</span></span><br><span class=\"line\">$ python manage.py crontab remove</span><br></pre></td></tr></table></figure>\n\n</li>\n</ul>\n<h2 id=\"支付宝接入\"><a href=\"#支付宝接入\" class=\"headerlink\" title=\"支付宝接入\"></a>支付宝接入</h2><ul>\n<li>Python支付宝SDK：<a href=\"https://github.com/fzlee/alipay/blob/master/README.zh-hans.md\" target=\"_blank\" rel=\"noopener\">https://github.com/fzlee/alipay/blob/master/README.zh-hans.md</a> </li>\n</ul>"},{"title":"Docker基础操作","date":"2020-09-30T03:36:28.000Z","top":0,"_content":"\n# Docker\n\n**开源的软件部署解决方案、轻量级的应用容器框架，采用C/S架构，其可以轻松的为任何应用创建一个轻量级的、可移植的、自给自足的容器。**\n\n> 是一种快速解决生产问题的一种技术手段。\n\n<!--more-->\n\n优缺点：\n\n- 优：\n  - 多： 适用场景多\n  - 快： 环境部署快、更新快\n  - 好： 好多人在用，东西好\n  - 省： 省钱省力省人工(123原则)\n- 缺：\n  - 太腻歪人： 依赖操作系统\n  - 不善于沟通：依赖网络\n  - 不善理财： 银行U盾等场景不能用\n\n**镜像**\n\n- 类似虚拟机的镜像，可以创建新的容器\n\n```dockerfile\n# 镜像\ndocker search [image_name]\t\t\t# 搜索镜像\ndocker pull [image_name]\t\t\t# 获取镜像\ndocker images\t\t\t\t\t\t# 查看镜像\ndocker history [image_name]\t\t\t# 查看镜像历史\ndocker tag [old_image]:[old_version]\t# 重命名\ndocker rm [image_name]\t\t\t\t# 删除\ndocker save -o [包文件] [镜像]\t\t# 导出镜像\ndocker load -i [image.tar_name]\t\t# 导入镜像\n```\n\n**容器**\n\n- 由镜像创建的运行实例，类似虚拟机\n\n```dockerfile\n# 容器\ndocker ps\t\t\t\t\t\t\t\t# 查看容器\ndocker start [container_id]\t\t\t\t# 启动已终止的容器\ndocker stop [container_id]\t\t\t\t# 关闭\ndocker rm [container_id]\t\t\t\t# 删除\n\t\t-f\t\t# 强制删除\ndocker run [docker_image] /bin/bash\n\t\t--name\t# 给容器定义一个名称\n\t\t-i \t\t# 让容器的标准输入保持打开。\n\t\t-t\t\t# 分配一个伪终端,并绑定到容器的标准输入上\n\t\t-d \t\t# 守护进程开启\n\t\t-v\t\t# 本地:容器 --映射\n\t\t-p  \t# 端口映射\ndocker exec -it 容器id /bin/bash\t\t\t# 进入后台运行容器\ndocker commit [container_id] [new_image:tag]\t# 基于容器创建镜像\n\t\t-m \t\t# '改动信息' \n\t\t-a \t\t# \"作者信息\"\ndocker logs [容器id]\t\t\t\t\t# 查看运行日志\ndocker inspect  [容器id]\t\t\t\t# 查看详细信息\n```\n\n**仓库（公有、私有、本地）**\n\n- 托管镜像\n\n# dockerflie\n\n Dockerfile类似于我们学习过的脚本，将我们在上面学到的镜像，使用自动化的方式实现出来。\n\n```dockerfile\n# 基础指令\nFROM <image>\t\t\t\t\t# 第一条指令（除首行注释外）\nMAINTAINER <name>\t\t\t\t# 作者信息\nRUN <command>\t\t\t\t\t# 镜像构建时候运行的命令\nEXPOSE <port>\t\t\t\t\t# 对外开发端口\nENTRYPOINT python3 manage.py runserver 0.0.0.0:8000\n\t\t\t\t\t\t\t\t# 运行Django项目，只能有一个\n\n# 文件编辑指令\nADD <src>... <dest>\t\t# 将指定的 <src> 文件复制到容器文件系统中的 <dest>\nCOPY <src>... <dest>\t\t\t# 复制文件\n\n# 环境指令\nENV <key> <value>\t\t\t\t# 设置环境变量\nWORKDIR /path/to/workdir\t\t# 切换目录\n```\n\n> 参考文档：\n>\n> 1.  [中文社区](http://www.docker.org.cn/index.html)","source":"_posts/Docker基础操作.md","raw":"---\ntitle: Docker基础操作\ndate: 2020-09-30 11:36:28\ntags: tool\ntop: 0\n---\n\n# Docker\n\n**开源的软件部署解决方案、轻量级的应用容器框架，采用C/S架构，其可以轻松的为任何应用创建一个轻量级的、可移植的、自给自足的容器。**\n\n> 是一种快速解决生产问题的一种技术手段。\n\n<!--more-->\n\n优缺点：\n\n- 优：\n  - 多： 适用场景多\n  - 快： 环境部署快、更新快\n  - 好： 好多人在用，东西好\n  - 省： 省钱省力省人工(123原则)\n- 缺：\n  - 太腻歪人： 依赖操作系统\n  - 不善于沟通：依赖网络\n  - 不善理财： 银行U盾等场景不能用\n\n**镜像**\n\n- 类似虚拟机的镜像，可以创建新的容器\n\n```dockerfile\n# 镜像\ndocker search [image_name]\t\t\t# 搜索镜像\ndocker pull [image_name]\t\t\t# 获取镜像\ndocker images\t\t\t\t\t\t# 查看镜像\ndocker history [image_name]\t\t\t# 查看镜像历史\ndocker tag [old_image]:[old_version]\t# 重命名\ndocker rm [image_name]\t\t\t\t# 删除\ndocker save -o [包文件] [镜像]\t\t# 导出镜像\ndocker load -i [image.tar_name]\t\t# 导入镜像\n```\n\n**容器**\n\n- 由镜像创建的运行实例，类似虚拟机\n\n```dockerfile\n# 容器\ndocker ps\t\t\t\t\t\t\t\t# 查看容器\ndocker start [container_id]\t\t\t\t# 启动已终止的容器\ndocker stop [container_id]\t\t\t\t# 关闭\ndocker rm [container_id]\t\t\t\t# 删除\n\t\t-f\t\t# 强制删除\ndocker run [docker_image] /bin/bash\n\t\t--name\t# 给容器定义一个名称\n\t\t-i \t\t# 让容器的标准输入保持打开。\n\t\t-t\t\t# 分配一个伪终端,并绑定到容器的标准输入上\n\t\t-d \t\t# 守护进程开启\n\t\t-v\t\t# 本地:容器 --映射\n\t\t-p  \t# 端口映射\ndocker exec -it 容器id /bin/bash\t\t\t# 进入后台运行容器\ndocker commit [container_id] [new_image:tag]\t# 基于容器创建镜像\n\t\t-m \t\t# '改动信息' \n\t\t-a \t\t# \"作者信息\"\ndocker logs [容器id]\t\t\t\t\t# 查看运行日志\ndocker inspect  [容器id]\t\t\t\t# 查看详细信息\n```\n\n**仓库（公有、私有、本地）**\n\n- 托管镜像\n\n# dockerflie\n\n Dockerfile类似于我们学习过的脚本，将我们在上面学到的镜像，使用自动化的方式实现出来。\n\n```dockerfile\n# 基础指令\nFROM <image>\t\t\t\t\t# 第一条指令（除首行注释外）\nMAINTAINER <name>\t\t\t\t# 作者信息\nRUN <command>\t\t\t\t\t# 镜像构建时候运行的命令\nEXPOSE <port>\t\t\t\t\t# 对外开发端口\nENTRYPOINT python3 manage.py runserver 0.0.0.0:8000\n\t\t\t\t\t\t\t\t# 运行Django项目，只能有一个\n\n# 文件编辑指令\nADD <src>... <dest>\t\t# 将指定的 <src> 文件复制到容器文件系统中的 <dest>\nCOPY <src>... <dest>\t\t\t# 复制文件\n\n# 环境指令\nENV <key> <value>\t\t\t\t# 设置环境变量\nWORKDIR /path/to/workdir\t\t# 切换目录\n```\n\n> 参考文档：\n>\n> 1.  [中文社区](http://www.docker.org.cn/index.html)","slug":"Docker基础操作","published":1,"updated":"2020-09-30T08:04:17.914Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckfp5akeg0002n8jh8n971q0s","content":"<h1 id=\"Docker\"><a href=\"#Docker\" class=\"headerlink\" title=\"Docker\"></a>Docker</h1><p><strong>开源的软件部署解决方案、轻量级的应用容器框架，采用C/S架构，其可以轻松的为任何应用创建一个轻量级的、可移植的、自给自足的容器。</strong></p>\n<blockquote>\n<p>是一种快速解决生产问题的一种技术手段。</p>\n</blockquote>\n<a id=\"more\"></a>\n\n<p>优缺点：</p>\n<ul>\n<li>优：<ul>\n<li>多： 适用场景多</li>\n<li>快： 环境部署快、更新快</li>\n<li>好： 好多人在用，东西好</li>\n<li>省： 省钱省力省人工(123原则)</li>\n</ul>\n</li>\n<li>缺：<ul>\n<li>太腻歪人： 依赖操作系统</li>\n<li>不善于沟通：依赖网络</li>\n<li>不善理财： 银行U盾等场景不能用</li>\n</ul>\n</li>\n</ul>\n<p><strong>镜像</strong></p>\n<ul>\n<li>类似虚拟机的镜像，可以创建新的容器</li>\n</ul>\n<figure class=\"highlight dockerfile\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 镜像</span></span><br><span class=\"line\">docker search [image_name]\t\t\t<span class=\"comment\"># 搜索镜像</span></span><br><span class=\"line\">docker pull [image_name]\t\t\t<span class=\"comment\"># 获取镜像</span></span><br><span class=\"line\">docker images\t\t\t\t\t\t<span class=\"comment\"># 查看镜像</span></span><br><span class=\"line\">docker history [image_name]\t\t\t<span class=\"comment\"># 查看镜像历史</span></span><br><span class=\"line\">docker tag [old_image]:[old_version]\t<span class=\"comment\"># 重命名</span></span><br><span class=\"line\">docker rm [image_name]\t\t\t\t<span class=\"comment\"># 删除</span></span><br><span class=\"line\">docker save -o [包文件] [镜像]\t\t<span class=\"comment\"># 导出镜像</span></span><br><span class=\"line\">docker load -i [image.tar_name]\t\t<span class=\"comment\"># 导入镜像</span></span><br></pre></td></tr></table></figure>\n\n<p><strong>容器</strong></p>\n<ul>\n<li>由镜像创建的运行实例，类似虚拟机</li>\n</ul>\n<figure class=\"highlight dockerfile\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 容器</span></span><br><span class=\"line\">docker ps\t\t\t\t\t\t\t\t<span class=\"comment\"># 查看容器</span></span><br><span class=\"line\">docker start [container_id]\t\t\t\t<span class=\"comment\"># 启动已终止的容器</span></span><br><span class=\"line\">docker stop [container_id]\t\t\t\t<span class=\"comment\"># 关闭</span></span><br><span class=\"line\">docker rm [container_id]\t\t\t\t<span class=\"comment\"># 删除</span></span><br><span class=\"line\">\t\t-f\t\t<span class=\"comment\"># 强制删除</span></span><br><span class=\"line\">docker <span class=\"keyword\">run</span><span class=\"bash\"> [docker_image] /bin/bash</span></span><br><span class=\"line\">\t\t--name\t<span class=\"comment\"># 给容器定义一个名称</span></span><br><span class=\"line\">\t\t-i \t\t<span class=\"comment\"># 让容器的标准输入保持打开。</span></span><br><span class=\"line\">\t\t-t\t\t<span class=\"comment\"># 分配一个伪终端,并绑定到容器的标准输入上</span></span><br><span class=\"line\">\t\t-d \t\t<span class=\"comment\"># 守护进程开启</span></span><br><span class=\"line\">\t\t-v\t\t<span class=\"comment\"># 本地:容器 --映射</span></span><br><span class=\"line\">\t\t-p  \t<span class=\"comment\"># 端口映射</span></span><br><span class=\"line\">docker exec -it 容器id /bin/bash\t\t\t<span class=\"comment\"># 进入后台运行容器</span></span><br><span class=\"line\">docker commit [container_id] [new_image:tag]\t<span class=\"comment\"># 基于容器创建镜像</span></span><br><span class=\"line\">\t\t-m \t\t<span class=\"comment\"># '改动信息' </span></span><br><span class=\"line\">\t\t-a \t\t<span class=\"comment\"># \"作者信息\"</span></span><br><span class=\"line\">docker logs [容器id]\t\t\t\t\t<span class=\"comment\"># 查看运行日志</span></span><br><span class=\"line\">docker inspect  [容器id]\t\t\t\t<span class=\"comment\"># 查看详细信息</span></span><br></pre></td></tr></table></figure>\n\n<p><strong>仓库（公有、私有、本地）</strong></p>\n<ul>\n<li>托管镜像</li>\n</ul>\n<h1 id=\"dockerflie\"><a href=\"#dockerflie\" class=\"headerlink\" title=\"dockerflie\"></a>dockerflie</h1><p> Dockerfile类似于我们学习过的脚本，将我们在上面学到的镜像，使用自动化的方式实现出来。</p>\n<figure class=\"highlight dockerfile\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 基础指令</span></span><br><span class=\"line\"><span class=\"keyword\">FROM</span> &lt;image&gt;\t\t\t\t\t<span class=\"comment\"># 第一条指令（除首行注释外）</span></span><br><span class=\"line\"><span class=\"keyword\">MAINTAINER</span> &lt;name&gt;\t\t\t\t<span class=\"comment\"># 作者信息</span></span><br><span class=\"line\"><span class=\"keyword\">RUN</span><span class=\"bash\"> &lt;<span class=\"built_in\">command</span>&gt;\t\t\t\t\t<span class=\"comment\"># 镜像构建时候运行的命令</span></span></span><br><span class=\"line\"><span class=\"keyword\">EXPOSE</span> &lt;port&gt;\t\t\t\t\t<span class=\"comment\"># 对外开发端口</span></span><br><span class=\"line\"><span class=\"keyword\">ENTRYPOINT</span><span class=\"bash\"> python3 manage.py runserver 0.0.0.0:8000</span></span><br><span class=\"line\">\t\t\t\t\t\t\t\t<span class=\"comment\"># 运行Django项目，只能有一个</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 文件编辑指令</span></span><br><span class=\"line\"><span class=\"keyword\">ADD</span><span class=\"bash\"> &lt;src&gt;... &lt;dest&gt;\t\t<span class=\"comment\"># 将指定的 &lt;src&gt; 文件复制到容器文件系统中的 &lt;dest&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">COPY</span><span class=\"bash\"> &lt;src&gt;... &lt;dest&gt;\t\t\t<span class=\"comment\"># 复制文件</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 环境指令</span></span><br><span class=\"line\"><span class=\"keyword\">ENV</span> &lt;key&gt; &lt;value&gt;\t\t\t\t<span class=\"comment\"># 设置环境变量</span></span><br><span class=\"line\"><span class=\"keyword\">WORKDIR</span><span class=\"bash\"> /path/to/workdir\t\t<span class=\"comment\"># 切换目录</span></span></span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>参考文档：</p>\n<ol>\n<li><a href=\"http://www.docker.org.cn/index.html\" target=\"_blank\" rel=\"noopener\">中文社区</a></li>\n</ol>\n</blockquote>\n","site":{"data":{}},"excerpt":"<h1 id=\"Docker\"><a href=\"#Docker\" class=\"headerlink\" title=\"Docker\"></a>Docker</h1><p><strong>开源的软件部署解决方案、轻量级的应用容器框架，采用C/S架构，其可以轻松的为任何应用创建一个轻量级的、可移植的、自给自足的容器。</strong></p>\n<blockquote>\n<p>是一种快速解决生产问题的一种技术手段。</p>\n</blockquote>","more":"<p>优缺点：</p>\n<ul>\n<li>优：<ul>\n<li>多： 适用场景多</li>\n<li>快： 环境部署快、更新快</li>\n<li>好： 好多人在用，东西好</li>\n<li>省： 省钱省力省人工(123原则)</li>\n</ul>\n</li>\n<li>缺：<ul>\n<li>太腻歪人： 依赖操作系统</li>\n<li>不善于沟通：依赖网络</li>\n<li>不善理财： 银行U盾等场景不能用</li>\n</ul>\n</li>\n</ul>\n<p><strong>镜像</strong></p>\n<ul>\n<li>类似虚拟机的镜像，可以创建新的容器</li>\n</ul>\n<figure class=\"highlight dockerfile\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 镜像</span></span><br><span class=\"line\">docker search [image_name]\t\t\t<span class=\"comment\"># 搜索镜像</span></span><br><span class=\"line\">docker pull [image_name]\t\t\t<span class=\"comment\"># 获取镜像</span></span><br><span class=\"line\">docker images\t\t\t\t\t\t<span class=\"comment\"># 查看镜像</span></span><br><span class=\"line\">docker history [image_name]\t\t\t<span class=\"comment\"># 查看镜像历史</span></span><br><span class=\"line\">docker tag [old_image]:[old_version]\t<span class=\"comment\"># 重命名</span></span><br><span class=\"line\">docker rm [image_name]\t\t\t\t<span class=\"comment\"># 删除</span></span><br><span class=\"line\">docker save -o [包文件] [镜像]\t\t<span class=\"comment\"># 导出镜像</span></span><br><span class=\"line\">docker load -i [image.tar_name]\t\t<span class=\"comment\"># 导入镜像</span></span><br></pre></td></tr></table></figure>\n\n<p><strong>容器</strong></p>\n<ul>\n<li>由镜像创建的运行实例，类似虚拟机</li>\n</ul>\n<figure class=\"highlight dockerfile\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 容器</span></span><br><span class=\"line\">docker ps\t\t\t\t\t\t\t\t<span class=\"comment\"># 查看容器</span></span><br><span class=\"line\">docker start [container_id]\t\t\t\t<span class=\"comment\"># 启动已终止的容器</span></span><br><span class=\"line\">docker stop [container_id]\t\t\t\t<span class=\"comment\"># 关闭</span></span><br><span class=\"line\">docker rm [container_id]\t\t\t\t<span class=\"comment\"># 删除</span></span><br><span class=\"line\">\t\t-f\t\t<span class=\"comment\"># 强制删除</span></span><br><span class=\"line\">docker <span class=\"keyword\">run</span><span class=\"bash\"> [docker_image] /bin/bash</span></span><br><span class=\"line\">\t\t--name\t<span class=\"comment\"># 给容器定义一个名称</span></span><br><span class=\"line\">\t\t-i \t\t<span class=\"comment\"># 让容器的标准输入保持打开。</span></span><br><span class=\"line\">\t\t-t\t\t<span class=\"comment\"># 分配一个伪终端,并绑定到容器的标准输入上</span></span><br><span class=\"line\">\t\t-d \t\t<span class=\"comment\"># 守护进程开启</span></span><br><span class=\"line\">\t\t-v\t\t<span class=\"comment\"># 本地:容器 --映射</span></span><br><span class=\"line\">\t\t-p  \t<span class=\"comment\"># 端口映射</span></span><br><span class=\"line\">docker exec -it 容器id /bin/bash\t\t\t<span class=\"comment\"># 进入后台运行容器</span></span><br><span class=\"line\">docker commit [container_id] [new_image:tag]\t<span class=\"comment\"># 基于容器创建镜像</span></span><br><span class=\"line\">\t\t-m \t\t<span class=\"comment\"># '改动信息' </span></span><br><span class=\"line\">\t\t-a \t\t<span class=\"comment\"># \"作者信息\"</span></span><br><span class=\"line\">docker logs [容器id]\t\t\t\t\t<span class=\"comment\"># 查看运行日志</span></span><br><span class=\"line\">docker inspect  [容器id]\t\t\t\t<span class=\"comment\"># 查看详细信息</span></span><br></pre></td></tr></table></figure>\n\n<p><strong>仓库（公有、私有、本地）</strong></p>\n<ul>\n<li>托管镜像</li>\n</ul>\n<h1 id=\"dockerflie\"><a href=\"#dockerflie\" class=\"headerlink\" title=\"dockerflie\"></a>dockerflie</h1><p> Dockerfile类似于我们学习过的脚本，将我们在上面学到的镜像，使用自动化的方式实现出来。</p>\n<figure class=\"highlight dockerfile\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 基础指令</span></span><br><span class=\"line\"><span class=\"keyword\">FROM</span> &lt;image&gt;\t\t\t\t\t<span class=\"comment\"># 第一条指令（除首行注释外）</span></span><br><span class=\"line\"><span class=\"keyword\">MAINTAINER</span> &lt;name&gt;\t\t\t\t<span class=\"comment\"># 作者信息</span></span><br><span class=\"line\"><span class=\"keyword\">RUN</span><span class=\"bash\"> &lt;<span class=\"built_in\">command</span>&gt;\t\t\t\t\t<span class=\"comment\"># 镜像构建时候运行的命令</span></span></span><br><span class=\"line\"><span class=\"keyword\">EXPOSE</span> &lt;port&gt;\t\t\t\t\t<span class=\"comment\"># 对外开发端口</span></span><br><span class=\"line\"><span class=\"keyword\">ENTRYPOINT</span><span class=\"bash\"> python3 manage.py runserver 0.0.0.0:8000</span></span><br><span class=\"line\">\t\t\t\t\t\t\t\t<span class=\"comment\"># 运行Django项目，只能有一个</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 文件编辑指令</span></span><br><span class=\"line\"><span class=\"keyword\">ADD</span><span class=\"bash\"> &lt;src&gt;... &lt;dest&gt;\t\t<span class=\"comment\"># 将指定的 &lt;src&gt; 文件复制到容器文件系统中的 &lt;dest&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">COPY</span><span class=\"bash\"> &lt;src&gt;... &lt;dest&gt;\t\t\t<span class=\"comment\"># 复制文件</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 环境指令</span></span><br><span class=\"line\"><span class=\"keyword\">ENV</span> &lt;key&gt; &lt;value&gt;\t\t\t\t<span class=\"comment\"># 设置环境变量</span></span><br><span class=\"line\"><span class=\"keyword\">WORKDIR</span><span class=\"bash\"> /path/to/workdir\t\t<span class=\"comment\"># 切换目录</span></span></span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>参考文档：</p>\n<ol>\n<li><a href=\"http://www.docker.org.cn/index.html\" target=\"_blank\" rel=\"noopener\">中文社区</a></li>\n</ol>\n</blockquote>"},{"title":"Flask和Django","date":"2020-09-30T03:21:03.000Z","top":0,"_content":"\n# Flask和Django\n\n- **轻量、简洁、扩展性强，原生不支持数据库**\n- 核心：werkzeug和jinja2\n\n<!--more-->\n## 1. Flask与Django对比\n\n- 与Django对比\n  - 不同点：\n    1. Django：支持 ORM、认证、CSRF/模板、后台管理等。 \n    2. Flask：自带jinja2模板，实现其它功能需要调用扩展包\n  - 相同点：\n    1.  性能都不⾼，都是单进程服务器。 \n\n## 2. MVT设计模式\n\n设计模式：解决一类问题而总结出来的经验和套路\n\n**MVC：**核心思想：分工、解耦，让不同代码之间降低耦合，增强代码的可扩展性和可移植性\n\n**MVT：**\n\n- M：模型 Model\n- V：视图 View\n- T：模板 Template\n\n## 3. Django信号\n\n**Django 提供一个“信号分发器”，允许解耦的应用在框架的其它地方发生操作时会被通知到。信号允许特定的sender（发送者）通知一组receiver（接收者）某些操作已经发生。**\n\n信号遵守的设计模式：**观察者设计模式（通知机制、监听机制）**\n\n- [使用](https://handout-1300728887.cos.ap-beijing.myqcloud.com/%E8%AE%B2%E4%B9%89/%E6%80%9D%E7%BB%B4%E5%AF%BC%E5%9B%BE/Django%E4%BF%A1%E5%8F%B7.jpg)\n\n## 4. Django项目中的社会化分享\n\n结合项目中使用：\n\n- MobTech平台创建应用：https://www.mob.com/\n\n  1. 注册登录\n  2. 产品中心 --> 开发者平台\n  3. 创建应用并添加产品和SDK\n  4. 进入到<应用管理>查看App Key和App Secret\n\n- 创建Django项目\n\n- 根据开发文档集成ShareSDK\n\n  - 进入文档中心，打开web集成文档\n\n    https://www.mob.com/wiki/list\n\n  - 根据开发文档集成ShareSDK，实现社会化分享功能\n\n## 5. ORM(object-relation-mapping)\n\n[参考文档](https://handout-1300728887.cos.ap-beijing.myqcloud.com/%E8%AE%B2%E4%B9%89/%E9%BB%91%E9%A9%AC%E5%A4%B4%E6%9D%A1%E9%A1%B9%E7%9B%AE%E8%AF%BE%E4%BB%B6/C02-Database/ORM.html)\n\n\n- 对象关系映射 本质上就是将数据从一种形式转换到另外一种形式，定义的类相当于数据库中的表，在类中的定义的属性相当于是表中的字段，实例化的每一个对象，相当于的每一条数据。\n  - 类 -> 表\n  - 类属性 -> 字段\n  - 类对象 -> 数据\n\n- 作用：\n\n  1. 省去编写sql语句，提⾼开发效率；\n\n  2. 防注⼊攻击\n\n  3. 适配不同的数据库。\n- 缺点：查询效率较低，需要手动的优化。\n- 操作方式：\n\n  1. 先创建模型类，再迁移到数据库中：不能对数据库表的字段的定义，实现精确控制。 \n  2. 使⽤sql创建数据库的表，定义模型类，通过模型类，实现ORM操作。 \n## 6. 中间件的定义方式、结构\n\n```python\ndef middleware_name(get_response):\n    # 这个节点表示请求初始化：在最开始的时候补充额外逻辑\n    def middleware(request):\n        # 这个节点表示请求被执行前：在请求执行的时候补充额外逻辑\n        response = get_response(request)\n        # z这个节点表示响应之前：在响应之前补充额外逻辑\n        return response\n    return middleware\n```\n\n# Q&F\n\n## 1. 前后端不分离的区别\n\n前后端不分离：\n\n- 页面的控制和渲染是由后端实现的\n  - 优点：页面展示无延迟，因为响应给用户的就是页面；方便实现搜索引擎排名，帮助爬虫服务器更高效率的爬取数据，即SEO\n  - 缺点：对后端程序员要求高\n\n前后端分离：\n\n- 页面的控制和渲染是由前端实现的\n  - 优点：后端程序员只需专注数据和业务即可\n  - 缺点：有延迟，先加载页面 -- 发请求获取数据 -- 渲染\n- 补充：前后端不分离，一般不做页面静态化，因为用户先拿到的就是静态页面\n\n## 2. Django自带的缓存cache和redis的区别\n\ncache是python实现缓存的一种工具\n\nredis是一种存放缓存数据的数据库\n\n可以使用cache这个缓存工具，将缓存数据缓存到redis数据库\n\n## 3. 如何对Django框架进行二次开发，增大并发数\n\n可能造成并发降低的原因：\n\n1. 数据库操作变慢\n2. python语言执行速度变慢\n\nDjango二次开发方向：\n\n- 扩展Django Models使其支持Sharding（一种数据库分片技术）\n- 手动关闭GC（垃圾回收）\n- **把那些稳定且对性能最敏感的组件，使用c或c++来重写**","source":"_posts/Flask和Django.md","raw":"---\ntitle: Flask和Django\ndate: 2020-09-30 11:21:03\ntags: Web\ntop: 0\n---\n\n# Flask和Django\n\n- **轻量、简洁、扩展性强，原生不支持数据库**\n- 核心：werkzeug和jinja2\n\n<!--more-->\n## 1. Flask与Django对比\n\n- 与Django对比\n  - 不同点：\n    1. Django：支持 ORM、认证、CSRF/模板、后台管理等。 \n    2. Flask：自带jinja2模板，实现其它功能需要调用扩展包\n  - 相同点：\n    1.  性能都不⾼，都是单进程服务器。 \n\n## 2. MVT设计模式\n\n设计模式：解决一类问题而总结出来的经验和套路\n\n**MVC：**核心思想：分工、解耦，让不同代码之间降低耦合，增强代码的可扩展性和可移植性\n\n**MVT：**\n\n- M：模型 Model\n- V：视图 View\n- T：模板 Template\n\n## 3. Django信号\n\n**Django 提供一个“信号分发器”，允许解耦的应用在框架的其它地方发生操作时会被通知到。信号允许特定的sender（发送者）通知一组receiver（接收者）某些操作已经发生。**\n\n信号遵守的设计模式：**观察者设计模式（通知机制、监听机制）**\n\n- [使用](https://handout-1300728887.cos.ap-beijing.myqcloud.com/%E8%AE%B2%E4%B9%89/%E6%80%9D%E7%BB%B4%E5%AF%BC%E5%9B%BE/Django%E4%BF%A1%E5%8F%B7.jpg)\n\n## 4. Django项目中的社会化分享\n\n结合项目中使用：\n\n- MobTech平台创建应用：https://www.mob.com/\n\n  1. 注册登录\n  2. 产品中心 --> 开发者平台\n  3. 创建应用并添加产品和SDK\n  4. 进入到<应用管理>查看App Key和App Secret\n\n- 创建Django项目\n\n- 根据开发文档集成ShareSDK\n\n  - 进入文档中心，打开web集成文档\n\n    https://www.mob.com/wiki/list\n\n  - 根据开发文档集成ShareSDK，实现社会化分享功能\n\n## 5. ORM(object-relation-mapping)\n\n[参考文档](https://handout-1300728887.cos.ap-beijing.myqcloud.com/%E8%AE%B2%E4%B9%89/%E9%BB%91%E9%A9%AC%E5%A4%B4%E6%9D%A1%E9%A1%B9%E7%9B%AE%E8%AF%BE%E4%BB%B6/C02-Database/ORM.html)\n\n\n- 对象关系映射 本质上就是将数据从一种形式转换到另外一种形式，定义的类相当于数据库中的表，在类中的定义的属性相当于是表中的字段，实例化的每一个对象，相当于的每一条数据。\n  - 类 -> 表\n  - 类属性 -> 字段\n  - 类对象 -> 数据\n\n- 作用：\n\n  1. 省去编写sql语句，提⾼开发效率；\n\n  2. 防注⼊攻击\n\n  3. 适配不同的数据库。\n- 缺点：查询效率较低，需要手动的优化。\n- 操作方式：\n\n  1. 先创建模型类，再迁移到数据库中：不能对数据库表的字段的定义，实现精确控制。 \n  2. 使⽤sql创建数据库的表，定义模型类，通过模型类，实现ORM操作。 \n## 6. 中间件的定义方式、结构\n\n```python\ndef middleware_name(get_response):\n    # 这个节点表示请求初始化：在最开始的时候补充额外逻辑\n    def middleware(request):\n        # 这个节点表示请求被执行前：在请求执行的时候补充额外逻辑\n        response = get_response(request)\n        # z这个节点表示响应之前：在响应之前补充额外逻辑\n        return response\n    return middleware\n```\n\n# Q&F\n\n## 1. 前后端不分离的区别\n\n前后端不分离：\n\n- 页面的控制和渲染是由后端实现的\n  - 优点：页面展示无延迟，因为响应给用户的就是页面；方便实现搜索引擎排名，帮助爬虫服务器更高效率的爬取数据，即SEO\n  - 缺点：对后端程序员要求高\n\n前后端分离：\n\n- 页面的控制和渲染是由前端实现的\n  - 优点：后端程序员只需专注数据和业务即可\n  - 缺点：有延迟，先加载页面 -- 发请求获取数据 -- 渲染\n- 补充：前后端不分离，一般不做页面静态化，因为用户先拿到的就是静态页面\n\n## 2. Django自带的缓存cache和redis的区别\n\ncache是python实现缓存的一种工具\n\nredis是一种存放缓存数据的数据库\n\n可以使用cache这个缓存工具，将缓存数据缓存到redis数据库\n\n## 3. 如何对Django框架进行二次开发，增大并发数\n\n可能造成并发降低的原因：\n\n1. 数据库操作变慢\n2. python语言执行速度变慢\n\nDjango二次开发方向：\n\n- 扩展Django Models使其支持Sharding（一种数据库分片技术）\n- 手动关闭GC（垃圾回收）\n- **把那些稳定且对性能最敏感的组件，使用c或c++来重写**","slug":"Flask和Django","published":1,"updated":"2020-09-30T07:44:50.104Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckfp5akej0004n8jh963s0v3f","content":"<h1 id=\"Flask和Django\"><a href=\"#Flask和Django\" class=\"headerlink\" title=\"Flask和Django\"></a>Flask和Django</h1><ul>\n<li><strong>轻量、简洁、扩展性强，原生不支持数据库</strong></li>\n<li>核心：werkzeug和jinja2</li>\n</ul>\n<a id=\"more\"></a>\n<h2 id=\"1-Flask与Django对比\"><a href=\"#1-Flask与Django对比\" class=\"headerlink\" title=\"1. Flask与Django对比\"></a>1. Flask与Django对比</h2><ul>\n<li>与Django对比<ul>\n<li>不同点：<ol>\n<li>Django：支持 ORM、认证、CSRF/模板、后台管理等。 </li>\n<li>Flask：自带jinja2模板，实现其它功能需要调用扩展包</li>\n</ol>\n</li>\n<li>相同点：<ol>\n<li>性能都不⾼，都是单进程服务器。 </li>\n</ol>\n</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"2-MVT设计模式\"><a href=\"#2-MVT设计模式\" class=\"headerlink\" title=\"2. MVT设计模式\"></a>2. MVT设计模式</h2><p>设计模式：解决一类问题而总结出来的经验和套路</p>\n<p><strong>MVC：</strong>核心思想：分工、解耦，让不同代码之间降低耦合，增强代码的可扩展性和可移植性</p>\n<p><strong>MVT：</strong></p>\n<ul>\n<li>M：模型 Model</li>\n<li>V：视图 View</li>\n<li>T：模板 Template</li>\n</ul>\n<h2 id=\"3-Django信号\"><a href=\"#3-Django信号\" class=\"headerlink\" title=\"3. Django信号\"></a>3. Django信号</h2><p><strong>Django 提供一个“信号分发器”，允许解耦的应用在框架的其它地方发生操作时会被通知到。信号允许特定的sender（发送者）通知一组receiver（接收者）某些操作已经发生。</strong></p>\n<p>信号遵守的设计模式：<strong>观察者设计模式（通知机制、监听机制）</strong></p>\n<ul>\n<li><a href=\"https://handout-1300728887.cos.ap-beijing.myqcloud.com/%E8%AE%B2%E4%B9%89/%E6%80%9D%E7%BB%B4%E5%AF%BC%E5%9B%BE/Django%E4%BF%A1%E5%8F%B7.jpg\" target=\"_blank\" rel=\"noopener\">使用</a></li>\n</ul>\n<h2 id=\"4-Django项目中的社会化分享\"><a href=\"#4-Django项目中的社会化分享\" class=\"headerlink\" title=\"4. Django项目中的社会化分享\"></a>4. Django项目中的社会化分享</h2><p>结合项目中使用：</p>\n<ul>\n<li><p>MobTech平台创建应用：<a href=\"https://www.mob.com/\" target=\"_blank\" rel=\"noopener\">https://www.mob.com/</a></p>\n<ol>\n<li>注册登录</li>\n<li>产品中心 –&gt; 开发者平台</li>\n<li>创建应用并添加产品和SDK</li>\n<li>进入到&lt;应用管理&gt;查看App Key和App Secret</li>\n</ol>\n</li>\n<li><p>创建Django项目</p>\n</li>\n<li><p>根据开发文档集成ShareSDK</p>\n<ul>\n<li><p>进入文档中心，打开web集成文档</p>\n<p><a href=\"https://www.mob.com/wiki/list\" target=\"_blank\" rel=\"noopener\">https://www.mob.com/wiki/list</a></p>\n</li>\n<li><p>根据开发文档集成ShareSDK，实现社会化分享功能</p>\n</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"5-ORM-object-relation-mapping\"><a href=\"#5-ORM-object-relation-mapping\" class=\"headerlink\" title=\"5. ORM(object-relation-mapping)\"></a>5. ORM(object-relation-mapping)</h2><p><a href=\"https://handout-1300728887.cos.ap-beijing.myqcloud.com/%E8%AE%B2%E4%B9%89/%E9%BB%91%E9%A9%AC%E5%A4%B4%E6%9D%A1%E9%A1%B9%E7%9B%AE%E8%AF%BE%E4%BB%B6/C02-Database/ORM.html\" target=\"_blank\" rel=\"noopener\">参考文档</a></p>\n<ul>\n<li><p>对象关系映射 本质上就是将数据从一种形式转换到另外一种形式，定义的类相当于数据库中的表，在类中的定义的属性相当于是表中的字段，实例化的每一个对象，相当于的每一条数据。</p>\n<ul>\n<li>类 -&gt; 表</li>\n<li>类属性 -&gt; 字段</li>\n<li>类对象 -&gt; 数据</li>\n</ul>\n</li>\n<li><p>作用：</p>\n<ol>\n<li><p>省去编写sql语句，提⾼开发效率；</p>\n</li>\n<li><p>防注⼊攻击</p>\n</li>\n<li><p>适配不同的数据库。</p>\n</li>\n</ol>\n</li>\n<li><p>缺点：查询效率较低，需要手动的优化。</p>\n</li>\n<li><p>操作方式：</p>\n<ol>\n<li>先创建模型类，再迁移到数据库中：不能对数据库表的字段的定义，实现精确控制。 </li>\n<li>使⽤sql创建数据库的表，定义模型类，通过模型类，实现ORM操作。 <h2 id=\"6-中间件的定义方式、结构\"><a href=\"#6-中间件的定义方式、结构\" class=\"headerlink\" title=\"6. 中间件的定义方式、结构\"></a>6. 中间件的定义方式、结构</h2></li>\n</ol>\n</li>\n</ul>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">middleware_name</span><span class=\"params\">(get_response)</span>:</span></span><br><span class=\"line\">    <span class=\"comment\"># 这个节点表示请求初始化：在最开始的时候补充额外逻辑</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">middleware</span><span class=\"params\">(request)</span>:</span></span><br><span class=\"line\">        <span class=\"comment\"># 这个节点表示请求被执行前：在请求执行的时候补充额外逻辑</span></span><br><span class=\"line\">        response = get_response(request)</span><br><span class=\"line\">        <span class=\"comment\"># z这个节点表示响应之前：在响应之前补充额外逻辑</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> response</span><br><span class=\"line\">    <span class=\"keyword\">return</span> middleware</span><br></pre></td></tr></table></figure>\n\n<h1 id=\"Q-amp-F\"><a href=\"#Q-amp-F\" class=\"headerlink\" title=\"Q&amp;F\"></a>Q&amp;F</h1><h2 id=\"1-前后端不分离的区别\"><a href=\"#1-前后端不分离的区别\" class=\"headerlink\" title=\"1. 前后端不分离的区别\"></a>1. 前后端不分离的区别</h2><p>前后端不分离：</p>\n<ul>\n<li>页面的控制和渲染是由后端实现的<ul>\n<li>优点：页面展示无延迟，因为响应给用户的就是页面；方便实现搜索引擎排名，帮助爬虫服务器更高效率的爬取数据，即SEO</li>\n<li>缺点：对后端程序员要求高</li>\n</ul>\n</li>\n</ul>\n<p>前后端分离：</p>\n<ul>\n<li>页面的控制和渲染是由前端实现的<ul>\n<li>优点：后端程序员只需专注数据和业务即可</li>\n<li>缺点：有延迟，先加载页面 – 发请求获取数据 – 渲染</li>\n</ul>\n</li>\n<li>补充：前后端不分离，一般不做页面静态化，因为用户先拿到的就是静态页面</li>\n</ul>\n<h2 id=\"2-Django自带的缓存cache和redis的区别\"><a href=\"#2-Django自带的缓存cache和redis的区别\" class=\"headerlink\" title=\"2. Django自带的缓存cache和redis的区别\"></a>2. Django自带的缓存cache和redis的区别</h2><p>cache是python实现缓存的一种工具</p>\n<p>redis是一种存放缓存数据的数据库</p>\n<p>可以使用cache这个缓存工具，将缓存数据缓存到redis数据库</p>\n<h2 id=\"3-如何对Django框架进行二次开发，增大并发数\"><a href=\"#3-如何对Django框架进行二次开发，增大并发数\" class=\"headerlink\" title=\"3. 如何对Django框架进行二次开发，增大并发数\"></a>3. 如何对Django框架进行二次开发，增大并发数</h2><p>可能造成并发降低的原因：</p>\n<ol>\n<li>数据库操作变慢</li>\n<li>python语言执行速度变慢</li>\n</ol>\n<p>Django二次开发方向：</p>\n<ul>\n<li>扩展Django Models使其支持Sharding（一种数据库分片技术）</li>\n<li>手动关闭GC（垃圾回收）</li>\n<li><strong>把那些稳定且对性能最敏感的组件，使用c或c++来重写</strong></li>\n</ul>\n","site":{"data":{}},"excerpt":"<h1 id=\"Flask和Django\"><a href=\"#Flask和Django\" class=\"headerlink\" title=\"Flask和Django\"></a>Flask和Django</h1><ul>\n<li><strong>轻量、简洁、扩展性强，原生不支持数据库</strong></li>\n<li>核心：werkzeug和jinja2</li>\n</ul>","more":"<h2 id=\"1-Flask与Django对比\"><a href=\"#1-Flask与Django对比\" class=\"headerlink\" title=\"1. Flask与Django对比\"></a>1. Flask与Django对比</h2><ul>\n<li>与Django对比<ul>\n<li>不同点：<ol>\n<li>Django：支持 ORM、认证、CSRF/模板、后台管理等。 </li>\n<li>Flask：自带jinja2模板，实现其它功能需要调用扩展包</li>\n</ol>\n</li>\n<li>相同点：<ol>\n<li>性能都不⾼，都是单进程服务器。 </li>\n</ol>\n</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"2-MVT设计模式\"><a href=\"#2-MVT设计模式\" class=\"headerlink\" title=\"2. MVT设计模式\"></a>2. MVT设计模式</h2><p>设计模式：解决一类问题而总结出来的经验和套路</p>\n<p><strong>MVC：</strong>核心思想：分工、解耦，让不同代码之间降低耦合，增强代码的可扩展性和可移植性</p>\n<p><strong>MVT：</strong></p>\n<ul>\n<li>M：模型 Model</li>\n<li>V：视图 View</li>\n<li>T：模板 Template</li>\n</ul>\n<h2 id=\"3-Django信号\"><a href=\"#3-Django信号\" class=\"headerlink\" title=\"3. Django信号\"></a>3. Django信号</h2><p><strong>Django 提供一个“信号分发器”，允许解耦的应用在框架的其它地方发生操作时会被通知到。信号允许特定的sender（发送者）通知一组receiver（接收者）某些操作已经发生。</strong></p>\n<p>信号遵守的设计模式：<strong>观察者设计模式（通知机制、监听机制）</strong></p>\n<ul>\n<li><a href=\"https://handout-1300728887.cos.ap-beijing.myqcloud.com/%E8%AE%B2%E4%B9%89/%E6%80%9D%E7%BB%B4%E5%AF%BC%E5%9B%BE/Django%E4%BF%A1%E5%8F%B7.jpg\" target=\"_blank\" rel=\"noopener\">使用</a></li>\n</ul>\n<h2 id=\"4-Django项目中的社会化分享\"><a href=\"#4-Django项目中的社会化分享\" class=\"headerlink\" title=\"4. Django项目中的社会化分享\"></a>4. Django项目中的社会化分享</h2><p>结合项目中使用：</p>\n<ul>\n<li><p>MobTech平台创建应用：<a href=\"https://www.mob.com/\" target=\"_blank\" rel=\"noopener\">https://www.mob.com/</a></p>\n<ol>\n<li>注册登录</li>\n<li>产品中心 –&gt; 开发者平台</li>\n<li>创建应用并添加产品和SDK</li>\n<li>进入到&lt;应用管理&gt;查看App Key和App Secret</li>\n</ol>\n</li>\n<li><p>创建Django项目</p>\n</li>\n<li><p>根据开发文档集成ShareSDK</p>\n<ul>\n<li><p>进入文档中心，打开web集成文档</p>\n<p><a href=\"https://www.mob.com/wiki/list\" target=\"_blank\" rel=\"noopener\">https://www.mob.com/wiki/list</a></p>\n</li>\n<li><p>根据开发文档集成ShareSDK，实现社会化分享功能</p>\n</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"5-ORM-object-relation-mapping\"><a href=\"#5-ORM-object-relation-mapping\" class=\"headerlink\" title=\"5. ORM(object-relation-mapping)\"></a>5. ORM(object-relation-mapping)</h2><p><a href=\"https://handout-1300728887.cos.ap-beijing.myqcloud.com/%E8%AE%B2%E4%B9%89/%E9%BB%91%E9%A9%AC%E5%A4%B4%E6%9D%A1%E9%A1%B9%E7%9B%AE%E8%AF%BE%E4%BB%B6/C02-Database/ORM.html\" target=\"_blank\" rel=\"noopener\">参考文档</a></p>\n<ul>\n<li><p>对象关系映射 本质上就是将数据从一种形式转换到另外一种形式，定义的类相当于数据库中的表，在类中的定义的属性相当于是表中的字段，实例化的每一个对象，相当于的每一条数据。</p>\n<ul>\n<li>类 -&gt; 表</li>\n<li>类属性 -&gt; 字段</li>\n<li>类对象 -&gt; 数据</li>\n</ul>\n</li>\n<li><p>作用：</p>\n<ol>\n<li><p>省去编写sql语句，提⾼开发效率；</p>\n</li>\n<li><p>防注⼊攻击</p>\n</li>\n<li><p>适配不同的数据库。</p>\n</li>\n</ol>\n</li>\n<li><p>缺点：查询效率较低，需要手动的优化。</p>\n</li>\n<li><p>操作方式：</p>\n<ol>\n<li>先创建模型类，再迁移到数据库中：不能对数据库表的字段的定义，实现精确控制。 </li>\n<li>使⽤sql创建数据库的表，定义模型类，通过模型类，实现ORM操作。 <h2 id=\"6-中间件的定义方式、结构\"><a href=\"#6-中间件的定义方式、结构\" class=\"headerlink\" title=\"6. 中间件的定义方式、结构\"></a>6. 中间件的定义方式、结构</h2></li>\n</ol>\n</li>\n</ul>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">middleware_name</span><span class=\"params\">(get_response)</span>:</span></span><br><span class=\"line\">    <span class=\"comment\"># 这个节点表示请求初始化：在最开始的时候补充额外逻辑</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">middleware</span><span class=\"params\">(request)</span>:</span></span><br><span class=\"line\">        <span class=\"comment\"># 这个节点表示请求被执行前：在请求执行的时候补充额外逻辑</span></span><br><span class=\"line\">        response = get_response(request)</span><br><span class=\"line\">        <span class=\"comment\"># z这个节点表示响应之前：在响应之前补充额外逻辑</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> response</span><br><span class=\"line\">    <span class=\"keyword\">return</span> middleware</span><br></pre></td></tr></table></figure>\n\n<h1 id=\"Q-amp-F\"><a href=\"#Q-amp-F\" class=\"headerlink\" title=\"Q&amp;F\"></a>Q&amp;F</h1><h2 id=\"1-前后端不分离的区别\"><a href=\"#1-前后端不分离的区别\" class=\"headerlink\" title=\"1. 前后端不分离的区别\"></a>1. 前后端不分离的区别</h2><p>前后端不分离：</p>\n<ul>\n<li>页面的控制和渲染是由后端实现的<ul>\n<li>优点：页面展示无延迟，因为响应给用户的就是页面；方便实现搜索引擎排名，帮助爬虫服务器更高效率的爬取数据，即SEO</li>\n<li>缺点：对后端程序员要求高</li>\n</ul>\n</li>\n</ul>\n<p>前后端分离：</p>\n<ul>\n<li>页面的控制和渲染是由前端实现的<ul>\n<li>优点：后端程序员只需专注数据和业务即可</li>\n<li>缺点：有延迟，先加载页面 – 发请求获取数据 – 渲染</li>\n</ul>\n</li>\n<li>补充：前后端不分离，一般不做页面静态化，因为用户先拿到的就是静态页面</li>\n</ul>\n<h2 id=\"2-Django自带的缓存cache和redis的区别\"><a href=\"#2-Django自带的缓存cache和redis的区别\" class=\"headerlink\" title=\"2. Django自带的缓存cache和redis的区别\"></a>2. Django自带的缓存cache和redis的区别</h2><p>cache是python实现缓存的一种工具</p>\n<p>redis是一种存放缓存数据的数据库</p>\n<p>可以使用cache这个缓存工具，将缓存数据缓存到redis数据库</p>\n<h2 id=\"3-如何对Django框架进行二次开发，增大并发数\"><a href=\"#3-如何对Django框架进行二次开发，增大并发数\" class=\"headerlink\" title=\"3. 如何对Django框架进行二次开发，增大并发数\"></a>3. 如何对Django框架进行二次开发，增大并发数</h2><p>可能造成并发降低的原因：</p>\n<ol>\n<li>数据库操作变慢</li>\n<li>python语言执行速度变慢</li>\n</ol>\n<p>Django二次开发方向：</p>\n<ul>\n<li>扩展Django Models使其支持Sharding（一种数据库分片技术）</li>\n<li>手动关闭GC（垃圾回收）</li>\n<li><strong>把那些稳定且对性能最敏感的组件，使用c或c++来重写</strong></li>\n</ul>"},{"title":"Linux基础命令","date":"2019-12-02T08:12:41.000Z","top":0,"_content":"\n# Linux常用命令总结\n\n## 操作系统\n\n- 作用: 整合系统硬件资源,支持软件的运行.\n\n- 常见操作系统:\n\n  - windows\n  - Linux\n  - Unix\n\n  <!-- more -->\n\n  - MacOS\n  - iOS\n  - 安卓\n\n- 虚拟机：用来模拟一台电脑\n\n- Linux 内核和发行版:\n\n  - 内核：Linux系统的核心代码, Linux kernal 4.4.0.12....\n  - 发行版：在内核的基础上,根据不同的应用需求添加额外的应用套件.\n    - RedHat\t\trpm包\n    - CentOS\n    - Debian\t\tdpg包\n    - Ubuntu\n\n- Linux文件系统结构 \n\n  - 顶层目录  /\n  - 普通用户家目录  /home\n  - 可执行程序目录  /bin   /sbin\n  - 配置文件目录    /etc\n\n  ---\n\n  ## Linux基础命令\n\n- Linux命令格式：命令   选项   参数\n\n- 获取命令**帮助**:\n\n  - 命令 --help\n  - man 命令\n\n- **自动补全**:tab 键\n\n  1. 提高输入速度\n  2. 降低输入错误率\n\n3. 可以提示命令,也可以提示路径\n\n- **路径**:\n  - 绝对路径: 以 根目录 / 开始的路径,称为绝对路径\n  - 相对路径: 除绝对路径以外的路径都相对路径\n\n- **查看文件内容**命令:  ls   -> list\n  - ls -a  查看所有文件\n  - linux当中的隐藏文件是以.开头的 ,   .a.txt\n  - ls -l  查看文件的详细信息\n  - ls -lh 以计算后的单位形式显示 详细信息\n\n```bash\nls -alh   默认参数是当前目录\n```\n\n- **切换目录**命令   cd   -> change directory\n  - cd 路径\n  - .  当前目录\n  - .. 当前目录的上一级目录\n  - ~  当前用户的家目录\n\n- **查看当前工作目录**命令  \n  - pwd   -> print work directory\n\n- **清屏命令**   clear   -> 快捷键  Ctrl + l\n\n- **创建空文件**  touch 文件名 ....\n\n- **创建空目录**  mkdir   make directory  \n  - mkdir 目录名 ....\t\t\t# 如果如果创建多个同级目录,目录之间需要空格分隔\n  - mkdir -p 目录名/目录名/....\n\n- **删除目录** rmdir  了解  只能删除空目录\n\n- 删除文件或目录的命令  rm   -> remove\n  rm 默认删除文件,如果是目录需使用选项\n\n```bash\nrm -r 目录名  删除目录级目录下的内容\nrm -i 文件名  删除前询问\nrm -f 文件名  强制删除不询问\n\n常用删除操作\nrm -rf *  删除所有文件不询问\n```\n\n- **复制文件或目录** cp  -> copy\n  - 默认只能复制文件,要复制目录需使用选项 -r\n\n```bash\ncp -r 源文件路径  目录文件位置或名\n```\n\n- **移动命令**  mv   -> move\n  - mv 源文件 目标文件\n  - 移动操作不考虑文件类型,移动可以兼具改名的功能\n\n- **查看文件内容**\n  - cat 文件名 ...   适合查看比较小的文本文件\n  - more  文件名 ...  适合查看比较大的文本文件,可以分屏显示 \n\n- **重定向**  >   >>\n  - stdin  标准输入文件   键盘\n  - stdout 标准输出文件   屏幕\n  - stderr 标准错误输出文件  屏幕\n\n\n```bash\nls -l > log.txt  文件不存在则创建,存在则覆盖\nls -l >> log.txt  文件不存在则创建,存在则追加到文件最后\n```\n\n- **管道** `|`\n  - 作用是用来连接两个命令\n  - 将左侧命令的执行结果 连接给 右侧的命令做为数据源\n\n```bash\nps aux | grep xxx\nls -l | more\n```\n\n- **文本内容查找**\t `grep`\n\n```bash\ngrep -i '查找内容' 被查找的文件     # 忽略大小写搜索\ngrep -n '查找内容' 被查找的文件     # 查找结果显示 行号\ngrep -v '查找内容' 被查找的文件     # 结果取反\n\n带正则表达式使用\ngrep -in '^查找内容' 被查找的文件     # 严格的开始\ngrep -in '查找内容$' 被查找的文件     # 严格的结束\ngrep -in '.' 被查找的文件     \t\t   # 匹配一个非换行符之外的字符\n```\n\n\n\n- 查找文件 `find` \n  - find 查找路径 -name 文件名\n\n\n```bash\nfind 查找路径 -name '文件名*'\nfind 查找路径 -name '文件名?'\n```\n\n\n\n- **链接命令**  `ln  link`\n\n  - 软链接: 符号链接  \n    - ln -s 源文件 目标连接位置   相当于**快捷方式**\n  - 硬链接: \n  - ln    源文件 目标连接位置     类似于**源文件的一个别名** \n\n- **区别:**\n\n  - 软链接 可以连接目录,硬连接不可以\n  - 软连接相当于快捷方式,不占储存空间,硬连接占用空间\n  - 硬连接会改变文件连接数,软连接不会\n  - 硬连接不能跨分区.\n\n- **打包压缩**\n\n  ```bash\n  tar zcvf xxx.tar.gz xx,....\n  tar zxvf xxx.tar.gz -C unzip_dir\n  \n  tar jcvf xxx.tar.bz2 xx,....\n  tar jxvf xxx.tar.bz2 -C unzip_dir\n  ```\n\n- **权限管理**\n\n  - 三类用户:\n    - 文件所有者 \tuser  u\n    - 所有者同组用户\t\tgroup   g\n    - 其它用户    other  o\n    - 全部用户     all  a\n  - 权限:\n    - 读取权限    r\n    - 写入权限    w\n    - 执行权限    x\n\n  <img src=\"https://tupian-1300728887.cos.ap-chengdu.myqcloud.com/Xnip2019-08-05_11-15-00.png\" style=\"zoom:100%;\" />\n\n\n  ```bash\n  chmod 用户角色 +/-/= 权限 文件\t# 字母法\n  \n  chmod 777  文件\t# 数字法\n  ```\n\n  - 切换用户身份\n    - 临时借用root权限 \n      - sudo 命令\n    - 切换到root用户环境中\n      - sudo -s\n\n\n  ```bash\n  su 用户名\t# 普通用户间切的\n  exit\t# 退出当前用户环境\n  whoami\t# 查看当用用户是谁\n  who\t\t# 查看所有登陆用户\n  which  命令\t\t# 查看命令位置\n  ```\n\n  - **用户管理**\n\n    - 添加用户组\n      - group  add 组名\n      - /etc/group\n    - 删除组\n      - group  del 组名\n      - 注意: 如果该组是用户的主组时,不能删除,需要先删除用户,再删除组\n    - 添加用户\n      - useradd  -m -g 组id 用户名\n        - -m 指定创建家目录,与用户名同名\n        - -g 用来指定用户所在的组\n\n  - **用户文件目录**\n\n    - /etc/passwd  保存用户信息\n    - /etc/shadow  保存用户的密码信息\n    - /etc/group   默认在创建用户时,会同创建一个同名的组 \n\n  - **修改密码命令**\n\n    - 为当前用户改密码\n      - passwd\n    - 为指定用户改密码,但是只能由root执行\n      - passwd 用户名\n\n  - **远程登陆**\n\n    - 需要先安装  openssh-server 软件包\n    - ssh 用户名@ip地址 \n\n  - **远程拷贝**:\n\n    - 上传:\n      - `scp 本地文件 user@IP:/路径`\n    - 下载:\n      - `scp user@ip:/资源位置   本地位置`\n\n  - **软件安装和卸载**\n\n    - 离线:\n      - 安装\t`dpkg -i xxx.deb`\n      - 卸载    `dpkg -r xxx`\n    - 在线:\n      1. 首要配置数据源    `/etc/apt/source.list`\n         2. 更新数据源    `sudo apt-get update`\n         3. 安装    `sudo apt-get install 软件名`\n         4. 卸载    `sudo apt-get remove 软件名`\n\n    ---\n\n## vim\n\n- 编辑模式    `i 从命令变成编辑模式`\n- 命令模式    `esc 键  退回到命令模式`\n- 末行模式\n  - :wq  保存退出    :wq!\n  - :w   保存不退出   :w!\n  - :q   退出不保存   :q!\n  - :x   保存退出     :x!\n- 配置文件设置\n\n```bash\n:set nu  设置行号\n:set nonu  取消行号 \n\n:syntax on  开启语法高亮\n:syntax off 关闭语法\n```\n\n- 命令模式操作\n\n\n  ```bash\n光标移动:\nhjkl  -> 左下上右\n0  \t回到行首\n$   跳到行尾\ngg  到首行\nG   到末行\nnG  到第n行\nM   到屏幕中间\nw   跳到下一个单词\n\nyy  复制当前光标行\nnyy 从当前光标开始向下复制n行\np  \t在当前光标下一行粘贴\nnp  粘贴n次\ndd \t剪切\nndd 剪切n行\n\nyG 复制到末行\nygg 复制到首行\n\nx 向后删除一个字符\nX 向前删除一个字符\n\n>>  向前缩进\n<<  向前缩进\n\n/查找内容\nn 向下跳到搜索内容\nN 反向跳\n\nu  撤消\nctrl + r  反撤消\n  ```","source":"_posts/Linux基础命令.md","raw":"---\ntitle: Linux基础命令\ndate: 2019-12-02 16:12:41\ntags: Linux\ntop: 0\n---\n\n# Linux常用命令总结\n\n## 操作系统\n\n- 作用: 整合系统硬件资源,支持软件的运行.\n\n- 常见操作系统:\n\n  - windows\n  - Linux\n  - Unix\n\n  <!-- more -->\n\n  - MacOS\n  - iOS\n  - 安卓\n\n- 虚拟机：用来模拟一台电脑\n\n- Linux 内核和发行版:\n\n  - 内核：Linux系统的核心代码, Linux kernal 4.4.0.12....\n  - 发行版：在内核的基础上,根据不同的应用需求添加额外的应用套件.\n    - RedHat\t\trpm包\n    - CentOS\n    - Debian\t\tdpg包\n    - Ubuntu\n\n- Linux文件系统结构 \n\n  - 顶层目录  /\n  - 普通用户家目录  /home\n  - 可执行程序目录  /bin   /sbin\n  - 配置文件目录    /etc\n\n  ---\n\n  ## Linux基础命令\n\n- Linux命令格式：命令   选项   参数\n\n- 获取命令**帮助**:\n\n  - 命令 --help\n  - man 命令\n\n- **自动补全**:tab 键\n\n  1. 提高输入速度\n  2. 降低输入错误率\n\n3. 可以提示命令,也可以提示路径\n\n- **路径**:\n  - 绝对路径: 以 根目录 / 开始的路径,称为绝对路径\n  - 相对路径: 除绝对路径以外的路径都相对路径\n\n- **查看文件内容**命令:  ls   -> list\n  - ls -a  查看所有文件\n  - linux当中的隐藏文件是以.开头的 ,   .a.txt\n  - ls -l  查看文件的详细信息\n  - ls -lh 以计算后的单位形式显示 详细信息\n\n```bash\nls -alh   默认参数是当前目录\n```\n\n- **切换目录**命令   cd   -> change directory\n  - cd 路径\n  - .  当前目录\n  - .. 当前目录的上一级目录\n  - ~  当前用户的家目录\n\n- **查看当前工作目录**命令  \n  - pwd   -> print work directory\n\n- **清屏命令**   clear   -> 快捷键  Ctrl + l\n\n- **创建空文件**  touch 文件名 ....\n\n- **创建空目录**  mkdir   make directory  \n  - mkdir 目录名 ....\t\t\t# 如果如果创建多个同级目录,目录之间需要空格分隔\n  - mkdir -p 目录名/目录名/....\n\n- **删除目录** rmdir  了解  只能删除空目录\n\n- 删除文件或目录的命令  rm   -> remove\n  rm 默认删除文件,如果是目录需使用选项\n\n```bash\nrm -r 目录名  删除目录级目录下的内容\nrm -i 文件名  删除前询问\nrm -f 文件名  强制删除不询问\n\n常用删除操作\nrm -rf *  删除所有文件不询问\n```\n\n- **复制文件或目录** cp  -> copy\n  - 默认只能复制文件,要复制目录需使用选项 -r\n\n```bash\ncp -r 源文件路径  目录文件位置或名\n```\n\n- **移动命令**  mv   -> move\n  - mv 源文件 目标文件\n  - 移动操作不考虑文件类型,移动可以兼具改名的功能\n\n- **查看文件内容**\n  - cat 文件名 ...   适合查看比较小的文本文件\n  - more  文件名 ...  适合查看比较大的文本文件,可以分屏显示 \n\n- **重定向**  >   >>\n  - stdin  标准输入文件   键盘\n  - stdout 标准输出文件   屏幕\n  - stderr 标准错误输出文件  屏幕\n\n\n```bash\nls -l > log.txt  文件不存在则创建,存在则覆盖\nls -l >> log.txt  文件不存在则创建,存在则追加到文件最后\n```\n\n- **管道** `|`\n  - 作用是用来连接两个命令\n  - 将左侧命令的执行结果 连接给 右侧的命令做为数据源\n\n```bash\nps aux | grep xxx\nls -l | more\n```\n\n- **文本内容查找**\t `grep`\n\n```bash\ngrep -i '查找内容' 被查找的文件     # 忽略大小写搜索\ngrep -n '查找内容' 被查找的文件     # 查找结果显示 行号\ngrep -v '查找内容' 被查找的文件     # 结果取反\n\n带正则表达式使用\ngrep -in '^查找内容' 被查找的文件     # 严格的开始\ngrep -in '查找内容$' 被查找的文件     # 严格的结束\ngrep -in '.' 被查找的文件     \t\t   # 匹配一个非换行符之外的字符\n```\n\n\n\n- 查找文件 `find` \n  - find 查找路径 -name 文件名\n\n\n```bash\nfind 查找路径 -name '文件名*'\nfind 查找路径 -name '文件名?'\n```\n\n\n\n- **链接命令**  `ln  link`\n\n  - 软链接: 符号链接  \n    - ln -s 源文件 目标连接位置   相当于**快捷方式**\n  - 硬链接: \n  - ln    源文件 目标连接位置     类似于**源文件的一个别名** \n\n- **区别:**\n\n  - 软链接 可以连接目录,硬连接不可以\n  - 软连接相当于快捷方式,不占储存空间,硬连接占用空间\n  - 硬连接会改变文件连接数,软连接不会\n  - 硬连接不能跨分区.\n\n- **打包压缩**\n\n  ```bash\n  tar zcvf xxx.tar.gz xx,....\n  tar zxvf xxx.tar.gz -C unzip_dir\n  \n  tar jcvf xxx.tar.bz2 xx,....\n  tar jxvf xxx.tar.bz2 -C unzip_dir\n  ```\n\n- **权限管理**\n\n  - 三类用户:\n    - 文件所有者 \tuser  u\n    - 所有者同组用户\t\tgroup   g\n    - 其它用户    other  o\n    - 全部用户     all  a\n  - 权限:\n    - 读取权限    r\n    - 写入权限    w\n    - 执行权限    x\n\n  <img src=\"https://tupian-1300728887.cos.ap-chengdu.myqcloud.com/Xnip2019-08-05_11-15-00.png\" style=\"zoom:100%;\" />\n\n\n  ```bash\n  chmod 用户角色 +/-/= 权限 文件\t# 字母法\n  \n  chmod 777  文件\t# 数字法\n  ```\n\n  - 切换用户身份\n    - 临时借用root权限 \n      - sudo 命令\n    - 切换到root用户环境中\n      - sudo -s\n\n\n  ```bash\n  su 用户名\t# 普通用户间切的\n  exit\t# 退出当前用户环境\n  whoami\t# 查看当用用户是谁\n  who\t\t# 查看所有登陆用户\n  which  命令\t\t# 查看命令位置\n  ```\n\n  - **用户管理**\n\n    - 添加用户组\n      - group  add 组名\n      - /etc/group\n    - 删除组\n      - group  del 组名\n      - 注意: 如果该组是用户的主组时,不能删除,需要先删除用户,再删除组\n    - 添加用户\n      - useradd  -m -g 组id 用户名\n        - -m 指定创建家目录,与用户名同名\n        - -g 用来指定用户所在的组\n\n  - **用户文件目录**\n\n    - /etc/passwd  保存用户信息\n    - /etc/shadow  保存用户的密码信息\n    - /etc/group   默认在创建用户时,会同创建一个同名的组 \n\n  - **修改密码命令**\n\n    - 为当前用户改密码\n      - passwd\n    - 为指定用户改密码,但是只能由root执行\n      - passwd 用户名\n\n  - **远程登陆**\n\n    - 需要先安装  openssh-server 软件包\n    - ssh 用户名@ip地址 \n\n  - **远程拷贝**:\n\n    - 上传:\n      - `scp 本地文件 user@IP:/路径`\n    - 下载:\n      - `scp user@ip:/资源位置   本地位置`\n\n  - **软件安装和卸载**\n\n    - 离线:\n      - 安装\t`dpkg -i xxx.deb`\n      - 卸载    `dpkg -r xxx`\n    - 在线:\n      1. 首要配置数据源    `/etc/apt/source.list`\n         2. 更新数据源    `sudo apt-get update`\n         3. 安装    `sudo apt-get install 软件名`\n         4. 卸载    `sudo apt-get remove 软件名`\n\n    ---\n\n## vim\n\n- 编辑模式    `i 从命令变成编辑模式`\n- 命令模式    `esc 键  退回到命令模式`\n- 末行模式\n  - :wq  保存退出    :wq!\n  - :w   保存不退出   :w!\n  - :q   退出不保存   :q!\n  - :x   保存退出     :x!\n- 配置文件设置\n\n```bash\n:set nu  设置行号\n:set nonu  取消行号 \n\n:syntax on  开启语法高亮\n:syntax off 关闭语法\n```\n\n- 命令模式操作\n\n\n  ```bash\n光标移动:\nhjkl  -> 左下上右\n0  \t回到行首\n$   跳到行尾\ngg  到首行\nG   到末行\nnG  到第n行\nM   到屏幕中间\nw   跳到下一个单词\n\nyy  复制当前光标行\nnyy 从当前光标开始向下复制n行\np  \t在当前光标下一行粘贴\nnp  粘贴n次\ndd \t剪切\nndd 剪切n行\n\nyG 复制到末行\nygg 复制到首行\n\nx 向后删除一个字符\nX 向前删除一个字符\n\n>>  向前缩进\n<<  向前缩进\n\n/查找内容\nn 向下跳到搜索内容\nN 反向跳\n\nu  撤消\nctrl + r  反撤消\n  ```","slug":"Linux基础命令","published":1,"updated":"2020-08-11T07:15:54.365Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckfp5aker0005n8jh63ya2xtq","content":"<h1 id=\"Linux常用命令总结\"><a href=\"#Linux常用命令总结\" class=\"headerlink\" title=\"Linux常用命令总结\"></a>Linux常用命令总结</h1><h2 id=\"操作系统\"><a href=\"#操作系统\" class=\"headerlink\" title=\"操作系统\"></a>操作系统</h2><ul>\n<li><p>作用: 整合系统硬件资源,支持软件的运行.</p>\n</li>\n<li><p>常见操作系统:</p>\n<ul>\n<li>windows</li>\n<li>Linux</li>\n<li>Unix</li>\n</ul>\n<a id=\"more\"></a>\n\n<ul>\n<li>MacOS</li>\n<li>iOS</li>\n<li>安卓</li>\n</ul>\n</li>\n<li><p>虚拟机：用来模拟一台电脑</p>\n</li>\n<li><p>Linux 内核和发行版:</p>\n<ul>\n<li>内核：Linux系统的核心代码, Linux kernal 4.4.0.12….</li>\n<li>发行版：在内核的基础上,根据不同的应用需求添加额外的应用套件.<ul>\n<li>RedHat        rpm包</li>\n<li>CentOS</li>\n<li>Debian        dpg包</li>\n<li>Ubuntu</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>Linux文件系统结构 </p>\n<ul>\n<li>顶层目录  /</li>\n<li>普通用户家目录  /home</li>\n<li>可执行程序目录  /bin   /sbin</li>\n<li>配置文件目录    /etc</li>\n</ul>\n<hr>\n<h2 id=\"Linux基础命令\"><a href=\"#Linux基础命令\" class=\"headerlink\" title=\"Linux基础命令\"></a>Linux基础命令</h2></li>\n<li><p>Linux命令格式：命令   选项   参数</p>\n</li>\n<li><p>获取命令<strong>帮助</strong>:</p>\n<ul>\n<li>命令 –help</li>\n<li>man 命令</li>\n</ul>\n</li>\n<li><p><strong>自动补全</strong>:tab 键</p>\n<ol>\n<li>提高输入速度</li>\n<li>降低输入错误率</li>\n</ol>\n</li>\n</ul>\n<ol start=\"3\">\n<li>可以提示命令,也可以提示路径</li>\n</ol>\n<ul>\n<li><p><strong>路径</strong>:</p>\n<ul>\n<li>绝对路径: 以 根目录 / 开始的路径,称为绝对路径</li>\n<li>相对路径: 除绝对路径以外的路径都相对路径</li>\n</ul>\n</li>\n<li><p><strong>查看文件内容</strong>命令:  ls   -&gt; list</p>\n<ul>\n<li>ls -a  查看所有文件</li>\n<li>linux当中的隐藏文件是以.开头的 ,   .a.txt</li>\n<li>ls -l  查看文件的详细信息</li>\n<li>ls -lh 以计算后的单位形式显示 详细信息</li>\n</ul>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ls -alh   默认参数是当前目录</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li><p><strong>切换目录</strong>命令   cd   -&gt; change directory</p>\n<ul>\n<li>cd 路径</li>\n<li>.  当前目录</li>\n<li>.. 当前目录的上一级目录</li>\n<li>~  当前用户的家目录</li>\n</ul>\n</li>\n<li><p><strong>查看当前工作目录</strong>命令  </p>\n<ul>\n<li>pwd   -&gt; print work directory</li>\n</ul>\n</li>\n<li><p><strong>清屏命令</strong>   clear   -&gt; 快捷键  Ctrl + l</p>\n</li>\n<li><p><strong>创建空文件</strong>  touch 文件名 ….</p>\n</li>\n<li><p><strong>创建空目录</strong>  mkdir   make directory  </p>\n<ul>\n<li>mkdir 目录名 ….            # 如果如果创建多个同级目录,目录之间需要空格分隔</li>\n<li>mkdir -p 目录名/目录名/….</li>\n</ul>\n</li>\n<li><p><strong>删除目录</strong> rmdir  了解  只能删除空目录</p>\n</li>\n<li><p>删除文件或目录的命令  rm   -&gt; remove<br>rm 默认删除文件,如果是目录需使用选项</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">rm -r 目录名  删除目录级目录下的内容</span><br><span class=\"line\">rm -i 文件名  删除前询问</span><br><span class=\"line\">rm -f 文件名  强制删除不询问</span><br><span class=\"line\"></span><br><span class=\"line\">常用删除操作</span><br><span class=\"line\">rm -rf *  删除所有文件不询问</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li><strong>复制文件或目录</strong> cp  -&gt; copy<ul>\n<li>默认只能复制文件,要复制目录需使用选项 -r</li>\n</ul>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">cp -r 源文件路径  目录文件位置或名</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li><p><strong>移动命令</strong>  mv   -&gt; move</p>\n<ul>\n<li>mv 源文件 目标文件</li>\n<li>移动操作不考虑文件类型,移动可以兼具改名的功能</li>\n</ul>\n</li>\n<li><p><strong>查看文件内容</strong></p>\n<ul>\n<li>cat 文件名 …   适合查看比较小的文本文件</li>\n<li>more  文件名 …  适合查看比较大的文本文件,可以分屏显示 </li>\n</ul>\n</li>\n<li><p><strong>重定向</strong>  &gt;   &gt;&gt;</p>\n<ul>\n<li>stdin  标准输入文件   键盘</li>\n<li>stdout 标准输出文件   屏幕</li>\n<li>stderr 标准错误输出文件  屏幕</li>\n</ul>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ls -l &gt; log.txt  文件不存在则创建,存在则覆盖</span><br><span class=\"line\">ls -l &gt;&gt; log.txt  文件不存在则创建,存在则追加到文件最后</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li><strong>管道</strong> <code>|</code><ul>\n<li>作用是用来连接两个命令</li>\n<li>将左侧命令的执行结果 连接给 右侧的命令做为数据源</li>\n</ul>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ps aux | grep xxx</span><br><span class=\"line\">ls -l | more</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li><strong>文本内容查找</strong>     <code>grep</code></li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">grep -i <span class=\"string\">'查找内容'</span> 被查找的文件     <span class=\"comment\"># 忽略大小写搜索</span></span><br><span class=\"line\">grep -n <span class=\"string\">'查找内容'</span> 被查找的文件     <span class=\"comment\"># 查找结果显示 行号</span></span><br><span class=\"line\">grep -v <span class=\"string\">'查找内容'</span> 被查找的文件     <span class=\"comment\"># 结果取反</span></span><br><span class=\"line\"></span><br><span class=\"line\">带正则表达式使用</span><br><span class=\"line\">grep -<span class=\"keyword\">in</span> <span class=\"string\">'^查找内容'</span> 被查找的文件     <span class=\"comment\"># 严格的开始</span></span><br><span class=\"line\">grep -<span class=\"keyword\">in</span> <span class=\"string\">'查找内容$'</span> 被查找的文件     <span class=\"comment\"># 严格的结束</span></span><br><span class=\"line\">grep -<span class=\"keyword\">in</span> <span class=\"string\">'.'</span> 被查找的文件     \t\t   <span class=\"comment\"># 匹配一个非换行符之外的字符</span></span><br></pre></td></tr></table></figure>\n\n\n\n<ul>\n<li>查找文件 <code>find</code> <ul>\n<li>find 查找路径 -name 文件名</li>\n</ul>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">find 查找路径 -name <span class=\"string\">'文件名*'</span></span><br><span class=\"line\">find 查找路径 -name <span class=\"string\">'文件名?'</span></span><br></pre></td></tr></table></figure>\n\n\n\n<ul>\n<li><p><strong>链接命令</strong>  <code>ln  link</code></p>\n<ul>\n<li>软链接: 符号链接  <ul>\n<li>ln -s 源文件 目标连接位置   相当于<strong>快捷方式</strong></li>\n</ul>\n</li>\n<li>硬链接: </li>\n<li>ln    源文件 目标连接位置     类似于<strong>源文件的一个别名</strong> </li>\n</ul>\n</li>\n<li><p><strong>区别:</strong></p>\n<ul>\n<li>软链接 可以连接目录,硬连接不可以</li>\n<li>软连接相当于快捷方式,不占储存空间,硬连接占用空间</li>\n<li>硬连接会改变文件连接数,软连接不会</li>\n<li>硬连接不能跨分区.</li>\n</ul>\n</li>\n<li><p><strong>打包压缩</strong></p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">tar zcvf xxx.tar.gz xx,....</span><br><span class=\"line\">tar zxvf xxx.tar.gz -C unzip_dir</span><br><span class=\"line\"></span><br><span class=\"line\">tar jcvf xxx.tar.bz2 xx,....</span><br><span class=\"line\">tar jxvf xxx.tar.bz2 -C unzip_dir</span><br></pre></td></tr></table></figure>\n</li>\n<li><p><strong>权限管理</strong></p>\n<ul>\n<li>三类用户:<ul>\n<li>文件所有者     user  u</li>\n<li>所有者同组用户        group   g</li>\n<li>其它用户    other  o</li>\n<li>全部用户     all  a</li>\n</ul>\n</li>\n<li>权限:<ul>\n<li>读取权限    r</li>\n<li>写入权限    w</li>\n<li>执行权限    x</li>\n</ul>\n</li>\n</ul>\n<img src=\"https://tupian-1300728887.cos.ap-chengdu.myqcloud.com/Xnip2019-08-05_11-15-00.png\" style=\"zoom:100%;\" />\n\n\n</li>\n</ul>\n  <figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">chmod 用户角色 +/-/= 权限 文件\t<span class=\"comment\"># 字母法</span></span><br><span class=\"line\"></span><br><span class=\"line\">chmod 777  文件\t<span class=\"comment\"># 数字法</span></span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>切换用户身份<ul>\n<li>临时借用root权限 <ul>\n<li>sudo 命令</li>\n</ul>\n</li>\n<li>切换到root用户环境中<ul>\n<li>sudo -s</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n  <figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">su 用户名\t<span class=\"comment\"># 普通用户间切的</span></span><br><span class=\"line\"><span class=\"built_in\">exit</span>\t<span class=\"comment\"># 退出当前用户环境</span></span><br><span class=\"line\">whoami\t<span class=\"comment\"># 查看当用用户是谁</span></span><br><span class=\"line\">who\t\t<span class=\"comment\"># 查看所有登陆用户</span></span><br><span class=\"line\"><span class=\"built_in\">which</span>  命令\t\t<span class=\"comment\"># 查看命令位置</span></span><br></pre></td></tr></table></figure>\n\n<ul>\n<li><p><strong>用户管理</strong></p>\n<ul>\n<li>添加用户组<ul>\n<li>group  add 组名</li>\n<li>/etc/group</li>\n</ul>\n</li>\n<li>删除组<ul>\n<li>group  del 组名</li>\n<li>注意: 如果该组是用户的主组时,不能删除,需要先删除用户,再删除组</li>\n</ul>\n</li>\n<li>添加用户<ul>\n<li>useradd  -m -g 组id 用户名<ul>\n<li>-m 指定创建家目录,与用户名同名</li>\n<li>-g 用来指定用户所在的组</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p><strong>用户文件目录</strong></p>\n<ul>\n<li>/etc/passwd  保存用户信息</li>\n<li>/etc/shadow  保存用户的密码信息</li>\n<li>/etc/group   默认在创建用户时,会同创建一个同名的组 </li>\n</ul>\n</li>\n<li><p><strong>修改密码命令</strong></p>\n<ul>\n<li>为当前用户改密码<ul>\n<li>passwd</li>\n</ul>\n</li>\n<li>为指定用户改密码,但是只能由root执行<ul>\n<li>passwd 用户名</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p><strong>远程登陆</strong></p>\n<ul>\n<li>需要先安装  openssh-server 软件包</li>\n<li>ssh 用户名@ip地址 </li>\n</ul>\n</li>\n<li><p><strong>远程拷贝</strong>:</p>\n<ul>\n<li>上传:<ul>\n<li><code>scp 本地文件 user@IP:/路径</code></li>\n</ul>\n</li>\n<li>下载:<ul>\n<li><code>scp user@ip:/资源位置   本地位置</code></li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p><strong>软件安装和卸载</strong></p>\n<ul>\n<li>离线:<ul>\n<li>安装    <code>dpkg -i xxx.deb</code></li>\n<li>卸载    <code>dpkg -r xxx</code></li>\n</ul>\n</li>\n<li>在线:<ol>\n<li>首要配置数据源    <code>/etc/apt/source.list</code><ol start=\"2\">\n<li>更新数据源    <code>sudo apt-get update</code></li>\n<li>安装    <code>sudo apt-get install 软件名</code></li>\n<li>卸载    <code>sudo apt-get remove 软件名</code></li>\n</ol>\n</li>\n</ol>\n</li>\n</ul>\n<hr>\n</li>\n</ul>\n<h2 id=\"vim\"><a href=\"#vim\" class=\"headerlink\" title=\"vim\"></a>vim</h2><ul>\n<li>编辑模式    <code>i 从命令变成编辑模式</code></li>\n<li>命令模式    <code>esc 键  退回到命令模式</code></li>\n<li>末行模式<ul>\n<li>:wq  保存退出    :wq!</li>\n<li>:w   保存不退出   :w!</li>\n<li>:q   退出不保存   :q!</li>\n<li>:x   保存退出     :x!</li>\n</ul>\n</li>\n<li>配置文件设置</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">:<span class=\"built_in\">set</span> nu  设置行号</span><br><span class=\"line\">:<span class=\"built_in\">set</span> nonu  取消行号 </span><br><span class=\"line\"></span><br><span class=\"line\">:syntax on  开启语法高亮</span><br><span class=\"line\">:syntax off 关闭语法</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>命令模式操作</li>\n</ul>\n  <figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">光标移动:</span><br><span class=\"line\">hjkl  -&gt; 左下上右</span><br><span class=\"line\">0  \t回到行首</span><br><span class=\"line\">$   跳到行尾</span><br><span class=\"line\">gg  到首行</span><br><span class=\"line\">G   到末行</span><br><span class=\"line\">nG  到第n行</span><br><span class=\"line\">M   到屏幕中间</span><br><span class=\"line\">w   跳到下一个单词</span><br><span class=\"line\"></span><br><span class=\"line\">yy  复制当前光标行</span><br><span class=\"line\">nyy 从当前光标开始向下复制n行</span><br><span class=\"line\">p  \t在当前光标下一行粘贴</span><br><span class=\"line\">np  粘贴n次</span><br><span class=\"line\">dd \t剪切</span><br><span class=\"line\">ndd 剪切n行</span><br><span class=\"line\"></span><br><span class=\"line\">yG 复制到末行</span><br><span class=\"line\">ygg 复制到首行</span><br><span class=\"line\"></span><br><span class=\"line\">x 向后删除一个字符</span><br><span class=\"line\">X 向前删除一个字符</span><br><span class=\"line\"></span><br><span class=\"line\">&gt;&gt;  向前缩进</span><br><span class=\"line\">&lt;&lt;  向前缩进</span><br><span class=\"line\"></span><br><span class=\"line\">/查找内容</span><br><span class=\"line\">n 向下跳到搜索内容</span><br><span class=\"line\">N 反向跳</span><br><span class=\"line\"></span><br><span class=\"line\">u  撤消</span><br><span class=\"line\">ctrl + r  反撤消</span><br></pre></td></tr></table></figure>","site":{"data":{}},"excerpt":"<h1 id=\"Linux常用命令总结\"><a href=\"#Linux常用命令总结\" class=\"headerlink\" title=\"Linux常用命令总结\"></a>Linux常用命令总结</h1><h2 id=\"操作系统\"><a href=\"#操作系统\" class=\"headerlink\" title=\"操作系统\"></a>操作系统</h2><ul>\n<li><p>作用: 整合系统硬件资源,支持软件的运行.</p>\n</li>\n<li><p>常见操作系统:</p>\n<ul>\n<li>windows</li>\n<li>Linux</li>\n<li>Unix</li>\n</ul>","more":"<ul>\n<li>MacOS</li>\n<li>iOS</li>\n<li>安卓</li>\n</ul>\n</li>\n<li><p>虚拟机：用来模拟一台电脑</p>\n</li>\n<li><p>Linux 内核和发行版:</p>\n<ul>\n<li>内核：Linux系统的核心代码, Linux kernal 4.4.0.12….</li>\n<li>发行版：在内核的基础上,根据不同的应用需求添加额外的应用套件.<ul>\n<li>RedHat        rpm包</li>\n<li>CentOS</li>\n<li>Debian        dpg包</li>\n<li>Ubuntu</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>Linux文件系统结构 </p>\n<ul>\n<li>顶层目录  /</li>\n<li>普通用户家目录  /home</li>\n<li>可执行程序目录  /bin   /sbin</li>\n<li>配置文件目录    /etc</li>\n</ul>\n<hr>\n<h2 id=\"Linux基础命令\"><a href=\"#Linux基础命令\" class=\"headerlink\" title=\"Linux基础命令\"></a>Linux基础命令</h2></li>\n<li><p>Linux命令格式：命令   选项   参数</p>\n</li>\n<li><p>获取命令<strong>帮助</strong>:</p>\n<ul>\n<li>命令 –help</li>\n<li>man 命令</li>\n</ul>\n</li>\n<li><p><strong>自动补全</strong>:tab 键</p>\n<ol>\n<li>提高输入速度</li>\n<li>降低输入错误率</li>\n</ol>\n</li>\n</ul>\n<ol start=\"3\">\n<li>可以提示命令,也可以提示路径</li>\n</ol>\n<ul>\n<li><p><strong>路径</strong>:</p>\n<ul>\n<li>绝对路径: 以 根目录 / 开始的路径,称为绝对路径</li>\n<li>相对路径: 除绝对路径以外的路径都相对路径</li>\n</ul>\n</li>\n<li><p><strong>查看文件内容</strong>命令:  ls   -&gt; list</p>\n<ul>\n<li>ls -a  查看所有文件</li>\n<li>linux当中的隐藏文件是以.开头的 ,   .a.txt</li>\n<li>ls -l  查看文件的详细信息</li>\n<li>ls -lh 以计算后的单位形式显示 详细信息</li>\n</ul>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ls -alh   默认参数是当前目录</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li><p><strong>切换目录</strong>命令   cd   -&gt; change directory</p>\n<ul>\n<li>cd 路径</li>\n<li>.  当前目录</li>\n<li>.. 当前目录的上一级目录</li>\n<li>~  当前用户的家目录</li>\n</ul>\n</li>\n<li><p><strong>查看当前工作目录</strong>命令  </p>\n<ul>\n<li>pwd   -&gt; print work directory</li>\n</ul>\n</li>\n<li><p><strong>清屏命令</strong>   clear   -&gt; 快捷键  Ctrl + l</p>\n</li>\n<li><p><strong>创建空文件</strong>  touch 文件名 ….</p>\n</li>\n<li><p><strong>创建空目录</strong>  mkdir   make directory  </p>\n<ul>\n<li>mkdir 目录名 ….            # 如果如果创建多个同级目录,目录之间需要空格分隔</li>\n<li>mkdir -p 目录名/目录名/….</li>\n</ul>\n</li>\n<li><p><strong>删除目录</strong> rmdir  了解  只能删除空目录</p>\n</li>\n<li><p>删除文件或目录的命令  rm   -&gt; remove<br>rm 默认删除文件,如果是目录需使用选项</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">rm -r 目录名  删除目录级目录下的内容</span><br><span class=\"line\">rm -i 文件名  删除前询问</span><br><span class=\"line\">rm -f 文件名  强制删除不询问</span><br><span class=\"line\"></span><br><span class=\"line\">常用删除操作</span><br><span class=\"line\">rm -rf *  删除所有文件不询问</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li><strong>复制文件或目录</strong> cp  -&gt; copy<ul>\n<li>默认只能复制文件,要复制目录需使用选项 -r</li>\n</ul>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">cp -r 源文件路径  目录文件位置或名</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li><p><strong>移动命令</strong>  mv   -&gt; move</p>\n<ul>\n<li>mv 源文件 目标文件</li>\n<li>移动操作不考虑文件类型,移动可以兼具改名的功能</li>\n</ul>\n</li>\n<li><p><strong>查看文件内容</strong></p>\n<ul>\n<li>cat 文件名 …   适合查看比较小的文本文件</li>\n<li>more  文件名 …  适合查看比较大的文本文件,可以分屏显示 </li>\n</ul>\n</li>\n<li><p><strong>重定向</strong>  &gt;   &gt;&gt;</p>\n<ul>\n<li>stdin  标准输入文件   键盘</li>\n<li>stdout 标准输出文件   屏幕</li>\n<li>stderr 标准错误输出文件  屏幕</li>\n</ul>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ls -l &gt; log.txt  文件不存在则创建,存在则覆盖</span><br><span class=\"line\">ls -l &gt;&gt; log.txt  文件不存在则创建,存在则追加到文件最后</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li><strong>管道</strong> <code>|</code><ul>\n<li>作用是用来连接两个命令</li>\n<li>将左侧命令的执行结果 连接给 右侧的命令做为数据源</li>\n</ul>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ps aux | grep xxx</span><br><span class=\"line\">ls -l | more</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li><strong>文本内容查找</strong>     <code>grep</code></li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">grep -i <span class=\"string\">'查找内容'</span> 被查找的文件     <span class=\"comment\"># 忽略大小写搜索</span></span><br><span class=\"line\">grep -n <span class=\"string\">'查找内容'</span> 被查找的文件     <span class=\"comment\"># 查找结果显示 行号</span></span><br><span class=\"line\">grep -v <span class=\"string\">'查找内容'</span> 被查找的文件     <span class=\"comment\"># 结果取反</span></span><br><span class=\"line\"></span><br><span class=\"line\">带正则表达式使用</span><br><span class=\"line\">grep -<span class=\"keyword\">in</span> <span class=\"string\">'^查找内容'</span> 被查找的文件     <span class=\"comment\"># 严格的开始</span></span><br><span class=\"line\">grep -<span class=\"keyword\">in</span> <span class=\"string\">'查找内容$'</span> 被查找的文件     <span class=\"comment\"># 严格的结束</span></span><br><span class=\"line\">grep -<span class=\"keyword\">in</span> <span class=\"string\">'.'</span> 被查找的文件     \t\t   <span class=\"comment\"># 匹配一个非换行符之外的字符</span></span><br></pre></td></tr></table></figure>\n\n\n\n<ul>\n<li>查找文件 <code>find</code> <ul>\n<li>find 查找路径 -name 文件名</li>\n</ul>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">find 查找路径 -name <span class=\"string\">'文件名*'</span></span><br><span class=\"line\">find 查找路径 -name <span class=\"string\">'文件名?'</span></span><br></pre></td></tr></table></figure>\n\n\n\n<ul>\n<li><p><strong>链接命令</strong>  <code>ln  link</code></p>\n<ul>\n<li>软链接: 符号链接  <ul>\n<li>ln -s 源文件 目标连接位置   相当于<strong>快捷方式</strong></li>\n</ul>\n</li>\n<li>硬链接: </li>\n<li>ln    源文件 目标连接位置     类似于<strong>源文件的一个别名</strong> </li>\n</ul>\n</li>\n<li><p><strong>区别:</strong></p>\n<ul>\n<li>软链接 可以连接目录,硬连接不可以</li>\n<li>软连接相当于快捷方式,不占储存空间,硬连接占用空间</li>\n<li>硬连接会改变文件连接数,软连接不会</li>\n<li>硬连接不能跨分区.</li>\n</ul>\n</li>\n<li><p><strong>打包压缩</strong></p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">tar zcvf xxx.tar.gz xx,....</span><br><span class=\"line\">tar zxvf xxx.tar.gz -C unzip_dir</span><br><span class=\"line\"></span><br><span class=\"line\">tar jcvf xxx.tar.bz2 xx,....</span><br><span class=\"line\">tar jxvf xxx.tar.bz2 -C unzip_dir</span><br></pre></td></tr></table></figure>\n</li>\n<li><p><strong>权限管理</strong></p>\n<ul>\n<li>三类用户:<ul>\n<li>文件所有者     user  u</li>\n<li>所有者同组用户        group   g</li>\n<li>其它用户    other  o</li>\n<li>全部用户     all  a</li>\n</ul>\n</li>\n<li>权限:<ul>\n<li>读取权限    r</li>\n<li>写入权限    w</li>\n<li>执行权限    x</li>\n</ul>\n</li>\n</ul>\n<img src=\"https://tupian-1300728887.cos.ap-chengdu.myqcloud.com/Xnip2019-08-05_11-15-00.png\" style=\"zoom:100%;\" />\n\n\n</li>\n</ul>\n  <figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">chmod 用户角色 +/-/= 权限 文件\t<span class=\"comment\"># 字母法</span></span><br><span class=\"line\"></span><br><span class=\"line\">chmod 777  文件\t<span class=\"comment\"># 数字法</span></span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>切换用户身份<ul>\n<li>临时借用root权限 <ul>\n<li>sudo 命令</li>\n</ul>\n</li>\n<li>切换到root用户环境中<ul>\n<li>sudo -s</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n  <figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">su 用户名\t<span class=\"comment\"># 普通用户间切的</span></span><br><span class=\"line\"><span class=\"built_in\">exit</span>\t<span class=\"comment\"># 退出当前用户环境</span></span><br><span class=\"line\">whoami\t<span class=\"comment\"># 查看当用用户是谁</span></span><br><span class=\"line\">who\t\t<span class=\"comment\"># 查看所有登陆用户</span></span><br><span class=\"line\"><span class=\"built_in\">which</span>  命令\t\t<span class=\"comment\"># 查看命令位置</span></span><br></pre></td></tr></table></figure>\n\n<ul>\n<li><p><strong>用户管理</strong></p>\n<ul>\n<li>添加用户组<ul>\n<li>group  add 组名</li>\n<li>/etc/group</li>\n</ul>\n</li>\n<li>删除组<ul>\n<li>group  del 组名</li>\n<li>注意: 如果该组是用户的主组时,不能删除,需要先删除用户,再删除组</li>\n</ul>\n</li>\n<li>添加用户<ul>\n<li>useradd  -m -g 组id 用户名<ul>\n<li>-m 指定创建家目录,与用户名同名</li>\n<li>-g 用来指定用户所在的组</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p><strong>用户文件目录</strong></p>\n<ul>\n<li>/etc/passwd  保存用户信息</li>\n<li>/etc/shadow  保存用户的密码信息</li>\n<li>/etc/group   默认在创建用户时,会同创建一个同名的组 </li>\n</ul>\n</li>\n<li><p><strong>修改密码命令</strong></p>\n<ul>\n<li>为当前用户改密码<ul>\n<li>passwd</li>\n</ul>\n</li>\n<li>为指定用户改密码,但是只能由root执行<ul>\n<li>passwd 用户名</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p><strong>远程登陆</strong></p>\n<ul>\n<li>需要先安装  openssh-server 软件包</li>\n<li>ssh 用户名@ip地址 </li>\n</ul>\n</li>\n<li><p><strong>远程拷贝</strong>:</p>\n<ul>\n<li>上传:<ul>\n<li><code>scp 本地文件 user@IP:/路径</code></li>\n</ul>\n</li>\n<li>下载:<ul>\n<li><code>scp user@ip:/资源位置   本地位置</code></li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p><strong>软件安装和卸载</strong></p>\n<ul>\n<li>离线:<ul>\n<li>安装    <code>dpkg -i xxx.deb</code></li>\n<li>卸载    <code>dpkg -r xxx</code></li>\n</ul>\n</li>\n<li>在线:<ol>\n<li>首要配置数据源    <code>/etc/apt/source.list</code><ol start=\"2\">\n<li>更新数据源    <code>sudo apt-get update</code></li>\n<li>安装    <code>sudo apt-get install 软件名</code></li>\n<li>卸载    <code>sudo apt-get remove 软件名</code></li>\n</ol>\n</li>\n</ol>\n</li>\n</ul>\n<hr>\n</li>\n</ul>\n<h2 id=\"vim\"><a href=\"#vim\" class=\"headerlink\" title=\"vim\"></a>vim</h2><ul>\n<li>编辑模式    <code>i 从命令变成编辑模式</code></li>\n<li>命令模式    <code>esc 键  退回到命令模式</code></li>\n<li>末行模式<ul>\n<li>:wq  保存退出    :wq!</li>\n<li>:w   保存不退出   :w!</li>\n<li>:q   退出不保存   :q!</li>\n<li>:x   保存退出     :x!</li>\n</ul>\n</li>\n<li>配置文件设置</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">:<span class=\"built_in\">set</span> nu  设置行号</span><br><span class=\"line\">:<span class=\"built_in\">set</span> nonu  取消行号 </span><br><span class=\"line\"></span><br><span class=\"line\">:syntax on  开启语法高亮</span><br><span class=\"line\">:syntax off 关闭语法</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>命令模式操作</li>\n</ul>\n  <figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">光标移动:</span><br><span class=\"line\">hjkl  -&gt; 左下上右</span><br><span class=\"line\">0  \t回到行首</span><br><span class=\"line\">$   跳到行尾</span><br><span class=\"line\">gg  到首行</span><br><span class=\"line\">G   到末行</span><br><span class=\"line\">nG  到第n行</span><br><span class=\"line\">M   到屏幕中间</span><br><span class=\"line\">w   跳到下一个单词</span><br><span class=\"line\"></span><br><span class=\"line\">yy  复制当前光标行</span><br><span class=\"line\">nyy 从当前光标开始向下复制n行</span><br><span class=\"line\">p  \t在当前光标下一行粘贴</span><br><span class=\"line\">np  粘贴n次</span><br><span class=\"line\">dd \t剪切</span><br><span class=\"line\">ndd 剪切n行</span><br><span class=\"line\"></span><br><span class=\"line\">yG 复制到末行</span><br><span class=\"line\">ygg 复制到首行</span><br><span class=\"line\"></span><br><span class=\"line\">x 向后删除一个字符</span><br><span class=\"line\">X 向前删除一个字符</span><br><span class=\"line\"></span><br><span class=\"line\">&gt;&gt;  向前缩进</span><br><span class=\"line\">&lt;&lt;  向前缩进</span><br><span class=\"line\"></span><br><span class=\"line\">/查找内容</span><br><span class=\"line\">n 向下跳到搜索内容</span><br><span class=\"line\">N 反向跳</span><br><span class=\"line\"></span><br><span class=\"line\">u  撤消</span><br><span class=\"line\">ctrl + r  反撤消</span><br></pre></td></tr></table></figure>"},{"title":"ES基本操作","date":"2020-07-11T03:11:47.000Z","top":1,"_content":"\n# Elasticsearch基本操作\n\n# 一、简介\n\n**Elasticsearch（ES）：**一款基于[Apache Lucene(TM)](https://lucene.apache.org/core/)的开源的全文检索和分析引擎。通过简单的`RESTful API`来隐藏其复杂性、同时也做了分布式相关的工作。\n\n**Lucene：**使用Java实现的一套搜索引擎库。\n\n<!--more-->\n\n- 分布式的实时文件存储，每个字段都被索引并可被搜索\n- 分布式的实时分析搜索引擎\n- 可以扩展到上百台服务器，处理PB级结构化或非结构化数据\n\n#### ES与关系型数据库对比\n\nElasticsearch集群可以包含多个索引（数据库），每一个索引可以包含多个类型（表），每一个类型包含多个文档（行），然后每个文档包含多个字段（列）\n\n| **关系型数据库** | **数据库**    | **表**     | **行** | **列** |\n| ---------------- | ------------- | ---------- | ------ | ------ |\n| ElasticSearch    | 索引（index） | 类型(type) | 文档   | 字段   |\n\n**相关概念：** \n\n1. 集群（cluster）：一个集群就是由一个或多个节点组织在一起，它们共同持有你整个的数据，并一起提供索引和搜索功能。\n2. 节点（node）：一个节点就是集群中的一个服务器，作为集群的一部分，参与集群的索引和搜索功能。\n3. 索引（index）： 一个索引就是一个具有相似特征的文档集合，相当于一个数据集。\n4. 类型（type）：在一个索引中，你可以定义一种或多种类型，相当于对一个索引中数据的逻辑划分（ES官方文档明确说明不推荐使用type，即建议一个索引只有一个type。ES7.0已经废弃了type）。\n5. 文档（document）： 一个文档是一个可被索引的基础信息单元，就是索引里面的一条数据，使用JSON格式来表示。\n6. 域（field）： 文档中的一个数据字段。一个文档由多个域组成。\n7. 分片（shards）：分片是索引的一部分，一个索引由多个分片组成。每个分片可以分布在不同的节点上，ES会根据文档id（也可以指定其他字段）做hash，使用得到的hash值将文档路由到指定分片上。分片是ES做Data Rebalance的最小单元。\n8. 副本（replicas）：创建索引时可以为索引指定0个或者多个副本。副本是分片级别的，即索引的分片由1个主分片（primary shard）和0个或者多个副本分片（replica shard）组成。primary shard可以接受读取和写入请求，replica shard只能接受读取请求。所以副本只能提高数据的可用性和并发读取能力。当primary shard所在服务器的节点挂掉以后，ES会通过leader选举机制将replica shard为primary shard。\n\n#### 文本分析\n\n**将文本转换成一系列单词（Term or Token）的过程，用于创建和查询倒排索引**\n\n- 分词器：是ES中专门处理分词的组件，由一下三部分组成\n  1. Character Filters：针对原始文本进行处理，比如去除html标签\n  2. Tokenizer：将原始文本按照一定规则切分为单词\n  3. Token Filters：针对Tokenizer处理的单词进行再加工，比如转小写、删除或增新等处理\n\n- 内置分词器：\n  1. Standard Analyzer：默认分词器，按词切分，小写处理，删除大多标点符号\n  2. Simple Analyzer：按照非字母切分、小写处理\n  3. Whitespace Analyzer：按照空白字符分割\n  4. Keyword Analyzer：不分词\n\n- 分词查看\n\n  ```json\n  POST /_analyze\n  {\n    \"analyzer\": \"keyword\",\n    \"text\": \"The 2 QUICK Brown-Foxes jumped over the lazy dog's bone.\"\n  }\n  ```\n\n详情点击跳转[官方文档](https://www.elastic.co/guide/en/elasticsearch/reference/7.5/analysis-analyzers.html)查看\n\n#### 倒排索引\n\n**ES把文档中的数据进行分析后，将词和文档之间建立映射关系。**\n\n组成：倒排索引由文档中不重复词的列表＋每个词被包含的文档ID列表\n\n查询过程：\n\n1. 搜索词“搜索引擎”，获得对应的文档ID列表，1，3\n2. 通过正排索引查询1和3的完整内容\n3. 返回最终结果\n\n<img src=\"https://tupian-1300728887.cos.ap-chengdu.myqcloud.com/image-20200904171011154.png\" alt=\"image-20200904171011154\" style=\"zoom:67%;\" />\n\n# 二、基本查询\n\n## 空查询\n\n```json\nGET /_search\n{}\n\nGET /_search\n{\n    \"query\": {\n        \"match_all\": {}\n    }\n}\n```\n\n### 字段详解\n\n![image-20200904172752621](https://tupian-1300728887.cos.ap-chengdu.myqcloud.com/image-20200904172752621.png)\n\n### 相关性\n\n**根据ES的相似度算法（TF/IDF）得出的结果，具体值由_score字段表示，根据以下维度计算得出**\n\n1. 检索词频率： 检索词在该字段出现的频率，频率越高，权重越大。字段中出现过 5 次要比只出现过 1 次的相关性高。\n\n2. 反向文档频率：检索词在使用中出现的频率，频率越高，权重越低。检索词出现在多数文档中会比出现在少数文档中的权重更低。\n\n3. 字段长度准则：字段长度越长，权重越低\n\n   ```json\n   // 请求后增加explain=true即可\n   GET /_search\n   {\n      \"explain\":true,\n      \"query\"   : { \"match\" : { \"name\" : \"John Smith\" }}\n   }\n   ```\n\n## 查询与过滤\n\n|            | **Query**                                                    | **Filter**                                                   |\n| ---------- | ------------------------------------------------------------ | ------------------------------------------------------------ |\n| 争对问题   | 该文档匹不匹配这个查询，它的相关度高么❓                      | 这篇文档是否与该查询匹配❓                                    |\n| 相关度处理 | 先查询符合搜索条件的文档数，然后计算每个文档对于搜索条件的相关度分数，再根据评分倒序排序 | 只根据搜索条件过滤出符合的文档,   不进行评分, 忽略TF/IDF信息 |\n| 性能       | 性能较差, 有排序 , 并且没有缓存功能（有倒排索引来弥补）      | 性能更好, 无排序；  会缓存比较常用的filter的数据             |\n| 栗子       | ❗ 查询与“first blog”字段最佳匹配的文档 ❗                     | ❗ 搜索博客等级(level)大于等于2, 同时发布日期(post_date)是2018-11-11的博客 ❗ |\n\n###  1. ❗ 查询与\"first blog\"字段最佳匹配的文档 ❗\n\n```json\n// query\nGET /_search\n{\n  \"query\": {\n    \"match\": {\n      \"desc\": \"four blog\"\n    }\n  }\n}\n\n// filter\nGET /_search\n{\n  \"query\": {\n    \"bool\": {\n      \"filter\": {\n        \"match\": {\n          \"desc\": \"four blog\"\n        }\n      }\n    }\n  }\n}\n```\n\n### 2. ❗ 搜索博客等级(level)大于等于2, 同时发布日期(post_date)是2018-11-11的博客 ❗\n\n```json\n// query\nGET /_search\n{\n    \"query\": {\n        \"bool\": {\n            \"must\": [\n                { \"match\": { \"post_date\": \"2018-11-11\" } }, \n                { \"range\": { \"level\": { \"gte\": 2 } } }\n            ]\n        }\n    }\n}\n// filter\nGET /_search\n{\n    \"query\": {\n        \"bool\": {\n            \"must\": { \n                \"match\": { \"post_date\": \"2018-11-11\" }\n            }, \n            \"filter\": {\n                \"range\": { \"level\": { \"gte\": 2 } }\n            }\n        }\n    }\n}\n```\n\n## 结构化搜索\n\n```json\nPOST /my_store/_bulk\n{ \"index\": { \"_id\": 1 }}\n{ \"price\" : 10, \"productID\" : \"XHDK-A-1293-#fJ3\" }\n{ \"index\": { \"_id\": 2 }}\n{ \"price\" : 20, \"productID\" : \"KDKE-B-9947-#kL5\" }\n{ \"index\": { \"_id\": 3 }}\n{ \"price\" : 30, \"productID\" : \"JODL-X-1937-#pV7\" }\n{ \"index\": { \"_id\": 4 }}\n{ \"price\" : 30, \"productID\" : \"QQPX-R-3956-#aD8\" }\n```\n\n**查看索引详情**\n\n```json\nGET /my_store\n```\n\n### 1. 精确值查找（term）\n\n> 1. 查询价格20的所有产品\n>\n>    SQL：==SELECT * FROM products WHERE price = 20==\n>\n>    ```json\n>    GET /_search\n>    {\n>     \"query\" : {\n>         \"constant_score\" : { \n>             \"filter\" : {\n>                 \"term\" : { \n>                     \"price\" : 20\n>                 }\n>             }\n>         }\n>     }\n>    }\n>    // constant_score关键字将trem查询转化为filter\n>    GET /_search\n>    {\n>      \"query\":{\n>        \"bool\": {\n>          \"filter\": {\n>            \"term\": {\n>              \"price\": 20\n>            }\n>          }\n>        }\n>      }\n>    }\n>    ```\n>\n> 2. 查询productID为XHDK-A-1293-#fJ3的文档\n>\n>    SQL：==SELECT * FROM products WHERE  productID = \"XHDK-A-1293-#fJ3\"==\n>\n>    ```json\n>    GET /_search\n>    {\n>        \"query\" : {\n>            \"constant_score\" : {\n>                \"filter\" : {\n>                    \"term\" : {\n>                        \"productID\" : \"XHDK-A-1293-#fJ3\"\n>                    }\n>                }\n>            }\n>        }\n>    }\n>    \n>    // 查看分词结果\n>    GET /my_store/_analyze\n>    {\n>      \"field\": \"productID\",\n>      \"text\": \"XHDK-A-1293-#fJ3\"\n>    }\n>    ```\n>\n>    总结：term会拿\"XHDK-A-1293-#fJ3\"，去倒排索引中找，但倒排索引表里只有\"xhdk\",\"a\",\"1293\",\"fj3\",因此查不到\n>\n>    **解决办法**\n>\n>    1. match_phrase关键字\n>\n>       ```json\n>       GET /_search\n>       {\n>           \"query\" : {\n>               \"match_phrase\" : {\n>                   \"productID\" : \"XHDK-A-1293-#fJ3\"\n>               }\n>           }\n>       }\n>       ```\n>\n>    2. 重新配置该字段的分词规则\n>\n>       ```json\n>       // 1.删除索引\n>       DELETE /my_store\n>       //2.指定productID字段使用keyword规则\n>       PUT /my_store\n>       {\n>       \t\"mappings\": {\n>       \t\t\t\"properties\": {\n>       \t\t\t\t\"price\": {\n>       \t\t\t\t\t\"type\": \"long\"\n>       \t\t\t\t},\n>       \t\t\t\t\"productID\": {\n>       \t\t\t\t\t\"type\": \"text\",\n>       \t\t\t\t\t\"analyzer\": \"keyword\"\n>       \t\t\t\t}\n>       \t\t\t}\n>       \t}\n>       }\n>       ```\n>\n\n### 2. 多个精确值查找（terms）\n\n> 1. 查找price为20 && 30 的文档\n>\n>    ```json\n>    GET /my_store/_search\n>    {\n>        \"query\" : {\n>            \"constant_score\" : {\n>                \"filter\" : {\n>                    \"terms\" : { \n>                        \"price\" : [20, 30]\n>                    }\n>                }\n>            }\n>        }\n>    }\n>    ```\n\n### 3. range(范围过滤)\n\n**gt:>   lt:<    gte:>=  lte:<=**\n\n> 1. 查找price大于20且小于40的产品\n>\n>    SQL：==SELECT * FROM products WHERE  price BETWEEN 20 AND 40==\n>\n>    ```json\n>    GET /my_store/_search\n>    {\n>        \"query\" : {\n>            \"constant_score\" : {\n>                \"filter\" : {\n>                    \"range\" : {\n>                        \"price\" : {\n>                            \"gte\" : 20,\n>                            \"lt\"  : 40\n>                        }\n>                    }\n>                }\n>            }\n>        }\n>    }\n>    ```\n>\n> 2. 日期范围查询  now  data||+1M\n>\n>    ```json\n>    GET /website/_search\n>    {\n>        \"query\" : {\n>            \"constant_score\" : {\n>                \"filter\" : {\n>                    \"range\" : {\n>                        \"post_date\": {\n>                            \"gte\" : \"2020-01-01\",\n>                            \"lt\": \"2020-09-09||+1h\"\n>                        }\n>                    }\n>                }\n>            }\n>        }\n>    }\n>    ```\n\n### 4. 组合查询（bool）\n\n> 1. SQL：==SELECT * FROM products WHERE (price = 20 OR productID = \"XHDK-A-1293-#fJ3\") AND (price != 30)==\n>\n>    ```json\n>    GET /my_store/_search\n>    {\n>       \"query\" : {\n>          \"constant_score\" : { \n>             \"filter\" : {\n>                \"bool\" : {\n>                  \"should\" : [\n>                     { \"term\" : {\"price\" : 20}}, \n>                     { \"term\" : {\"productID\" : \"XHDK-A-1293-#fJ3\"}} \n>                  ],\n>                  \"must_not\" : {\n>                     \"term\" : {\"price\" : 30} \n>                  }\n>               }\n>             }\n>          }\n>       }\n>    }\n>    ```\n>\n> 2. SQL：==SELECT * FROM products WHERE productID = \"KDKE-B-9947-#kL5\" OR (productID = \"JODL-X-1937-#pV7\" AND price = 30)==\n>\n>    ```json\n>    GET /my_store/_search\n>    {\n>       \"query\" : {\n>          \"constant_score\" : {\n>             \"filter\" : {\n>                \"bool\" : {\n>                  \"should\" : [\n>                    { \"term\" : {\"productID\" : \"KDKE-B-9947-#kL5\"}}, \n>                    { \"bool\" : { \n>                      \"must\" : [\n>                        { \"term\" : {\"productID\" : \"JODL-X-1937-#pV7\"}}, \n>                        { \"term\" : {\"price\" : 30}} \n>                      ]\n>                    }}\n>                  ]\n>               }\n>             }\n>          }\n>       }\n>    }\n>    ```\n\n### 5. 处理null值（exists）\n\n```json\nPOST /posts/_bulk\n{ \"index\": { \"_id\": \"1\"              }}\n{ \"tags\" : [\"search\"]                }  \n{ \"index\": { \"_id\": \"2\"              }}\n{ \"tags\" : [\"search\", \"open_source\"] }  \n{ \"index\": { \"_id\": \"3\"              }}\n{ \"other_field\" : \"some data\"        }  \n{ \"index\": { \"_id\": \"4\"              }}\n{ \"tags\" : null                      }  \n{ \"index\": { \"_id\": \"5\"              }}\n{ \"tags\" : [\"search\", null]          }\n```\n\n> 1. 存在查询\n>\n>    ==SQL:SELECT tags FROM posts WHERE tags IS NOT NULL==\n>\n>    ```json\n>    GET /posts/_search\n>    {\n>        \"query\" : {\n>            \"constant_score\" : {\n>                \"filter\" : {\n>                    \"exists\" : { \"field\" : \"tags\" }\n>                }\n>            }\n>        }\n>    }\n>    ```\n>\n> 2. 缺失查询\n>\n>    ==SQL:SELECT tags FROM posts WHERE tags IS NULL==\n>\n>    ```json\n>    GET /posts/_search\n>    {\n>        \"query\" : {\n>            \"constant_score\" : {\n>                \"filter\" : {\n>                  \"bool\": {\n>                    \"must_not\":{\"exists\" : { \"field\" : \"tags\" }}\n>                  }\n>                }\n>            }\n>        }\n>    }\n>    ```\n\n## 全文搜索\n\n```json\nPOST /my_index/my_type/_bulk\n{ \"index\": { \"_id\": 1 }}\n{ \"title\": \"The quick brown fox\" }\n{ \"index\": { \"_id\": 2 }}\n{ \"title\": \"The quick brown fox jumps over the lazy dog\" }\n{ \"index\": { \"_id\": 3 }}\n{ \"title\": \"The quick brown fox jumps over the quick dog\" }\n{ \"index\": { \"_id\": 4 }}\n{ \"title\": \"Brown fox brown dog\" }\n```\n\n### 1. match\n\n> 1. 单个词查询\n>\n>    ```json\n>    GET /my_index/_search\n>    {\n>        \"query\": {\n>            \"match\": {\n>                \"title\": \"QUICK!\"\n>            }\n>        }\n>    }\n>    ```\n>\n>    执行过程：\n>\n>    1. 检查字段类型\n>\n>    2. 分析查询字符串\n>\n>       ```json\n>       GET /_analyze\n>       {\n>         \"text\": \"QUICK!\"\n>       }\n>       ```\n>\n>    3. 调用term查询，去倒排索引中查询包含quick的文档\n>\n>       ```json\n>       GET /my_type/_search\n>       {\n>         \"query\": {\n>           \"term\": {\n>             \"title\": \"quick\"\n>           }\n>         }\n>       }\n>       ```\n>\n>    4. 为每个文档评分并排序\n>\n> 2. 多词查询\n>\n>    ```json\n>    GET /my_index/_search\n>    {\n>        \"query\": {\n>            \"match\": {\n>                \"title\": \"BROWN DOG!\"\n>            }\n>        }\n>    }\n>    \n>    GET /my_index/_search\n>    {\n>      \"query\": {\n>        \"bool\": {\n>          \"should\": [\n>            {\"term\": {\"title\": \"brown\"}},\n>            {\"term\":{\"title\":\"dog\"}}\n>          ]\n>        }\n>      }\n>    }\n>    ```\n>\n>    总结:被匹配的此项越多，文档越相关\n>\n> 3. operator：修改匹配关系\n>\n>    ```json\n>    GET /my_index/_search\n>    {\n>        \"query\": {\n>            \"match\": {\n>                \"title\": {      \n>                    \"query\":    \"BROWN DOG!\",\n>                    \"operator\": \"and\"\n>                }\n>            }\n>        }\n>    }\n>    \n>    GET /my_index/_search\n>    {\n>      \"query\": {\n>        \"bool\": {\n>          \"must\": [\n>            {\"term\": {\"title\": \"brown\"}},\n>            {\"term\":{\"title\":\"dog\"}}\n>          ]\n>        }\n>      }\n>    }\n>    ```\n>\n\n### 2. bool（组合查询）\n\n> 1. 查询包含quick，但不包含lazy的所有文档，如果包含should里的字段，则该文章相关度更高\n>\n>    ```json\n>    GET /my_index/_search\n>    {\n>      \"query\": {\n>        \"bool\": {\n>          \"must\":     { \"match\": { \"title\": \"quick\" }},\n>          \"must_not\": { \"match\": { \"title\": \"lazy\"  }},\n>          \"should\": [\n>                      { \"match\": { \"title\": \"brown\" }},\n>                      { \"match\": { \"title\": \"dog\"   }}\n>          ]\n>        }\n>      }\n>    }\n>    ```\n\n### 3. match_phrase（短语匹配）\n\n```json\nGET /my_index/_search\n{\n    \"query\": {\n        \"match_phrase\": {\n            \"title\": \"quick brown fox\"\n        }\n    }\n}\n```\n\n## 分页（深度分页）from+size\n\n缺点：\n\n- 效率低。比如from=5000，size=100，es需要在各个分片上匹配排序并得到5000+100条有效数据，然后在结果集中取最后100条结果。\n- 最大可查询条数为1W条。ES目前默认支持的skin值max_result_window=10000，当from+size>max_result_window时，ES就会返回错误。\n- ==解决办法：使用scroll（游标查询）==\n\n```json\n{\n  \"query\": {\n    \"match_all\": {}\n  },\n  \"from\": 0,  \n  \"size\": 1  \n}\n```\n\nfrom：从第几个商品开始查，最开始是 0\n\nsize：要查几个结果\n\n## 游标查询（scroll）\n\n- 启动游标查询\n\n  ```\n  CET /host/_search?scroll=1m\n  ```\n\n  scroll=1m表示游标查询窗口保持1分钟，如果一次取的数据量大可以设置大一些的时间；返回字段包含一个scroll_id，接下来用这个字段获取后续值\n\n- 循环获取\n\n  循环获取余下值\n\n  ```json\n  GET /_search/scroll\n  {\n  \t\"scroll\": \"1m\"，\n  \t\"scroll_id\": scroll_id\n  }\n  ```\n\n  > python操作\n  >\n  > ```python\n  > from elasticsearch import Elasticsearch\n  > \n  > es = Elasticsearch(['localhost:9200'])\n  > # 1.启动游标\n  > queryData = es.search(\"internal_isop_log\", body=dsl_body, scroll='1m', size=1000)\n  > # 获取scroll_id\n  > hits_list = queryData.get(\"hits\").get(\"hits\")\n  > scroll_id = queryData['_scroll_id']\n  > \n  > # 2.循环获取\n  > total = queryData.get(\"hits\").get(\"total\").get('value')\n  > for i in range(int(total / 1000)):\n  >     ss = {'scroll': '1m', 'scroll_id': scroll_id}\n  >     res = self.es.scroll(body=ss)\n  > ```\n\n## 模糊查询\n\n1. 创建索引，设置postcode字段使用keyword规则 ❗模糊查询会匹配倒排表里的字段 ❗\n\n   ```json\n   PUT /address\n   {\n   \t\"mappings\": {\n   \t\t\t\"properties\": {\n   \t\t\t\t\"postcode\": {\n   \t\t\t\t\t\"type\": \"text\",\n   \t\t\t\t\t\"analyzer\": \"keyword\"\n   \t\t\t\t}\n   \t\t\t}\n   \t}\n   }\n   ```\n\n2. 导入数据\n\n   ```json\n   PUT /address/_bulk\n   { \"index\": { \"_id\": 1 }}\n   { \"postcode\": \"W1V 3DG\" }\n   { \"index\": { \"_id\": 2 }}\n   { \"postcode\": \"W2F 8HW\" }\n   { \"index\": { \"_id\": 3 }}\n   { \"postcode\": \"W1F 7HW\" }\n   { \"index\": { \"_id\": 4 }}\n   { \"postcode\": \"WC1N 1LZ\" }\n   { \"index\": { \"_id\": 5 }}\n   { \"postcode\": \"SW5 0BE\" }\n   ```\n\n3. 倒排表\n\n   |    Term    | Doc IDs |\n   | :--------: | :-----: |\n   | \"SW5 0BE\"  |    5    |\n   | \"W1F 7HW\"  |    3    |\n   | \"W1V 3DG\"  |    1    |\n   | \"W2F 8HW\"  |    2    |\n   | \"WC1N 1LZ\" |    4    |\n\n1. 前缀匹配（prefix）\n\n   匹配postcode字段以“W1”开头的文档\n   \n   ```json\n   GET /address/_search\n   {\n       \"query\": {\n           \"prefix\": {\n               \"postcode\": \"W1\"\n           }\n       }\n   }\n   ```\n\n2. 通配符查询（wildcard）\n\n   ```json\n   GET /address/_search\n   {\n       \"query\": {\n           \"wildcard\": {\n               \"postcode\": \"W?F*HW\" \n           }\n       }\n   }\n   ```\n\n3. 正则匹配（regexp）\n\n   ```json\n   GET /address/_search\n   {\n       \"query\": {\n           \"regexp\": {\n               \"postcode\": \"W[0-9].+\" \n           }\n       }\n   }\n   ```\n\n**不配置分词规则带来的影响**\n\n>  栗子：title字段为“Quick brown fox” ，倒排索引中会生成： quick 、 brown 和 fox \n>\n>  | { \"regexp\": { \"title\": \"br.*\" }}      | 可以匹配                       |\n>  | ------------------------------------- | ------------------------------ |\n>  | { \"regexp\": { \"title\": \"Qu.*\" }}      | 匹配不到：quick为小写          |\n>  | { \"regexp\": { \"title\": \"quick br*\" }} | 匹配不到：quick和brown是分开的 |\n\n# 三、聚合分组\n\nElasticSearch除了致力于搜索之外，也提供了聚合实时分析数据的功能，透过聚合，我们可以得到一个数据的概览，分析和总结全套的数据\n\n对相同的数据进行 搜索/过滤 + 分析，两个愿望一次满足\n\n聚合的两个主要的概念，分别是 桶 和 指标\n\n- 桶(Buckets) : 满足特定条件的文档的集合\n\n  1. 当聚合开始被执行，每个文档会决定符合哪个桶的条件，如果匹配到，文档将放入相应的桶并接着进行聚合操作\n\n     > 像是一个员工属于男性桶或者女性桶\n\n  2. 桶可以被嵌套在其他桶里面\n\n     > 北京能放在中国桶裡\n\n- 指标(Metrics) : 对桶内的文档进行统计计算\n\n  1. 桶能让我们划分文档到有意义的集合， 但是最终我们需要的是对这些桶内的文档进行一些指标的计算\n\n  2. 指标通常是简单的数学运算(像是min、max、avg、sum）\n\n     > 计算像平均薪资、最高出售价格、95%的查询延迟这样的数据\n\n### 执行顺序\n\n当query和aggs一起存在时，会先执行query的主查询，主查询query执行完后会搜出一批结果，而这些结果才会被拿去aggs拿去做聚合\n\n```json\n{\n    \"query\": { ... },\n    \"size\": 0,\n    \"aggs\": {\n        \"custom_name1\": {  //aggs后面接著的是一个自定义的name\n            \"桶\": { ... }  //再来才是接桶\n        },\n        \"custom_name2\": {  //一个aggs裡可以有很多聚合\n            \"桶\": { ... }\n        },\n        \"custom_name3\": {\n            \"桶\": {\n               .....\n            },\n            \"aggs\": {  //aggs可以嵌套在别的aggs裡面\n                \"in_name\": { //记得使用aggs需要先自定义一个name\n                    \"桶\": { ... } //in_name的桶作用的文档是custom_name3的桶的结果\n                }\n            }\n        }\n    }\n}\n```\n\n### 常见的桶\n\n1. terms桶 : 针对某个field的值进行分组，field有几种值就分成几组\n\n   - terms桶在进行分组时，会爲此field中的每种值创建一个新的桶\n\n   - 要注意此 \"terms桶\" 和平常用在主查询query中的 \"查找terms\" 是不同的东西\n\n     > 测试数据\n     >\n     > ```json\n     > { \"color\": \"red\" }\n     > { \"color\": \"green\" }\n     > { \"color\": [\"red\", \"blue\"] }\n     > ```\n     >\n     > dsl语句\n     >\n     > ```json\n     > {\n     >     \"query\": {\n     >         \"match_all\": {}\n     >     },\n     >     \"size\": 0,\n     >     \"aggs\": {\n     >         \"my_name\": {\n     >             \"terms\": {\n     >                 \"field\": \"color\" //使用color来进行分组\n     >             }\n     >         }\n     >     }\n     > }\n     > ```\n     >\n     > 结果\n     >\n     > ```json\n     > \"aggregations\": {\n     >     \"my_name\": {\n     >         \"doc_count_error_upper_bound\": 0,\n     >         \"sum_other_doc_count\": 0,\n     >         \"buckets\": [\n     >             {\n     >                 \"key\": \"blue\",\n     >                 \"doc_count\": 1\n     >             },\n     >             {\n     >                 \"key\": \"red\",\n     >                 \"doc_count\": 2  //表示color为red的文档有2个，此例中就是 {\"color\": \"red\"} 和 {\"color\": [\"red\", \"blue\"]}这两个文档\n     >             },\n     >             {\n     >                 \"key\": \"green\",\n     >                 \"doc_count\": 1\n     >             }\n     >         ]\n     >     }\n     > }\n     > ```\n     >\n     > \n\n2. filter桶 : 一个用来过滤的桶\n\n   - 要注意此处的 \"filter桶\" 和用在主查询query的 \"过滤filter\" 的用法是一模一样的，都是过滤，不过差别是 \"filter桶\" 会自己给创建一个新的桶，而不会像 \"过滤filter\" 一样依附在query下，因为filter桶毕竟还是一个聚合桶，因此他可以和别的桶进行嵌套，但他不是依附在别的桶上\n\n     > 测试数据\n     >\n     > 同上\n     >\n     > dsl语句\n     >\n     > ```json\n     > {\n     >     \"query\": {\n     >         \"match_all\": {}\n     >     },\n     >     \"size\": 0,\n     >     \"aggs\": {\n     >         \"my_name\": {\n     >             \"filter\": { //因为他用法跟一般的过滤filter一样，所以也能使用bool嵌套\n     >                 \"bool\": {\n     >                     \"must\": {\n     >                         \"terms\": { //注意此terms是查找terms，不是terms桶\n     >                             \"color\": [ \"red\", \"blue\" ]\n     >                         }\n     >                     }\n     >                 }\n     >             }\n     >         }\n     >     }\n     > }\n     > ```\n     >\n     > 结果\n     >\n     > ```json\n     > \"aggregations\": {\n     >     \"my_name\": {\n     >         \"doc_count\": 2 //filter桶计算出来的文档数量\n     >     }\n     > }\n     > ```\n     >\n     > \n\n3. top_hits桶 : 在某个桶底下找出这个桶的前几笔hits，返回的hits格式和主查询query返回的hits格式一模一样\n\n   - 参数\n\n     1. from、size\n\n     2. sort：sort : 设置返回的hits的排序\n\n        - 要注意，假设在主查询query裡已经对数据设置了排序sort，此sort并不会对aggs裡面的数据造成影响，也就是说主查询query查找出来的数据会先丢进aggs而非先经过sort，因此就算主查询设置了sort，也不会影响aggs数据裡的排序因此如果在top_hits桶裡的返回的hits数据想要排序，需要自己在top_hits桶裡设置sort\n\n        - 如果没有设置sort，默认使用主查询query所查出来的_score排序\n\n     3. _source : 设置返回的字段\n\n     > 测试数据\n     >\n     > ```json\n     > { \"color\": \"red\", \"price\": 100 }\n     > { \"color\": [\"red\", \"blue\"], \"price\": 1000 }\n     > ```\n     >\n     > dsl语句\n     >\n     > 使用terms桶分组，再使用top_hits桶找出每个group裡面的price最小的前5笔hits\n     >\n     > ```\n     > {\n     >     \"query\": {\n     >         \"match_all\": {}\n     >     },\n     >     \"size\": 0,\n     >     \"aggs\": {\n     >         \"my_name\": {\n     >             \"terms\": {\n     >                 \"field\": \"color\"\n     >             },\n     >             \"aggs\": {\n     >                 \"my_top_hits\": {\n     >                     \"top_hits\": {\n     >                         \"size\": 5,\n     >                         \"sort\": {\n     >                             \"price\": \"asc\"\n     >                         }\n     >                     }\n     >                 }\n     >             }\n     >         }\n     >     }\n     > }\n     > ```\n     >\n     > 结果\n     >\n     > ```json\n     > \"aggregations\": {\n     >     \"my_name\": {\n     >         \"doc_count_error_upper_bound\": 0,\n     >         \"sum_other_doc_count\": 0,\n     >         \"buckets\": [\n     >             {\n     >                 \"key\": \"red\",\n     >                 \"doc_count\": 2,  //terms桶计算出来的color为red的文档数\n     >                 \"my_top_hits\": {\n     >                     \"hits\": {  //top_hits桶找出color为red的这些文档中，price从小到大排序取前5笔\n     >                         \"total\": 2,\n     >                         \"max_score\": null,\n     >                         \"hits\": [\n     >                             {\n     >                                 \"_score\": null,\n     >                                 \"_source\": { \"color\": \"red\", \"price\": 100 },\n     >                                 \"sort\": [ 100 ]\n     >                             },\n     >                             {\n     >                                 \"_score\": null,\n     >                                 \"_source\": { \"color\": [ \"red\", \"blue\" ], \"price\": 1000 },\n     >                                 \"sort\": [ 1000 ]\n     >                             }\n     >                         ]\n     >                     }\n     >                 }\n     >             },\n     >             {\n     >                 \"key\": \"blue\",\n     >                 \"doc_count\": 1,  //terms桶计算出来的color为blue的文档数\n     >                 \"my_top_hits\": {\n     >                     \"hits\": { //top_hits桶找出的hits\n     >                         \"total\": 1,\n     >                         \"max_score\": null,\n     >                         \"hits\": [\n     >                             {\n     >                                 \"_source\": {\n     >                                     \"color\": [ \"red\", \"blue\" ], \"price\": 1000 },\n     >                                 \"sort\": [ 1000 ]\n     >                             }\n     >                         ]\n     >                     }\n     >                 }\n     >             }\n     >         ]\n     >     }\n     > }\n     > ```\n     >\n     > \n\n4. date_histogram桶，对指定时间段内数据进行分组\n\n   - 参数\n\n     1. time_zone:\"+08:00\"：设置市区（东八区），不指定会影响分组时间错误\n     2. interval：聚合时间间隔\n        - year（1y）年\n        - quarter（1q）季度\n        - month（1M）月份\n        - week（1w）星期\n        - day（1d）天\n        - hour（1h）小时\n        - minute（1m）分钟\n        - second（1s）秒\n     3. format：指定返回时间格式\n\n     > dsl语句\n     >\n     > ```json\n     > {\n     >     \"query\": {\n     >         \"match_all\": {}\n     >     },\n     >     \"size\": 0,\n     > \"aggs\": {\n     >             // 自己取的聚合名字\n     >             \"group_by_grabTime\": {\n     >                 // es提供的时间处理函数\n     >                 \"date_histogram\": {\n     >                     // 需要聚合分组的字段名称, 类型需要为date, 格式没有要求\n     >                     \"field\": \"@timestamp\",\n     >                     // 按什么时间段聚合, 这里是5分钟, 可用的interval在上面给出\n     >                     \"interval\": \"5m\",\n     >                     // 设置时区, 这样就相当于东八区的时间\n     >                     \"time_zone\":\"+08:00\",\n     >                     // 返回值格式化，HH大写，不然不能区分上午、下午\n     >                     \"format\": \"yyyy-MM-dd HH\",   \n     >                     // 为空的话则填充0\n     >                     \"min_doc_count\": 0,\n     >                     // 需要填充0的范围\n     >                     \"extended_bounds\": {\n     >                         \"min\": 1533556800000,\n     >                         \"max\": 1533806520000\n     >                     }\n     >                 },\n     >                 // 聚合\n     >                 \"aggs\": {\n     >                     // 自己取的名称\n     >                     \"group_by_status\": {\n     >                         // es提供\n     >                         \"terms\": {\n     >                             // 聚合字段名\n     >                             \"field\": \"LowStatusOfPrice\"\n     >                         }\n     >                     }\n     >                 }\n     >             }\n     >         }\n     > ```","source":"_posts/ES基本操作.md","raw":"---\ntitle: ES基本操作\ndate: 2020-07-11 11:11:47\ntags: ES\ntop: 1\n---\n\n# Elasticsearch基本操作\n\n# 一、简介\n\n**Elasticsearch（ES）：**一款基于[Apache Lucene(TM)](https://lucene.apache.org/core/)的开源的全文检索和分析引擎。通过简单的`RESTful API`来隐藏其复杂性、同时也做了分布式相关的工作。\n\n**Lucene：**使用Java实现的一套搜索引擎库。\n\n<!--more-->\n\n- 分布式的实时文件存储，每个字段都被索引并可被搜索\n- 分布式的实时分析搜索引擎\n- 可以扩展到上百台服务器，处理PB级结构化或非结构化数据\n\n#### ES与关系型数据库对比\n\nElasticsearch集群可以包含多个索引（数据库），每一个索引可以包含多个类型（表），每一个类型包含多个文档（行），然后每个文档包含多个字段（列）\n\n| **关系型数据库** | **数据库**    | **表**     | **行** | **列** |\n| ---------------- | ------------- | ---------- | ------ | ------ |\n| ElasticSearch    | 索引（index） | 类型(type) | 文档   | 字段   |\n\n**相关概念：** \n\n1. 集群（cluster）：一个集群就是由一个或多个节点组织在一起，它们共同持有你整个的数据，并一起提供索引和搜索功能。\n2. 节点（node）：一个节点就是集群中的一个服务器，作为集群的一部分，参与集群的索引和搜索功能。\n3. 索引（index）： 一个索引就是一个具有相似特征的文档集合，相当于一个数据集。\n4. 类型（type）：在一个索引中，你可以定义一种或多种类型，相当于对一个索引中数据的逻辑划分（ES官方文档明确说明不推荐使用type，即建议一个索引只有一个type。ES7.0已经废弃了type）。\n5. 文档（document）： 一个文档是一个可被索引的基础信息单元，就是索引里面的一条数据，使用JSON格式来表示。\n6. 域（field）： 文档中的一个数据字段。一个文档由多个域组成。\n7. 分片（shards）：分片是索引的一部分，一个索引由多个分片组成。每个分片可以分布在不同的节点上，ES会根据文档id（也可以指定其他字段）做hash，使用得到的hash值将文档路由到指定分片上。分片是ES做Data Rebalance的最小单元。\n8. 副本（replicas）：创建索引时可以为索引指定0个或者多个副本。副本是分片级别的，即索引的分片由1个主分片（primary shard）和0个或者多个副本分片（replica shard）组成。primary shard可以接受读取和写入请求，replica shard只能接受读取请求。所以副本只能提高数据的可用性和并发读取能力。当primary shard所在服务器的节点挂掉以后，ES会通过leader选举机制将replica shard为primary shard。\n\n#### 文本分析\n\n**将文本转换成一系列单词（Term or Token）的过程，用于创建和查询倒排索引**\n\n- 分词器：是ES中专门处理分词的组件，由一下三部分组成\n  1. Character Filters：针对原始文本进行处理，比如去除html标签\n  2. Tokenizer：将原始文本按照一定规则切分为单词\n  3. Token Filters：针对Tokenizer处理的单词进行再加工，比如转小写、删除或增新等处理\n\n- 内置分词器：\n  1. Standard Analyzer：默认分词器，按词切分，小写处理，删除大多标点符号\n  2. Simple Analyzer：按照非字母切分、小写处理\n  3. Whitespace Analyzer：按照空白字符分割\n  4. Keyword Analyzer：不分词\n\n- 分词查看\n\n  ```json\n  POST /_analyze\n  {\n    \"analyzer\": \"keyword\",\n    \"text\": \"The 2 QUICK Brown-Foxes jumped over the lazy dog's bone.\"\n  }\n  ```\n\n详情点击跳转[官方文档](https://www.elastic.co/guide/en/elasticsearch/reference/7.5/analysis-analyzers.html)查看\n\n#### 倒排索引\n\n**ES把文档中的数据进行分析后，将词和文档之间建立映射关系。**\n\n组成：倒排索引由文档中不重复词的列表＋每个词被包含的文档ID列表\n\n查询过程：\n\n1. 搜索词“搜索引擎”，获得对应的文档ID列表，1，3\n2. 通过正排索引查询1和3的完整内容\n3. 返回最终结果\n\n<img src=\"https://tupian-1300728887.cos.ap-chengdu.myqcloud.com/image-20200904171011154.png\" alt=\"image-20200904171011154\" style=\"zoom:67%;\" />\n\n# 二、基本查询\n\n## 空查询\n\n```json\nGET /_search\n{}\n\nGET /_search\n{\n    \"query\": {\n        \"match_all\": {}\n    }\n}\n```\n\n### 字段详解\n\n![image-20200904172752621](https://tupian-1300728887.cos.ap-chengdu.myqcloud.com/image-20200904172752621.png)\n\n### 相关性\n\n**根据ES的相似度算法（TF/IDF）得出的结果，具体值由_score字段表示，根据以下维度计算得出**\n\n1. 检索词频率： 检索词在该字段出现的频率，频率越高，权重越大。字段中出现过 5 次要比只出现过 1 次的相关性高。\n\n2. 反向文档频率：检索词在使用中出现的频率，频率越高，权重越低。检索词出现在多数文档中会比出现在少数文档中的权重更低。\n\n3. 字段长度准则：字段长度越长，权重越低\n\n   ```json\n   // 请求后增加explain=true即可\n   GET /_search\n   {\n      \"explain\":true,\n      \"query\"   : { \"match\" : { \"name\" : \"John Smith\" }}\n   }\n   ```\n\n## 查询与过滤\n\n|            | **Query**                                                    | **Filter**                                                   |\n| ---------- | ------------------------------------------------------------ | ------------------------------------------------------------ |\n| 争对问题   | 该文档匹不匹配这个查询，它的相关度高么❓                      | 这篇文档是否与该查询匹配❓                                    |\n| 相关度处理 | 先查询符合搜索条件的文档数，然后计算每个文档对于搜索条件的相关度分数，再根据评分倒序排序 | 只根据搜索条件过滤出符合的文档,   不进行评分, 忽略TF/IDF信息 |\n| 性能       | 性能较差, 有排序 , 并且没有缓存功能（有倒排索引来弥补）      | 性能更好, 无排序；  会缓存比较常用的filter的数据             |\n| 栗子       | ❗ 查询与“first blog”字段最佳匹配的文档 ❗                     | ❗ 搜索博客等级(level)大于等于2, 同时发布日期(post_date)是2018-11-11的博客 ❗ |\n\n###  1. ❗ 查询与\"first blog\"字段最佳匹配的文档 ❗\n\n```json\n// query\nGET /_search\n{\n  \"query\": {\n    \"match\": {\n      \"desc\": \"four blog\"\n    }\n  }\n}\n\n// filter\nGET /_search\n{\n  \"query\": {\n    \"bool\": {\n      \"filter\": {\n        \"match\": {\n          \"desc\": \"four blog\"\n        }\n      }\n    }\n  }\n}\n```\n\n### 2. ❗ 搜索博客等级(level)大于等于2, 同时发布日期(post_date)是2018-11-11的博客 ❗\n\n```json\n// query\nGET /_search\n{\n    \"query\": {\n        \"bool\": {\n            \"must\": [\n                { \"match\": { \"post_date\": \"2018-11-11\" } }, \n                { \"range\": { \"level\": { \"gte\": 2 } } }\n            ]\n        }\n    }\n}\n// filter\nGET /_search\n{\n    \"query\": {\n        \"bool\": {\n            \"must\": { \n                \"match\": { \"post_date\": \"2018-11-11\" }\n            }, \n            \"filter\": {\n                \"range\": { \"level\": { \"gte\": 2 } }\n            }\n        }\n    }\n}\n```\n\n## 结构化搜索\n\n```json\nPOST /my_store/_bulk\n{ \"index\": { \"_id\": 1 }}\n{ \"price\" : 10, \"productID\" : \"XHDK-A-1293-#fJ3\" }\n{ \"index\": { \"_id\": 2 }}\n{ \"price\" : 20, \"productID\" : \"KDKE-B-9947-#kL5\" }\n{ \"index\": { \"_id\": 3 }}\n{ \"price\" : 30, \"productID\" : \"JODL-X-1937-#pV7\" }\n{ \"index\": { \"_id\": 4 }}\n{ \"price\" : 30, \"productID\" : \"QQPX-R-3956-#aD8\" }\n```\n\n**查看索引详情**\n\n```json\nGET /my_store\n```\n\n### 1. 精确值查找（term）\n\n> 1. 查询价格20的所有产品\n>\n>    SQL：==SELECT * FROM products WHERE price = 20==\n>\n>    ```json\n>    GET /_search\n>    {\n>     \"query\" : {\n>         \"constant_score\" : { \n>             \"filter\" : {\n>                 \"term\" : { \n>                     \"price\" : 20\n>                 }\n>             }\n>         }\n>     }\n>    }\n>    // constant_score关键字将trem查询转化为filter\n>    GET /_search\n>    {\n>      \"query\":{\n>        \"bool\": {\n>          \"filter\": {\n>            \"term\": {\n>              \"price\": 20\n>            }\n>          }\n>        }\n>      }\n>    }\n>    ```\n>\n> 2. 查询productID为XHDK-A-1293-#fJ3的文档\n>\n>    SQL：==SELECT * FROM products WHERE  productID = \"XHDK-A-1293-#fJ3\"==\n>\n>    ```json\n>    GET /_search\n>    {\n>        \"query\" : {\n>            \"constant_score\" : {\n>                \"filter\" : {\n>                    \"term\" : {\n>                        \"productID\" : \"XHDK-A-1293-#fJ3\"\n>                    }\n>                }\n>            }\n>        }\n>    }\n>    \n>    // 查看分词结果\n>    GET /my_store/_analyze\n>    {\n>      \"field\": \"productID\",\n>      \"text\": \"XHDK-A-1293-#fJ3\"\n>    }\n>    ```\n>\n>    总结：term会拿\"XHDK-A-1293-#fJ3\"，去倒排索引中找，但倒排索引表里只有\"xhdk\",\"a\",\"1293\",\"fj3\",因此查不到\n>\n>    **解决办法**\n>\n>    1. match_phrase关键字\n>\n>       ```json\n>       GET /_search\n>       {\n>           \"query\" : {\n>               \"match_phrase\" : {\n>                   \"productID\" : \"XHDK-A-1293-#fJ3\"\n>               }\n>           }\n>       }\n>       ```\n>\n>    2. 重新配置该字段的分词规则\n>\n>       ```json\n>       // 1.删除索引\n>       DELETE /my_store\n>       //2.指定productID字段使用keyword规则\n>       PUT /my_store\n>       {\n>       \t\"mappings\": {\n>       \t\t\t\"properties\": {\n>       \t\t\t\t\"price\": {\n>       \t\t\t\t\t\"type\": \"long\"\n>       \t\t\t\t},\n>       \t\t\t\t\"productID\": {\n>       \t\t\t\t\t\"type\": \"text\",\n>       \t\t\t\t\t\"analyzer\": \"keyword\"\n>       \t\t\t\t}\n>       \t\t\t}\n>       \t}\n>       }\n>       ```\n>\n\n### 2. 多个精确值查找（terms）\n\n> 1. 查找price为20 && 30 的文档\n>\n>    ```json\n>    GET /my_store/_search\n>    {\n>        \"query\" : {\n>            \"constant_score\" : {\n>                \"filter\" : {\n>                    \"terms\" : { \n>                        \"price\" : [20, 30]\n>                    }\n>                }\n>            }\n>        }\n>    }\n>    ```\n\n### 3. range(范围过滤)\n\n**gt:>   lt:<    gte:>=  lte:<=**\n\n> 1. 查找price大于20且小于40的产品\n>\n>    SQL：==SELECT * FROM products WHERE  price BETWEEN 20 AND 40==\n>\n>    ```json\n>    GET /my_store/_search\n>    {\n>        \"query\" : {\n>            \"constant_score\" : {\n>                \"filter\" : {\n>                    \"range\" : {\n>                        \"price\" : {\n>                            \"gte\" : 20,\n>                            \"lt\"  : 40\n>                        }\n>                    }\n>                }\n>            }\n>        }\n>    }\n>    ```\n>\n> 2. 日期范围查询  now  data||+1M\n>\n>    ```json\n>    GET /website/_search\n>    {\n>        \"query\" : {\n>            \"constant_score\" : {\n>                \"filter\" : {\n>                    \"range\" : {\n>                        \"post_date\": {\n>                            \"gte\" : \"2020-01-01\",\n>                            \"lt\": \"2020-09-09||+1h\"\n>                        }\n>                    }\n>                }\n>            }\n>        }\n>    }\n>    ```\n\n### 4. 组合查询（bool）\n\n> 1. SQL：==SELECT * FROM products WHERE (price = 20 OR productID = \"XHDK-A-1293-#fJ3\") AND (price != 30)==\n>\n>    ```json\n>    GET /my_store/_search\n>    {\n>       \"query\" : {\n>          \"constant_score\" : { \n>             \"filter\" : {\n>                \"bool\" : {\n>                  \"should\" : [\n>                     { \"term\" : {\"price\" : 20}}, \n>                     { \"term\" : {\"productID\" : \"XHDK-A-1293-#fJ3\"}} \n>                  ],\n>                  \"must_not\" : {\n>                     \"term\" : {\"price\" : 30} \n>                  }\n>               }\n>             }\n>          }\n>       }\n>    }\n>    ```\n>\n> 2. SQL：==SELECT * FROM products WHERE productID = \"KDKE-B-9947-#kL5\" OR (productID = \"JODL-X-1937-#pV7\" AND price = 30)==\n>\n>    ```json\n>    GET /my_store/_search\n>    {\n>       \"query\" : {\n>          \"constant_score\" : {\n>             \"filter\" : {\n>                \"bool\" : {\n>                  \"should\" : [\n>                    { \"term\" : {\"productID\" : \"KDKE-B-9947-#kL5\"}}, \n>                    { \"bool\" : { \n>                      \"must\" : [\n>                        { \"term\" : {\"productID\" : \"JODL-X-1937-#pV7\"}}, \n>                        { \"term\" : {\"price\" : 30}} \n>                      ]\n>                    }}\n>                  ]\n>               }\n>             }\n>          }\n>       }\n>    }\n>    ```\n\n### 5. 处理null值（exists）\n\n```json\nPOST /posts/_bulk\n{ \"index\": { \"_id\": \"1\"              }}\n{ \"tags\" : [\"search\"]                }  \n{ \"index\": { \"_id\": \"2\"              }}\n{ \"tags\" : [\"search\", \"open_source\"] }  \n{ \"index\": { \"_id\": \"3\"              }}\n{ \"other_field\" : \"some data\"        }  \n{ \"index\": { \"_id\": \"4\"              }}\n{ \"tags\" : null                      }  \n{ \"index\": { \"_id\": \"5\"              }}\n{ \"tags\" : [\"search\", null]          }\n```\n\n> 1. 存在查询\n>\n>    ==SQL:SELECT tags FROM posts WHERE tags IS NOT NULL==\n>\n>    ```json\n>    GET /posts/_search\n>    {\n>        \"query\" : {\n>            \"constant_score\" : {\n>                \"filter\" : {\n>                    \"exists\" : { \"field\" : \"tags\" }\n>                }\n>            }\n>        }\n>    }\n>    ```\n>\n> 2. 缺失查询\n>\n>    ==SQL:SELECT tags FROM posts WHERE tags IS NULL==\n>\n>    ```json\n>    GET /posts/_search\n>    {\n>        \"query\" : {\n>            \"constant_score\" : {\n>                \"filter\" : {\n>                  \"bool\": {\n>                    \"must_not\":{\"exists\" : { \"field\" : \"tags\" }}\n>                  }\n>                }\n>            }\n>        }\n>    }\n>    ```\n\n## 全文搜索\n\n```json\nPOST /my_index/my_type/_bulk\n{ \"index\": { \"_id\": 1 }}\n{ \"title\": \"The quick brown fox\" }\n{ \"index\": { \"_id\": 2 }}\n{ \"title\": \"The quick brown fox jumps over the lazy dog\" }\n{ \"index\": { \"_id\": 3 }}\n{ \"title\": \"The quick brown fox jumps over the quick dog\" }\n{ \"index\": { \"_id\": 4 }}\n{ \"title\": \"Brown fox brown dog\" }\n```\n\n### 1. match\n\n> 1. 单个词查询\n>\n>    ```json\n>    GET /my_index/_search\n>    {\n>        \"query\": {\n>            \"match\": {\n>                \"title\": \"QUICK!\"\n>            }\n>        }\n>    }\n>    ```\n>\n>    执行过程：\n>\n>    1. 检查字段类型\n>\n>    2. 分析查询字符串\n>\n>       ```json\n>       GET /_analyze\n>       {\n>         \"text\": \"QUICK!\"\n>       }\n>       ```\n>\n>    3. 调用term查询，去倒排索引中查询包含quick的文档\n>\n>       ```json\n>       GET /my_type/_search\n>       {\n>         \"query\": {\n>           \"term\": {\n>             \"title\": \"quick\"\n>           }\n>         }\n>       }\n>       ```\n>\n>    4. 为每个文档评分并排序\n>\n> 2. 多词查询\n>\n>    ```json\n>    GET /my_index/_search\n>    {\n>        \"query\": {\n>            \"match\": {\n>                \"title\": \"BROWN DOG!\"\n>            }\n>        }\n>    }\n>    \n>    GET /my_index/_search\n>    {\n>      \"query\": {\n>        \"bool\": {\n>          \"should\": [\n>            {\"term\": {\"title\": \"brown\"}},\n>            {\"term\":{\"title\":\"dog\"}}\n>          ]\n>        }\n>      }\n>    }\n>    ```\n>\n>    总结:被匹配的此项越多，文档越相关\n>\n> 3. operator：修改匹配关系\n>\n>    ```json\n>    GET /my_index/_search\n>    {\n>        \"query\": {\n>            \"match\": {\n>                \"title\": {      \n>                    \"query\":    \"BROWN DOG!\",\n>                    \"operator\": \"and\"\n>                }\n>            }\n>        }\n>    }\n>    \n>    GET /my_index/_search\n>    {\n>      \"query\": {\n>        \"bool\": {\n>          \"must\": [\n>            {\"term\": {\"title\": \"brown\"}},\n>            {\"term\":{\"title\":\"dog\"}}\n>          ]\n>        }\n>      }\n>    }\n>    ```\n>\n\n### 2. bool（组合查询）\n\n> 1. 查询包含quick，但不包含lazy的所有文档，如果包含should里的字段，则该文章相关度更高\n>\n>    ```json\n>    GET /my_index/_search\n>    {\n>      \"query\": {\n>        \"bool\": {\n>          \"must\":     { \"match\": { \"title\": \"quick\" }},\n>          \"must_not\": { \"match\": { \"title\": \"lazy\"  }},\n>          \"should\": [\n>                      { \"match\": { \"title\": \"brown\" }},\n>                      { \"match\": { \"title\": \"dog\"   }}\n>          ]\n>        }\n>      }\n>    }\n>    ```\n\n### 3. match_phrase（短语匹配）\n\n```json\nGET /my_index/_search\n{\n    \"query\": {\n        \"match_phrase\": {\n            \"title\": \"quick brown fox\"\n        }\n    }\n}\n```\n\n## 分页（深度分页）from+size\n\n缺点：\n\n- 效率低。比如from=5000，size=100，es需要在各个分片上匹配排序并得到5000+100条有效数据，然后在结果集中取最后100条结果。\n- 最大可查询条数为1W条。ES目前默认支持的skin值max_result_window=10000，当from+size>max_result_window时，ES就会返回错误。\n- ==解决办法：使用scroll（游标查询）==\n\n```json\n{\n  \"query\": {\n    \"match_all\": {}\n  },\n  \"from\": 0,  \n  \"size\": 1  \n}\n```\n\nfrom：从第几个商品开始查，最开始是 0\n\nsize：要查几个结果\n\n## 游标查询（scroll）\n\n- 启动游标查询\n\n  ```\n  CET /host/_search?scroll=1m\n  ```\n\n  scroll=1m表示游标查询窗口保持1分钟，如果一次取的数据量大可以设置大一些的时间；返回字段包含一个scroll_id，接下来用这个字段获取后续值\n\n- 循环获取\n\n  循环获取余下值\n\n  ```json\n  GET /_search/scroll\n  {\n  \t\"scroll\": \"1m\"，\n  \t\"scroll_id\": scroll_id\n  }\n  ```\n\n  > python操作\n  >\n  > ```python\n  > from elasticsearch import Elasticsearch\n  > \n  > es = Elasticsearch(['localhost:9200'])\n  > # 1.启动游标\n  > queryData = es.search(\"internal_isop_log\", body=dsl_body, scroll='1m', size=1000)\n  > # 获取scroll_id\n  > hits_list = queryData.get(\"hits\").get(\"hits\")\n  > scroll_id = queryData['_scroll_id']\n  > \n  > # 2.循环获取\n  > total = queryData.get(\"hits\").get(\"total\").get('value')\n  > for i in range(int(total / 1000)):\n  >     ss = {'scroll': '1m', 'scroll_id': scroll_id}\n  >     res = self.es.scroll(body=ss)\n  > ```\n\n## 模糊查询\n\n1. 创建索引，设置postcode字段使用keyword规则 ❗模糊查询会匹配倒排表里的字段 ❗\n\n   ```json\n   PUT /address\n   {\n   \t\"mappings\": {\n   \t\t\t\"properties\": {\n   \t\t\t\t\"postcode\": {\n   \t\t\t\t\t\"type\": \"text\",\n   \t\t\t\t\t\"analyzer\": \"keyword\"\n   \t\t\t\t}\n   \t\t\t}\n   \t}\n   }\n   ```\n\n2. 导入数据\n\n   ```json\n   PUT /address/_bulk\n   { \"index\": { \"_id\": 1 }}\n   { \"postcode\": \"W1V 3DG\" }\n   { \"index\": { \"_id\": 2 }}\n   { \"postcode\": \"W2F 8HW\" }\n   { \"index\": { \"_id\": 3 }}\n   { \"postcode\": \"W1F 7HW\" }\n   { \"index\": { \"_id\": 4 }}\n   { \"postcode\": \"WC1N 1LZ\" }\n   { \"index\": { \"_id\": 5 }}\n   { \"postcode\": \"SW5 0BE\" }\n   ```\n\n3. 倒排表\n\n   |    Term    | Doc IDs |\n   | :--------: | :-----: |\n   | \"SW5 0BE\"  |    5    |\n   | \"W1F 7HW\"  |    3    |\n   | \"W1V 3DG\"  |    1    |\n   | \"W2F 8HW\"  |    2    |\n   | \"WC1N 1LZ\" |    4    |\n\n1. 前缀匹配（prefix）\n\n   匹配postcode字段以“W1”开头的文档\n   \n   ```json\n   GET /address/_search\n   {\n       \"query\": {\n           \"prefix\": {\n               \"postcode\": \"W1\"\n           }\n       }\n   }\n   ```\n\n2. 通配符查询（wildcard）\n\n   ```json\n   GET /address/_search\n   {\n       \"query\": {\n           \"wildcard\": {\n               \"postcode\": \"W?F*HW\" \n           }\n       }\n   }\n   ```\n\n3. 正则匹配（regexp）\n\n   ```json\n   GET /address/_search\n   {\n       \"query\": {\n           \"regexp\": {\n               \"postcode\": \"W[0-9].+\" \n           }\n       }\n   }\n   ```\n\n**不配置分词规则带来的影响**\n\n>  栗子：title字段为“Quick brown fox” ，倒排索引中会生成： quick 、 brown 和 fox \n>\n>  | { \"regexp\": { \"title\": \"br.*\" }}      | 可以匹配                       |\n>  | ------------------------------------- | ------------------------------ |\n>  | { \"regexp\": { \"title\": \"Qu.*\" }}      | 匹配不到：quick为小写          |\n>  | { \"regexp\": { \"title\": \"quick br*\" }} | 匹配不到：quick和brown是分开的 |\n\n# 三、聚合分组\n\nElasticSearch除了致力于搜索之外，也提供了聚合实时分析数据的功能，透过聚合，我们可以得到一个数据的概览，分析和总结全套的数据\n\n对相同的数据进行 搜索/过滤 + 分析，两个愿望一次满足\n\n聚合的两个主要的概念，分别是 桶 和 指标\n\n- 桶(Buckets) : 满足特定条件的文档的集合\n\n  1. 当聚合开始被执行，每个文档会决定符合哪个桶的条件，如果匹配到，文档将放入相应的桶并接着进行聚合操作\n\n     > 像是一个员工属于男性桶或者女性桶\n\n  2. 桶可以被嵌套在其他桶里面\n\n     > 北京能放在中国桶裡\n\n- 指标(Metrics) : 对桶内的文档进行统计计算\n\n  1. 桶能让我们划分文档到有意义的集合， 但是最终我们需要的是对这些桶内的文档进行一些指标的计算\n\n  2. 指标通常是简单的数学运算(像是min、max、avg、sum）\n\n     > 计算像平均薪资、最高出售价格、95%的查询延迟这样的数据\n\n### 执行顺序\n\n当query和aggs一起存在时，会先执行query的主查询，主查询query执行完后会搜出一批结果，而这些结果才会被拿去aggs拿去做聚合\n\n```json\n{\n    \"query\": { ... },\n    \"size\": 0,\n    \"aggs\": {\n        \"custom_name1\": {  //aggs后面接著的是一个自定义的name\n            \"桶\": { ... }  //再来才是接桶\n        },\n        \"custom_name2\": {  //一个aggs裡可以有很多聚合\n            \"桶\": { ... }\n        },\n        \"custom_name3\": {\n            \"桶\": {\n               .....\n            },\n            \"aggs\": {  //aggs可以嵌套在别的aggs裡面\n                \"in_name\": { //记得使用aggs需要先自定义一个name\n                    \"桶\": { ... } //in_name的桶作用的文档是custom_name3的桶的结果\n                }\n            }\n        }\n    }\n}\n```\n\n### 常见的桶\n\n1. terms桶 : 针对某个field的值进行分组，field有几种值就分成几组\n\n   - terms桶在进行分组时，会爲此field中的每种值创建一个新的桶\n\n   - 要注意此 \"terms桶\" 和平常用在主查询query中的 \"查找terms\" 是不同的东西\n\n     > 测试数据\n     >\n     > ```json\n     > { \"color\": \"red\" }\n     > { \"color\": \"green\" }\n     > { \"color\": [\"red\", \"blue\"] }\n     > ```\n     >\n     > dsl语句\n     >\n     > ```json\n     > {\n     >     \"query\": {\n     >         \"match_all\": {}\n     >     },\n     >     \"size\": 0,\n     >     \"aggs\": {\n     >         \"my_name\": {\n     >             \"terms\": {\n     >                 \"field\": \"color\" //使用color来进行分组\n     >             }\n     >         }\n     >     }\n     > }\n     > ```\n     >\n     > 结果\n     >\n     > ```json\n     > \"aggregations\": {\n     >     \"my_name\": {\n     >         \"doc_count_error_upper_bound\": 0,\n     >         \"sum_other_doc_count\": 0,\n     >         \"buckets\": [\n     >             {\n     >                 \"key\": \"blue\",\n     >                 \"doc_count\": 1\n     >             },\n     >             {\n     >                 \"key\": \"red\",\n     >                 \"doc_count\": 2  //表示color为red的文档有2个，此例中就是 {\"color\": \"red\"} 和 {\"color\": [\"red\", \"blue\"]}这两个文档\n     >             },\n     >             {\n     >                 \"key\": \"green\",\n     >                 \"doc_count\": 1\n     >             }\n     >         ]\n     >     }\n     > }\n     > ```\n     >\n     > \n\n2. filter桶 : 一个用来过滤的桶\n\n   - 要注意此处的 \"filter桶\" 和用在主查询query的 \"过滤filter\" 的用法是一模一样的，都是过滤，不过差别是 \"filter桶\" 会自己给创建一个新的桶，而不会像 \"过滤filter\" 一样依附在query下，因为filter桶毕竟还是一个聚合桶，因此他可以和别的桶进行嵌套，但他不是依附在别的桶上\n\n     > 测试数据\n     >\n     > 同上\n     >\n     > dsl语句\n     >\n     > ```json\n     > {\n     >     \"query\": {\n     >         \"match_all\": {}\n     >     },\n     >     \"size\": 0,\n     >     \"aggs\": {\n     >         \"my_name\": {\n     >             \"filter\": { //因为他用法跟一般的过滤filter一样，所以也能使用bool嵌套\n     >                 \"bool\": {\n     >                     \"must\": {\n     >                         \"terms\": { //注意此terms是查找terms，不是terms桶\n     >                             \"color\": [ \"red\", \"blue\" ]\n     >                         }\n     >                     }\n     >                 }\n     >             }\n     >         }\n     >     }\n     > }\n     > ```\n     >\n     > 结果\n     >\n     > ```json\n     > \"aggregations\": {\n     >     \"my_name\": {\n     >         \"doc_count\": 2 //filter桶计算出来的文档数量\n     >     }\n     > }\n     > ```\n     >\n     > \n\n3. top_hits桶 : 在某个桶底下找出这个桶的前几笔hits，返回的hits格式和主查询query返回的hits格式一模一样\n\n   - 参数\n\n     1. from、size\n\n     2. sort：sort : 设置返回的hits的排序\n\n        - 要注意，假设在主查询query裡已经对数据设置了排序sort，此sort并不会对aggs裡面的数据造成影响，也就是说主查询query查找出来的数据会先丢进aggs而非先经过sort，因此就算主查询设置了sort，也不会影响aggs数据裡的排序因此如果在top_hits桶裡的返回的hits数据想要排序，需要自己在top_hits桶裡设置sort\n\n        - 如果没有设置sort，默认使用主查询query所查出来的_score排序\n\n     3. _source : 设置返回的字段\n\n     > 测试数据\n     >\n     > ```json\n     > { \"color\": \"red\", \"price\": 100 }\n     > { \"color\": [\"red\", \"blue\"], \"price\": 1000 }\n     > ```\n     >\n     > dsl语句\n     >\n     > 使用terms桶分组，再使用top_hits桶找出每个group裡面的price最小的前5笔hits\n     >\n     > ```\n     > {\n     >     \"query\": {\n     >         \"match_all\": {}\n     >     },\n     >     \"size\": 0,\n     >     \"aggs\": {\n     >         \"my_name\": {\n     >             \"terms\": {\n     >                 \"field\": \"color\"\n     >             },\n     >             \"aggs\": {\n     >                 \"my_top_hits\": {\n     >                     \"top_hits\": {\n     >                         \"size\": 5,\n     >                         \"sort\": {\n     >                             \"price\": \"asc\"\n     >                         }\n     >                     }\n     >                 }\n     >             }\n     >         }\n     >     }\n     > }\n     > ```\n     >\n     > 结果\n     >\n     > ```json\n     > \"aggregations\": {\n     >     \"my_name\": {\n     >         \"doc_count_error_upper_bound\": 0,\n     >         \"sum_other_doc_count\": 0,\n     >         \"buckets\": [\n     >             {\n     >                 \"key\": \"red\",\n     >                 \"doc_count\": 2,  //terms桶计算出来的color为red的文档数\n     >                 \"my_top_hits\": {\n     >                     \"hits\": {  //top_hits桶找出color为red的这些文档中，price从小到大排序取前5笔\n     >                         \"total\": 2,\n     >                         \"max_score\": null,\n     >                         \"hits\": [\n     >                             {\n     >                                 \"_score\": null,\n     >                                 \"_source\": { \"color\": \"red\", \"price\": 100 },\n     >                                 \"sort\": [ 100 ]\n     >                             },\n     >                             {\n     >                                 \"_score\": null,\n     >                                 \"_source\": { \"color\": [ \"red\", \"blue\" ], \"price\": 1000 },\n     >                                 \"sort\": [ 1000 ]\n     >                             }\n     >                         ]\n     >                     }\n     >                 }\n     >             },\n     >             {\n     >                 \"key\": \"blue\",\n     >                 \"doc_count\": 1,  //terms桶计算出来的color为blue的文档数\n     >                 \"my_top_hits\": {\n     >                     \"hits\": { //top_hits桶找出的hits\n     >                         \"total\": 1,\n     >                         \"max_score\": null,\n     >                         \"hits\": [\n     >                             {\n     >                                 \"_source\": {\n     >                                     \"color\": [ \"red\", \"blue\" ], \"price\": 1000 },\n     >                                 \"sort\": [ 1000 ]\n     >                             }\n     >                         ]\n     >                     }\n     >                 }\n     >             }\n     >         ]\n     >     }\n     > }\n     > ```\n     >\n     > \n\n4. date_histogram桶，对指定时间段内数据进行分组\n\n   - 参数\n\n     1. time_zone:\"+08:00\"：设置市区（东八区），不指定会影响分组时间错误\n     2. interval：聚合时间间隔\n        - year（1y）年\n        - quarter（1q）季度\n        - month（1M）月份\n        - week（1w）星期\n        - day（1d）天\n        - hour（1h）小时\n        - minute（1m）分钟\n        - second（1s）秒\n     3. format：指定返回时间格式\n\n     > dsl语句\n     >\n     > ```json\n     > {\n     >     \"query\": {\n     >         \"match_all\": {}\n     >     },\n     >     \"size\": 0,\n     > \"aggs\": {\n     >             // 自己取的聚合名字\n     >             \"group_by_grabTime\": {\n     >                 // es提供的时间处理函数\n     >                 \"date_histogram\": {\n     >                     // 需要聚合分组的字段名称, 类型需要为date, 格式没有要求\n     >                     \"field\": \"@timestamp\",\n     >                     // 按什么时间段聚合, 这里是5分钟, 可用的interval在上面给出\n     >                     \"interval\": \"5m\",\n     >                     // 设置时区, 这样就相当于东八区的时间\n     >                     \"time_zone\":\"+08:00\",\n     >                     // 返回值格式化，HH大写，不然不能区分上午、下午\n     >                     \"format\": \"yyyy-MM-dd HH\",   \n     >                     // 为空的话则填充0\n     >                     \"min_doc_count\": 0,\n     >                     // 需要填充0的范围\n     >                     \"extended_bounds\": {\n     >                         \"min\": 1533556800000,\n     >                         \"max\": 1533806520000\n     >                     }\n     >                 },\n     >                 // 聚合\n     >                 \"aggs\": {\n     >                     // 自己取的名称\n     >                     \"group_by_status\": {\n     >                         // es提供\n     >                         \"terms\": {\n     >                             // 聚合字段名\n     >                             \"field\": \"LowStatusOfPrice\"\n     >                         }\n     >                     }\n     >                 }\n     >             }\n     >         }\n     > ```","slug":"ES基本操作","published":1,"updated":"2020-09-04T09:40:45.625Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckfp5akey0006n8jh6g0ja3ju","content":"<h1 id=\"Elasticsearch基本操作\"><a href=\"#Elasticsearch基本操作\" class=\"headerlink\" title=\"Elasticsearch基本操作\"></a>Elasticsearch基本操作</h1><h1 id=\"一、简介\"><a href=\"#一、简介\" class=\"headerlink\" title=\"一、简介\"></a>一、简介</h1><p><strong>Elasticsearch（ES）：</strong>一款基于<a href=\"https://lucene.apache.org/core/\" target=\"_blank\" rel=\"noopener\">Apache Lucene(TM)</a>的开源的全文检索和分析引擎。通过简单的<code>RESTful API</code>来隐藏其复杂性、同时也做了分布式相关的工作。</p>\n<p><strong>Lucene：</strong>使用Java实现的一套搜索引擎库。</p>\n<a id=\"more\"></a>\n\n<ul>\n<li>分布式的实时文件存储，每个字段都被索引并可被搜索</li>\n<li>分布式的实时分析搜索引擎</li>\n<li>可以扩展到上百台服务器，处理PB级结构化或非结构化数据</li>\n</ul>\n<h4 id=\"ES与关系型数据库对比\"><a href=\"#ES与关系型数据库对比\" class=\"headerlink\" title=\"ES与关系型数据库对比\"></a>ES与关系型数据库对比</h4><p>Elasticsearch集群可以包含多个索引（数据库），每一个索引可以包含多个类型（表），每一个类型包含多个文档（行），然后每个文档包含多个字段（列）</p>\n<table>\n<thead>\n<tr>\n<th><strong>关系型数据库</strong></th>\n<th><strong>数据库</strong></th>\n<th><strong>表</strong></th>\n<th><strong>行</strong></th>\n<th><strong>列</strong></th>\n</tr>\n</thead>\n<tbody><tr>\n<td>ElasticSearch</td>\n<td>索引（index）</td>\n<td>类型(type)</td>\n<td>文档</td>\n<td>字段</td>\n</tr>\n</tbody></table>\n<p><strong>相关概念：</strong> </p>\n<ol>\n<li>集群（cluster）：一个集群就是由一个或多个节点组织在一起，它们共同持有你整个的数据，并一起提供索引和搜索功能。</li>\n<li>节点（node）：一个节点就是集群中的一个服务器，作为集群的一部分，参与集群的索引和搜索功能。</li>\n<li>索引（index）： 一个索引就是一个具有相似特征的文档集合，相当于一个数据集。</li>\n<li>类型（type）：在一个索引中，你可以定义一种或多种类型，相当于对一个索引中数据的逻辑划分（ES官方文档明确说明不推荐使用type，即建议一个索引只有一个type。ES7.0已经废弃了type）。</li>\n<li>文档（document）： 一个文档是一个可被索引的基础信息单元，就是索引里面的一条数据，使用JSON格式来表示。</li>\n<li>域（field）： 文档中的一个数据字段。一个文档由多个域组成。</li>\n<li>分片（shards）：分片是索引的一部分，一个索引由多个分片组成。每个分片可以分布在不同的节点上，ES会根据文档id（也可以指定其他字段）做hash，使用得到的hash值将文档路由到指定分片上。分片是ES做Data Rebalance的最小单元。</li>\n<li>副本（replicas）：创建索引时可以为索引指定0个或者多个副本。副本是分片级别的，即索引的分片由1个主分片（primary shard）和0个或者多个副本分片（replica shard）组成。primary shard可以接受读取和写入请求，replica shard只能接受读取请求。所以副本只能提高数据的可用性和并发读取能力。当primary shard所在服务器的节点挂掉以后，ES会通过leader选举机制将replica shard为primary shard。</li>\n</ol>\n<h4 id=\"文本分析\"><a href=\"#文本分析\" class=\"headerlink\" title=\"文本分析\"></a>文本分析</h4><p><strong>将文本转换成一系列单词（Term or Token）的过程，用于创建和查询倒排索引</strong></p>\n<ul>\n<li><p>分词器：是ES中专门处理分词的组件，由一下三部分组成</p>\n<ol>\n<li>Character Filters：针对原始文本进行处理，比如去除html标签</li>\n<li>Tokenizer：将原始文本按照一定规则切分为单词</li>\n<li>Token Filters：针对Tokenizer处理的单词进行再加工，比如转小写、删除或增新等处理</li>\n</ol>\n</li>\n<li><p>内置分词器：</p>\n<ol>\n<li>Standard Analyzer：默认分词器，按词切分，小写处理，删除大多标点符号</li>\n<li>Simple Analyzer：按照非字母切分、小写处理</li>\n<li>Whitespace Analyzer：按照空白字符分割</li>\n<li>Keyword Analyzer：不分词</li>\n</ol>\n</li>\n<li><p>分词查看</p>\n<figure class=\"highlight json\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">POST /_analyze</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">  <span class=\"attr\">\"analyzer\"</span>: <span class=\"string\">\"keyword\"</span>,</span><br><span class=\"line\">  <span class=\"attr\">\"text\"</span>: <span class=\"string\">\"The 2 QUICK Brown-Foxes jumped over the lazy dog's bone.\"</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n</li>\n</ul>\n<p>详情点击跳转<a href=\"https://www.elastic.co/guide/en/elasticsearch/reference/7.5/analysis-analyzers.html\" target=\"_blank\" rel=\"noopener\">官方文档</a>查看</p>\n<h4 id=\"倒排索引\"><a href=\"#倒排索引\" class=\"headerlink\" title=\"倒排索引\"></a>倒排索引</h4><p><strong>ES把文档中的数据进行分析后，将词和文档之间建立映射关系。</strong></p>\n<p>组成：倒排索引由文档中不重复词的列表＋每个词被包含的文档ID列表</p>\n<p>查询过程：</p>\n<ol>\n<li>搜索词“搜索引擎”，获得对应的文档ID列表，1，3</li>\n<li>通过正排索引查询1和3的完整内容</li>\n<li>返回最终结果</li>\n</ol>\n<img src=\"https://tupian-1300728887.cos.ap-chengdu.myqcloud.com/image-20200904171011154.png\" alt=\"image-20200904171011154\" style=\"zoom:67%;\" />\n\n<h1 id=\"二、基本查询\"><a href=\"#二、基本查询\" class=\"headerlink\" title=\"二、基本查询\"></a>二、基本查询</h1><h2 id=\"空查询\"><a href=\"#空查询\" class=\"headerlink\" title=\"空查询\"></a>空查询</h2><figure class=\"highlight json\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">GET /_search</span><br><span class=\"line\">&#123;&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">GET /_search</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"attr\">\"query\"</span>: &#123;</span><br><span class=\"line\">        <span class=\"attr\">\"match_all\"</span>: &#123;&#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"字段详解\"><a href=\"#字段详解\" class=\"headerlink\" title=\"字段详解\"></a>字段详解</h3><p><img src=\"https://tupian-1300728887.cos.ap-chengdu.myqcloud.com/image-20200904172752621.png\" alt=\"image-20200904172752621\"></p>\n<h3 id=\"相关性\"><a href=\"#相关性\" class=\"headerlink\" title=\"相关性\"></a>相关性</h3><p><strong>根据ES的相似度算法（TF/IDF）得出的结果，具体值由_score字段表示，根据以下维度计算得出</strong></p>\n<ol>\n<li><p>检索词频率： 检索词在该字段出现的频率，频率越高，权重越大。字段中出现过 5 次要比只出现过 1 次的相关性高。</p>\n</li>\n<li><p>反向文档频率：检索词在使用中出现的频率，频率越高，权重越低。检索词出现在多数文档中会比出现在少数文档中的权重更低。</p>\n</li>\n<li><p>字段长度准则：字段长度越长，权重越低</p>\n<figure class=\"highlight json\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 请求后增加explain=true即可</span></span><br><span class=\"line\">GET /_search</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">   <span class=\"attr\">\"explain\"</span>:<span class=\"literal\">true</span>,</span><br><span class=\"line\">   <span class=\"attr\">\"query\"</span>   : &#123; <span class=\"attr\">\"match\"</span> : &#123; <span class=\"attr\">\"name\"</span> : <span class=\"string\">\"John Smith\"</span> &#125;&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n</li>\n</ol>\n<h2 id=\"查询与过滤\"><a href=\"#查询与过滤\" class=\"headerlink\" title=\"查询与过滤\"></a>查询与过滤</h2><table>\n<thead>\n<tr>\n<th></th>\n<th><strong>Query</strong></th>\n<th><strong>Filter</strong></th>\n</tr>\n</thead>\n<tbody><tr>\n<td>争对问题</td>\n<td>该文档匹不匹配这个查询，它的相关度高么❓</td>\n<td>这篇文档是否与该查询匹配❓</td>\n</tr>\n<tr>\n<td>相关度处理</td>\n<td>先查询符合搜索条件的文档数，然后计算每个文档对于搜索条件的相关度分数，再根据评分倒序排序</td>\n<td>只根据搜索条件过滤出符合的文档,   不进行评分, 忽略TF/IDF信息</td>\n</tr>\n<tr>\n<td>性能</td>\n<td>性能较差, 有排序 , 并且没有缓存功能（有倒排索引来弥补）</td>\n<td>性能更好, 无排序；  会缓存比较常用的filter的数据</td>\n</tr>\n<tr>\n<td>栗子</td>\n<td>❗ 查询与“first blog”字段最佳匹配的文档 ❗</td>\n<td>❗ 搜索博客等级(level)大于等于2, 同时发布日期(post_date)是2018-11-11的博客 ❗</td>\n</tr>\n</tbody></table>\n<h3 id=\"1-❗-查询与”first-blog”字段最佳匹配的文档-❗\"><a href=\"#1-❗-查询与”first-blog”字段最佳匹配的文档-❗\" class=\"headerlink\" title=\"1. ❗ 查询与”first blog”字段最佳匹配的文档 ❗\"></a>1. ❗ 查询与”first blog”字段最佳匹配的文档 ❗</h3><figure class=\"highlight json\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// query</span></span><br><span class=\"line\">GET /_search</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">  <span class=\"attr\">\"query\"</span>: &#123;</span><br><span class=\"line\">    <span class=\"attr\">\"match\"</span>: &#123;</span><br><span class=\"line\">      <span class=\"attr\">\"desc\"</span>: <span class=\"string\">\"four blog\"</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// filter</span></span><br><span class=\"line\">GET /_search</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">  <span class=\"attr\">\"query\"</span>: &#123;</span><br><span class=\"line\">    <span class=\"attr\">\"bool\"</span>: &#123;</span><br><span class=\"line\">      <span class=\"attr\">\"filter\"</span>: &#123;</span><br><span class=\"line\">        <span class=\"attr\">\"match\"</span>: &#123;</span><br><span class=\"line\">          <span class=\"attr\">\"desc\"</span>: <span class=\"string\">\"four blog\"</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"2-❗-搜索博客等级-level-大于等于2-同时发布日期-post-date-是2018-11-11的博客-❗\"><a href=\"#2-❗-搜索博客等级-level-大于等于2-同时发布日期-post-date-是2018-11-11的博客-❗\" class=\"headerlink\" title=\"2. ❗ 搜索博客等级(level)大于等于2, 同时发布日期(post_date)是2018-11-11的博客 ❗\"></a>2. ❗ 搜索博客等级(level)大于等于2, 同时发布日期(post_date)是2018-11-11的博客 ❗</h3><figure class=\"highlight json\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// query</span></span><br><span class=\"line\">GET /_search</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"attr\">\"query\"</span>: &#123;</span><br><span class=\"line\">        <span class=\"attr\">\"bool\"</span>: &#123;</span><br><span class=\"line\">            <span class=\"attr\">\"must\"</span>: [</span><br><span class=\"line\">                &#123; <span class=\"attr\">\"match\"</span>: &#123; <span class=\"attr\">\"post_date\"</span>: <span class=\"string\">\"2018-11-11\"</span> &#125; &#125;, </span><br><span class=\"line\">                &#123; <span class=\"attr\">\"range\"</span>: &#123; <span class=\"attr\">\"level\"</span>: &#123; <span class=\"attr\">\"gte\"</span>: <span class=\"number\">2</span> &#125; &#125; &#125;</span><br><span class=\"line\">            ]</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// filter</span></span><br><span class=\"line\">GET /_search</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"attr\">\"query\"</span>: &#123;</span><br><span class=\"line\">        <span class=\"attr\">\"bool\"</span>: &#123;</span><br><span class=\"line\">            <span class=\"attr\">\"must\"</span>: &#123; </span><br><span class=\"line\">                <span class=\"attr\">\"match\"</span>: &#123; <span class=\"attr\">\"post_date\"</span>: <span class=\"string\">\"2018-11-11\"</span> &#125;</span><br><span class=\"line\">            &#125;, </span><br><span class=\"line\">            <span class=\"attr\">\"filter\"</span>: &#123;</span><br><span class=\"line\">                <span class=\"attr\">\"range\"</span>: &#123; <span class=\"attr\">\"level\"</span>: &#123; <span class=\"attr\">\"gte\"</span>: <span class=\"number\">2</span> &#125; &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"结构化搜索\"><a href=\"#结构化搜索\" class=\"headerlink\" title=\"结构化搜索\"></a>结构化搜索</h2><figure class=\"highlight json\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">POST /my_store/_bulk</span><br><span class=\"line\">&#123; <span class=\"attr\">\"index\"</span>: &#123; <span class=\"attr\">\"_id\"</span>: <span class=\"number\">1</span> &#125;&#125;</span><br><span class=\"line\">&#123; <span class=\"attr\">\"price\"</span> : <span class=\"number\">10</span>, <span class=\"attr\">\"productID\"</span> : <span class=\"string\">\"XHDK-A-1293-#fJ3\"</span> &#125;</span><br><span class=\"line\">&#123; <span class=\"attr\">\"index\"</span>: &#123; <span class=\"attr\">\"_id\"</span>: <span class=\"number\">2</span> &#125;&#125;</span><br><span class=\"line\">&#123; <span class=\"attr\">\"price\"</span> : <span class=\"number\">20</span>, <span class=\"attr\">\"productID\"</span> : <span class=\"string\">\"KDKE-B-9947-#kL5\"</span> &#125;</span><br><span class=\"line\">&#123; <span class=\"attr\">\"index\"</span>: &#123; <span class=\"attr\">\"_id\"</span>: <span class=\"number\">3</span> &#125;&#125;</span><br><span class=\"line\">&#123; <span class=\"attr\">\"price\"</span> : <span class=\"number\">30</span>, <span class=\"attr\">\"productID\"</span> : <span class=\"string\">\"JODL-X-1937-#pV7\"</span> &#125;</span><br><span class=\"line\">&#123; <span class=\"attr\">\"index\"</span>: &#123; <span class=\"attr\">\"_id\"</span>: <span class=\"number\">4</span> &#125;&#125;</span><br><span class=\"line\">&#123; <span class=\"attr\">\"price\"</span> : <span class=\"number\">30</span>, <span class=\"attr\">\"productID\"</span> : <span class=\"string\">\"QQPX-R-3956-#aD8\"</span> &#125;</span><br></pre></td></tr></table></figure>\n\n<p><strong>查看索引详情</strong></p>\n<figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">GET /my_store</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"1-精确值查找（term）\"><a href=\"#1-精确值查找（term）\" class=\"headerlink\" title=\"1. 精确值查找（term）\"></a>1. 精确值查找（term）</h3><blockquote>\n<ol>\n<li><p>查询价格20的所有产品</p>\n<p>SQL：==SELECT * FROM products WHERE price = 20==</p>\n<figure class=\"highlight json\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">GET /_search</span><br><span class=\"line\">&#123;</span><br><span class=\"line\"> <span class=\"attr\">\"query\"</span> : &#123;</span><br><span class=\"line\">     <span class=\"attr\">\"constant_score\"</span> : &#123; </span><br><span class=\"line\">         <span class=\"attr\">\"filter\"</span> : &#123;</span><br><span class=\"line\">             <span class=\"attr\">\"term\"</span> : &#123; </span><br><span class=\"line\">                 <span class=\"attr\">\"price\"</span> : <span class=\"number\">20</span></span><br><span class=\"line\">             &#125;</span><br><span class=\"line\">         &#125;</span><br><span class=\"line\">     &#125;</span><br><span class=\"line\"> &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// constant_score关键字将trem查询转化为filter</span></span><br><span class=\"line\">GET /_search</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">  <span class=\"attr\">\"query\"</span>:&#123;</span><br><span class=\"line\">    <span class=\"attr\">\"bool\"</span>: &#123;</span><br><span class=\"line\">      <span class=\"attr\">\"filter\"</span>: &#123;</span><br><span class=\"line\">        <span class=\"attr\">\"term\"</span>: &#123;</span><br><span class=\"line\">          <span class=\"attr\">\"price\"</span>: <span class=\"number\">20</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>查询productID为XHDK-A-1293-#fJ3的文档</p>\n<p>SQL：==SELECT * FROM products WHERE  productID = “XHDK-A-1293-#fJ3”==</p>\n<figure class=\"highlight json\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">GET /_search</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"attr\">\"query\"</span> : &#123;</span><br><span class=\"line\">        <span class=\"attr\">\"constant_score\"</span> : &#123;</span><br><span class=\"line\">            <span class=\"attr\">\"filter\"</span> : &#123;</span><br><span class=\"line\">                <span class=\"attr\">\"term\"</span> : &#123;</span><br><span class=\"line\">                    <span class=\"attr\">\"productID\"</span> : <span class=\"string\">\"XHDK-A-1293-#fJ3\"</span></span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 查看分词结果</span></span><br><span class=\"line\">GET /my_store/_analyze</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">  <span class=\"attr\">\"field\"</span>: <span class=\"string\">\"productID\"</span>,</span><br><span class=\"line\">  <span class=\"attr\">\"text\"</span>: <span class=\"string\">\"XHDK-A-1293-#fJ3\"</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>总结：term会拿”XHDK-A-1293-#fJ3”，去倒排索引中找，但倒排索引表里只有”xhdk”,”a”,”1293”,”fj3”,因此查不到</p>\n<p><strong>解决办法</strong></p>\n<ol>\n<li><p>match_phrase关键字</p>\n<figure class=\"highlight json\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">GET /_search</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"attr\">\"query\"</span> : &#123;</span><br><span class=\"line\">        <span class=\"attr\">\"match_phrase\"</span> : &#123;</span><br><span class=\"line\">            <span class=\"attr\">\"productID\"</span> : <span class=\"string\">\"XHDK-A-1293-#fJ3\"</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>重新配置该字段的分词规则</p>\n<figure class=\"highlight json\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 1.删除索引</span></span><br><span class=\"line\">DELETE /my_store</span><br><span class=\"line\"><span class=\"comment\">//2.指定productID字段使用keyword规则</span></span><br><span class=\"line\">PUT /my_store</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\t<span class=\"attr\">\"mappings\"</span>: &#123;</span><br><span class=\"line\">\t\t\t<span class=\"attr\">\"properties\"</span>: &#123;</span><br><span class=\"line\">\t\t\t\t<span class=\"attr\">\"price\"</span>: &#123;</span><br><span class=\"line\">\t\t\t\t\t<span class=\"attr\">\"type\"</span>: <span class=\"string\">\"long\"</span></span><br><span class=\"line\">\t\t\t\t&#125;,</span><br><span class=\"line\">\t\t\t\t<span class=\"attr\">\"productID\"</span>: &#123;</span><br><span class=\"line\">\t\t\t\t\t<span class=\"attr\">\"type\"</span>: <span class=\"string\">\"text\"</span>,</span><br><span class=\"line\">\t\t\t\t\t<span class=\"attr\">\"analyzer\"</span>: <span class=\"string\">\"keyword\"</span></span><br><span class=\"line\">\t\t\t\t&#125;</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n</li>\n</ol>\n</li>\n</ol>\n</blockquote>\n<h3 id=\"2-多个精确值查找（terms）\"><a href=\"#2-多个精确值查找（terms）\" class=\"headerlink\" title=\"2. 多个精确值查找（terms）\"></a>2. 多个精确值查找（terms）</h3><blockquote>\n<ol>\n<li><p>查找price为20 &amp;&amp; 30 的文档</p>\n<figure class=\"highlight json\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">GET /my_store/_search</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"attr\">\"query\"</span> : &#123;</span><br><span class=\"line\">        <span class=\"attr\">\"constant_score\"</span> : &#123;</span><br><span class=\"line\">            <span class=\"attr\">\"filter\"</span> : &#123;</span><br><span class=\"line\">                <span class=\"attr\">\"terms\"</span> : &#123; </span><br><span class=\"line\">                    <span class=\"attr\">\"price\"</span> : [<span class=\"number\">20</span>, <span class=\"number\">30</span>]</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n</ol>\n</blockquote>\n<h3 id=\"3-range-范围过滤\"><a href=\"#3-range-范围过滤\" class=\"headerlink\" title=\"3. range(范围过滤)\"></a>3. range(范围过滤)</h3><p><strong>gt:&gt;   lt:&lt;    gte:&gt;=  lte:&lt;=</strong></p>\n<blockquote>\n<ol>\n<li><p>查找price大于20且小于40的产品</p>\n<p>SQL：==SELECT * FROM products WHERE  price BETWEEN 20 AND 40==</p>\n<figure class=\"highlight json\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">GET /my_store/_search</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"attr\">\"query\"</span> : &#123;</span><br><span class=\"line\">        <span class=\"attr\">\"constant_score\"</span> : &#123;</span><br><span class=\"line\">            <span class=\"attr\">\"filter\"</span> : &#123;</span><br><span class=\"line\">                <span class=\"attr\">\"range\"</span> : &#123;</span><br><span class=\"line\">                    <span class=\"attr\">\"price\"</span> : &#123;</span><br><span class=\"line\">                        <span class=\"attr\">\"gte\"</span> : <span class=\"number\">20</span>,</span><br><span class=\"line\">                        <span class=\"attr\">\"lt\"</span>  : <span class=\"number\">40</span></span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>日期范围查询  now  data||+1M</p>\n<figure class=\"highlight json\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">GET /website/_search</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"attr\">\"query\"</span> : &#123;</span><br><span class=\"line\">        <span class=\"attr\">\"constant_score\"</span> : &#123;</span><br><span class=\"line\">            <span class=\"attr\">\"filter\"</span> : &#123;</span><br><span class=\"line\">                <span class=\"attr\">\"range\"</span> : &#123;</span><br><span class=\"line\">                    <span class=\"attr\">\"post_date\"</span>: &#123;</span><br><span class=\"line\">                        <span class=\"attr\">\"gte\"</span> : <span class=\"string\">\"2020-01-01\"</span>,</span><br><span class=\"line\">                        <span class=\"attr\">\"lt\"</span>: <span class=\"string\">\"2020-09-09||+1h\"</span></span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n</ol>\n</blockquote>\n<h3 id=\"4-组合查询（bool）\"><a href=\"#4-组合查询（bool）\" class=\"headerlink\" title=\"4. 组合查询（bool）\"></a>4. 组合查询（bool）</h3><blockquote>\n<ol>\n<li><p>SQL：==SELECT * FROM products WHERE (price = 20 OR productID = “XHDK-A-1293-#fJ3”) AND (price != 30)==</p>\n<figure class=\"highlight json\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">GET /my_store/_search</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">   <span class=\"attr\">\"query\"</span> : &#123;</span><br><span class=\"line\">      <span class=\"attr\">\"constant_score\"</span> : &#123; </span><br><span class=\"line\">         <span class=\"attr\">\"filter\"</span> : &#123;</span><br><span class=\"line\">            <span class=\"attr\">\"bool\"</span> : &#123;</span><br><span class=\"line\">              <span class=\"attr\">\"should\"</span> : [</span><br><span class=\"line\">                 &#123; <span class=\"attr\">\"term\"</span> : &#123;<span class=\"attr\">\"price\"</span> : <span class=\"number\">20</span>&#125;&#125;, </span><br><span class=\"line\">                 &#123; <span class=\"attr\">\"term\"</span> : &#123;<span class=\"attr\">\"productID\"</span> : <span class=\"string\">\"XHDK-A-1293-#fJ3\"</span>&#125;&#125; </span><br><span class=\"line\">              ],</span><br><span class=\"line\">              <span class=\"attr\">\"must_not\"</span> : &#123;</span><br><span class=\"line\">                 <span class=\"attr\">\"term\"</span> : &#123;<span class=\"attr\">\"price\"</span> : <span class=\"number\">30</span>&#125; </span><br><span class=\"line\">              &#125;</span><br><span class=\"line\">           &#125;</span><br><span class=\"line\">         &#125;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>SQL：==SELECT * FROM products WHERE productID = “KDKE-B-9947-#kL5” OR (productID = “JODL-X-1937-#pV7” AND price = 30)==</p>\n<figure class=\"highlight json\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">GET /my_store/_search</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">   <span class=\"attr\">\"query\"</span> : &#123;</span><br><span class=\"line\">      <span class=\"attr\">\"constant_score\"</span> : &#123;</span><br><span class=\"line\">         <span class=\"attr\">\"filter\"</span> : &#123;</span><br><span class=\"line\">            <span class=\"attr\">\"bool\"</span> : &#123;</span><br><span class=\"line\">              <span class=\"attr\">\"should\"</span> : [</span><br><span class=\"line\">                &#123; <span class=\"attr\">\"term\"</span> : &#123;<span class=\"attr\">\"productID\"</span> : <span class=\"string\">\"KDKE-B-9947-#kL5\"</span>&#125;&#125;, </span><br><span class=\"line\">                &#123; <span class=\"attr\">\"bool\"</span> : &#123; </span><br><span class=\"line\">                  <span class=\"attr\">\"must\"</span> : [</span><br><span class=\"line\">                    &#123; <span class=\"attr\">\"term\"</span> : &#123;<span class=\"attr\">\"productID\"</span> : <span class=\"string\">\"JODL-X-1937-#pV7\"</span>&#125;&#125;, </span><br><span class=\"line\">                    &#123; <span class=\"attr\">\"term\"</span> : &#123;<span class=\"attr\">\"price\"</span> : <span class=\"number\">30</span>&#125;&#125; </span><br><span class=\"line\">                  ]</span><br><span class=\"line\">                &#125;&#125;</span><br><span class=\"line\">              ]</span><br><span class=\"line\">           &#125;</span><br><span class=\"line\">         &#125;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n</ol>\n</blockquote>\n<h3 id=\"5-处理null值（exists）\"><a href=\"#5-处理null值（exists）\" class=\"headerlink\" title=\"5. 处理null值（exists）\"></a>5. 处理null值（exists）</h3><figure class=\"highlight json\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">POST /posts/_bulk</span><br><span class=\"line\">&#123; <span class=\"attr\">\"index\"</span>: &#123; <span class=\"attr\">\"_id\"</span>: <span class=\"string\">\"1\"</span>              &#125;&#125;</span><br><span class=\"line\">&#123; <span class=\"attr\">\"tags\"</span> : [<span class=\"string\">\"search\"</span>]                &#125;  </span><br><span class=\"line\">&#123; <span class=\"attr\">\"index\"</span>: &#123; <span class=\"attr\">\"_id\"</span>: <span class=\"string\">\"2\"</span>              &#125;&#125;</span><br><span class=\"line\">&#123; <span class=\"attr\">\"tags\"</span> : [<span class=\"string\">\"search\"</span>, <span class=\"string\">\"open_source\"</span>] &#125;  </span><br><span class=\"line\">&#123; <span class=\"attr\">\"index\"</span>: &#123; <span class=\"attr\">\"_id\"</span>: <span class=\"string\">\"3\"</span>              &#125;&#125;</span><br><span class=\"line\">&#123; <span class=\"attr\">\"other_field\"</span> : <span class=\"string\">\"some data\"</span>        &#125;  </span><br><span class=\"line\">&#123; <span class=\"attr\">\"index\"</span>: &#123; <span class=\"attr\">\"_id\"</span>: <span class=\"string\">\"4\"</span>              &#125;&#125;</span><br><span class=\"line\">&#123; <span class=\"attr\">\"tags\"</span> : <span class=\"literal\">null</span>                      &#125;  </span><br><span class=\"line\">&#123; <span class=\"attr\">\"index\"</span>: &#123; <span class=\"attr\">\"_id\"</span>: <span class=\"string\">\"5\"</span>              &#125;&#125;</span><br><span class=\"line\">&#123; <span class=\"attr\">\"tags\"</span> : [<span class=\"string\">\"search\"</span>, <span class=\"literal\">null</span>]          &#125;</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<ol>\n<li><p>存在查询</p>\n<p>==SQL:SELECT tags FROM posts WHERE tags IS NOT NULL==</p>\n<figure class=\"highlight json\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">GET /posts/_search</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"attr\">\"query\"</span> : &#123;</span><br><span class=\"line\">        <span class=\"attr\">\"constant_score\"</span> : &#123;</span><br><span class=\"line\">            <span class=\"attr\">\"filter\"</span> : &#123;</span><br><span class=\"line\">                <span class=\"attr\">\"exists\"</span> : &#123; <span class=\"attr\">\"field\"</span> : <span class=\"string\">\"tags\"</span> &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>缺失查询</p>\n<p>==SQL:SELECT tags FROM posts WHERE tags IS NULL==</p>\n<figure class=\"highlight json\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">GET /posts/_search</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"attr\">\"query\"</span> : &#123;</span><br><span class=\"line\">        <span class=\"attr\">\"constant_score\"</span> : &#123;</span><br><span class=\"line\">            <span class=\"attr\">\"filter\"</span> : &#123;</span><br><span class=\"line\">              <span class=\"attr\">\"bool\"</span>: &#123;</span><br><span class=\"line\">                <span class=\"attr\">\"must_not\"</span>:&#123;<span class=\"attr\">\"exists\"</span> : &#123; <span class=\"attr\">\"field\"</span> : <span class=\"string\">\"tags\"</span> &#125;&#125;</span><br><span class=\"line\">              &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n</ol>\n</blockquote>\n<h2 id=\"全文搜索\"><a href=\"#全文搜索\" class=\"headerlink\" title=\"全文搜索\"></a>全文搜索</h2><figure class=\"highlight json\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">POST /my_index/my_type/_bulk</span><br><span class=\"line\">&#123; <span class=\"attr\">\"index\"</span>: &#123; <span class=\"attr\">\"_id\"</span>: <span class=\"number\">1</span> &#125;&#125;</span><br><span class=\"line\">&#123; <span class=\"attr\">\"title\"</span>: <span class=\"string\">\"The quick brown fox\"</span> &#125;</span><br><span class=\"line\">&#123; <span class=\"attr\">\"index\"</span>: &#123; <span class=\"attr\">\"_id\"</span>: <span class=\"number\">2</span> &#125;&#125;</span><br><span class=\"line\">&#123; <span class=\"attr\">\"title\"</span>: <span class=\"string\">\"The quick brown fox jumps over the lazy dog\"</span> &#125;</span><br><span class=\"line\">&#123; <span class=\"attr\">\"index\"</span>: &#123; <span class=\"attr\">\"_id\"</span>: <span class=\"number\">3</span> &#125;&#125;</span><br><span class=\"line\">&#123; <span class=\"attr\">\"title\"</span>: <span class=\"string\">\"The quick brown fox jumps over the quick dog\"</span> &#125;</span><br><span class=\"line\">&#123; <span class=\"attr\">\"index\"</span>: &#123; <span class=\"attr\">\"_id\"</span>: <span class=\"number\">4</span> &#125;&#125;</span><br><span class=\"line\">&#123; <span class=\"attr\">\"title\"</span>: <span class=\"string\">\"Brown fox brown dog\"</span> &#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"1-match\"><a href=\"#1-match\" class=\"headerlink\" title=\"1. match\"></a>1. match</h3><blockquote>\n<ol>\n<li><p>单个词查询</p>\n<figure class=\"highlight json\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">GET /my_index/_search</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"attr\">\"query\"</span>: &#123;</span><br><span class=\"line\">        <span class=\"attr\">\"match\"</span>: &#123;</span><br><span class=\"line\">            <span class=\"attr\">\"title\"</span>: <span class=\"string\">\"QUICK!\"</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>执行过程：</p>\n<ol>\n<li><p>检查字段类型</p>\n</li>\n<li><p>分析查询字符串</p>\n<figure class=\"highlight json\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">GET /_analyze</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">  <span class=\"attr\">\"text\"</span>: <span class=\"string\">\"QUICK!\"</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>调用term查询，去倒排索引中查询包含quick的文档</p>\n<figure class=\"highlight json\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">GET /my_type/_search</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">  <span class=\"attr\">\"query\"</span>: &#123;</span><br><span class=\"line\">    <span class=\"attr\">\"term\"</span>: &#123;</span><br><span class=\"line\">      <span class=\"attr\">\"title\"</span>: <span class=\"string\">\"quick\"</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>为每个文档评分并排序</p>\n</li>\n</ol>\n</li>\n<li><p>多词查询</p>\n<figure class=\"highlight json\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">GET /my_index/_search</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"attr\">\"query\"</span>: &#123;</span><br><span class=\"line\">        <span class=\"attr\">\"match\"</span>: &#123;</span><br><span class=\"line\">            <span class=\"attr\">\"title\"</span>: <span class=\"string\">\"BROWN DOG!\"</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">GET /my_index/_search</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">  <span class=\"attr\">\"query\"</span>: &#123;</span><br><span class=\"line\">    <span class=\"attr\">\"bool\"</span>: &#123;</span><br><span class=\"line\">      <span class=\"attr\">\"should\"</span>: [</span><br><span class=\"line\">        &#123;<span class=\"attr\">\"term\"</span>: &#123;<span class=\"attr\">\"title\"</span>: <span class=\"string\">\"brown\"</span>&#125;&#125;,</span><br><span class=\"line\">        &#123;<span class=\"attr\">\"term\"</span>:&#123;<span class=\"attr\">\"title\"</span>:<span class=\"string\">\"dog\"</span>&#125;&#125;</span><br><span class=\"line\">      ]</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>总结:被匹配的此项越多，文档越相关</p>\n</li>\n<li><p>operator：修改匹配关系</p>\n<figure class=\"highlight json\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">GET /my_index/_search</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"attr\">\"query\"</span>: &#123;</span><br><span class=\"line\">        <span class=\"attr\">\"match\"</span>: &#123;</span><br><span class=\"line\">            <span class=\"attr\">\"title\"</span>: &#123;      </span><br><span class=\"line\">                <span class=\"attr\">\"query\"</span>:    <span class=\"string\">\"BROWN DOG!\"</span>,</span><br><span class=\"line\">                <span class=\"attr\">\"operator\"</span>: <span class=\"string\">\"and\"</span></span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">GET /my_index/_search</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">  <span class=\"attr\">\"query\"</span>: &#123;</span><br><span class=\"line\">    <span class=\"attr\">\"bool\"</span>: &#123;</span><br><span class=\"line\">      <span class=\"attr\">\"must\"</span>: [</span><br><span class=\"line\">        &#123;<span class=\"attr\">\"term\"</span>: &#123;<span class=\"attr\">\"title\"</span>: <span class=\"string\">\"brown\"</span>&#125;&#125;,</span><br><span class=\"line\">        &#123;<span class=\"attr\">\"term\"</span>:&#123;<span class=\"attr\">\"title\"</span>:<span class=\"string\">\"dog\"</span>&#125;&#125;</span><br><span class=\"line\">      ]</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n</li>\n</ol>\n</blockquote>\n<h3 id=\"2-bool（组合查询）\"><a href=\"#2-bool（组合查询）\" class=\"headerlink\" title=\"2. bool（组合查询）\"></a>2. bool（组合查询）</h3><blockquote>\n<ol>\n<li><p>查询包含quick，但不包含lazy的所有文档，如果包含should里的字段，则该文章相关度更高</p>\n<figure class=\"highlight json\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">GET /my_index/_search</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">  <span class=\"attr\">\"query\"</span>: &#123;</span><br><span class=\"line\">    <span class=\"attr\">\"bool\"</span>: &#123;</span><br><span class=\"line\">      <span class=\"attr\">\"must\"</span>:     &#123; <span class=\"attr\">\"match\"</span>: &#123; <span class=\"attr\">\"title\"</span>: <span class=\"string\">\"quick\"</span> &#125;&#125;,</span><br><span class=\"line\">      <span class=\"attr\">\"must_not\"</span>: &#123; <span class=\"attr\">\"match\"</span>: &#123; <span class=\"attr\">\"title\"</span>: <span class=\"string\">\"lazy\"</span>  &#125;&#125;,</span><br><span class=\"line\">      <span class=\"attr\">\"should\"</span>: [</span><br><span class=\"line\">                  &#123; <span class=\"attr\">\"match\"</span>: &#123; <span class=\"attr\">\"title\"</span>: <span class=\"string\">\"brown\"</span> &#125;&#125;,</span><br><span class=\"line\">                  &#123; <span class=\"attr\">\"match\"</span>: &#123; <span class=\"attr\">\"title\"</span>: <span class=\"string\">\"dog\"</span>   &#125;&#125;</span><br><span class=\"line\">      ]</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n</ol>\n</blockquote>\n<h3 id=\"3-match-phrase（短语匹配）\"><a href=\"#3-match-phrase（短语匹配）\" class=\"headerlink\" title=\"3. match_phrase（短语匹配）\"></a>3. match_phrase（短语匹配）</h3><figure class=\"highlight json\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">GET /my_index/_search</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"attr\">\"query\"</span>: &#123;</span><br><span class=\"line\">        <span class=\"attr\">\"match_phrase\"</span>: &#123;</span><br><span class=\"line\">            <span class=\"attr\">\"title\"</span>: <span class=\"string\">\"quick brown fox\"</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"分页（深度分页）from-size\"><a href=\"#分页（深度分页）from-size\" class=\"headerlink\" title=\"分页（深度分页）from+size\"></a>分页（深度分页）from+size</h2><p>缺点：</p>\n<ul>\n<li>效率低。比如from=5000，size=100，es需要在各个分片上匹配排序并得到5000+100条有效数据，然后在结果集中取最后100条结果。</li>\n<li>最大可查询条数为1W条。ES目前默认支持的skin值max_result_window=10000，当from+size&gt;max_result_window时，ES就会返回错误。</li>\n<li>==解决办法：使用scroll（游标查询）==</li>\n</ul>\n<figure class=\"highlight json\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">  <span class=\"attr\">\"query\"</span>: &#123;</span><br><span class=\"line\">    <span class=\"attr\">\"match_all\"</span>: &#123;&#125;</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  <span class=\"attr\">\"from\"</span>: <span class=\"number\">0</span>,  </span><br><span class=\"line\">  <span class=\"attr\">\"size\"</span>: <span class=\"number\">1</span>  </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>from：从第几个商品开始查，最开始是 0</p>\n<p>size：要查几个结果</p>\n<h2 id=\"游标查询（scroll）\"><a href=\"#游标查询（scroll）\" class=\"headerlink\" title=\"游标查询（scroll）\"></a>游标查询（scroll）</h2><ul>\n<li><p>启动游标查询</p>\n<figure class=\"highlight routeros\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">CET /host/_search?<span class=\"attribute\">scroll</span>=1m</span><br></pre></td></tr></table></figure>\n\n<p>scroll=1m表示游标查询窗口保持1分钟，如果一次取的数据量大可以设置大一些的时间；返回字段包含一个scroll_id，接下来用这个字段获取后续值</p>\n</li>\n<li><p>循环获取</p>\n<p>循环获取余下值</p>\n<figure class=\"highlight json\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">GET /_search/scroll</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\t<span class=\"attr\">\"scroll\"</span>: <span class=\"string\">\"1m\"</span>，</span><br><span class=\"line\">\t<span class=\"string\">\"scroll_id\"</span>: scroll_id</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>python操作</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">from</span> elasticsearch <span class=\"keyword\">import</span> Elasticsearch</span><br><span class=\"line\"></span><br><span class=\"line\">es = Elasticsearch([<span class=\"string\">'localhost:9200'</span>])</span><br><span class=\"line\"><span class=\"comment\"># 1.启动游标</span></span><br><span class=\"line\">queryData = es.search(<span class=\"string\">\"internal_isop_log\"</span>, body=dsl_body, scroll=<span class=\"string\">'1m'</span>, size=<span class=\"number\">1000</span>)</span><br><span class=\"line\"><span class=\"comment\"># 获取scroll_id</span></span><br><span class=\"line\">hits_list = queryData.get(<span class=\"string\">\"hits\"</span>).get(<span class=\"string\">\"hits\"</span>)</span><br><span class=\"line\">scroll_id = queryData[<span class=\"string\">'_scroll_id'</span>]</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 2.循环获取</span></span><br><span class=\"line\">total = queryData.get(<span class=\"string\">\"hits\"</span>).get(<span class=\"string\">\"total\"</span>).get(<span class=\"string\">'value'</span>)</span><br><span class=\"line\"><span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> range(int(total / <span class=\"number\">1000</span>)):</span><br><span class=\"line\">    ss = &#123;<span class=\"string\">'scroll'</span>: <span class=\"string\">'1m'</span>, <span class=\"string\">'scroll_id'</span>: scroll_id&#125;</span><br><span class=\"line\">    res = self.es.scroll(body=ss)</span><br></pre></td></tr></table></figure>\n</blockquote>\n</li>\n</ul>\n<h2 id=\"模糊查询\"><a href=\"#模糊查询\" class=\"headerlink\" title=\"模糊查询\"></a>模糊查询</h2><ol>\n<li><p>创建索引，设置postcode字段使用keyword规则 ❗模糊查询会匹配倒排表里的字段 ❗</p>\n<figure class=\"highlight json\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">PUT /address</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\t<span class=\"attr\">\"mappings\"</span>: &#123;</span><br><span class=\"line\">\t\t\t<span class=\"attr\">\"properties\"</span>: &#123;</span><br><span class=\"line\">\t\t\t\t<span class=\"attr\">\"postcode\"</span>: &#123;</span><br><span class=\"line\">\t\t\t\t\t<span class=\"attr\">\"type\"</span>: <span class=\"string\">\"text\"</span>,</span><br><span class=\"line\">\t\t\t\t\t<span class=\"attr\">\"analyzer\"</span>: <span class=\"string\">\"keyword\"</span></span><br><span class=\"line\">\t\t\t\t&#125;</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>导入数据</p>\n<figure class=\"highlight json\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">PUT /address/_bulk</span><br><span class=\"line\">&#123; <span class=\"attr\">\"index\"</span>: &#123; <span class=\"attr\">\"_id\"</span>: <span class=\"number\">1</span> &#125;&#125;</span><br><span class=\"line\">&#123; <span class=\"attr\">\"postcode\"</span>: <span class=\"string\">\"W1V 3DG\"</span> &#125;</span><br><span class=\"line\">&#123; <span class=\"attr\">\"index\"</span>: &#123; <span class=\"attr\">\"_id\"</span>: <span class=\"number\">2</span> &#125;&#125;</span><br><span class=\"line\">&#123; <span class=\"attr\">\"postcode\"</span>: <span class=\"string\">\"W2F 8HW\"</span> &#125;</span><br><span class=\"line\">&#123; <span class=\"attr\">\"index\"</span>: &#123; <span class=\"attr\">\"_id\"</span>: <span class=\"number\">3</span> &#125;&#125;</span><br><span class=\"line\">&#123; <span class=\"attr\">\"postcode\"</span>: <span class=\"string\">\"W1F 7HW\"</span> &#125;</span><br><span class=\"line\">&#123; <span class=\"attr\">\"index\"</span>: &#123; <span class=\"attr\">\"_id\"</span>: <span class=\"number\">4</span> &#125;&#125;</span><br><span class=\"line\">&#123; <span class=\"attr\">\"postcode\"</span>: <span class=\"string\">\"WC1N 1LZ\"</span> &#125;</span><br><span class=\"line\">&#123; <span class=\"attr\">\"index\"</span>: &#123; <span class=\"attr\">\"_id\"</span>: <span class=\"number\">5</span> &#125;&#125;</span><br><span class=\"line\">&#123; <span class=\"attr\">\"postcode\"</span>: <span class=\"string\">\"SW5 0BE\"</span> &#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>倒排表</p>\n<table>\n<thead>\n<tr>\n<th align=\"center\">Term</th>\n<th align=\"center\">Doc IDs</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\">“SW5 0BE”</td>\n<td align=\"center\">5</td>\n</tr>\n<tr>\n<td align=\"center\">“W1F 7HW”</td>\n<td align=\"center\">3</td>\n</tr>\n<tr>\n<td align=\"center\">“W1V 3DG”</td>\n<td align=\"center\">1</td>\n</tr>\n<tr>\n<td align=\"center\">“W2F 8HW”</td>\n<td align=\"center\">2</td>\n</tr>\n<tr>\n<td align=\"center\">“WC1N 1LZ”</td>\n<td align=\"center\">4</td>\n</tr>\n</tbody></table>\n</li>\n<li><p>前缀匹配（prefix）</p>\n<p>匹配postcode字段以“W1”开头的文档</p>\n<figure class=\"highlight json\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">GET /address/_search</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"attr\">\"query\"</span>: &#123;</span><br><span class=\"line\">        <span class=\"attr\">\"prefix\"</span>: &#123;</span><br><span class=\"line\">            <span class=\"attr\">\"postcode\"</span>: <span class=\"string\">\"W1\"</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>通配符查询（wildcard）</p>\n<figure class=\"highlight json\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">GET /address/_search</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"attr\">\"query\"</span>: &#123;</span><br><span class=\"line\">        <span class=\"attr\">\"wildcard\"</span>: &#123;</span><br><span class=\"line\">            <span class=\"attr\">\"postcode\"</span>: <span class=\"string\">\"W?F*HW\"</span> </span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>正则匹配（regexp）</p>\n<figure class=\"highlight json\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">GET /address/_search</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"attr\">\"query\"</span>: &#123;</span><br><span class=\"line\">        <span class=\"attr\">\"regexp\"</span>: &#123;</span><br><span class=\"line\">            <span class=\"attr\">\"postcode\"</span>: <span class=\"string\">\"W[0-9].+\"</span> </span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n</li>\n</ol>\n<p><strong>不配置分词规则带来的影响</strong></p>\n<blockquote>\n<p> 栗子：title字段为“Quick brown fox” ，倒排索引中会生成： quick 、 brown 和 fox </p>\n<table>\n<thead>\n<tr>\n<th>{ “regexp”: { “title”: “br.*” }}</th>\n<th>可以匹配</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>{ “regexp”: { “title”: “Qu.*” }}</td>\n<td>匹配不到：quick为小写</td>\n</tr>\n<tr>\n<td>{ “regexp”: { “title”: “quick br*” }}</td>\n<td>匹配不到：quick和brown是分开的</td>\n</tr>\n</tbody></table>\n</blockquote>\n<h1 id=\"三、聚合分组\"><a href=\"#三、聚合分组\" class=\"headerlink\" title=\"三、聚合分组\"></a>三、聚合分组</h1><p>ElasticSearch除了致力于搜索之外，也提供了聚合实时分析数据的功能，透过聚合，我们可以得到一个数据的概览，分析和总结全套的数据</p>\n<p>对相同的数据进行 搜索/过滤 + 分析，两个愿望一次满足</p>\n<p>聚合的两个主要的概念，分别是 桶 和 指标</p>\n<ul>\n<li><p>桶(Buckets) : 满足特定条件的文档的集合</p>\n<ol>\n<li><p>当聚合开始被执行，每个文档会决定符合哪个桶的条件，如果匹配到，文档将放入相应的桶并接着进行聚合操作</p>\n<blockquote>\n<p>像是一个员工属于男性桶或者女性桶</p>\n</blockquote>\n</li>\n<li><p>桶可以被嵌套在其他桶里面</p>\n<blockquote>\n<p>北京能放在中国桶裡</p>\n</blockquote>\n</li>\n</ol>\n</li>\n<li><p>指标(Metrics) : 对桶内的文档进行统计计算</p>\n<ol>\n<li><p>桶能让我们划分文档到有意义的集合， 但是最终我们需要的是对这些桶内的文档进行一些指标的计算</p>\n</li>\n<li><p>指标通常是简单的数学运算(像是min、max、avg、sum）</p>\n<blockquote>\n<p>计算像平均薪资、最高出售价格、95%的查询延迟这样的数据</p>\n</blockquote>\n</li>\n</ol>\n</li>\n</ul>\n<h3 id=\"执行顺序\"><a href=\"#执行顺序\" class=\"headerlink\" title=\"执行顺序\"></a>执行顺序</h3><p>当query和aggs一起存在时，会先执行query的主查询，主查询query执行完后会搜出一批结果，而这些结果才会被拿去aggs拿去做聚合</p>\n<figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">    \"query\": &#123; ... &#125;,</span><br><span class=\"line\">    \"size\": 0,</span><br><span class=\"line\">    \"aggs\": &#123;</span><br><span class=\"line\">        \"custom_name1\": &#123;  //aggs后面接著的是一个自定义的name</span><br><span class=\"line\">            \"桶\": &#123; ... &#125;  //再来才是接桶</span><br><span class=\"line\">        &#125;,</span><br><span class=\"line\">        \"custom_name2\": &#123;  //一个aggs裡可以有很多聚合</span><br><span class=\"line\">            \"桶\": &#123; ... &#125;</span><br><span class=\"line\">        &#125;,</span><br><span class=\"line\">        \"custom_name3\": &#123;</span><br><span class=\"line\">            \"桶\": &#123;</span><br><span class=\"line\">               .....</span><br><span class=\"line\">            &#125;,</span><br><span class=\"line\">            \"aggs\": &#123;  //aggs可以嵌套在别的aggs裡面</span><br><span class=\"line\">                \"in_name\": &#123; //记得使用aggs需要先自定义一个name</span><br><span class=\"line\">                    \"桶\": &#123; ... &#125; //in_name的桶作用的文档是custom_name3的桶的结果</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"常见的桶\"><a href=\"#常见的桶\" class=\"headerlink\" title=\"常见的桶\"></a>常见的桶</h3><ol>\n<li><p>terms桶 : 针对某个field的值进行分组，field有几种值就分成几组</p>\n<ul>\n<li><p>terms桶在进行分组时，会爲此field中的每种值创建一个新的桶</p>\n</li>\n<li><p>要注意此 “terms桶” 和平常用在主查询query中的 “查找terms” 是不同的东西</p>\n<blockquote>\n<p>测试数据</p>\n<figure class=\"highlight json\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123; <span class=\"attr\">\"color\"</span>: <span class=\"string\">\"red\"</span> &#125;</span><br><span class=\"line\">&#123; <span class=\"attr\">\"color\"</span>: <span class=\"string\">\"green\"</span> &#125;</span><br><span class=\"line\">&#123; <span class=\"attr\">\"color\"</span>: [<span class=\"string\">\"red\"</span>, <span class=\"string\">\"blue\"</span>] &#125;</span><br></pre></td></tr></table></figure>\n\n<p>dsl语句</p>\n<figure class=\"highlight json\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"attr\">\"query\"</span>: &#123;</span><br><span class=\"line\">        <span class=\"attr\">\"match_all\"</span>: &#123;&#125;</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    <span class=\"attr\">\"size\"</span>: <span class=\"number\">0</span>,</span><br><span class=\"line\">    <span class=\"attr\">\"aggs\"</span>: &#123;</span><br><span class=\"line\">        <span class=\"attr\">\"my_name\"</span>: &#123;</span><br><span class=\"line\">            <span class=\"attr\">\"terms\"</span>: &#123;</span><br><span class=\"line\">                <span class=\"attr\">\"field\"</span>: <span class=\"string\">\"color\"</span> <span class=\"comment\">//使用color来进行分组</span></span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>结果</p>\n<figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">\"aggregations\": &#123;</span><br><span class=\"line\">    \"my_name\": &#123;</span><br><span class=\"line\">        \"doc_count_error_upper_bound\": 0,</span><br><span class=\"line\">        \"sum_other_doc_count\": 0,</span><br><span class=\"line\">        \"buckets\": [</span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                <span class=\"attr\">\"key\"</span>: <span class=\"string\">\"blue\"</span>,</span><br><span class=\"line\">                <span class=\"attr\">\"doc_count\"</span>: <span class=\"number\">1</span></span><br><span class=\"line\">            &#125;,</span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                <span class=\"attr\">\"key\"</span>: <span class=\"string\">\"red\"</span>,</span><br><span class=\"line\">                <span class=\"attr\">\"doc_count\"</span>: <span class=\"number\">2</span>  <span class=\"comment\">//表示color为red的文档有2个，此例中就是 &#123;\"color\": \"red\"&#125; 和 &#123;\"color\": [\"red\", \"blue\"]&#125;这两个文档</span></span><br><span class=\"line\">            &#125;,</span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                <span class=\"attr\">\"key\"</span>: <span class=\"string\">\"green\"</span>,</span><br><span class=\"line\">                <span class=\"attr\">\"doc_count\"</span>: <span class=\"number\">1</span></span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        ]</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n</blockquote>\n</li>\n</ul>\n</li>\n<li><p>filter桶 : 一个用来过滤的桶</p>\n<ul>\n<li><p>要注意此处的 “filter桶” 和用在主查询query的 “过滤filter” 的用法是一模一样的，都是过滤，不过差别是 “filter桶” 会自己给创建一个新的桶，而不会像 “过滤filter” 一样依附在query下，因为filter桶毕竟还是一个聚合桶，因此他可以和别的桶进行嵌套，但他不是依附在别的桶上</p>\n<blockquote>\n<p>测试数据</p>\n<p>同上</p>\n<p>dsl语句</p>\n<figure class=\"highlight json\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"attr\">\"query\"</span>: &#123;</span><br><span class=\"line\">        <span class=\"attr\">\"match_all\"</span>: &#123;&#125;</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    <span class=\"attr\">\"size\"</span>: <span class=\"number\">0</span>,</span><br><span class=\"line\">    <span class=\"attr\">\"aggs\"</span>: &#123;</span><br><span class=\"line\">        <span class=\"attr\">\"my_name\"</span>: &#123;</span><br><span class=\"line\">            <span class=\"attr\">\"filter\"</span>: &#123; <span class=\"comment\">//因为他用法跟一般的过滤filter一样，所以也能使用bool嵌套</span></span><br><span class=\"line\">                <span class=\"attr\">\"bool\"</span>: &#123;</span><br><span class=\"line\">                    <span class=\"attr\">\"must\"</span>: &#123;</span><br><span class=\"line\">                        <span class=\"attr\">\"terms\"</span>: &#123; <span class=\"comment\">//注意此terms是查找terms，不是terms桶</span></span><br><span class=\"line\">                            <span class=\"attr\">\"color\"</span>: [ <span class=\"string\">\"red\"</span>, <span class=\"string\">\"blue\"</span> ]</span><br><span class=\"line\">                        &#125;</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>结果</p>\n<figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">\"aggregations\": &#123;</span><br><span class=\"line\">    \"my_name\": &#123;</span><br><span class=\"line\">        \"doc_count\": 2 //filter桶计算出来的文档数量</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n</blockquote>\n</li>\n</ul>\n</li>\n<li><p>top_hits桶 : 在某个桶底下找出这个桶的前几笔hits，返回的hits格式和主查询query返回的hits格式一模一样</p>\n<ul>\n<li><p>参数</p>\n<ol>\n<li><p>from、size</p>\n</li>\n<li><p>sort：sort : 设置返回的hits的排序</p>\n<ul>\n<li><p>要注意，假设在主查询query裡已经对数据设置了排序sort，此sort并不会对aggs裡面的数据造成影响，也就是说主查询query查找出来的数据会先丢进aggs而非先经过sort，因此就算主查询设置了sort，也不会影响aggs数据裡的排序因此如果在top_hits桶裡的返回的hits数据想要排序，需要自己在top_hits桶裡设置sort</p>\n</li>\n<li><p>如果没有设置sort，默认使用主查询query所查出来的_score排序</p>\n</li>\n</ul>\n</li>\n<li><p>_source : 设置返回的字段</p>\n</li>\n</ol>\n<blockquote>\n<p>测试数据</p>\n<figure class=\"highlight json\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123; <span class=\"attr\">\"color\"</span>: <span class=\"string\">\"red\"</span>, <span class=\"attr\">\"price\"</span>: <span class=\"number\">100</span> &#125;</span><br><span class=\"line\">&#123; <span class=\"attr\">\"color\"</span>: [<span class=\"string\">\"red\"</span>, <span class=\"string\">\"blue\"</span>], <span class=\"attr\">\"price\"</span>: <span class=\"number\">1000</span> &#125;</span><br></pre></td></tr></table></figure>\n\n<p>dsl语句</p>\n<p>使用terms桶分组，再使用top_hits桶找出每个group裡面的price最小的前5笔hits</p>\n<figure class=\"highlight json\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"attr\">\"query\"</span>: &#123;</span><br><span class=\"line\">        <span class=\"attr\">\"match_all\"</span>: &#123;&#125;</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    <span class=\"attr\">\"size\"</span>: <span class=\"number\">0</span>,</span><br><span class=\"line\">    <span class=\"attr\">\"aggs\"</span>: &#123;</span><br><span class=\"line\">        <span class=\"attr\">\"my_name\"</span>: &#123;</span><br><span class=\"line\">            <span class=\"attr\">\"terms\"</span>: &#123;</span><br><span class=\"line\">                <span class=\"attr\">\"field\"</span>: <span class=\"string\">\"color\"</span></span><br><span class=\"line\">            &#125;,</span><br><span class=\"line\">            <span class=\"attr\">\"aggs\"</span>: &#123;</span><br><span class=\"line\">                <span class=\"attr\">\"my_top_hits\"</span>: &#123;</span><br><span class=\"line\">                    <span class=\"attr\">\"top_hits\"</span>: &#123;</span><br><span class=\"line\">                        <span class=\"attr\">\"size\"</span>: <span class=\"number\">5</span>,</span><br><span class=\"line\">                        <span class=\"attr\">\"sort\"</span>: &#123;</span><br><span class=\"line\">                            <span class=\"attr\">\"price\"</span>: <span class=\"string\">\"asc\"</span></span><br><span class=\"line\">                        &#125;</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>结果</p>\n<figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">\"aggregations\": &#123;</span><br><span class=\"line\">    \"my_name\": &#123;</span><br><span class=\"line\">        \"doc_count_error_upper_bound\": 0,</span><br><span class=\"line\">        \"sum_other_doc_count\": 0,</span><br><span class=\"line\">        \"buckets\": [</span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                <span class=\"attr\">\"key\"</span>: <span class=\"string\">\"red\"</span>,</span><br><span class=\"line\">                <span class=\"attr\">\"doc_count\"</span>: <span class=\"number\">2</span>,  <span class=\"comment\">//terms桶计算出来的color为red的文档数</span></span><br><span class=\"line\">                <span class=\"attr\">\"my_top_hits\"</span>: &#123;</span><br><span class=\"line\">                    <span class=\"attr\">\"hits\"</span>: &#123;  <span class=\"comment\">//top_hits桶找出color为red的这些文档中，price从小到大排序取前5笔</span></span><br><span class=\"line\">                        <span class=\"attr\">\"total\"</span>: <span class=\"number\">2</span>,</span><br><span class=\"line\">                        <span class=\"attr\">\"max_score\"</span>: <span class=\"literal\">null</span>,</span><br><span class=\"line\">                        <span class=\"attr\">\"hits\"</span>: [</span><br><span class=\"line\">                            &#123;</span><br><span class=\"line\">                                <span class=\"attr\">\"_score\"</span>: <span class=\"literal\">null</span>,</span><br><span class=\"line\">                                <span class=\"attr\">\"_source\"</span>: &#123; <span class=\"attr\">\"color\"</span>: <span class=\"string\">\"red\"</span>, <span class=\"attr\">\"price\"</span>: <span class=\"number\">100</span> &#125;,</span><br><span class=\"line\">                                <span class=\"attr\">\"sort\"</span>: [ <span class=\"number\">100</span> ]</span><br><span class=\"line\">                            &#125;,</span><br><span class=\"line\">                            &#123;</span><br><span class=\"line\">                                <span class=\"attr\">\"_score\"</span>: <span class=\"literal\">null</span>,</span><br><span class=\"line\">                                <span class=\"attr\">\"_source\"</span>: &#123; <span class=\"attr\">\"color\"</span>: [ <span class=\"string\">\"red\"</span>, <span class=\"string\">\"blue\"</span> ], <span class=\"attr\">\"price\"</span>: <span class=\"number\">1000</span> &#125;,</span><br><span class=\"line\">                                <span class=\"attr\">\"sort\"</span>: [ <span class=\"number\">1000</span> ]</span><br><span class=\"line\">                            &#125;</span><br><span class=\"line\">                        ]</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;,</span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                <span class=\"attr\">\"key\"</span>: <span class=\"string\">\"blue\"</span>,</span><br><span class=\"line\">                <span class=\"attr\">\"doc_count\"</span>: <span class=\"number\">1</span>,  <span class=\"comment\">//terms桶计算出来的color为blue的文档数</span></span><br><span class=\"line\">                <span class=\"attr\">\"my_top_hits\"</span>: &#123;</span><br><span class=\"line\">                    <span class=\"attr\">\"hits\"</span>: &#123; <span class=\"comment\">//top_hits桶找出的hits</span></span><br><span class=\"line\">                        <span class=\"attr\">\"total\"</span>: <span class=\"number\">1</span>,</span><br><span class=\"line\">                        <span class=\"attr\">\"max_score\"</span>: <span class=\"literal\">null</span>,</span><br><span class=\"line\">                        <span class=\"attr\">\"hits\"</span>: [</span><br><span class=\"line\">                            &#123;</span><br><span class=\"line\">                                <span class=\"attr\">\"_source\"</span>: &#123;</span><br><span class=\"line\">                                    <span class=\"attr\">\"color\"</span>: [ <span class=\"string\">\"red\"</span>, <span class=\"string\">\"blue\"</span> ], <span class=\"attr\">\"price\"</span>: <span class=\"number\">1000</span> &#125;,</span><br><span class=\"line\">                                <span class=\"attr\">\"sort\"</span>: [ <span class=\"number\">1000</span> ]</span><br><span class=\"line\">                            &#125;</span><br><span class=\"line\">                        ]</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        ]</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n</blockquote>\n</li>\n</ul>\n</li>\n<li><p>date_histogram桶，对指定时间段内数据进行分组</p>\n<ul>\n<li><p>参数</p>\n<ol>\n<li>time_zone:”+08:00”：设置市区（东八区），不指定会影响分组时间错误</li>\n<li>interval：聚合时间间隔<ul>\n<li>year（1y）年</li>\n<li>quarter（1q）季度</li>\n<li>month（1M）月份</li>\n<li>week（1w）星期</li>\n<li>day（1d）天</li>\n<li>hour（1h）小时</li>\n<li>minute（1m）分钟</li>\n<li>second（1s）秒</li>\n</ul>\n</li>\n<li>format：指定返回时间格式</li>\n</ol>\n<blockquote>\n<p>dsl语句</p>\n<figure class=\"highlight json\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"attr\">\"query\"</span>: &#123;</span><br><span class=\"line\">        <span class=\"attr\">\"match_all\"</span>: &#123;&#125;</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    <span class=\"attr\">\"size\"</span>: <span class=\"number\">0</span>,</span><br><span class=\"line\"><span class=\"attr\">\"aggs\"</span>: &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 自己取的聚合名字</span></span><br><span class=\"line\">            <span class=\"attr\">\"group_by_grabTime\"</span>: &#123;</span><br><span class=\"line\">                <span class=\"comment\">// es提供的时间处理函数</span></span><br><span class=\"line\">                <span class=\"attr\">\"date_histogram\"</span>: &#123;</span><br><span class=\"line\">                    <span class=\"comment\">// 需要聚合分组的字段名称, 类型需要为date, 格式没有要求</span></span><br><span class=\"line\">                    <span class=\"attr\">\"field\"</span>: <span class=\"string\">\"@timestamp\"</span>,</span><br><span class=\"line\">                    <span class=\"comment\">// 按什么时间段聚合, 这里是5分钟, 可用的interval在上面给出</span></span><br><span class=\"line\">                    <span class=\"attr\">\"interval\"</span>: <span class=\"string\">\"5m\"</span>,</span><br><span class=\"line\">                    <span class=\"comment\">// 设置时区, 这样就相当于东八区的时间</span></span><br><span class=\"line\">                    <span class=\"attr\">\"time_zone\"</span>:<span class=\"string\">\"+08:00\"</span>,</span><br><span class=\"line\">                    <span class=\"comment\">// 返回值格式化，HH大写，不然不能区分上午、下午</span></span><br><span class=\"line\">                    <span class=\"attr\">\"format\"</span>: <span class=\"string\">\"yyyy-MM-dd HH\"</span>,   </span><br><span class=\"line\">                    <span class=\"comment\">// 为空的话则填充0</span></span><br><span class=\"line\">                    <span class=\"attr\">\"min_doc_count\"</span>: <span class=\"number\">0</span>,</span><br><span class=\"line\">                    <span class=\"comment\">// 需要填充0的范围</span></span><br><span class=\"line\">                    <span class=\"attr\">\"extended_bounds\"</span>: &#123;</span><br><span class=\"line\">                        <span class=\"attr\">\"min\"</span>: <span class=\"number\">1533556800000</span>,</span><br><span class=\"line\">                        <span class=\"attr\">\"max\"</span>: <span class=\"number\">1533806520000</span></span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                &#125;,</span><br><span class=\"line\">                <span class=\"comment\">// 聚合</span></span><br><span class=\"line\">                <span class=\"attr\">\"aggs\"</span>: &#123;</span><br><span class=\"line\">                    <span class=\"comment\">// 自己取的名称</span></span><br><span class=\"line\">                    <span class=\"attr\">\"group_by_status\"</span>: &#123;</span><br><span class=\"line\">                        <span class=\"comment\">// es提供</span></span><br><span class=\"line\">                        <span class=\"attr\">\"terms\"</span>: &#123;</span><br><span class=\"line\">                            <span class=\"comment\">// 聚合字段名</span></span><br><span class=\"line\">                            <span class=\"attr\">\"field\"</span>: <span class=\"string\">\"LowStatusOfPrice\"</span></span><br><span class=\"line\">                        &#125;</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br></pre></td></tr></table></figure></blockquote>\n</li>\n</ul>\n</li>\n</ol>\n","site":{"data":{}},"excerpt":"<h1 id=\"Elasticsearch基本操作\"><a href=\"#Elasticsearch基本操作\" class=\"headerlink\" title=\"Elasticsearch基本操作\"></a>Elasticsearch基本操作</h1><h1 id=\"一、简介\"><a href=\"#一、简介\" class=\"headerlink\" title=\"一、简介\"></a>一、简介</h1><p><strong>Elasticsearch（ES）：</strong>一款基于<a href=\"https://lucene.apache.org/core/\" target=\"_blank\" rel=\"noopener\">Apache Lucene(TM)</a>的开源的全文检索和分析引擎。通过简单的<code>RESTful API</code>来隐藏其复杂性、同时也做了分布式相关的工作。</p>\n<p><strong>Lucene：</strong>使用Java实现的一套搜索引擎库。</p>","more":"<ul>\n<li>分布式的实时文件存储，每个字段都被索引并可被搜索</li>\n<li>分布式的实时分析搜索引擎</li>\n<li>可以扩展到上百台服务器，处理PB级结构化或非结构化数据</li>\n</ul>\n<h4 id=\"ES与关系型数据库对比\"><a href=\"#ES与关系型数据库对比\" class=\"headerlink\" title=\"ES与关系型数据库对比\"></a>ES与关系型数据库对比</h4><p>Elasticsearch集群可以包含多个索引（数据库），每一个索引可以包含多个类型（表），每一个类型包含多个文档（行），然后每个文档包含多个字段（列）</p>\n<table>\n<thead>\n<tr>\n<th><strong>关系型数据库</strong></th>\n<th><strong>数据库</strong></th>\n<th><strong>表</strong></th>\n<th><strong>行</strong></th>\n<th><strong>列</strong></th>\n</tr>\n</thead>\n<tbody><tr>\n<td>ElasticSearch</td>\n<td>索引（index）</td>\n<td>类型(type)</td>\n<td>文档</td>\n<td>字段</td>\n</tr>\n</tbody></table>\n<p><strong>相关概念：</strong> </p>\n<ol>\n<li>集群（cluster）：一个集群就是由一个或多个节点组织在一起，它们共同持有你整个的数据，并一起提供索引和搜索功能。</li>\n<li>节点（node）：一个节点就是集群中的一个服务器，作为集群的一部分，参与集群的索引和搜索功能。</li>\n<li>索引（index）： 一个索引就是一个具有相似特征的文档集合，相当于一个数据集。</li>\n<li>类型（type）：在一个索引中，你可以定义一种或多种类型，相当于对一个索引中数据的逻辑划分（ES官方文档明确说明不推荐使用type，即建议一个索引只有一个type。ES7.0已经废弃了type）。</li>\n<li>文档（document）： 一个文档是一个可被索引的基础信息单元，就是索引里面的一条数据，使用JSON格式来表示。</li>\n<li>域（field）： 文档中的一个数据字段。一个文档由多个域组成。</li>\n<li>分片（shards）：分片是索引的一部分，一个索引由多个分片组成。每个分片可以分布在不同的节点上，ES会根据文档id（也可以指定其他字段）做hash，使用得到的hash值将文档路由到指定分片上。分片是ES做Data Rebalance的最小单元。</li>\n<li>副本（replicas）：创建索引时可以为索引指定0个或者多个副本。副本是分片级别的，即索引的分片由1个主分片（primary shard）和0个或者多个副本分片（replica shard）组成。primary shard可以接受读取和写入请求，replica shard只能接受读取请求。所以副本只能提高数据的可用性和并发读取能力。当primary shard所在服务器的节点挂掉以后，ES会通过leader选举机制将replica shard为primary shard。</li>\n</ol>\n<h4 id=\"文本分析\"><a href=\"#文本分析\" class=\"headerlink\" title=\"文本分析\"></a>文本分析</h4><p><strong>将文本转换成一系列单词（Term or Token）的过程，用于创建和查询倒排索引</strong></p>\n<ul>\n<li><p>分词器：是ES中专门处理分词的组件，由一下三部分组成</p>\n<ol>\n<li>Character Filters：针对原始文本进行处理，比如去除html标签</li>\n<li>Tokenizer：将原始文本按照一定规则切分为单词</li>\n<li>Token Filters：针对Tokenizer处理的单词进行再加工，比如转小写、删除或增新等处理</li>\n</ol>\n</li>\n<li><p>内置分词器：</p>\n<ol>\n<li>Standard Analyzer：默认分词器，按词切分，小写处理，删除大多标点符号</li>\n<li>Simple Analyzer：按照非字母切分、小写处理</li>\n<li>Whitespace Analyzer：按照空白字符分割</li>\n<li>Keyword Analyzer：不分词</li>\n</ol>\n</li>\n<li><p>分词查看</p>\n<figure class=\"highlight json\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">POST /_analyze</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">  <span class=\"attr\">\"analyzer\"</span>: <span class=\"string\">\"keyword\"</span>,</span><br><span class=\"line\">  <span class=\"attr\">\"text\"</span>: <span class=\"string\">\"The 2 QUICK Brown-Foxes jumped over the lazy dog's bone.\"</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n</li>\n</ul>\n<p>详情点击跳转<a href=\"https://www.elastic.co/guide/en/elasticsearch/reference/7.5/analysis-analyzers.html\" target=\"_blank\" rel=\"noopener\">官方文档</a>查看</p>\n<h4 id=\"倒排索引\"><a href=\"#倒排索引\" class=\"headerlink\" title=\"倒排索引\"></a>倒排索引</h4><p><strong>ES把文档中的数据进行分析后，将词和文档之间建立映射关系。</strong></p>\n<p>组成：倒排索引由文档中不重复词的列表＋每个词被包含的文档ID列表</p>\n<p>查询过程：</p>\n<ol>\n<li>搜索词“搜索引擎”，获得对应的文档ID列表，1，3</li>\n<li>通过正排索引查询1和3的完整内容</li>\n<li>返回最终结果</li>\n</ol>\n<img src=\"https://tupian-1300728887.cos.ap-chengdu.myqcloud.com/image-20200904171011154.png\" alt=\"image-20200904171011154\" style=\"zoom:67%;\" />\n\n<h1 id=\"二、基本查询\"><a href=\"#二、基本查询\" class=\"headerlink\" title=\"二、基本查询\"></a>二、基本查询</h1><h2 id=\"空查询\"><a href=\"#空查询\" class=\"headerlink\" title=\"空查询\"></a>空查询</h2><figure class=\"highlight json\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">GET /_search</span><br><span class=\"line\">&#123;&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">GET /_search</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"attr\">\"query\"</span>: &#123;</span><br><span class=\"line\">        <span class=\"attr\">\"match_all\"</span>: &#123;&#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"字段详解\"><a href=\"#字段详解\" class=\"headerlink\" title=\"字段详解\"></a>字段详解</h3><p><img src=\"https://tupian-1300728887.cos.ap-chengdu.myqcloud.com/image-20200904172752621.png\" alt=\"image-20200904172752621\"></p>\n<h3 id=\"相关性\"><a href=\"#相关性\" class=\"headerlink\" title=\"相关性\"></a>相关性</h3><p><strong>根据ES的相似度算法（TF/IDF）得出的结果，具体值由_score字段表示，根据以下维度计算得出</strong></p>\n<ol>\n<li><p>检索词频率： 检索词在该字段出现的频率，频率越高，权重越大。字段中出现过 5 次要比只出现过 1 次的相关性高。</p>\n</li>\n<li><p>反向文档频率：检索词在使用中出现的频率，频率越高，权重越低。检索词出现在多数文档中会比出现在少数文档中的权重更低。</p>\n</li>\n<li><p>字段长度准则：字段长度越长，权重越低</p>\n<figure class=\"highlight json\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 请求后增加explain=true即可</span></span><br><span class=\"line\">GET /_search</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">   <span class=\"attr\">\"explain\"</span>:<span class=\"literal\">true</span>,</span><br><span class=\"line\">   <span class=\"attr\">\"query\"</span>   : &#123; <span class=\"attr\">\"match\"</span> : &#123; <span class=\"attr\">\"name\"</span> : <span class=\"string\">\"John Smith\"</span> &#125;&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n</li>\n</ol>\n<h2 id=\"查询与过滤\"><a href=\"#查询与过滤\" class=\"headerlink\" title=\"查询与过滤\"></a>查询与过滤</h2><table>\n<thead>\n<tr>\n<th></th>\n<th><strong>Query</strong></th>\n<th><strong>Filter</strong></th>\n</tr>\n</thead>\n<tbody><tr>\n<td>争对问题</td>\n<td>该文档匹不匹配这个查询，它的相关度高么❓</td>\n<td>这篇文档是否与该查询匹配❓</td>\n</tr>\n<tr>\n<td>相关度处理</td>\n<td>先查询符合搜索条件的文档数，然后计算每个文档对于搜索条件的相关度分数，再根据评分倒序排序</td>\n<td>只根据搜索条件过滤出符合的文档,   不进行评分, 忽略TF/IDF信息</td>\n</tr>\n<tr>\n<td>性能</td>\n<td>性能较差, 有排序 , 并且没有缓存功能（有倒排索引来弥补）</td>\n<td>性能更好, 无排序；  会缓存比较常用的filter的数据</td>\n</tr>\n<tr>\n<td>栗子</td>\n<td>❗ 查询与“first blog”字段最佳匹配的文档 ❗</td>\n<td>❗ 搜索博客等级(level)大于等于2, 同时发布日期(post_date)是2018-11-11的博客 ❗</td>\n</tr>\n</tbody></table>\n<h3 id=\"1-❗-查询与”first-blog”字段最佳匹配的文档-❗\"><a href=\"#1-❗-查询与”first-blog”字段最佳匹配的文档-❗\" class=\"headerlink\" title=\"1. ❗ 查询与”first blog”字段最佳匹配的文档 ❗\"></a>1. ❗ 查询与”first blog”字段最佳匹配的文档 ❗</h3><figure class=\"highlight json\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// query</span></span><br><span class=\"line\">GET /_search</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">  <span class=\"attr\">\"query\"</span>: &#123;</span><br><span class=\"line\">    <span class=\"attr\">\"match\"</span>: &#123;</span><br><span class=\"line\">      <span class=\"attr\">\"desc\"</span>: <span class=\"string\">\"four blog\"</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// filter</span></span><br><span class=\"line\">GET /_search</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">  <span class=\"attr\">\"query\"</span>: &#123;</span><br><span class=\"line\">    <span class=\"attr\">\"bool\"</span>: &#123;</span><br><span class=\"line\">      <span class=\"attr\">\"filter\"</span>: &#123;</span><br><span class=\"line\">        <span class=\"attr\">\"match\"</span>: &#123;</span><br><span class=\"line\">          <span class=\"attr\">\"desc\"</span>: <span class=\"string\">\"four blog\"</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"2-❗-搜索博客等级-level-大于等于2-同时发布日期-post-date-是2018-11-11的博客-❗\"><a href=\"#2-❗-搜索博客等级-level-大于等于2-同时发布日期-post-date-是2018-11-11的博客-❗\" class=\"headerlink\" title=\"2. ❗ 搜索博客等级(level)大于等于2, 同时发布日期(post_date)是2018-11-11的博客 ❗\"></a>2. ❗ 搜索博客等级(level)大于等于2, 同时发布日期(post_date)是2018-11-11的博客 ❗</h3><figure class=\"highlight json\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// query</span></span><br><span class=\"line\">GET /_search</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"attr\">\"query\"</span>: &#123;</span><br><span class=\"line\">        <span class=\"attr\">\"bool\"</span>: &#123;</span><br><span class=\"line\">            <span class=\"attr\">\"must\"</span>: [</span><br><span class=\"line\">                &#123; <span class=\"attr\">\"match\"</span>: &#123; <span class=\"attr\">\"post_date\"</span>: <span class=\"string\">\"2018-11-11\"</span> &#125; &#125;, </span><br><span class=\"line\">                &#123; <span class=\"attr\">\"range\"</span>: &#123; <span class=\"attr\">\"level\"</span>: &#123; <span class=\"attr\">\"gte\"</span>: <span class=\"number\">2</span> &#125; &#125; &#125;</span><br><span class=\"line\">            ]</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// filter</span></span><br><span class=\"line\">GET /_search</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"attr\">\"query\"</span>: &#123;</span><br><span class=\"line\">        <span class=\"attr\">\"bool\"</span>: &#123;</span><br><span class=\"line\">            <span class=\"attr\">\"must\"</span>: &#123; </span><br><span class=\"line\">                <span class=\"attr\">\"match\"</span>: &#123; <span class=\"attr\">\"post_date\"</span>: <span class=\"string\">\"2018-11-11\"</span> &#125;</span><br><span class=\"line\">            &#125;, </span><br><span class=\"line\">            <span class=\"attr\">\"filter\"</span>: &#123;</span><br><span class=\"line\">                <span class=\"attr\">\"range\"</span>: &#123; <span class=\"attr\">\"level\"</span>: &#123; <span class=\"attr\">\"gte\"</span>: <span class=\"number\">2</span> &#125; &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"结构化搜索\"><a href=\"#结构化搜索\" class=\"headerlink\" title=\"结构化搜索\"></a>结构化搜索</h2><figure class=\"highlight json\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">POST /my_store/_bulk</span><br><span class=\"line\">&#123; <span class=\"attr\">\"index\"</span>: &#123; <span class=\"attr\">\"_id\"</span>: <span class=\"number\">1</span> &#125;&#125;</span><br><span class=\"line\">&#123; <span class=\"attr\">\"price\"</span> : <span class=\"number\">10</span>, <span class=\"attr\">\"productID\"</span> : <span class=\"string\">\"XHDK-A-1293-#fJ3\"</span> &#125;</span><br><span class=\"line\">&#123; <span class=\"attr\">\"index\"</span>: &#123; <span class=\"attr\">\"_id\"</span>: <span class=\"number\">2</span> &#125;&#125;</span><br><span class=\"line\">&#123; <span class=\"attr\">\"price\"</span> : <span class=\"number\">20</span>, <span class=\"attr\">\"productID\"</span> : <span class=\"string\">\"KDKE-B-9947-#kL5\"</span> &#125;</span><br><span class=\"line\">&#123; <span class=\"attr\">\"index\"</span>: &#123; <span class=\"attr\">\"_id\"</span>: <span class=\"number\">3</span> &#125;&#125;</span><br><span class=\"line\">&#123; <span class=\"attr\">\"price\"</span> : <span class=\"number\">30</span>, <span class=\"attr\">\"productID\"</span> : <span class=\"string\">\"JODL-X-1937-#pV7\"</span> &#125;</span><br><span class=\"line\">&#123; <span class=\"attr\">\"index\"</span>: &#123; <span class=\"attr\">\"_id\"</span>: <span class=\"number\">4</span> &#125;&#125;</span><br><span class=\"line\">&#123; <span class=\"attr\">\"price\"</span> : <span class=\"number\">30</span>, <span class=\"attr\">\"productID\"</span> : <span class=\"string\">\"QQPX-R-3956-#aD8\"</span> &#125;</span><br></pre></td></tr></table></figure>\n\n<p><strong>查看索引详情</strong></p>\n<figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">GET /my_store</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"1-精确值查找（term）\"><a href=\"#1-精确值查找（term）\" class=\"headerlink\" title=\"1. 精确值查找（term）\"></a>1. 精确值查找（term）</h3><blockquote>\n<ol>\n<li><p>查询价格20的所有产品</p>\n<p>SQL：==SELECT * FROM products WHERE price = 20==</p>\n<figure class=\"highlight json\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">GET /_search</span><br><span class=\"line\">&#123;</span><br><span class=\"line\"> <span class=\"attr\">\"query\"</span> : &#123;</span><br><span class=\"line\">     <span class=\"attr\">\"constant_score\"</span> : &#123; </span><br><span class=\"line\">         <span class=\"attr\">\"filter\"</span> : &#123;</span><br><span class=\"line\">             <span class=\"attr\">\"term\"</span> : &#123; </span><br><span class=\"line\">                 <span class=\"attr\">\"price\"</span> : <span class=\"number\">20</span></span><br><span class=\"line\">             &#125;</span><br><span class=\"line\">         &#125;</span><br><span class=\"line\">     &#125;</span><br><span class=\"line\"> &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// constant_score关键字将trem查询转化为filter</span></span><br><span class=\"line\">GET /_search</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">  <span class=\"attr\">\"query\"</span>:&#123;</span><br><span class=\"line\">    <span class=\"attr\">\"bool\"</span>: &#123;</span><br><span class=\"line\">      <span class=\"attr\">\"filter\"</span>: &#123;</span><br><span class=\"line\">        <span class=\"attr\">\"term\"</span>: &#123;</span><br><span class=\"line\">          <span class=\"attr\">\"price\"</span>: <span class=\"number\">20</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>查询productID为XHDK-A-1293-#fJ3的文档</p>\n<p>SQL：==SELECT * FROM products WHERE  productID = “XHDK-A-1293-#fJ3”==</p>\n<figure class=\"highlight json\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">GET /_search</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"attr\">\"query\"</span> : &#123;</span><br><span class=\"line\">        <span class=\"attr\">\"constant_score\"</span> : &#123;</span><br><span class=\"line\">            <span class=\"attr\">\"filter\"</span> : &#123;</span><br><span class=\"line\">                <span class=\"attr\">\"term\"</span> : &#123;</span><br><span class=\"line\">                    <span class=\"attr\">\"productID\"</span> : <span class=\"string\">\"XHDK-A-1293-#fJ3\"</span></span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 查看分词结果</span></span><br><span class=\"line\">GET /my_store/_analyze</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">  <span class=\"attr\">\"field\"</span>: <span class=\"string\">\"productID\"</span>,</span><br><span class=\"line\">  <span class=\"attr\">\"text\"</span>: <span class=\"string\">\"XHDK-A-1293-#fJ3\"</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>总结：term会拿”XHDK-A-1293-#fJ3”，去倒排索引中找，但倒排索引表里只有”xhdk”,”a”,”1293”,”fj3”,因此查不到</p>\n<p><strong>解决办法</strong></p>\n<ol>\n<li><p>match_phrase关键字</p>\n<figure class=\"highlight json\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">GET /_search</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"attr\">\"query\"</span> : &#123;</span><br><span class=\"line\">        <span class=\"attr\">\"match_phrase\"</span> : &#123;</span><br><span class=\"line\">            <span class=\"attr\">\"productID\"</span> : <span class=\"string\">\"XHDK-A-1293-#fJ3\"</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>重新配置该字段的分词规则</p>\n<figure class=\"highlight json\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 1.删除索引</span></span><br><span class=\"line\">DELETE /my_store</span><br><span class=\"line\"><span class=\"comment\">//2.指定productID字段使用keyword规则</span></span><br><span class=\"line\">PUT /my_store</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\t<span class=\"attr\">\"mappings\"</span>: &#123;</span><br><span class=\"line\">\t\t\t<span class=\"attr\">\"properties\"</span>: &#123;</span><br><span class=\"line\">\t\t\t\t<span class=\"attr\">\"price\"</span>: &#123;</span><br><span class=\"line\">\t\t\t\t\t<span class=\"attr\">\"type\"</span>: <span class=\"string\">\"long\"</span></span><br><span class=\"line\">\t\t\t\t&#125;,</span><br><span class=\"line\">\t\t\t\t<span class=\"attr\">\"productID\"</span>: &#123;</span><br><span class=\"line\">\t\t\t\t\t<span class=\"attr\">\"type\"</span>: <span class=\"string\">\"text\"</span>,</span><br><span class=\"line\">\t\t\t\t\t<span class=\"attr\">\"analyzer\"</span>: <span class=\"string\">\"keyword\"</span></span><br><span class=\"line\">\t\t\t\t&#125;</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n</li>\n</ol>\n</li>\n</ol>\n</blockquote>\n<h3 id=\"2-多个精确值查找（terms）\"><a href=\"#2-多个精确值查找（terms）\" class=\"headerlink\" title=\"2. 多个精确值查找（terms）\"></a>2. 多个精确值查找（terms）</h3><blockquote>\n<ol>\n<li><p>查找price为20 &amp;&amp; 30 的文档</p>\n<figure class=\"highlight json\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">GET /my_store/_search</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"attr\">\"query\"</span> : &#123;</span><br><span class=\"line\">        <span class=\"attr\">\"constant_score\"</span> : &#123;</span><br><span class=\"line\">            <span class=\"attr\">\"filter\"</span> : &#123;</span><br><span class=\"line\">                <span class=\"attr\">\"terms\"</span> : &#123; </span><br><span class=\"line\">                    <span class=\"attr\">\"price\"</span> : [<span class=\"number\">20</span>, <span class=\"number\">30</span>]</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n</ol>\n</blockquote>\n<h3 id=\"3-range-范围过滤\"><a href=\"#3-range-范围过滤\" class=\"headerlink\" title=\"3. range(范围过滤)\"></a>3. range(范围过滤)</h3><p><strong>gt:&gt;   lt:&lt;    gte:&gt;=  lte:&lt;=</strong></p>\n<blockquote>\n<ol>\n<li><p>查找price大于20且小于40的产品</p>\n<p>SQL：==SELECT * FROM products WHERE  price BETWEEN 20 AND 40==</p>\n<figure class=\"highlight json\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">GET /my_store/_search</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"attr\">\"query\"</span> : &#123;</span><br><span class=\"line\">        <span class=\"attr\">\"constant_score\"</span> : &#123;</span><br><span class=\"line\">            <span class=\"attr\">\"filter\"</span> : &#123;</span><br><span class=\"line\">                <span class=\"attr\">\"range\"</span> : &#123;</span><br><span class=\"line\">                    <span class=\"attr\">\"price\"</span> : &#123;</span><br><span class=\"line\">                        <span class=\"attr\">\"gte\"</span> : <span class=\"number\">20</span>,</span><br><span class=\"line\">                        <span class=\"attr\">\"lt\"</span>  : <span class=\"number\">40</span></span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>日期范围查询  now  data||+1M</p>\n<figure class=\"highlight json\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">GET /website/_search</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"attr\">\"query\"</span> : &#123;</span><br><span class=\"line\">        <span class=\"attr\">\"constant_score\"</span> : &#123;</span><br><span class=\"line\">            <span class=\"attr\">\"filter\"</span> : &#123;</span><br><span class=\"line\">                <span class=\"attr\">\"range\"</span> : &#123;</span><br><span class=\"line\">                    <span class=\"attr\">\"post_date\"</span>: &#123;</span><br><span class=\"line\">                        <span class=\"attr\">\"gte\"</span> : <span class=\"string\">\"2020-01-01\"</span>,</span><br><span class=\"line\">                        <span class=\"attr\">\"lt\"</span>: <span class=\"string\">\"2020-09-09||+1h\"</span></span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n</ol>\n</blockquote>\n<h3 id=\"4-组合查询（bool）\"><a href=\"#4-组合查询（bool）\" class=\"headerlink\" title=\"4. 组合查询（bool）\"></a>4. 组合查询（bool）</h3><blockquote>\n<ol>\n<li><p>SQL：==SELECT * FROM products WHERE (price = 20 OR productID = “XHDK-A-1293-#fJ3”) AND (price != 30)==</p>\n<figure class=\"highlight json\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">GET /my_store/_search</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">   <span class=\"attr\">\"query\"</span> : &#123;</span><br><span class=\"line\">      <span class=\"attr\">\"constant_score\"</span> : &#123; </span><br><span class=\"line\">         <span class=\"attr\">\"filter\"</span> : &#123;</span><br><span class=\"line\">            <span class=\"attr\">\"bool\"</span> : &#123;</span><br><span class=\"line\">              <span class=\"attr\">\"should\"</span> : [</span><br><span class=\"line\">                 &#123; <span class=\"attr\">\"term\"</span> : &#123;<span class=\"attr\">\"price\"</span> : <span class=\"number\">20</span>&#125;&#125;, </span><br><span class=\"line\">                 &#123; <span class=\"attr\">\"term\"</span> : &#123;<span class=\"attr\">\"productID\"</span> : <span class=\"string\">\"XHDK-A-1293-#fJ3\"</span>&#125;&#125; </span><br><span class=\"line\">              ],</span><br><span class=\"line\">              <span class=\"attr\">\"must_not\"</span> : &#123;</span><br><span class=\"line\">                 <span class=\"attr\">\"term\"</span> : &#123;<span class=\"attr\">\"price\"</span> : <span class=\"number\">30</span>&#125; </span><br><span class=\"line\">              &#125;</span><br><span class=\"line\">           &#125;</span><br><span class=\"line\">         &#125;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>SQL：==SELECT * FROM products WHERE productID = “KDKE-B-9947-#kL5” OR (productID = “JODL-X-1937-#pV7” AND price = 30)==</p>\n<figure class=\"highlight json\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">GET /my_store/_search</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">   <span class=\"attr\">\"query\"</span> : &#123;</span><br><span class=\"line\">      <span class=\"attr\">\"constant_score\"</span> : &#123;</span><br><span class=\"line\">         <span class=\"attr\">\"filter\"</span> : &#123;</span><br><span class=\"line\">            <span class=\"attr\">\"bool\"</span> : &#123;</span><br><span class=\"line\">              <span class=\"attr\">\"should\"</span> : [</span><br><span class=\"line\">                &#123; <span class=\"attr\">\"term\"</span> : &#123;<span class=\"attr\">\"productID\"</span> : <span class=\"string\">\"KDKE-B-9947-#kL5\"</span>&#125;&#125;, </span><br><span class=\"line\">                &#123; <span class=\"attr\">\"bool\"</span> : &#123; </span><br><span class=\"line\">                  <span class=\"attr\">\"must\"</span> : [</span><br><span class=\"line\">                    &#123; <span class=\"attr\">\"term\"</span> : &#123;<span class=\"attr\">\"productID\"</span> : <span class=\"string\">\"JODL-X-1937-#pV7\"</span>&#125;&#125;, </span><br><span class=\"line\">                    &#123; <span class=\"attr\">\"term\"</span> : &#123;<span class=\"attr\">\"price\"</span> : <span class=\"number\">30</span>&#125;&#125; </span><br><span class=\"line\">                  ]</span><br><span class=\"line\">                &#125;&#125;</span><br><span class=\"line\">              ]</span><br><span class=\"line\">           &#125;</span><br><span class=\"line\">         &#125;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n</ol>\n</blockquote>\n<h3 id=\"5-处理null值（exists）\"><a href=\"#5-处理null值（exists）\" class=\"headerlink\" title=\"5. 处理null值（exists）\"></a>5. 处理null值（exists）</h3><figure class=\"highlight json\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">POST /posts/_bulk</span><br><span class=\"line\">&#123; <span class=\"attr\">\"index\"</span>: &#123; <span class=\"attr\">\"_id\"</span>: <span class=\"string\">\"1\"</span>              &#125;&#125;</span><br><span class=\"line\">&#123; <span class=\"attr\">\"tags\"</span> : [<span class=\"string\">\"search\"</span>]                &#125;  </span><br><span class=\"line\">&#123; <span class=\"attr\">\"index\"</span>: &#123; <span class=\"attr\">\"_id\"</span>: <span class=\"string\">\"2\"</span>              &#125;&#125;</span><br><span class=\"line\">&#123; <span class=\"attr\">\"tags\"</span> : [<span class=\"string\">\"search\"</span>, <span class=\"string\">\"open_source\"</span>] &#125;  </span><br><span class=\"line\">&#123; <span class=\"attr\">\"index\"</span>: &#123; <span class=\"attr\">\"_id\"</span>: <span class=\"string\">\"3\"</span>              &#125;&#125;</span><br><span class=\"line\">&#123; <span class=\"attr\">\"other_field\"</span> : <span class=\"string\">\"some data\"</span>        &#125;  </span><br><span class=\"line\">&#123; <span class=\"attr\">\"index\"</span>: &#123; <span class=\"attr\">\"_id\"</span>: <span class=\"string\">\"4\"</span>              &#125;&#125;</span><br><span class=\"line\">&#123; <span class=\"attr\">\"tags\"</span> : <span class=\"literal\">null</span>                      &#125;  </span><br><span class=\"line\">&#123; <span class=\"attr\">\"index\"</span>: &#123; <span class=\"attr\">\"_id\"</span>: <span class=\"string\">\"5\"</span>              &#125;&#125;</span><br><span class=\"line\">&#123; <span class=\"attr\">\"tags\"</span> : [<span class=\"string\">\"search\"</span>, <span class=\"literal\">null</span>]          &#125;</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<ol>\n<li><p>存在查询</p>\n<p>==SQL:SELECT tags FROM posts WHERE tags IS NOT NULL==</p>\n<figure class=\"highlight json\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">GET /posts/_search</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"attr\">\"query\"</span> : &#123;</span><br><span class=\"line\">        <span class=\"attr\">\"constant_score\"</span> : &#123;</span><br><span class=\"line\">            <span class=\"attr\">\"filter\"</span> : &#123;</span><br><span class=\"line\">                <span class=\"attr\">\"exists\"</span> : &#123; <span class=\"attr\">\"field\"</span> : <span class=\"string\">\"tags\"</span> &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>缺失查询</p>\n<p>==SQL:SELECT tags FROM posts WHERE tags IS NULL==</p>\n<figure class=\"highlight json\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">GET /posts/_search</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"attr\">\"query\"</span> : &#123;</span><br><span class=\"line\">        <span class=\"attr\">\"constant_score\"</span> : &#123;</span><br><span class=\"line\">            <span class=\"attr\">\"filter\"</span> : &#123;</span><br><span class=\"line\">              <span class=\"attr\">\"bool\"</span>: &#123;</span><br><span class=\"line\">                <span class=\"attr\">\"must_not\"</span>:&#123;<span class=\"attr\">\"exists\"</span> : &#123; <span class=\"attr\">\"field\"</span> : <span class=\"string\">\"tags\"</span> &#125;&#125;</span><br><span class=\"line\">              &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n</ol>\n</blockquote>\n<h2 id=\"全文搜索\"><a href=\"#全文搜索\" class=\"headerlink\" title=\"全文搜索\"></a>全文搜索</h2><figure class=\"highlight json\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">POST /my_index/my_type/_bulk</span><br><span class=\"line\">&#123; <span class=\"attr\">\"index\"</span>: &#123; <span class=\"attr\">\"_id\"</span>: <span class=\"number\">1</span> &#125;&#125;</span><br><span class=\"line\">&#123; <span class=\"attr\">\"title\"</span>: <span class=\"string\">\"The quick brown fox\"</span> &#125;</span><br><span class=\"line\">&#123; <span class=\"attr\">\"index\"</span>: &#123; <span class=\"attr\">\"_id\"</span>: <span class=\"number\">2</span> &#125;&#125;</span><br><span class=\"line\">&#123; <span class=\"attr\">\"title\"</span>: <span class=\"string\">\"The quick brown fox jumps over the lazy dog\"</span> &#125;</span><br><span class=\"line\">&#123; <span class=\"attr\">\"index\"</span>: &#123; <span class=\"attr\">\"_id\"</span>: <span class=\"number\">3</span> &#125;&#125;</span><br><span class=\"line\">&#123; <span class=\"attr\">\"title\"</span>: <span class=\"string\">\"The quick brown fox jumps over the quick dog\"</span> &#125;</span><br><span class=\"line\">&#123; <span class=\"attr\">\"index\"</span>: &#123; <span class=\"attr\">\"_id\"</span>: <span class=\"number\">4</span> &#125;&#125;</span><br><span class=\"line\">&#123; <span class=\"attr\">\"title\"</span>: <span class=\"string\">\"Brown fox brown dog\"</span> &#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"1-match\"><a href=\"#1-match\" class=\"headerlink\" title=\"1. match\"></a>1. match</h3><blockquote>\n<ol>\n<li><p>单个词查询</p>\n<figure class=\"highlight json\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">GET /my_index/_search</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"attr\">\"query\"</span>: &#123;</span><br><span class=\"line\">        <span class=\"attr\">\"match\"</span>: &#123;</span><br><span class=\"line\">            <span class=\"attr\">\"title\"</span>: <span class=\"string\">\"QUICK!\"</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>执行过程：</p>\n<ol>\n<li><p>检查字段类型</p>\n</li>\n<li><p>分析查询字符串</p>\n<figure class=\"highlight json\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">GET /_analyze</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">  <span class=\"attr\">\"text\"</span>: <span class=\"string\">\"QUICK!\"</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>调用term查询，去倒排索引中查询包含quick的文档</p>\n<figure class=\"highlight json\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">GET /my_type/_search</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">  <span class=\"attr\">\"query\"</span>: &#123;</span><br><span class=\"line\">    <span class=\"attr\">\"term\"</span>: &#123;</span><br><span class=\"line\">      <span class=\"attr\">\"title\"</span>: <span class=\"string\">\"quick\"</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>为每个文档评分并排序</p>\n</li>\n</ol>\n</li>\n<li><p>多词查询</p>\n<figure class=\"highlight json\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">GET /my_index/_search</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"attr\">\"query\"</span>: &#123;</span><br><span class=\"line\">        <span class=\"attr\">\"match\"</span>: &#123;</span><br><span class=\"line\">            <span class=\"attr\">\"title\"</span>: <span class=\"string\">\"BROWN DOG!\"</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">GET /my_index/_search</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">  <span class=\"attr\">\"query\"</span>: &#123;</span><br><span class=\"line\">    <span class=\"attr\">\"bool\"</span>: &#123;</span><br><span class=\"line\">      <span class=\"attr\">\"should\"</span>: [</span><br><span class=\"line\">        &#123;<span class=\"attr\">\"term\"</span>: &#123;<span class=\"attr\">\"title\"</span>: <span class=\"string\">\"brown\"</span>&#125;&#125;,</span><br><span class=\"line\">        &#123;<span class=\"attr\">\"term\"</span>:&#123;<span class=\"attr\">\"title\"</span>:<span class=\"string\">\"dog\"</span>&#125;&#125;</span><br><span class=\"line\">      ]</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>总结:被匹配的此项越多，文档越相关</p>\n</li>\n<li><p>operator：修改匹配关系</p>\n<figure class=\"highlight json\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">GET /my_index/_search</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"attr\">\"query\"</span>: &#123;</span><br><span class=\"line\">        <span class=\"attr\">\"match\"</span>: &#123;</span><br><span class=\"line\">            <span class=\"attr\">\"title\"</span>: &#123;      </span><br><span class=\"line\">                <span class=\"attr\">\"query\"</span>:    <span class=\"string\">\"BROWN DOG!\"</span>,</span><br><span class=\"line\">                <span class=\"attr\">\"operator\"</span>: <span class=\"string\">\"and\"</span></span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">GET /my_index/_search</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">  <span class=\"attr\">\"query\"</span>: &#123;</span><br><span class=\"line\">    <span class=\"attr\">\"bool\"</span>: &#123;</span><br><span class=\"line\">      <span class=\"attr\">\"must\"</span>: [</span><br><span class=\"line\">        &#123;<span class=\"attr\">\"term\"</span>: &#123;<span class=\"attr\">\"title\"</span>: <span class=\"string\">\"brown\"</span>&#125;&#125;,</span><br><span class=\"line\">        &#123;<span class=\"attr\">\"term\"</span>:&#123;<span class=\"attr\">\"title\"</span>:<span class=\"string\">\"dog\"</span>&#125;&#125;</span><br><span class=\"line\">      ]</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n</li>\n</ol>\n</blockquote>\n<h3 id=\"2-bool（组合查询）\"><a href=\"#2-bool（组合查询）\" class=\"headerlink\" title=\"2. bool（组合查询）\"></a>2. bool（组合查询）</h3><blockquote>\n<ol>\n<li><p>查询包含quick，但不包含lazy的所有文档，如果包含should里的字段，则该文章相关度更高</p>\n<figure class=\"highlight json\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">GET /my_index/_search</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">  <span class=\"attr\">\"query\"</span>: &#123;</span><br><span class=\"line\">    <span class=\"attr\">\"bool\"</span>: &#123;</span><br><span class=\"line\">      <span class=\"attr\">\"must\"</span>:     &#123; <span class=\"attr\">\"match\"</span>: &#123; <span class=\"attr\">\"title\"</span>: <span class=\"string\">\"quick\"</span> &#125;&#125;,</span><br><span class=\"line\">      <span class=\"attr\">\"must_not\"</span>: &#123; <span class=\"attr\">\"match\"</span>: &#123; <span class=\"attr\">\"title\"</span>: <span class=\"string\">\"lazy\"</span>  &#125;&#125;,</span><br><span class=\"line\">      <span class=\"attr\">\"should\"</span>: [</span><br><span class=\"line\">                  &#123; <span class=\"attr\">\"match\"</span>: &#123; <span class=\"attr\">\"title\"</span>: <span class=\"string\">\"brown\"</span> &#125;&#125;,</span><br><span class=\"line\">                  &#123; <span class=\"attr\">\"match\"</span>: &#123; <span class=\"attr\">\"title\"</span>: <span class=\"string\">\"dog\"</span>   &#125;&#125;</span><br><span class=\"line\">      ]</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n</ol>\n</blockquote>\n<h3 id=\"3-match-phrase（短语匹配）\"><a href=\"#3-match-phrase（短语匹配）\" class=\"headerlink\" title=\"3. match_phrase（短语匹配）\"></a>3. match_phrase（短语匹配）</h3><figure class=\"highlight json\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">GET /my_index/_search</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"attr\">\"query\"</span>: &#123;</span><br><span class=\"line\">        <span class=\"attr\">\"match_phrase\"</span>: &#123;</span><br><span class=\"line\">            <span class=\"attr\">\"title\"</span>: <span class=\"string\">\"quick brown fox\"</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"分页（深度分页）from-size\"><a href=\"#分页（深度分页）from-size\" class=\"headerlink\" title=\"分页（深度分页）from+size\"></a>分页（深度分页）from+size</h2><p>缺点：</p>\n<ul>\n<li>效率低。比如from=5000，size=100，es需要在各个分片上匹配排序并得到5000+100条有效数据，然后在结果集中取最后100条结果。</li>\n<li>最大可查询条数为1W条。ES目前默认支持的skin值max_result_window=10000，当from+size&gt;max_result_window时，ES就会返回错误。</li>\n<li>==解决办法：使用scroll（游标查询）==</li>\n</ul>\n<figure class=\"highlight json\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">  <span class=\"attr\">\"query\"</span>: &#123;</span><br><span class=\"line\">    <span class=\"attr\">\"match_all\"</span>: &#123;&#125;</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  <span class=\"attr\">\"from\"</span>: <span class=\"number\">0</span>,  </span><br><span class=\"line\">  <span class=\"attr\">\"size\"</span>: <span class=\"number\">1</span>  </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>from：从第几个商品开始查，最开始是 0</p>\n<p>size：要查几个结果</p>\n<h2 id=\"游标查询（scroll）\"><a href=\"#游标查询（scroll）\" class=\"headerlink\" title=\"游标查询（scroll）\"></a>游标查询（scroll）</h2><ul>\n<li><p>启动游标查询</p>\n<figure class=\"highlight routeros\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">CET /host/_search?<span class=\"attribute\">scroll</span>=1m</span><br></pre></td></tr></table></figure>\n\n<p>scroll=1m表示游标查询窗口保持1分钟，如果一次取的数据量大可以设置大一些的时间；返回字段包含一个scroll_id，接下来用这个字段获取后续值</p>\n</li>\n<li><p>循环获取</p>\n<p>循环获取余下值</p>\n<figure class=\"highlight json\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">GET /_search/scroll</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\t<span class=\"attr\">\"scroll\"</span>: <span class=\"string\">\"1m\"</span>，</span><br><span class=\"line\">\t<span class=\"string\">\"scroll_id\"</span>: scroll_id</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>python操作</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">from</span> elasticsearch <span class=\"keyword\">import</span> Elasticsearch</span><br><span class=\"line\"></span><br><span class=\"line\">es = Elasticsearch([<span class=\"string\">'localhost:9200'</span>])</span><br><span class=\"line\"><span class=\"comment\"># 1.启动游标</span></span><br><span class=\"line\">queryData = es.search(<span class=\"string\">\"internal_isop_log\"</span>, body=dsl_body, scroll=<span class=\"string\">'1m'</span>, size=<span class=\"number\">1000</span>)</span><br><span class=\"line\"><span class=\"comment\"># 获取scroll_id</span></span><br><span class=\"line\">hits_list = queryData.get(<span class=\"string\">\"hits\"</span>).get(<span class=\"string\">\"hits\"</span>)</span><br><span class=\"line\">scroll_id = queryData[<span class=\"string\">'_scroll_id'</span>]</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 2.循环获取</span></span><br><span class=\"line\">total = queryData.get(<span class=\"string\">\"hits\"</span>).get(<span class=\"string\">\"total\"</span>).get(<span class=\"string\">'value'</span>)</span><br><span class=\"line\"><span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> range(int(total / <span class=\"number\">1000</span>)):</span><br><span class=\"line\">    ss = &#123;<span class=\"string\">'scroll'</span>: <span class=\"string\">'1m'</span>, <span class=\"string\">'scroll_id'</span>: scroll_id&#125;</span><br><span class=\"line\">    res = self.es.scroll(body=ss)</span><br></pre></td></tr></table></figure>\n</blockquote>\n</li>\n</ul>\n<h2 id=\"模糊查询\"><a href=\"#模糊查询\" class=\"headerlink\" title=\"模糊查询\"></a>模糊查询</h2><ol>\n<li><p>创建索引，设置postcode字段使用keyword规则 ❗模糊查询会匹配倒排表里的字段 ❗</p>\n<figure class=\"highlight json\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">PUT /address</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\t<span class=\"attr\">\"mappings\"</span>: &#123;</span><br><span class=\"line\">\t\t\t<span class=\"attr\">\"properties\"</span>: &#123;</span><br><span class=\"line\">\t\t\t\t<span class=\"attr\">\"postcode\"</span>: &#123;</span><br><span class=\"line\">\t\t\t\t\t<span class=\"attr\">\"type\"</span>: <span class=\"string\">\"text\"</span>,</span><br><span class=\"line\">\t\t\t\t\t<span class=\"attr\">\"analyzer\"</span>: <span class=\"string\">\"keyword\"</span></span><br><span class=\"line\">\t\t\t\t&#125;</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>导入数据</p>\n<figure class=\"highlight json\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">PUT /address/_bulk</span><br><span class=\"line\">&#123; <span class=\"attr\">\"index\"</span>: &#123; <span class=\"attr\">\"_id\"</span>: <span class=\"number\">1</span> &#125;&#125;</span><br><span class=\"line\">&#123; <span class=\"attr\">\"postcode\"</span>: <span class=\"string\">\"W1V 3DG\"</span> &#125;</span><br><span class=\"line\">&#123; <span class=\"attr\">\"index\"</span>: &#123; <span class=\"attr\">\"_id\"</span>: <span class=\"number\">2</span> &#125;&#125;</span><br><span class=\"line\">&#123; <span class=\"attr\">\"postcode\"</span>: <span class=\"string\">\"W2F 8HW\"</span> &#125;</span><br><span class=\"line\">&#123; <span class=\"attr\">\"index\"</span>: &#123; <span class=\"attr\">\"_id\"</span>: <span class=\"number\">3</span> &#125;&#125;</span><br><span class=\"line\">&#123; <span class=\"attr\">\"postcode\"</span>: <span class=\"string\">\"W1F 7HW\"</span> &#125;</span><br><span class=\"line\">&#123; <span class=\"attr\">\"index\"</span>: &#123; <span class=\"attr\">\"_id\"</span>: <span class=\"number\">4</span> &#125;&#125;</span><br><span class=\"line\">&#123; <span class=\"attr\">\"postcode\"</span>: <span class=\"string\">\"WC1N 1LZ\"</span> &#125;</span><br><span class=\"line\">&#123; <span class=\"attr\">\"index\"</span>: &#123; <span class=\"attr\">\"_id\"</span>: <span class=\"number\">5</span> &#125;&#125;</span><br><span class=\"line\">&#123; <span class=\"attr\">\"postcode\"</span>: <span class=\"string\">\"SW5 0BE\"</span> &#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>倒排表</p>\n<table>\n<thead>\n<tr>\n<th align=\"center\">Term</th>\n<th align=\"center\">Doc IDs</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\">“SW5 0BE”</td>\n<td align=\"center\">5</td>\n</tr>\n<tr>\n<td align=\"center\">“W1F 7HW”</td>\n<td align=\"center\">3</td>\n</tr>\n<tr>\n<td align=\"center\">“W1V 3DG”</td>\n<td align=\"center\">1</td>\n</tr>\n<tr>\n<td align=\"center\">“W2F 8HW”</td>\n<td align=\"center\">2</td>\n</tr>\n<tr>\n<td align=\"center\">“WC1N 1LZ”</td>\n<td align=\"center\">4</td>\n</tr>\n</tbody></table>\n</li>\n<li><p>前缀匹配（prefix）</p>\n<p>匹配postcode字段以“W1”开头的文档</p>\n<figure class=\"highlight json\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">GET /address/_search</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"attr\">\"query\"</span>: &#123;</span><br><span class=\"line\">        <span class=\"attr\">\"prefix\"</span>: &#123;</span><br><span class=\"line\">            <span class=\"attr\">\"postcode\"</span>: <span class=\"string\">\"W1\"</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>通配符查询（wildcard）</p>\n<figure class=\"highlight json\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">GET /address/_search</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"attr\">\"query\"</span>: &#123;</span><br><span class=\"line\">        <span class=\"attr\">\"wildcard\"</span>: &#123;</span><br><span class=\"line\">            <span class=\"attr\">\"postcode\"</span>: <span class=\"string\">\"W?F*HW\"</span> </span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>正则匹配（regexp）</p>\n<figure class=\"highlight json\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">GET /address/_search</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"attr\">\"query\"</span>: &#123;</span><br><span class=\"line\">        <span class=\"attr\">\"regexp\"</span>: &#123;</span><br><span class=\"line\">            <span class=\"attr\">\"postcode\"</span>: <span class=\"string\">\"W[0-9].+\"</span> </span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n</li>\n</ol>\n<p><strong>不配置分词规则带来的影响</strong></p>\n<blockquote>\n<p> 栗子：title字段为“Quick brown fox” ，倒排索引中会生成： quick 、 brown 和 fox </p>\n<table>\n<thead>\n<tr>\n<th>{ “regexp”: { “title”: “br.*” }}</th>\n<th>可以匹配</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>{ “regexp”: { “title”: “Qu.*” }}</td>\n<td>匹配不到：quick为小写</td>\n</tr>\n<tr>\n<td>{ “regexp”: { “title”: “quick br*” }}</td>\n<td>匹配不到：quick和brown是分开的</td>\n</tr>\n</tbody></table>\n</blockquote>\n<h1 id=\"三、聚合分组\"><a href=\"#三、聚合分组\" class=\"headerlink\" title=\"三、聚合分组\"></a>三、聚合分组</h1><p>ElasticSearch除了致力于搜索之外，也提供了聚合实时分析数据的功能，透过聚合，我们可以得到一个数据的概览，分析和总结全套的数据</p>\n<p>对相同的数据进行 搜索/过滤 + 分析，两个愿望一次满足</p>\n<p>聚合的两个主要的概念，分别是 桶 和 指标</p>\n<ul>\n<li><p>桶(Buckets) : 满足特定条件的文档的集合</p>\n<ol>\n<li><p>当聚合开始被执行，每个文档会决定符合哪个桶的条件，如果匹配到，文档将放入相应的桶并接着进行聚合操作</p>\n<blockquote>\n<p>像是一个员工属于男性桶或者女性桶</p>\n</blockquote>\n</li>\n<li><p>桶可以被嵌套在其他桶里面</p>\n<blockquote>\n<p>北京能放在中国桶裡</p>\n</blockquote>\n</li>\n</ol>\n</li>\n<li><p>指标(Metrics) : 对桶内的文档进行统计计算</p>\n<ol>\n<li><p>桶能让我们划分文档到有意义的集合， 但是最终我们需要的是对这些桶内的文档进行一些指标的计算</p>\n</li>\n<li><p>指标通常是简单的数学运算(像是min、max、avg、sum）</p>\n<blockquote>\n<p>计算像平均薪资、最高出售价格、95%的查询延迟这样的数据</p>\n</blockquote>\n</li>\n</ol>\n</li>\n</ul>\n<h3 id=\"执行顺序\"><a href=\"#执行顺序\" class=\"headerlink\" title=\"执行顺序\"></a>执行顺序</h3><p>当query和aggs一起存在时，会先执行query的主查询，主查询query执行完后会搜出一批结果，而这些结果才会被拿去aggs拿去做聚合</p>\n<figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">    \"query\": &#123; ... &#125;,</span><br><span class=\"line\">    \"size\": 0,</span><br><span class=\"line\">    \"aggs\": &#123;</span><br><span class=\"line\">        \"custom_name1\": &#123;  //aggs后面接著的是一个自定义的name</span><br><span class=\"line\">            \"桶\": &#123; ... &#125;  //再来才是接桶</span><br><span class=\"line\">        &#125;,</span><br><span class=\"line\">        \"custom_name2\": &#123;  //一个aggs裡可以有很多聚合</span><br><span class=\"line\">            \"桶\": &#123; ... &#125;</span><br><span class=\"line\">        &#125;,</span><br><span class=\"line\">        \"custom_name3\": &#123;</span><br><span class=\"line\">            \"桶\": &#123;</span><br><span class=\"line\">               .....</span><br><span class=\"line\">            &#125;,</span><br><span class=\"line\">            \"aggs\": &#123;  //aggs可以嵌套在别的aggs裡面</span><br><span class=\"line\">                \"in_name\": &#123; //记得使用aggs需要先自定义一个name</span><br><span class=\"line\">                    \"桶\": &#123; ... &#125; //in_name的桶作用的文档是custom_name3的桶的结果</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"常见的桶\"><a href=\"#常见的桶\" class=\"headerlink\" title=\"常见的桶\"></a>常见的桶</h3><ol>\n<li><p>terms桶 : 针对某个field的值进行分组，field有几种值就分成几组</p>\n<ul>\n<li><p>terms桶在进行分组时，会爲此field中的每种值创建一个新的桶</p>\n</li>\n<li><p>要注意此 “terms桶” 和平常用在主查询query中的 “查找terms” 是不同的东西</p>\n<blockquote>\n<p>测试数据</p>\n<figure class=\"highlight json\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123; <span class=\"attr\">\"color\"</span>: <span class=\"string\">\"red\"</span> &#125;</span><br><span class=\"line\">&#123; <span class=\"attr\">\"color\"</span>: <span class=\"string\">\"green\"</span> &#125;</span><br><span class=\"line\">&#123; <span class=\"attr\">\"color\"</span>: [<span class=\"string\">\"red\"</span>, <span class=\"string\">\"blue\"</span>] &#125;</span><br></pre></td></tr></table></figure>\n\n<p>dsl语句</p>\n<figure class=\"highlight json\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"attr\">\"query\"</span>: &#123;</span><br><span class=\"line\">        <span class=\"attr\">\"match_all\"</span>: &#123;&#125;</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    <span class=\"attr\">\"size\"</span>: <span class=\"number\">0</span>,</span><br><span class=\"line\">    <span class=\"attr\">\"aggs\"</span>: &#123;</span><br><span class=\"line\">        <span class=\"attr\">\"my_name\"</span>: &#123;</span><br><span class=\"line\">            <span class=\"attr\">\"terms\"</span>: &#123;</span><br><span class=\"line\">                <span class=\"attr\">\"field\"</span>: <span class=\"string\">\"color\"</span> <span class=\"comment\">//使用color来进行分组</span></span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>结果</p>\n<figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">\"aggregations\": &#123;</span><br><span class=\"line\">    \"my_name\": &#123;</span><br><span class=\"line\">        \"doc_count_error_upper_bound\": 0,</span><br><span class=\"line\">        \"sum_other_doc_count\": 0,</span><br><span class=\"line\">        \"buckets\": [</span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                <span class=\"attr\">\"key\"</span>: <span class=\"string\">\"blue\"</span>,</span><br><span class=\"line\">                <span class=\"attr\">\"doc_count\"</span>: <span class=\"number\">1</span></span><br><span class=\"line\">            &#125;,</span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                <span class=\"attr\">\"key\"</span>: <span class=\"string\">\"red\"</span>,</span><br><span class=\"line\">                <span class=\"attr\">\"doc_count\"</span>: <span class=\"number\">2</span>  <span class=\"comment\">//表示color为red的文档有2个，此例中就是 &#123;\"color\": \"red\"&#125; 和 &#123;\"color\": [\"red\", \"blue\"]&#125;这两个文档</span></span><br><span class=\"line\">            &#125;,</span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                <span class=\"attr\">\"key\"</span>: <span class=\"string\">\"green\"</span>,</span><br><span class=\"line\">                <span class=\"attr\">\"doc_count\"</span>: <span class=\"number\">1</span></span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        ]</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n</blockquote>\n</li>\n</ul>\n</li>\n<li><p>filter桶 : 一个用来过滤的桶</p>\n<ul>\n<li><p>要注意此处的 “filter桶” 和用在主查询query的 “过滤filter” 的用法是一模一样的，都是过滤，不过差别是 “filter桶” 会自己给创建一个新的桶，而不会像 “过滤filter” 一样依附在query下，因为filter桶毕竟还是一个聚合桶，因此他可以和别的桶进行嵌套，但他不是依附在别的桶上</p>\n<blockquote>\n<p>测试数据</p>\n<p>同上</p>\n<p>dsl语句</p>\n<figure class=\"highlight json\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"attr\">\"query\"</span>: &#123;</span><br><span class=\"line\">        <span class=\"attr\">\"match_all\"</span>: &#123;&#125;</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    <span class=\"attr\">\"size\"</span>: <span class=\"number\">0</span>,</span><br><span class=\"line\">    <span class=\"attr\">\"aggs\"</span>: &#123;</span><br><span class=\"line\">        <span class=\"attr\">\"my_name\"</span>: &#123;</span><br><span class=\"line\">            <span class=\"attr\">\"filter\"</span>: &#123; <span class=\"comment\">//因为他用法跟一般的过滤filter一样，所以也能使用bool嵌套</span></span><br><span class=\"line\">                <span class=\"attr\">\"bool\"</span>: &#123;</span><br><span class=\"line\">                    <span class=\"attr\">\"must\"</span>: &#123;</span><br><span class=\"line\">                        <span class=\"attr\">\"terms\"</span>: &#123; <span class=\"comment\">//注意此terms是查找terms，不是terms桶</span></span><br><span class=\"line\">                            <span class=\"attr\">\"color\"</span>: [ <span class=\"string\">\"red\"</span>, <span class=\"string\">\"blue\"</span> ]</span><br><span class=\"line\">                        &#125;</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>结果</p>\n<figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">\"aggregations\": &#123;</span><br><span class=\"line\">    \"my_name\": &#123;</span><br><span class=\"line\">        \"doc_count\": 2 //filter桶计算出来的文档数量</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n</blockquote>\n</li>\n</ul>\n</li>\n<li><p>top_hits桶 : 在某个桶底下找出这个桶的前几笔hits，返回的hits格式和主查询query返回的hits格式一模一样</p>\n<ul>\n<li><p>参数</p>\n<ol>\n<li><p>from、size</p>\n</li>\n<li><p>sort：sort : 设置返回的hits的排序</p>\n<ul>\n<li><p>要注意，假设在主查询query裡已经对数据设置了排序sort，此sort并不会对aggs裡面的数据造成影响，也就是说主查询query查找出来的数据会先丢进aggs而非先经过sort，因此就算主查询设置了sort，也不会影响aggs数据裡的排序因此如果在top_hits桶裡的返回的hits数据想要排序，需要自己在top_hits桶裡设置sort</p>\n</li>\n<li><p>如果没有设置sort，默认使用主查询query所查出来的_score排序</p>\n</li>\n</ul>\n</li>\n<li><p>_source : 设置返回的字段</p>\n</li>\n</ol>\n<blockquote>\n<p>测试数据</p>\n<figure class=\"highlight json\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123; <span class=\"attr\">\"color\"</span>: <span class=\"string\">\"red\"</span>, <span class=\"attr\">\"price\"</span>: <span class=\"number\">100</span> &#125;</span><br><span class=\"line\">&#123; <span class=\"attr\">\"color\"</span>: [<span class=\"string\">\"red\"</span>, <span class=\"string\">\"blue\"</span>], <span class=\"attr\">\"price\"</span>: <span class=\"number\">1000</span> &#125;</span><br></pre></td></tr></table></figure>\n\n<p>dsl语句</p>\n<p>使用terms桶分组，再使用top_hits桶找出每个group裡面的price最小的前5笔hits</p>\n<figure class=\"highlight json\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"attr\">\"query\"</span>: &#123;</span><br><span class=\"line\">        <span class=\"attr\">\"match_all\"</span>: &#123;&#125;</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    <span class=\"attr\">\"size\"</span>: <span class=\"number\">0</span>,</span><br><span class=\"line\">    <span class=\"attr\">\"aggs\"</span>: &#123;</span><br><span class=\"line\">        <span class=\"attr\">\"my_name\"</span>: &#123;</span><br><span class=\"line\">            <span class=\"attr\">\"terms\"</span>: &#123;</span><br><span class=\"line\">                <span class=\"attr\">\"field\"</span>: <span class=\"string\">\"color\"</span></span><br><span class=\"line\">            &#125;,</span><br><span class=\"line\">            <span class=\"attr\">\"aggs\"</span>: &#123;</span><br><span class=\"line\">                <span class=\"attr\">\"my_top_hits\"</span>: &#123;</span><br><span class=\"line\">                    <span class=\"attr\">\"top_hits\"</span>: &#123;</span><br><span class=\"line\">                        <span class=\"attr\">\"size\"</span>: <span class=\"number\">5</span>,</span><br><span class=\"line\">                        <span class=\"attr\">\"sort\"</span>: &#123;</span><br><span class=\"line\">                            <span class=\"attr\">\"price\"</span>: <span class=\"string\">\"asc\"</span></span><br><span class=\"line\">                        &#125;</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>结果</p>\n<figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">\"aggregations\": &#123;</span><br><span class=\"line\">    \"my_name\": &#123;</span><br><span class=\"line\">        \"doc_count_error_upper_bound\": 0,</span><br><span class=\"line\">        \"sum_other_doc_count\": 0,</span><br><span class=\"line\">        \"buckets\": [</span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                <span class=\"attr\">\"key\"</span>: <span class=\"string\">\"red\"</span>,</span><br><span class=\"line\">                <span class=\"attr\">\"doc_count\"</span>: <span class=\"number\">2</span>,  <span class=\"comment\">//terms桶计算出来的color为red的文档数</span></span><br><span class=\"line\">                <span class=\"attr\">\"my_top_hits\"</span>: &#123;</span><br><span class=\"line\">                    <span class=\"attr\">\"hits\"</span>: &#123;  <span class=\"comment\">//top_hits桶找出color为red的这些文档中，price从小到大排序取前5笔</span></span><br><span class=\"line\">                        <span class=\"attr\">\"total\"</span>: <span class=\"number\">2</span>,</span><br><span class=\"line\">                        <span class=\"attr\">\"max_score\"</span>: <span class=\"literal\">null</span>,</span><br><span class=\"line\">                        <span class=\"attr\">\"hits\"</span>: [</span><br><span class=\"line\">                            &#123;</span><br><span class=\"line\">                                <span class=\"attr\">\"_score\"</span>: <span class=\"literal\">null</span>,</span><br><span class=\"line\">                                <span class=\"attr\">\"_source\"</span>: &#123; <span class=\"attr\">\"color\"</span>: <span class=\"string\">\"red\"</span>, <span class=\"attr\">\"price\"</span>: <span class=\"number\">100</span> &#125;,</span><br><span class=\"line\">                                <span class=\"attr\">\"sort\"</span>: [ <span class=\"number\">100</span> ]</span><br><span class=\"line\">                            &#125;,</span><br><span class=\"line\">                            &#123;</span><br><span class=\"line\">                                <span class=\"attr\">\"_score\"</span>: <span class=\"literal\">null</span>,</span><br><span class=\"line\">                                <span class=\"attr\">\"_source\"</span>: &#123; <span class=\"attr\">\"color\"</span>: [ <span class=\"string\">\"red\"</span>, <span class=\"string\">\"blue\"</span> ], <span class=\"attr\">\"price\"</span>: <span class=\"number\">1000</span> &#125;,</span><br><span class=\"line\">                                <span class=\"attr\">\"sort\"</span>: [ <span class=\"number\">1000</span> ]</span><br><span class=\"line\">                            &#125;</span><br><span class=\"line\">                        ]</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;,</span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                <span class=\"attr\">\"key\"</span>: <span class=\"string\">\"blue\"</span>,</span><br><span class=\"line\">                <span class=\"attr\">\"doc_count\"</span>: <span class=\"number\">1</span>,  <span class=\"comment\">//terms桶计算出来的color为blue的文档数</span></span><br><span class=\"line\">                <span class=\"attr\">\"my_top_hits\"</span>: &#123;</span><br><span class=\"line\">                    <span class=\"attr\">\"hits\"</span>: &#123; <span class=\"comment\">//top_hits桶找出的hits</span></span><br><span class=\"line\">                        <span class=\"attr\">\"total\"</span>: <span class=\"number\">1</span>,</span><br><span class=\"line\">                        <span class=\"attr\">\"max_score\"</span>: <span class=\"literal\">null</span>,</span><br><span class=\"line\">                        <span class=\"attr\">\"hits\"</span>: [</span><br><span class=\"line\">                            &#123;</span><br><span class=\"line\">                                <span class=\"attr\">\"_source\"</span>: &#123;</span><br><span class=\"line\">                                    <span class=\"attr\">\"color\"</span>: [ <span class=\"string\">\"red\"</span>, <span class=\"string\">\"blue\"</span> ], <span class=\"attr\">\"price\"</span>: <span class=\"number\">1000</span> &#125;,</span><br><span class=\"line\">                                <span class=\"attr\">\"sort\"</span>: [ <span class=\"number\">1000</span> ]</span><br><span class=\"line\">                            &#125;</span><br><span class=\"line\">                        ]</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        ]</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n</blockquote>\n</li>\n</ul>\n</li>\n<li><p>date_histogram桶，对指定时间段内数据进行分组</p>\n<ul>\n<li><p>参数</p>\n<ol>\n<li>time_zone:”+08:00”：设置市区（东八区），不指定会影响分组时间错误</li>\n<li>interval：聚合时间间隔<ul>\n<li>year（1y）年</li>\n<li>quarter（1q）季度</li>\n<li>month（1M）月份</li>\n<li>week（1w）星期</li>\n<li>day（1d）天</li>\n<li>hour（1h）小时</li>\n<li>minute（1m）分钟</li>\n<li>second（1s）秒</li>\n</ul>\n</li>\n<li>format：指定返回时间格式</li>\n</ol>\n<blockquote>\n<p>dsl语句</p>\n<figure class=\"highlight json\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"attr\">\"query\"</span>: &#123;</span><br><span class=\"line\">        <span class=\"attr\">\"match_all\"</span>: &#123;&#125;</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    <span class=\"attr\">\"size\"</span>: <span class=\"number\">0</span>,</span><br><span class=\"line\"><span class=\"attr\">\"aggs\"</span>: &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 自己取的聚合名字</span></span><br><span class=\"line\">            <span class=\"attr\">\"group_by_grabTime\"</span>: &#123;</span><br><span class=\"line\">                <span class=\"comment\">// es提供的时间处理函数</span></span><br><span class=\"line\">                <span class=\"attr\">\"date_histogram\"</span>: &#123;</span><br><span class=\"line\">                    <span class=\"comment\">// 需要聚合分组的字段名称, 类型需要为date, 格式没有要求</span></span><br><span class=\"line\">                    <span class=\"attr\">\"field\"</span>: <span class=\"string\">\"@timestamp\"</span>,</span><br><span class=\"line\">                    <span class=\"comment\">// 按什么时间段聚合, 这里是5分钟, 可用的interval在上面给出</span></span><br><span class=\"line\">                    <span class=\"attr\">\"interval\"</span>: <span class=\"string\">\"5m\"</span>,</span><br><span class=\"line\">                    <span class=\"comment\">// 设置时区, 这样就相当于东八区的时间</span></span><br><span class=\"line\">                    <span class=\"attr\">\"time_zone\"</span>:<span class=\"string\">\"+08:00\"</span>,</span><br><span class=\"line\">                    <span class=\"comment\">// 返回值格式化，HH大写，不然不能区分上午、下午</span></span><br><span class=\"line\">                    <span class=\"attr\">\"format\"</span>: <span class=\"string\">\"yyyy-MM-dd HH\"</span>,   </span><br><span class=\"line\">                    <span class=\"comment\">// 为空的话则填充0</span></span><br><span class=\"line\">                    <span class=\"attr\">\"min_doc_count\"</span>: <span class=\"number\">0</span>,</span><br><span class=\"line\">                    <span class=\"comment\">// 需要填充0的范围</span></span><br><span class=\"line\">                    <span class=\"attr\">\"extended_bounds\"</span>: &#123;</span><br><span class=\"line\">                        <span class=\"attr\">\"min\"</span>: <span class=\"number\">1533556800000</span>,</span><br><span class=\"line\">                        <span class=\"attr\">\"max\"</span>: <span class=\"number\">1533806520000</span></span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                &#125;,</span><br><span class=\"line\">                <span class=\"comment\">// 聚合</span></span><br><span class=\"line\">                <span class=\"attr\">\"aggs\"</span>: &#123;</span><br><span class=\"line\">                    <span class=\"comment\">// 自己取的名称</span></span><br><span class=\"line\">                    <span class=\"attr\">\"group_by_status\"</span>: &#123;</span><br><span class=\"line\">                        <span class=\"comment\">// es提供</span></span><br><span class=\"line\">                        <span class=\"attr\">\"terms\"</span>: &#123;</span><br><span class=\"line\">                            <span class=\"comment\">// 聚合字段名</span></span><br><span class=\"line\">                            <span class=\"attr\">\"field\"</span>: <span class=\"string\">\"LowStatusOfPrice\"</span></span><br><span class=\"line\">                        &#125;</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br></pre></td></tr></table></figure></blockquote>\n</li>\n</ul>\n</li>\n</ol>"},{"title":"Python操作Excel文件","date":"2020-07-11T03:15:21.000Z","top":0,"_content":"\n# python操作excel文件\n\n### 一、xlrd和xlwt读写 \n\n**常用单元格中的数据类型：**\n\n- **0. empty（空的）,1 string（text）, 2 number, 3 date, 4 boolean, 5 error， 6 blank（空白表格）**\n\n#### 1. 安装\n\n```bash\npip install xlrd\t# 读取\npip install xlwt\t# 写入\n```\n\n<!--more-->\n\n#### 2. 读取（xlrd）\n\n- 导入模块\n\n  `import xlrd`\n\n- 打开Excel文件\n\n  `workbook = xlrd.open_workbook('file_path')`\n\n- 使用\n\n  - 获取工作表\n\n    ```python\n    sheet = workbook.sheets()[0]\t\t\t\t\t# 通过索引顺序获取\n    sheet = workbook.sheet_by_index(0)\t\t\t\t# 通过索引顺序获取\n    sheet = workbook.sheet_by_name(u'sheet_name')\t# 通过名称获取\n    ```\n\n  -  获取整行和整列的值（数组）\n\n    ```python\n    # i：数值 读取哪行或哪列\n    sheet.row_values(i)\n    sheet.col_values(i)\n    ```\n\n  - 读取行数和列数\n\n    ```python\n    nrows = sheet.nrows\n    ncols = sheet.ncols\n    ```\n\n  - 读取行列数据类型\n\n    ```python\n    # slice返回：[类型:值]\n    row_type = sheet.row_slice(0)\n    col_type = sheet.col_slice(0)\n    \n    # types返回对应类型列表：[1, 1, 1]\n    row_type = sheet.row_types(0)\n    col_type = sheet.col_types(0)\n    ```\n\n  - 读取单元格\n\n    ```python\n    # 先行后列\n    A1 = sheet.cell(0,0).value\n    C4 = sheet.cell(3,2).value\n    \n    A1 = sheet.cell_value(0,0)\n    C4 = sheet.cell_value(3,2)\n    \n    # 使用行列索引\n    A1 = sheet.row(0)[0].value\t# 一行一列\n    C4 = sheet.row(3)[2].value\t# 四行三列\n    C4 = sheet.col(2)[3].value\t# 三列四行\n    ```\n\n> test.xlsx文件\n>\n> ![image-20200712113803995](https://tupian-1300728887.cos.ap-chengdu.myqcloud.com/excel.png)\n>\n> demo代码块\n>\n> ```python\n> # python2.7\n> # -*- coding:utf-8 -*-\n> import sys\n> import xlwt\n> \n> # 修改编译格式（防乱码）\n> default_encoding = 'utf-8'\n> if sys.getdefaultencoding() != default_encoding:\n>     reload(sys)\n>     sys.setdefaultencoding(default_encoding)\n> \n> def read_excel(sheet_name):\n>     # 打开文件 file_path：文件路径\n>     workbook = xlrd.open_workbook('test.xlsx', formatting_info=False)\n>     # formatting_info默认为True，指定False可读取.xlsx文件\n>     sheet = workbook.sheet_by_name('Sheet1')\t# 指定读取sheet\n> \n>     # 行列数据\n>     print '第一行：', sheet.row_values(0)\n>     # 第一行： ['A1', 'B1', 'C1', 'D1', 'E1', 'F1'...]\n>     print '第一列：', sheet.col_values(0)\n>     # 第一列： ['A1', 'A2', 'A3', 'A4', 'A5', 'A6'...]\n> \n>     # 行列数\n>     print '行数：', sheet.nrows\t# 行数： 17\n>     print '列数：', sheet.ncols\t# 列数： 9\n>     \n>     # 行列类型\n>     print sheet.row_slice(0)\t# [text:'A1', text:'B1', text:'C1'...]\n>     print sheet.col_slice(0)\n>     \n>     print sheet.row_types(0)\t# [1, 1, 1, 1, 1...]\n>     print sheet.col_types(0)\n>     \n>     # 单元格\n>     print sheet.cell(0,0).value\t\t# A1\n>     print sheet.cell(3,2).value\t\t# C4\n>     \n>     print sheet.cell_value(0,0)\t\t# A1\n>     print sheet.cell_value(3,2)\t\t# C4\n>     \n>     print sheet.row(0)[0].value\t# 一行一列\tA1\n>     print sheet.row(3)[2].value\t# 四行三列\tC4\n>     print sheet.col(2)[3].value\t# 三列四行\tC4\n> \n> read_excel()\n> ```\n\n\n\n#### 3. 写入（xlwt）\n\n> 注：xlwt不支持xlsx\n\n- 导入模块\n\n  `import xlwt`\n\n- 打开Excel文件\n\n  `book = xlwt.Workbook(encoding='utf-8')`\n\n- 使用\n\n  - 设置字体\n\n    ```python\n    font = xlwt.Font()\t\t\t# 为样式创建字体\n    font.bold = True \t\t\t# 粗体\n    font.italic = True \t\t\t# 斜体\n    font.underline = 10 \t\t# 下划线(其中当值为9，整行的填充色为蓝色)\n    font.struck_out = True \t\t# 删除线\n    font.name = u'微软雅黑'\t\t # 字体\n    font.color = 'black'\t\t# 颜色\n    font.height= 220 \t\t\t#字体大小，220就是11号字体，大概就是11*20得来的吧\n    ```\n\n  - 居中\n\n    ```python\n    alignment = xlwt.Alignment()\t\t\t\t# 设置字体在单元格的位置\n    alignment.horz = xlwt.Alignment.HORZ_CENTER # 水平方向\n    alignment.vert = xlwt.Alignment.VERT_TOP  \t# 垂直方向\n    ```\n\n  - 背景颜色\n\n    ```python\n    pattern = xlwt.Pattern()\n    pattern.pattern = xlwt.Pattern.SOLID_PATTERN\n    pattern.pattern_fore_colour = i\t\t\t\t\t# i:可选值\n    ```\n\n    - 可选参数：\n\n      ![](https://tupian-1300728887.cos.ap-chengdu.myqcloud.com/%E9%A2%9C%E8%89%B2%E5%AF%B9%E7%85%A7%E8%A1%A8.png)\n\n  - 设置边框\n\n    - 细实线:1，小粗实线:2，细虚线:3，中细虚线:4，大粗实线:5，双线:6，细点虚线:7\n\n      大粗虚线:8，细点划线:9，粗点划线:10，细双点划线:11，粗双点划线:12，斜点划线:13\n\n    ```python\n    border = xlwt.Borders() \t\t\t\t# 给单元格加框线, 1:细实线\n    border.left = 1\n    border.top = 1\n    border.right =1\n    border.bottom = 1\n    \n    border.left_colour = 0 \t\t\t\t\t#设置框线颜色，0:黑色\n    border.right_colour = 0\n    border.top_colour = 0\n    border.bottom_colour = 0\n    ```\n\n  - 加超链接\n\n    ```python\n    # 输出文本百度，为超链接第一行第一列\n    sheet.write(0, 0, xlwt.Formula('HYPERLINK(\"https://www.baidu.com\";\"百度\")'))\n    ```\n\n> demo代码块\n>\n> ```python\n> # python2.7\n> # -*- coding:utf-8 -*-\n> import sys\n> import xlwt\n> \n> # 修改编译格式（防乱码）\n> default_encoding = 'utf-8'\n> if sys.getdefaultencoding() != default_encoding:\n>     reload(sys)\n>     sys.setdefaultencoding(default_encoding)\n>     \n> def write_excel():\n>     data_list = [['姓名', '性别', '年龄'],\n>                  ['张三', '男', 18],\n>                  ['李雷', '女', 22],\n>                  ['韩梅梅', '女', 20]]\n>     try:\n>         book = xlwt.Workbook(encoding='utf-8')\n> \n>         # 设置字体\n>         font = xlwt.Font()\n>         font.bold = True\n> \n>         # 设置居中\n>         alignment = xlwt.Alignment()\n>         alignment.horz = xlwt.Alignment.HORZ_CENTER  # 水平方向\n>         alignment.vert = xlwt.Alignment.VERT_TOP  # 垂直方向\n> \n>         # 设置背景颜色\n>         pattern = xlwt.Pattern()\n>         pattern.pattern = xlwt.Pattern.SOLID_PATTERN\n>         pattern.pattern_fore_colour = 22  # 背景颜色\n> \n>         # 设置边框\n>         borders = xlwt.Borders()\n>         borders.left = xlwt.Borders.THIN\n>         borders.right = xlwt.Borders.THIN\n>         borders.top = xlwt.Borders.THIN\n>         borders.bottom = xlwt.Borders.THIN\n>         \n>         borders.left_colour = 0 \t\t\t\t#设置框线颜色\n>         borders.right_colour = 0\n>         borders.top_colour = 0\n>         borders.bottom_colour = 0\n> \n>         # 定义不同的excel style\n>         style1 = xlwt.XFStyle()\t# 初始化样式\n>         style1.font = font\n>         style1.alignment = alignment\n>         style1.pattern = pattern\n>         style1.borders = borders\n> \n>         style2 = xlwt.XFStyle()\n>         style2.alignment = alignment\n>         style2.borders = borders\n>         \n>         # 指定sheet\n>         sheet = book.add_sheet('人员添加')\n>         # 列宽自适应\n>         set_width(sheet, data_list)\n>         # 写入数据\n>         for row in range(len(data_list)):\n>             for col in range(len(data_list[row])):\n>                 # 标题格式\n>                 if row == 0:\n>                     sheet.write(row, col, data_list[row][col], style=style1)\n>                 else:\n>                     sheet.write(row, col, data_list[row][col], style=style2)\n>         sheet.write(0, 0, xlwt.Formula('HYPERLINK(\"https://www.baidu.com\";\"百度\")')) \n>         # 输出文本百度，为超链接第一行第一列\n>         book.save('test.xls'.decode('utf-8'))\n>     except Exception, e:\n>         print e\n> \n> # 获取字符串长度，一个中文的长度为2\n> def len_byte(value):\n>     length = len(value)\n>     utf8_length = len(value.encode('utf-8'))\n>     length = (utf8_length - length) / 2 + length\n>     return int(length)\n> \n> def set_width(sheet, data_list):\n>     # 确定栏位宽度\n>     col_width = []\n>     for i in range(len(data_list)):\n>         for j in range(len(data_list[i])):\n>             if i == 0:\n>                 col_width.append(len_byte(data_list[i][j]))\n>             else:\n>                 if col_width[j] < len_byte(str(data_list[i][j])):\n>                     col_width[j] = len_byte(data_list[i][j])\n> \n>     # 设置栏位宽度，栏位宽度小于10时候采用默认宽度\n>     for i in range(len(col_width)):\n>         if col_width[i] > 10:\n>             sheet.col(i).width = 256 * (col_width[i] + 1)\n>             \n> write_excel()\n> ```\n>\n> 运行效果\n>\n> ![image-20200712162231433](https://tupian-1300728887.cos.ap-chengdu.myqcloud.com/image-20200712162231433.png)\n\n\n\n\n\n","source":"_posts/Python操作Excel文件.md","raw":"---\ntitle: Python操作Excel文件\ndate: 2020-07-11 11:15:21\ntags: Python\ntop: 0\n---\n\n# python操作excel文件\n\n### 一、xlrd和xlwt读写 \n\n**常用单元格中的数据类型：**\n\n- **0. empty（空的）,1 string（text）, 2 number, 3 date, 4 boolean, 5 error， 6 blank（空白表格）**\n\n#### 1. 安装\n\n```bash\npip install xlrd\t# 读取\npip install xlwt\t# 写入\n```\n\n<!--more-->\n\n#### 2. 读取（xlrd）\n\n- 导入模块\n\n  `import xlrd`\n\n- 打开Excel文件\n\n  `workbook = xlrd.open_workbook('file_path')`\n\n- 使用\n\n  - 获取工作表\n\n    ```python\n    sheet = workbook.sheets()[0]\t\t\t\t\t# 通过索引顺序获取\n    sheet = workbook.sheet_by_index(0)\t\t\t\t# 通过索引顺序获取\n    sheet = workbook.sheet_by_name(u'sheet_name')\t# 通过名称获取\n    ```\n\n  -  获取整行和整列的值（数组）\n\n    ```python\n    # i：数值 读取哪行或哪列\n    sheet.row_values(i)\n    sheet.col_values(i)\n    ```\n\n  - 读取行数和列数\n\n    ```python\n    nrows = sheet.nrows\n    ncols = sheet.ncols\n    ```\n\n  - 读取行列数据类型\n\n    ```python\n    # slice返回：[类型:值]\n    row_type = sheet.row_slice(0)\n    col_type = sheet.col_slice(0)\n    \n    # types返回对应类型列表：[1, 1, 1]\n    row_type = sheet.row_types(0)\n    col_type = sheet.col_types(0)\n    ```\n\n  - 读取单元格\n\n    ```python\n    # 先行后列\n    A1 = sheet.cell(0,0).value\n    C4 = sheet.cell(3,2).value\n    \n    A1 = sheet.cell_value(0,0)\n    C4 = sheet.cell_value(3,2)\n    \n    # 使用行列索引\n    A1 = sheet.row(0)[0].value\t# 一行一列\n    C4 = sheet.row(3)[2].value\t# 四行三列\n    C4 = sheet.col(2)[3].value\t# 三列四行\n    ```\n\n> test.xlsx文件\n>\n> ![image-20200712113803995](https://tupian-1300728887.cos.ap-chengdu.myqcloud.com/excel.png)\n>\n> demo代码块\n>\n> ```python\n> # python2.7\n> # -*- coding:utf-8 -*-\n> import sys\n> import xlwt\n> \n> # 修改编译格式（防乱码）\n> default_encoding = 'utf-8'\n> if sys.getdefaultencoding() != default_encoding:\n>     reload(sys)\n>     sys.setdefaultencoding(default_encoding)\n> \n> def read_excel(sheet_name):\n>     # 打开文件 file_path：文件路径\n>     workbook = xlrd.open_workbook('test.xlsx', formatting_info=False)\n>     # formatting_info默认为True，指定False可读取.xlsx文件\n>     sheet = workbook.sheet_by_name('Sheet1')\t# 指定读取sheet\n> \n>     # 行列数据\n>     print '第一行：', sheet.row_values(0)\n>     # 第一行： ['A1', 'B1', 'C1', 'D1', 'E1', 'F1'...]\n>     print '第一列：', sheet.col_values(0)\n>     # 第一列： ['A1', 'A2', 'A3', 'A4', 'A5', 'A6'...]\n> \n>     # 行列数\n>     print '行数：', sheet.nrows\t# 行数： 17\n>     print '列数：', sheet.ncols\t# 列数： 9\n>     \n>     # 行列类型\n>     print sheet.row_slice(0)\t# [text:'A1', text:'B1', text:'C1'...]\n>     print sheet.col_slice(0)\n>     \n>     print sheet.row_types(0)\t# [1, 1, 1, 1, 1...]\n>     print sheet.col_types(0)\n>     \n>     # 单元格\n>     print sheet.cell(0,0).value\t\t# A1\n>     print sheet.cell(3,2).value\t\t# C4\n>     \n>     print sheet.cell_value(0,0)\t\t# A1\n>     print sheet.cell_value(3,2)\t\t# C4\n>     \n>     print sheet.row(0)[0].value\t# 一行一列\tA1\n>     print sheet.row(3)[2].value\t# 四行三列\tC4\n>     print sheet.col(2)[3].value\t# 三列四行\tC4\n> \n> read_excel()\n> ```\n\n\n\n#### 3. 写入（xlwt）\n\n> 注：xlwt不支持xlsx\n\n- 导入模块\n\n  `import xlwt`\n\n- 打开Excel文件\n\n  `book = xlwt.Workbook(encoding='utf-8')`\n\n- 使用\n\n  - 设置字体\n\n    ```python\n    font = xlwt.Font()\t\t\t# 为样式创建字体\n    font.bold = True \t\t\t# 粗体\n    font.italic = True \t\t\t# 斜体\n    font.underline = 10 \t\t# 下划线(其中当值为9，整行的填充色为蓝色)\n    font.struck_out = True \t\t# 删除线\n    font.name = u'微软雅黑'\t\t # 字体\n    font.color = 'black'\t\t# 颜色\n    font.height= 220 \t\t\t#字体大小，220就是11号字体，大概就是11*20得来的吧\n    ```\n\n  - 居中\n\n    ```python\n    alignment = xlwt.Alignment()\t\t\t\t# 设置字体在单元格的位置\n    alignment.horz = xlwt.Alignment.HORZ_CENTER # 水平方向\n    alignment.vert = xlwt.Alignment.VERT_TOP  \t# 垂直方向\n    ```\n\n  - 背景颜色\n\n    ```python\n    pattern = xlwt.Pattern()\n    pattern.pattern = xlwt.Pattern.SOLID_PATTERN\n    pattern.pattern_fore_colour = i\t\t\t\t\t# i:可选值\n    ```\n\n    - 可选参数：\n\n      ![](https://tupian-1300728887.cos.ap-chengdu.myqcloud.com/%E9%A2%9C%E8%89%B2%E5%AF%B9%E7%85%A7%E8%A1%A8.png)\n\n  - 设置边框\n\n    - 细实线:1，小粗实线:2，细虚线:3，中细虚线:4，大粗实线:5，双线:6，细点虚线:7\n\n      大粗虚线:8，细点划线:9，粗点划线:10，细双点划线:11，粗双点划线:12，斜点划线:13\n\n    ```python\n    border = xlwt.Borders() \t\t\t\t# 给单元格加框线, 1:细实线\n    border.left = 1\n    border.top = 1\n    border.right =1\n    border.bottom = 1\n    \n    border.left_colour = 0 \t\t\t\t\t#设置框线颜色，0:黑色\n    border.right_colour = 0\n    border.top_colour = 0\n    border.bottom_colour = 0\n    ```\n\n  - 加超链接\n\n    ```python\n    # 输出文本百度，为超链接第一行第一列\n    sheet.write(0, 0, xlwt.Formula('HYPERLINK(\"https://www.baidu.com\";\"百度\")'))\n    ```\n\n> demo代码块\n>\n> ```python\n> # python2.7\n> # -*- coding:utf-8 -*-\n> import sys\n> import xlwt\n> \n> # 修改编译格式（防乱码）\n> default_encoding = 'utf-8'\n> if sys.getdefaultencoding() != default_encoding:\n>     reload(sys)\n>     sys.setdefaultencoding(default_encoding)\n>     \n> def write_excel():\n>     data_list = [['姓名', '性别', '年龄'],\n>                  ['张三', '男', 18],\n>                  ['李雷', '女', 22],\n>                  ['韩梅梅', '女', 20]]\n>     try:\n>         book = xlwt.Workbook(encoding='utf-8')\n> \n>         # 设置字体\n>         font = xlwt.Font()\n>         font.bold = True\n> \n>         # 设置居中\n>         alignment = xlwt.Alignment()\n>         alignment.horz = xlwt.Alignment.HORZ_CENTER  # 水平方向\n>         alignment.vert = xlwt.Alignment.VERT_TOP  # 垂直方向\n> \n>         # 设置背景颜色\n>         pattern = xlwt.Pattern()\n>         pattern.pattern = xlwt.Pattern.SOLID_PATTERN\n>         pattern.pattern_fore_colour = 22  # 背景颜色\n> \n>         # 设置边框\n>         borders = xlwt.Borders()\n>         borders.left = xlwt.Borders.THIN\n>         borders.right = xlwt.Borders.THIN\n>         borders.top = xlwt.Borders.THIN\n>         borders.bottom = xlwt.Borders.THIN\n>         \n>         borders.left_colour = 0 \t\t\t\t#设置框线颜色\n>         borders.right_colour = 0\n>         borders.top_colour = 0\n>         borders.bottom_colour = 0\n> \n>         # 定义不同的excel style\n>         style1 = xlwt.XFStyle()\t# 初始化样式\n>         style1.font = font\n>         style1.alignment = alignment\n>         style1.pattern = pattern\n>         style1.borders = borders\n> \n>         style2 = xlwt.XFStyle()\n>         style2.alignment = alignment\n>         style2.borders = borders\n>         \n>         # 指定sheet\n>         sheet = book.add_sheet('人员添加')\n>         # 列宽自适应\n>         set_width(sheet, data_list)\n>         # 写入数据\n>         for row in range(len(data_list)):\n>             for col in range(len(data_list[row])):\n>                 # 标题格式\n>                 if row == 0:\n>                     sheet.write(row, col, data_list[row][col], style=style1)\n>                 else:\n>                     sheet.write(row, col, data_list[row][col], style=style2)\n>         sheet.write(0, 0, xlwt.Formula('HYPERLINK(\"https://www.baidu.com\";\"百度\")')) \n>         # 输出文本百度，为超链接第一行第一列\n>         book.save('test.xls'.decode('utf-8'))\n>     except Exception, e:\n>         print e\n> \n> # 获取字符串长度，一个中文的长度为2\n> def len_byte(value):\n>     length = len(value)\n>     utf8_length = len(value.encode('utf-8'))\n>     length = (utf8_length - length) / 2 + length\n>     return int(length)\n> \n> def set_width(sheet, data_list):\n>     # 确定栏位宽度\n>     col_width = []\n>     for i in range(len(data_list)):\n>         for j in range(len(data_list[i])):\n>             if i == 0:\n>                 col_width.append(len_byte(data_list[i][j]))\n>             else:\n>                 if col_width[j] < len_byte(str(data_list[i][j])):\n>                     col_width[j] = len_byte(data_list[i][j])\n> \n>     # 设置栏位宽度，栏位宽度小于10时候采用默认宽度\n>     for i in range(len(col_width)):\n>         if col_width[i] > 10:\n>             sheet.col(i).width = 256 * (col_width[i] + 1)\n>             \n> write_excel()\n> ```\n>\n> 运行效果\n>\n> ![image-20200712162231433](https://tupian-1300728887.cos.ap-chengdu.myqcloud.com/image-20200712162231433.png)\n\n\n\n\n\n","slug":"Python操作Excel文件","published":1,"updated":"2020-08-11T07:16:05.465Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckfp5akf10009n8jhemmu272u","content":"<h1 id=\"python操作excel文件\"><a href=\"#python操作excel文件\" class=\"headerlink\" title=\"python操作excel文件\"></a>python操作excel文件</h1><h3 id=\"一、xlrd和xlwt读写\"><a href=\"#一、xlrd和xlwt读写\" class=\"headerlink\" title=\"一、xlrd和xlwt读写\"></a>一、xlrd和xlwt读写</h3><p><strong>常用单元格中的数据类型：</strong></p>\n<ul>\n<li><strong>0. empty（空的）,1 string（text）, 2 number, 3 date, 4 boolean, 5 error， 6 blank（空白表格）</strong></li>\n</ul>\n<h4 id=\"1-安装\"><a href=\"#1-安装\" class=\"headerlink\" title=\"1. 安装\"></a>1. 安装</h4><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">pip install xlrd\t<span class=\"comment\"># 读取</span></span><br><span class=\"line\">pip install xlwt\t<span class=\"comment\"># 写入</span></span><br></pre></td></tr></table></figure>\n\n<a id=\"more\"></a>\n\n<h4 id=\"2-读取（xlrd）\"><a href=\"#2-读取（xlrd）\" class=\"headerlink\" title=\"2. 读取（xlrd）\"></a>2. 读取（xlrd）</h4><ul>\n<li><p>导入模块</p>\n<p><code>import xlrd</code></p>\n</li>\n<li><p>打开Excel文件</p>\n<p><code>workbook = xlrd.open_workbook(&#39;file_path&#39;)</code></p>\n</li>\n<li><p>使用</p>\n<ul>\n<li><p>获取工作表</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sheet = workbook.sheets()[<span class=\"number\">0</span>]\t\t\t\t\t<span class=\"comment\"># 通过索引顺序获取</span></span><br><span class=\"line\">sheet = workbook.sheet_by_index(<span class=\"number\">0</span>)\t\t\t\t<span class=\"comment\"># 通过索引顺序获取</span></span><br><span class=\"line\">sheet = workbook.sheet_by_name(<span class=\"string\">u'sheet_name'</span>)\t<span class=\"comment\"># 通过名称获取</span></span><br></pre></td></tr></table></figure>\n</li>\n<li><p>获取整行和整列的值（数组）</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># i：数值 读取哪行或哪列</span></span><br><span class=\"line\">sheet.row_values(i)</span><br><span class=\"line\">sheet.col_values(i)</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>读取行数和列数</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">nrows = sheet.nrows</span><br><span class=\"line\">ncols = sheet.ncols</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>读取行列数据类型</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># slice返回：[类型:值]</span></span><br><span class=\"line\">row_type = sheet.row_slice(<span class=\"number\">0</span>)</span><br><span class=\"line\">col_type = sheet.col_slice(<span class=\"number\">0</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># types返回对应类型列表：[1, 1, 1]</span></span><br><span class=\"line\">row_type = sheet.row_types(<span class=\"number\">0</span>)</span><br><span class=\"line\">col_type = sheet.col_types(<span class=\"number\">0</span>)</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>读取单元格</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 先行后列</span></span><br><span class=\"line\">A1 = sheet.cell(<span class=\"number\">0</span>,<span class=\"number\">0</span>).value</span><br><span class=\"line\">C4 = sheet.cell(<span class=\"number\">3</span>,<span class=\"number\">2</span>).value</span><br><span class=\"line\"></span><br><span class=\"line\">A1 = sheet.cell_value(<span class=\"number\">0</span>,<span class=\"number\">0</span>)</span><br><span class=\"line\">C4 = sheet.cell_value(<span class=\"number\">3</span>,<span class=\"number\">2</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 使用行列索引</span></span><br><span class=\"line\">A1 = sheet.row(<span class=\"number\">0</span>)[<span class=\"number\">0</span>].value\t<span class=\"comment\"># 一行一列</span></span><br><span class=\"line\">C4 = sheet.row(<span class=\"number\">3</span>)[<span class=\"number\">2</span>].value\t<span class=\"comment\"># 四行三列</span></span><br><span class=\"line\">C4 = sheet.col(<span class=\"number\">2</span>)[<span class=\"number\">3</span>].value\t<span class=\"comment\"># 三列四行</span></span><br></pre></td></tr></table></figure>\n\n</li>\n</ul>\n</li>\n</ul>\n<blockquote>\n<p>test.xlsx文件</p>\n<p><img src=\"https://tupian-1300728887.cos.ap-chengdu.myqcloud.com/excel.png\" alt=\"image-20200712113803995\"></p>\n<p>demo代码块</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># python2.7</span></span><br><span class=\"line\"><span class=\"comment\"># -*- coding:utf-8 -*-</span></span><br><span class=\"line\"><span class=\"keyword\">import</span> sys</span><br><span class=\"line\"><span class=\"keyword\">import</span> xlwt</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 修改编译格式（防乱码）</span></span><br><span class=\"line\">default_encoding = <span class=\"string\">'utf-8'</span></span><br><span class=\"line\"><span class=\"keyword\">if</span> sys.getdefaultencoding() != default_encoding:</span><br><span class=\"line\">    reload(sys)</span><br><span class=\"line\">    sys.setdefaultencoding(default_encoding)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">read_excel</span><span class=\"params\">(sheet_name)</span>:</span></span><br><span class=\"line\">    <span class=\"comment\"># 打开文件 file_path：文件路径</span></span><br><span class=\"line\">    workbook = xlrd.open_workbook(<span class=\"string\">'test.xlsx'</span>, formatting_info=<span class=\"literal\">False</span>)</span><br><span class=\"line\">    <span class=\"comment\"># formatting_info默认为True，指定False可读取.xlsx文件</span></span><br><span class=\"line\">    sheet = workbook.sheet_by_name(<span class=\"string\">'Sheet1'</span>)\t<span class=\"comment\"># 指定读取sheet</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\"># 行列数据</span></span><br><span class=\"line\">    <span class=\"keyword\">print</span> <span class=\"string\">'第一行：'</span>, sheet.row_values(<span class=\"number\">0</span>)</span><br><span class=\"line\">    <span class=\"comment\"># 第一行： ['A1', 'B1', 'C1', 'D1', 'E1', 'F1'...]</span></span><br><span class=\"line\">    <span class=\"keyword\">print</span> <span class=\"string\">'第一列：'</span>, sheet.col_values(<span class=\"number\">0</span>)</span><br><span class=\"line\">    <span class=\"comment\"># 第一列： ['A1', 'A2', 'A3', 'A4', 'A5', 'A6'...]</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\"># 行列数</span></span><br><span class=\"line\">    <span class=\"keyword\">print</span> <span class=\"string\">'行数：'</span>, sheet.nrows\t<span class=\"comment\"># 行数： 17</span></span><br><span class=\"line\">    <span class=\"keyword\">print</span> <span class=\"string\">'列数：'</span>, sheet.ncols\t<span class=\"comment\"># 列数： 9</span></span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\"># 行列类型</span></span><br><span class=\"line\">    <span class=\"keyword\">print</span> sheet.row_slice(<span class=\"number\">0</span>)\t<span class=\"comment\"># [text:'A1', text:'B1', text:'C1'...]</span></span><br><span class=\"line\">    <span class=\"keyword\">print</span> sheet.col_slice(<span class=\"number\">0</span>)</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">print</span> sheet.row_types(<span class=\"number\">0</span>)\t<span class=\"comment\"># [1, 1, 1, 1, 1...]</span></span><br><span class=\"line\">    <span class=\"keyword\">print</span> sheet.col_types(<span class=\"number\">0</span>)</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\"># 单元格</span></span><br><span class=\"line\">    <span class=\"keyword\">print</span> sheet.cell(<span class=\"number\">0</span>,<span class=\"number\">0</span>).value\t\t<span class=\"comment\"># A1</span></span><br><span class=\"line\">    <span class=\"keyword\">print</span> sheet.cell(<span class=\"number\">3</span>,<span class=\"number\">2</span>).value\t\t<span class=\"comment\"># C4</span></span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">print</span> sheet.cell_value(<span class=\"number\">0</span>,<span class=\"number\">0</span>)\t\t<span class=\"comment\"># A1</span></span><br><span class=\"line\">    <span class=\"keyword\">print</span> sheet.cell_value(<span class=\"number\">3</span>,<span class=\"number\">2</span>)\t\t<span class=\"comment\"># C4</span></span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">print</span> sheet.row(<span class=\"number\">0</span>)[<span class=\"number\">0</span>].value\t<span class=\"comment\"># 一行一列\tA1</span></span><br><span class=\"line\">    <span class=\"keyword\">print</span> sheet.row(<span class=\"number\">3</span>)[<span class=\"number\">2</span>].value\t<span class=\"comment\"># 四行三列\tC4</span></span><br><span class=\"line\">    <span class=\"keyword\">print</span> sheet.col(<span class=\"number\">2</span>)[<span class=\"number\">3</span>].value\t<span class=\"comment\"># 三列四行\tC4</span></span><br><span class=\"line\"></span><br><span class=\"line\">read_excel()</span><br></pre></td></tr></table></figure>\n</blockquote>\n<h4 id=\"3-写入（xlwt）\"><a href=\"#3-写入（xlwt）\" class=\"headerlink\" title=\"3. 写入（xlwt）\"></a>3. 写入（xlwt）</h4><blockquote>\n<p>注：xlwt不支持xlsx</p>\n</blockquote>\n<ul>\n<li><p>导入模块</p>\n<p><code>import xlwt</code></p>\n</li>\n<li><p>打开Excel文件</p>\n<p><code>book = xlwt.Workbook(encoding=&#39;utf-8&#39;)</code></p>\n</li>\n<li><p>使用</p>\n<ul>\n<li><p>设置字体</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">font = xlwt.Font()\t\t\t<span class=\"comment\"># 为样式创建字体</span></span><br><span class=\"line\">font.bold = <span class=\"literal\">True</span> \t\t\t<span class=\"comment\"># 粗体</span></span><br><span class=\"line\">font.italic = <span class=\"literal\">True</span> \t\t\t<span class=\"comment\"># 斜体</span></span><br><span class=\"line\">font.underline = <span class=\"number\">10</span> \t\t<span class=\"comment\"># 下划线(其中当值为9，整行的填充色为蓝色)</span></span><br><span class=\"line\">font.struck_out = <span class=\"literal\">True</span> \t\t<span class=\"comment\"># 删除线</span></span><br><span class=\"line\">font.name = <span class=\"string\">u'微软雅黑'</span>\t\t <span class=\"comment\"># 字体</span></span><br><span class=\"line\">font.color = <span class=\"string\">'black'</span>\t\t<span class=\"comment\"># 颜色</span></span><br><span class=\"line\">font.height= <span class=\"number\">220</span> \t\t\t<span class=\"comment\">#字体大小，220就是11号字体，大概就是11*20得来的吧</span></span><br></pre></td></tr></table></figure>\n</li>\n<li><p>居中</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">alignment = xlwt.Alignment()\t\t\t\t<span class=\"comment\"># 设置字体在单元格的位置</span></span><br><span class=\"line\">alignment.horz = xlwt.Alignment.HORZ_CENTER <span class=\"comment\"># 水平方向</span></span><br><span class=\"line\">alignment.vert = xlwt.Alignment.VERT_TOP  \t<span class=\"comment\"># 垂直方向</span></span><br></pre></td></tr></table></figure>\n</li>\n<li><p>背景颜色</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">pattern = xlwt.Pattern()</span><br><span class=\"line\">pattern.pattern = xlwt.Pattern.SOLID_PATTERN</span><br><span class=\"line\">pattern.pattern_fore_colour = i\t\t\t\t\t<span class=\"comment\"># i:可选值</span></span><br></pre></td></tr></table></figure>\n\n<ul>\n<li><p>可选参数：</p>\n<p><img src=\"https://tupian-1300728887.cos.ap-chengdu.myqcloud.com/%E9%A2%9C%E8%89%B2%E5%AF%B9%E7%85%A7%E8%A1%A8.png\" alt=\"\"></p>\n</li>\n</ul>\n</li>\n<li><p>设置边框</p>\n<ul>\n<li><p>细实线:1，小粗实线:2，细虚线:3，中细虚线:4，大粗实线:5，双线:6，细点虚线:7</p>\n<p>大粗虚线:8，细点划线:9，粗点划线:10，细双点划线:11，粗双点划线:12，斜点划线:13</p>\n</li>\n</ul>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">border = xlwt.Borders() \t\t\t\t<span class=\"comment\"># 给单元格加框线, 1:细实线</span></span><br><span class=\"line\">border.left = <span class=\"number\">1</span></span><br><span class=\"line\">border.top = <span class=\"number\">1</span></span><br><span class=\"line\">border.right =<span class=\"number\">1</span></span><br><span class=\"line\">border.bottom = <span class=\"number\">1</span></span><br><span class=\"line\"></span><br><span class=\"line\">border.left_colour = <span class=\"number\">0</span> \t\t\t\t\t<span class=\"comment\">#设置框线颜色，0:黑色</span></span><br><span class=\"line\">border.right_colour = <span class=\"number\">0</span></span><br><span class=\"line\">border.top_colour = <span class=\"number\">0</span></span><br><span class=\"line\">border.bottom_colour = <span class=\"number\">0</span></span><br></pre></td></tr></table></figure>\n</li>\n<li><p>加超链接</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 输出文本百度，为超链接第一行第一列</span></span><br><span class=\"line\">sheet.write(<span class=\"number\">0</span>, <span class=\"number\">0</span>, xlwt.Formula(<span class=\"string\">'HYPERLINK(\"https://www.baidu.com\";\"百度\")'</span>))</span><br></pre></td></tr></table></figure>\n\n</li>\n</ul>\n</li>\n</ul>\n<blockquote>\n<p>demo代码块</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># python2.7</span></span><br><span class=\"line\"><span class=\"comment\"># -*- coding:utf-8 -*-</span></span><br><span class=\"line\"><span class=\"keyword\">import</span> sys</span><br><span class=\"line\"><span class=\"keyword\">import</span> xlwt</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 修改编译格式（防乱码）</span></span><br><span class=\"line\">default_encoding = <span class=\"string\">'utf-8'</span></span><br><span class=\"line\"><span class=\"keyword\">if</span> sys.getdefaultencoding() != default_encoding:</span><br><span class=\"line\">    reload(sys)</span><br><span class=\"line\">    sys.setdefaultencoding(default_encoding)</span><br><span class=\"line\">    </span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">write_excel</span><span class=\"params\">()</span>:</span></span><br><span class=\"line\">    data_list = [[<span class=\"string\">'姓名'</span>, <span class=\"string\">'性别'</span>, <span class=\"string\">'年龄'</span>],</span><br><span class=\"line\">                 [<span class=\"string\">'张三'</span>, <span class=\"string\">'男'</span>, <span class=\"number\">18</span>],</span><br><span class=\"line\">                 [<span class=\"string\">'李雷'</span>, <span class=\"string\">'女'</span>, <span class=\"number\">22</span>],</span><br><span class=\"line\">                 [<span class=\"string\">'韩梅梅'</span>, <span class=\"string\">'女'</span>, <span class=\"number\">20</span>]]</span><br><span class=\"line\">    <span class=\"keyword\">try</span>:</span><br><span class=\"line\">        book = xlwt.Workbook(encoding=<span class=\"string\">'utf-8'</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\"># 设置字体</span></span><br><span class=\"line\">        font = xlwt.Font()</span><br><span class=\"line\">        font.bold = <span class=\"literal\">True</span></span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\"># 设置居中</span></span><br><span class=\"line\">        alignment = xlwt.Alignment()</span><br><span class=\"line\">        alignment.horz = xlwt.Alignment.HORZ_CENTER  <span class=\"comment\"># 水平方向</span></span><br><span class=\"line\">        alignment.vert = xlwt.Alignment.VERT_TOP  <span class=\"comment\"># 垂直方向</span></span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\"># 设置背景颜色</span></span><br><span class=\"line\">        pattern = xlwt.Pattern()</span><br><span class=\"line\">        pattern.pattern = xlwt.Pattern.SOLID_PATTERN</span><br><span class=\"line\">        pattern.pattern_fore_colour = <span class=\"number\">22</span>  <span class=\"comment\"># 背景颜色</span></span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\"># 设置边框</span></span><br><span class=\"line\">        borders = xlwt.Borders()</span><br><span class=\"line\">        borders.left = xlwt.Borders.THIN</span><br><span class=\"line\">        borders.right = xlwt.Borders.THIN</span><br><span class=\"line\">        borders.top = xlwt.Borders.THIN</span><br><span class=\"line\">        borders.bottom = xlwt.Borders.THIN</span><br><span class=\"line\">        </span><br><span class=\"line\">        borders.left_colour = <span class=\"number\">0</span> \t\t\t\t<span class=\"comment\">#设置框线颜色</span></span><br><span class=\"line\">        borders.right_colour = <span class=\"number\">0</span></span><br><span class=\"line\">        borders.top_colour = <span class=\"number\">0</span></span><br><span class=\"line\">        borders.bottom_colour = <span class=\"number\">0</span></span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\"># 定义不同的excel style</span></span><br><span class=\"line\">        style1 = xlwt.XFStyle()\t<span class=\"comment\"># 初始化样式</span></span><br><span class=\"line\">        style1.font = font</span><br><span class=\"line\">        style1.alignment = alignment</span><br><span class=\"line\">        style1.pattern = pattern</span><br><span class=\"line\">        style1.borders = borders</span><br><span class=\"line\"></span><br><span class=\"line\">        style2 = xlwt.XFStyle()</span><br><span class=\"line\">        style2.alignment = alignment</span><br><span class=\"line\">        style2.borders = borders</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"comment\"># 指定sheet</span></span><br><span class=\"line\">        sheet = book.add_sheet(<span class=\"string\">'人员添加'</span>)</span><br><span class=\"line\">        <span class=\"comment\"># 列宽自适应</span></span><br><span class=\"line\">        set_width(sheet, data_list)</span><br><span class=\"line\">        <span class=\"comment\"># 写入数据</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> row <span class=\"keyword\">in</span> range(len(data_list)):</span><br><span class=\"line\">            <span class=\"keyword\">for</span> col <span class=\"keyword\">in</span> range(len(data_list[row])):</span><br><span class=\"line\">                <span class=\"comment\"># 标题格式</span></span><br><span class=\"line\">                <span class=\"keyword\">if</span> row == <span class=\"number\">0</span>:</span><br><span class=\"line\">                    sheet.write(row, col, data_list[row][col], style=style1)</span><br><span class=\"line\">                <span class=\"keyword\">else</span>:</span><br><span class=\"line\">                    sheet.write(row, col, data_list[row][col], style=style2)</span><br><span class=\"line\">        sheet.write(<span class=\"number\">0</span>, <span class=\"number\">0</span>, xlwt.Formula(<span class=\"string\">'HYPERLINK(\"https://www.baidu.com\";\"百度\")'</span>)) </span><br><span class=\"line\">        <span class=\"comment\"># 输出文本百度，为超链接第一行第一列</span></span><br><span class=\"line\">        book.save(<span class=\"string\">'test.xls'</span>.decode(<span class=\"string\">'utf-8'</span>))</span><br><span class=\"line\">    <span class=\"keyword\">except</span> Exception, e:</span><br><span class=\"line\">        <span class=\"keyword\">print</span> e</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 获取字符串长度，一个中文的长度为2</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">len_byte</span><span class=\"params\">(value)</span>:</span></span><br><span class=\"line\">    length = len(value)</span><br><span class=\"line\">    utf8_length = len(value.encode(<span class=\"string\">'utf-8'</span>))</span><br><span class=\"line\">    length = (utf8_length - length) / <span class=\"number\">2</span> + length</span><br><span class=\"line\">    <span class=\"keyword\">return</span> int(length)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">set_width</span><span class=\"params\">(sheet, data_list)</span>:</span></span><br><span class=\"line\">    <span class=\"comment\"># 确定栏位宽度</span></span><br><span class=\"line\">    col_width = []</span><br><span class=\"line\">    <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> range(len(data_list)):</span><br><span class=\"line\">        <span class=\"keyword\">for</span> j <span class=\"keyword\">in</span> range(len(data_list[i])):</span><br><span class=\"line\">            <span class=\"keyword\">if</span> i == <span class=\"number\">0</span>:</span><br><span class=\"line\">                col_width.append(len_byte(data_list[i][j]))</span><br><span class=\"line\">            <span class=\"keyword\">else</span>:</span><br><span class=\"line\">                <span class=\"keyword\">if</span> col_width[j] &lt; len_byte(str(data_list[i][j])):</span><br><span class=\"line\">                    col_width[j] = len_byte(data_list[i][j])</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\"># 设置栏位宽度，栏位宽度小于10时候采用默认宽度</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> range(len(col_width)):</span><br><span class=\"line\">        <span class=\"keyword\">if</span> col_width[i] &gt; <span class=\"number\">10</span>:</span><br><span class=\"line\">            sheet.col(i).width = <span class=\"number\">256</span> * (col_width[i] + <span class=\"number\">1</span>)</span><br><span class=\"line\">            </span><br><span class=\"line\">write_excel()</span><br></pre></td></tr></table></figure>\n\n<p>运行效果</p>\n<p><img src=\"https://tupian-1300728887.cos.ap-chengdu.myqcloud.com/image-20200712162231433.png\" alt=\"image-20200712162231433\"></p>\n</blockquote>\n","site":{"data":{}},"excerpt":"<h1 id=\"python操作excel文件\"><a href=\"#python操作excel文件\" class=\"headerlink\" title=\"python操作excel文件\"></a>python操作excel文件</h1><h3 id=\"一、xlrd和xlwt读写\"><a href=\"#一、xlrd和xlwt读写\" class=\"headerlink\" title=\"一、xlrd和xlwt读写\"></a>一、xlrd和xlwt读写</h3><p><strong>常用单元格中的数据类型：</strong></p>\n<ul>\n<li><strong>0. empty（空的）,1 string（text）, 2 number, 3 date, 4 boolean, 5 error， 6 blank（空白表格）</strong></li>\n</ul>\n<h4 id=\"1-安装\"><a href=\"#1-安装\" class=\"headerlink\" title=\"1. 安装\"></a>1. 安装</h4><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">pip install xlrd\t<span class=\"comment\"># 读取</span></span><br><span class=\"line\">pip install xlwt\t<span class=\"comment\"># 写入</span></span><br></pre></td></tr></table></figure>","more":"<h4 id=\"2-读取（xlrd）\"><a href=\"#2-读取（xlrd）\" class=\"headerlink\" title=\"2. 读取（xlrd）\"></a>2. 读取（xlrd）</h4><ul>\n<li><p>导入模块</p>\n<p><code>import xlrd</code></p>\n</li>\n<li><p>打开Excel文件</p>\n<p><code>workbook = xlrd.open_workbook(&#39;file_path&#39;)</code></p>\n</li>\n<li><p>使用</p>\n<ul>\n<li><p>获取工作表</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sheet = workbook.sheets()[<span class=\"number\">0</span>]\t\t\t\t\t<span class=\"comment\"># 通过索引顺序获取</span></span><br><span class=\"line\">sheet = workbook.sheet_by_index(<span class=\"number\">0</span>)\t\t\t\t<span class=\"comment\"># 通过索引顺序获取</span></span><br><span class=\"line\">sheet = workbook.sheet_by_name(<span class=\"string\">u'sheet_name'</span>)\t<span class=\"comment\"># 通过名称获取</span></span><br></pre></td></tr></table></figure>\n</li>\n<li><p>获取整行和整列的值（数组）</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># i：数值 读取哪行或哪列</span></span><br><span class=\"line\">sheet.row_values(i)</span><br><span class=\"line\">sheet.col_values(i)</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>读取行数和列数</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">nrows = sheet.nrows</span><br><span class=\"line\">ncols = sheet.ncols</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>读取行列数据类型</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># slice返回：[类型:值]</span></span><br><span class=\"line\">row_type = sheet.row_slice(<span class=\"number\">0</span>)</span><br><span class=\"line\">col_type = sheet.col_slice(<span class=\"number\">0</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># types返回对应类型列表：[1, 1, 1]</span></span><br><span class=\"line\">row_type = sheet.row_types(<span class=\"number\">0</span>)</span><br><span class=\"line\">col_type = sheet.col_types(<span class=\"number\">0</span>)</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>读取单元格</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 先行后列</span></span><br><span class=\"line\">A1 = sheet.cell(<span class=\"number\">0</span>,<span class=\"number\">0</span>).value</span><br><span class=\"line\">C4 = sheet.cell(<span class=\"number\">3</span>,<span class=\"number\">2</span>).value</span><br><span class=\"line\"></span><br><span class=\"line\">A1 = sheet.cell_value(<span class=\"number\">0</span>,<span class=\"number\">0</span>)</span><br><span class=\"line\">C4 = sheet.cell_value(<span class=\"number\">3</span>,<span class=\"number\">2</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 使用行列索引</span></span><br><span class=\"line\">A1 = sheet.row(<span class=\"number\">0</span>)[<span class=\"number\">0</span>].value\t<span class=\"comment\"># 一行一列</span></span><br><span class=\"line\">C4 = sheet.row(<span class=\"number\">3</span>)[<span class=\"number\">2</span>].value\t<span class=\"comment\"># 四行三列</span></span><br><span class=\"line\">C4 = sheet.col(<span class=\"number\">2</span>)[<span class=\"number\">3</span>].value\t<span class=\"comment\"># 三列四行</span></span><br></pre></td></tr></table></figure>\n\n</li>\n</ul>\n</li>\n</ul>\n<blockquote>\n<p>test.xlsx文件</p>\n<p><img src=\"https://tupian-1300728887.cos.ap-chengdu.myqcloud.com/excel.png\" alt=\"image-20200712113803995\"></p>\n<p>demo代码块</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># python2.7</span></span><br><span class=\"line\"><span class=\"comment\"># -*- coding:utf-8 -*-</span></span><br><span class=\"line\"><span class=\"keyword\">import</span> sys</span><br><span class=\"line\"><span class=\"keyword\">import</span> xlwt</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 修改编译格式（防乱码）</span></span><br><span class=\"line\">default_encoding = <span class=\"string\">'utf-8'</span></span><br><span class=\"line\"><span class=\"keyword\">if</span> sys.getdefaultencoding() != default_encoding:</span><br><span class=\"line\">    reload(sys)</span><br><span class=\"line\">    sys.setdefaultencoding(default_encoding)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">read_excel</span><span class=\"params\">(sheet_name)</span>:</span></span><br><span class=\"line\">    <span class=\"comment\"># 打开文件 file_path：文件路径</span></span><br><span class=\"line\">    workbook = xlrd.open_workbook(<span class=\"string\">'test.xlsx'</span>, formatting_info=<span class=\"literal\">False</span>)</span><br><span class=\"line\">    <span class=\"comment\"># formatting_info默认为True，指定False可读取.xlsx文件</span></span><br><span class=\"line\">    sheet = workbook.sheet_by_name(<span class=\"string\">'Sheet1'</span>)\t<span class=\"comment\"># 指定读取sheet</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\"># 行列数据</span></span><br><span class=\"line\">    <span class=\"keyword\">print</span> <span class=\"string\">'第一行：'</span>, sheet.row_values(<span class=\"number\">0</span>)</span><br><span class=\"line\">    <span class=\"comment\"># 第一行： ['A1', 'B1', 'C1', 'D1', 'E1', 'F1'...]</span></span><br><span class=\"line\">    <span class=\"keyword\">print</span> <span class=\"string\">'第一列：'</span>, sheet.col_values(<span class=\"number\">0</span>)</span><br><span class=\"line\">    <span class=\"comment\"># 第一列： ['A1', 'A2', 'A3', 'A4', 'A5', 'A6'...]</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\"># 行列数</span></span><br><span class=\"line\">    <span class=\"keyword\">print</span> <span class=\"string\">'行数：'</span>, sheet.nrows\t<span class=\"comment\"># 行数： 17</span></span><br><span class=\"line\">    <span class=\"keyword\">print</span> <span class=\"string\">'列数：'</span>, sheet.ncols\t<span class=\"comment\"># 列数： 9</span></span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\"># 行列类型</span></span><br><span class=\"line\">    <span class=\"keyword\">print</span> sheet.row_slice(<span class=\"number\">0</span>)\t<span class=\"comment\"># [text:'A1', text:'B1', text:'C1'...]</span></span><br><span class=\"line\">    <span class=\"keyword\">print</span> sheet.col_slice(<span class=\"number\">0</span>)</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">print</span> sheet.row_types(<span class=\"number\">0</span>)\t<span class=\"comment\"># [1, 1, 1, 1, 1...]</span></span><br><span class=\"line\">    <span class=\"keyword\">print</span> sheet.col_types(<span class=\"number\">0</span>)</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\"># 单元格</span></span><br><span class=\"line\">    <span class=\"keyword\">print</span> sheet.cell(<span class=\"number\">0</span>,<span class=\"number\">0</span>).value\t\t<span class=\"comment\"># A1</span></span><br><span class=\"line\">    <span class=\"keyword\">print</span> sheet.cell(<span class=\"number\">3</span>,<span class=\"number\">2</span>).value\t\t<span class=\"comment\"># C4</span></span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">print</span> sheet.cell_value(<span class=\"number\">0</span>,<span class=\"number\">0</span>)\t\t<span class=\"comment\"># A1</span></span><br><span class=\"line\">    <span class=\"keyword\">print</span> sheet.cell_value(<span class=\"number\">3</span>,<span class=\"number\">2</span>)\t\t<span class=\"comment\"># C4</span></span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">print</span> sheet.row(<span class=\"number\">0</span>)[<span class=\"number\">0</span>].value\t<span class=\"comment\"># 一行一列\tA1</span></span><br><span class=\"line\">    <span class=\"keyword\">print</span> sheet.row(<span class=\"number\">3</span>)[<span class=\"number\">2</span>].value\t<span class=\"comment\"># 四行三列\tC4</span></span><br><span class=\"line\">    <span class=\"keyword\">print</span> sheet.col(<span class=\"number\">2</span>)[<span class=\"number\">3</span>].value\t<span class=\"comment\"># 三列四行\tC4</span></span><br><span class=\"line\"></span><br><span class=\"line\">read_excel()</span><br></pre></td></tr></table></figure>\n</blockquote>\n<h4 id=\"3-写入（xlwt）\"><a href=\"#3-写入（xlwt）\" class=\"headerlink\" title=\"3. 写入（xlwt）\"></a>3. 写入（xlwt）</h4><blockquote>\n<p>注：xlwt不支持xlsx</p>\n</blockquote>\n<ul>\n<li><p>导入模块</p>\n<p><code>import xlwt</code></p>\n</li>\n<li><p>打开Excel文件</p>\n<p><code>book = xlwt.Workbook(encoding=&#39;utf-8&#39;)</code></p>\n</li>\n<li><p>使用</p>\n<ul>\n<li><p>设置字体</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">font = xlwt.Font()\t\t\t<span class=\"comment\"># 为样式创建字体</span></span><br><span class=\"line\">font.bold = <span class=\"literal\">True</span> \t\t\t<span class=\"comment\"># 粗体</span></span><br><span class=\"line\">font.italic = <span class=\"literal\">True</span> \t\t\t<span class=\"comment\"># 斜体</span></span><br><span class=\"line\">font.underline = <span class=\"number\">10</span> \t\t<span class=\"comment\"># 下划线(其中当值为9，整行的填充色为蓝色)</span></span><br><span class=\"line\">font.struck_out = <span class=\"literal\">True</span> \t\t<span class=\"comment\"># 删除线</span></span><br><span class=\"line\">font.name = <span class=\"string\">u'微软雅黑'</span>\t\t <span class=\"comment\"># 字体</span></span><br><span class=\"line\">font.color = <span class=\"string\">'black'</span>\t\t<span class=\"comment\"># 颜色</span></span><br><span class=\"line\">font.height= <span class=\"number\">220</span> \t\t\t<span class=\"comment\">#字体大小，220就是11号字体，大概就是11*20得来的吧</span></span><br></pre></td></tr></table></figure>\n</li>\n<li><p>居中</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">alignment = xlwt.Alignment()\t\t\t\t<span class=\"comment\"># 设置字体在单元格的位置</span></span><br><span class=\"line\">alignment.horz = xlwt.Alignment.HORZ_CENTER <span class=\"comment\"># 水平方向</span></span><br><span class=\"line\">alignment.vert = xlwt.Alignment.VERT_TOP  \t<span class=\"comment\"># 垂直方向</span></span><br></pre></td></tr></table></figure>\n</li>\n<li><p>背景颜色</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">pattern = xlwt.Pattern()</span><br><span class=\"line\">pattern.pattern = xlwt.Pattern.SOLID_PATTERN</span><br><span class=\"line\">pattern.pattern_fore_colour = i\t\t\t\t\t<span class=\"comment\"># i:可选值</span></span><br></pre></td></tr></table></figure>\n\n<ul>\n<li><p>可选参数：</p>\n<p><img src=\"https://tupian-1300728887.cos.ap-chengdu.myqcloud.com/%E9%A2%9C%E8%89%B2%E5%AF%B9%E7%85%A7%E8%A1%A8.png\" alt=\"\"></p>\n</li>\n</ul>\n</li>\n<li><p>设置边框</p>\n<ul>\n<li><p>细实线:1，小粗实线:2，细虚线:3，中细虚线:4，大粗实线:5，双线:6，细点虚线:7</p>\n<p>大粗虚线:8，细点划线:9，粗点划线:10，细双点划线:11，粗双点划线:12，斜点划线:13</p>\n</li>\n</ul>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">border = xlwt.Borders() \t\t\t\t<span class=\"comment\"># 给单元格加框线, 1:细实线</span></span><br><span class=\"line\">border.left = <span class=\"number\">1</span></span><br><span class=\"line\">border.top = <span class=\"number\">1</span></span><br><span class=\"line\">border.right =<span class=\"number\">1</span></span><br><span class=\"line\">border.bottom = <span class=\"number\">1</span></span><br><span class=\"line\"></span><br><span class=\"line\">border.left_colour = <span class=\"number\">0</span> \t\t\t\t\t<span class=\"comment\">#设置框线颜色，0:黑色</span></span><br><span class=\"line\">border.right_colour = <span class=\"number\">0</span></span><br><span class=\"line\">border.top_colour = <span class=\"number\">0</span></span><br><span class=\"line\">border.bottom_colour = <span class=\"number\">0</span></span><br></pre></td></tr></table></figure>\n</li>\n<li><p>加超链接</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 输出文本百度，为超链接第一行第一列</span></span><br><span class=\"line\">sheet.write(<span class=\"number\">0</span>, <span class=\"number\">0</span>, xlwt.Formula(<span class=\"string\">'HYPERLINK(\"https://www.baidu.com\";\"百度\")'</span>))</span><br></pre></td></tr></table></figure>\n\n</li>\n</ul>\n</li>\n</ul>\n<blockquote>\n<p>demo代码块</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># python2.7</span></span><br><span class=\"line\"><span class=\"comment\"># -*- coding:utf-8 -*-</span></span><br><span class=\"line\"><span class=\"keyword\">import</span> sys</span><br><span class=\"line\"><span class=\"keyword\">import</span> xlwt</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 修改编译格式（防乱码）</span></span><br><span class=\"line\">default_encoding = <span class=\"string\">'utf-8'</span></span><br><span class=\"line\"><span class=\"keyword\">if</span> sys.getdefaultencoding() != default_encoding:</span><br><span class=\"line\">    reload(sys)</span><br><span class=\"line\">    sys.setdefaultencoding(default_encoding)</span><br><span class=\"line\">    </span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">write_excel</span><span class=\"params\">()</span>:</span></span><br><span class=\"line\">    data_list = [[<span class=\"string\">'姓名'</span>, <span class=\"string\">'性别'</span>, <span class=\"string\">'年龄'</span>],</span><br><span class=\"line\">                 [<span class=\"string\">'张三'</span>, <span class=\"string\">'男'</span>, <span class=\"number\">18</span>],</span><br><span class=\"line\">                 [<span class=\"string\">'李雷'</span>, <span class=\"string\">'女'</span>, <span class=\"number\">22</span>],</span><br><span class=\"line\">                 [<span class=\"string\">'韩梅梅'</span>, <span class=\"string\">'女'</span>, <span class=\"number\">20</span>]]</span><br><span class=\"line\">    <span class=\"keyword\">try</span>:</span><br><span class=\"line\">        book = xlwt.Workbook(encoding=<span class=\"string\">'utf-8'</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\"># 设置字体</span></span><br><span class=\"line\">        font = xlwt.Font()</span><br><span class=\"line\">        font.bold = <span class=\"literal\">True</span></span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\"># 设置居中</span></span><br><span class=\"line\">        alignment = xlwt.Alignment()</span><br><span class=\"line\">        alignment.horz = xlwt.Alignment.HORZ_CENTER  <span class=\"comment\"># 水平方向</span></span><br><span class=\"line\">        alignment.vert = xlwt.Alignment.VERT_TOP  <span class=\"comment\"># 垂直方向</span></span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\"># 设置背景颜色</span></span><br><span class=\"line\">        pattern = xlwt.Pattern()</span><br><span class=\"line\">        pattern.pattern = xlwt.Pattern.SOLID_PATTERN</span><br><span class=\"line\">        pattern.pattern_fore_colour = <span class=\"number\">22</span>  <span class=\"comment\"># 背景颜色</span></span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\"># 设置边框</span></span><br><span class=\"line\">        borders = xlwt.Borders()</span><br><span class=\"line\">        borders.left = xlwt.Borders.THIN</span><br><span class=\"line\">        borders.right = xlwt.Borders.THIN</span><br><span class=\"line\">        borders.top = xlwt.Borders.THIN</span><br><span class=\"line\">        borders.bottom = xlwt.Borders.THIN</span><br><span class=\"line\">        </span><br><span class=\"line\">        borders.left_colour = <span class=\"number\">0</span> \t\t\t\t<span class=\"comment\">#设置框线颜色</span></span><br><span class=\"line\">        borders.right_colour = <span class=\"number\">0</span></span><br><span class=\"line\">        borders.top_colour = <span class=\"number\">0</span></span><br><span class=\"line\">        borders.bottom_colour = <span class=\"number\">0</span></span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\"># 定义不同的excel style</span></span><br><span class=\"line\">        style1 = xlwt.XFStyle()\t<span class=\"comment\"># 初始化样式</span></span><br><span class=\"line\">        style1.font = font</span><br><span class=\"line\">        style1.alignment = alignment</span><br><span class=\"line\">        style1.pattern = pattern</span><br><span class=\"line\">        style1.borders = borders</span><br><span class=\"line\"></span><br><span class=\"line\">        style2 = xlwt.XFStyle()</span><br><span class=\"line\">        style2.alignment = alignment</span><br><span class=\"line\">        style2.borders = borders</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"comment\"># 指定sheet</span></span><br><span class=\"line\">        sheet = book.add_sheet(<span class=\"string\">'人员添加'</span>)</span><br><span class=\"line\">        <span class=\"comment\"># 列宽自适应</span></span><br><span class=\"line\">        set_width(sheet, data_list)</span><br><span class=\"line\">        <span class=\"comment\"># 写入数据</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> row <span class=\"keyword\">in</span> range(len(data_list)):</span><br><span class=\"line\">            <span class=\"keyword\">for</span> col <span class=\"keyword\">in</span> range(len(data_list[row])):</span><br><span class=\"line\">                <span class=\"comment\"># 标题格式</span></span><br><span class=\"line\">                <span class=\"keyword\">if</span> row == <span class=\"number\">0</span>:</span><br><span class=\"line\">                    sheet.write(row, col, data_list[row][col], style=style1)</span><br><span class=\"line\">                <span class=\"keyword\">else</span>:</span><br><span class=\"line\">                    sheet.write(row, col, data_list[row][col], style=style2)</span><br><span class=\"line\">        sheet.write(<span class=\"number\">0</span>, <span class=\"number\">0</span>, xlwt.Formula(<span class=\"string\">'HYPERLINK(\"https://www.baidu.com\";\"百度\")'</span>)) </span><br><span class=\"line\">        <span class=\"comment\"># 输出文本百度，为超链接第一行第一列</span></span><br><span class=\"line\">        book.save(<span class=\"string\">'test.xls'</span>.decode(<span class=\"string\">'utf-8'</span>))</span><br><span class=\"line\">    <span class=\"keyword\">except</span> Exception, e:</span><br><span class=\"line\">        <span class=\"keyword\">print</span> e</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 获取字符串长度，一个中文的长度为2</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">len_byte</span><span class=\"params\">(value)</span>:</span></span><br><span class=\"line\">    length = len(value)</span><br><span class=\"line\">    utf8_length = len(value.encode(<span class=\"string\">'utf-8'</span>))</span><br><span class=\"line\">    length = (utf8_length - length) / <span class=\"number\">2</span> + length</span><br><span class=\"line\">    <span class=\"keyword\">return</span> int(length)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">set_width</span><span class=\"params\">(sheet, data_list)</span>:</span></span><br><span class=\"line\">    <span class=\"comment\"># 确定栏位宽度</span></span><br><span class=\"line\">    col_width = []</span><br><span class=\"line\">    <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> range(len(data_list)):</span><br><span class=\"line\">        <span class=\"keyword\">for</span> j <span class=\"keyword\">in</span> range(len(data_list[i])):</span><br><span class=\"line\">            <span class=\"keyword\">if</span> i == <span class=\"number\">0</span>:</span><br><span class=\"line\">                col_width.append(len_byte(data_list[i][j]))</span><br><span class=\"line\">            <span class=\"keyword\">else</span>:</span><br><span class=\"line\">                <span class=\"keyword\">if</span> col_width[j] &lt; len_byte(str(data_list[i][j])):</span><br><span class=\"line\">                    col_width[j] = len_byte(data_list[i][j])</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\"># 设置栏位宽度，栏位宽度小于10时候采用默认宽度</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> range(len(col_width)):</span><br><span class=\"line\">        <span class=\"keyword\">if</span> col_width[i] &gt; <span class=\"number\">10</span>:</span><br><span class=\"line\">            sheet.col(i).width = <span class=\"number\">256</span> * (col_width[i] + <span class=\"number\">1</span>)</span><br><span class=\"line\">            </span><br><span class=\"line\">write_excel()</span><br></pre></td></tr></table></figure>\n\n<p>运行效果</p>\n<p><img src=\"https://tupian-1300728887.cos.ap-chengdu.myqcloud.com/image-20200712162231433.png\" alt=\"image-20200712162231433\"></p>\n</blockquote>"},{"title":"MongDB","date":"2020-05-03T02:51:33.000Z","top":0,"_content":"\n# 一、MongoDB简介\n\n​\t\t**MongoDB 是由C++语言编写的，是一个基于分布式文件存储的开源数据库系统。**将数据存储为一个文档，数据结构由键值对组成，文档类似于 JSON 对象。字段值可以包含其他文档，数组及文档数组。\n\n**特点：**\n\n- 面向文档存储的数据库，操作简单\n- 可设置任何属性的索引，实现快速排序\n- 可通过本地或者网络创建数据镜像\n\n<!--more-->\n\n## 1. 安装MangoDB\n\n官网下载地址：https://www.mongodb.com/download-center/community\n\n**配置：**\n\n1. 创建D:\\mongodb\\data\\log目录，用来存放日志文件；\n2. 在D:\\mongodb\\data\\log目录里新建mongodb.log，用来存放日志信息；\n3. 创建D:\\mongodb\\data\\db目录，用来存放数据库数据，\n4. 并在D:\\mongodb目录下创建mongo.config，在文件内部复制如下文本：\n\n```bash\n# 数据文件  此处=后对应到数据所存放的目录\ndbpath=d:\\mongodb\\data\\db\n# 日志文件  此处=后对应到日志文件所在路径\nlogpath=d:\\mongodb\\data\\log\\mongodb.log\n# 错误日志采用追加模式，配置这个选项后mongodb的日志会追加到现有的日志文件，而不是从新创建一个新文件\nlogappend=true \n#启用日志文件，默认启用\njournal=true \n#这个选项可以过滤掉一些无用的日志信息，若需要调试使用请设置为false\nquiet=true \n#端口号 默认为27017\nport=27017\n```\n\n**测试是否安装成功**\n\n- 进入\\MongoDB\\Server\\3.4\\bin文件夹下，点击mongod.exe，如果闪一下退出，说明安装正常\n\n  ![](https://tupian-1300728887.cos.ap-chengdu.myqcloud.com/MangoDB%E6%88%90%E5%8A%9F.png)\n\n**安装MongoDB服务**\n\n- 执行mongod.exe，使用--install选项来安装服务，使用--config选项来指定之前创建的配置文件。\n\n  ```\n  C:\\mongodb\\bin\\mongod.exe --config \"C:\\mongodb\\mongod.cfg\" --install\n  ```\n\n**终端操作（管理员）**\n\n- 启动MongoDB服务\n\n  `net start MongoDB`\n\n- 关闭MongoDB服务\n\n  `net stop MongoDB`\n\n- 移除 MongoDB 服务\n\n  `**\\mongodb\\bin\\mongod.exe --remove`\n\n## 2. 概念\n\n| SQL术语/概念 | MongoDB术语/概念 |              解释/说明              |\n| :----------: | :--------------: | :---------------------------------: |\n|   database   |     database     |               数据库                |\n|    table     |    collection    |            数据库表/集合            |\n|     row      |     document     |           数据记录行/文档           |\n|    column    |      field       |             数据字段/域             |\n|    index     |      index       |                索引                 |\n| table joins  |                  |        表连接,MongoDB不支持         |\n| primary key  |   primary key    | 主键,MongoDB自动将_id字段设置为主键 |\n\n### 2.1 数据库\n\nMongoDB的默认数据库为\"db\"，该数据库存储在data目录中。\n\nMongoDB的单个实例可以容纳多个独立的数据库，每一个都有自己的集合和权限，不同的数据库也放置在不同的文件中。\n\n1. 显示所有数据的列表：`show dbs`\n\n2. 显示当前数据库对象或集合:`db`\n\n3. 连接到一个指定的数据库:`use`\n\n\n**自带特殊数据库：**\n\n- **admin**： 从权限的角度来看，这是\"root\"数据库。要是将一个用户添加到这个数据库，这个用户自动继承所有数据库的权限。一些特定的服务器端命令也只能从这个数据库运行，比如列出所有的数据库或者关闭服务器。\n- **local:** 这个数据永远不会被复制，可以用来存储限于本地单台服务器的任意集合\n- **config**: 当Mongo用于分片设置时，config数据库在内部使用，用于保存分片的相关信息。\n\n### 2.2 文档\n\n​\t\t文档是一组键值(key-value)对(即 BSON)。MongoDB 的文档不需要设置相同的字段，并且相同的字段不需要相同的数据类型\n\n| RDBMS  |              MongoDB              |\n| :----: | :-------------------------------: |\n| 数据库 |              数据库               |\n|  表格  |               集合                |\n|   行   |               文档                |\n|   列   |               字段                |\n| 表联合 |             嵌入文档              |\n|  主键  | 主键 (MongoDB 提供了 key 为 _id ) |\n\n1. 文档中的键/值对是有序的。\n2. 文档中的值不仅可以是在双引号里面的字符串，还可以是其他几种数据类型（甚至可以是整个嵌入的文档)。\n3. MongoDB区分类型和大小写。\n4. MongoDB的文档不能有重复的键。\n5. 文档的键是字符串。除了少数例外情况，键可以使用任意UTF-8字符。\n\n文档键命名规范：\n\n- 键不能含有\\0 (空字符)。这个字符用来表示键的结尾。\n- $有特别的意义，只有在特定环境下才能使用。\n- 以下划线\"_\"开头的键是保留的(不是严格要求的)。\n\n### 2.3 集合\n\n​\t\tMongoDB文档组，相比于表格\n\n集合命名规范：\n\n- 集合名不能是空字符串\"\"。\n- 集合名不能含有\\0字符（空字符)，这个字符表示集合名的结尾。\n- 集合名不能以\"system.\"开头，这是为系统集合保留的前缀。\n- 用户创建的集合名字不能含有保留字符。有些驱动程序的确支持在集合名里面包含，这是因为某些系统生成的集合中包含该字符。除非你要访问这种系统创建的集合，否则千万不要在名字里出现$。　\n\n### 2.4 元数据\n\n​\t\t存储数据库信息集合\n\n|       集合命名空间       |                   描述                    |\n| :----------------------: | :---------------------------------------: |\n| dbname.system.namespaces |            列出所有名字空间。             |\n|  dbname.system.indexes   |              列出所有索引。               |\n|  dbname.system.profile   |       包含数据库概要(profile)信息。       |\n|   dbname.system.users    |       列出所有可访问数据库的用户。        |\n|   dbname.local.sources   | 包含复制对端（slave）的服务器信息和状态。 |\n\n- 在indexes中插入数据，可创建索引\n- users是可以修改的\n- profile是可以删除的\n\n### 2.5 MongoDB数据类型\n\n|       String       | 字符串。存储数据常用的数据类型。在 MongoDB 中，UTF-8 编码的字符串才是合法的。 |\n| :----------------: | :----------------------------------------------------------- |\n|      Integer       | 整型数值。用于存储数值。根据你所采用的服务器，可分为 32 位或 64 位。 |\n|      Boolean       | 布尔值。用于存储布尔值（真/假）。                            |\n|       Double       | 双精度浮点值。用于存储浮点值。                               |\n|    Min/Max keys    | 将一个值与 BSON（二进制的 JSON）元素的最低值和最高值相对比。 |\n|       Array        | 用于将数组或列表或多个值存储为一个键。                       |\n|     Timestamp      | 时间戳。记录文档修改或添加的具体时间。                       |\n|       Object       | 用于内嵌文档。                                               |\n|        Null        | 用于创建空值。                                               |\n|       Symbol       | 符号。该数据类型基本上等同于字符串类型，但不同的是，它一般用于采用特殊符号类型的语言。 |\n|        Date        | 日期时间。用 UNIX 时间格式来存储当前日期或时间。你可以指定自己的日期时间：创建 Date 对象，传入年月日信息。 |\n|     Object ID      | 对象 ID。用于创建文档的 ID。                                 |\n|    Binary Data     | 二进制数据。用于存储二进制数据。                             |\n|        Code        | 代码类型。用于在文档中存储 JavaScript 代码。                 |\n| Regular expression | 正则表达式类型。用于存储正则表达式。                         |\n\n**ObjectId 类似唯一主键，可以很快的去生成和排序，**包含 12 bytes，含义是：\n\n- 前 4 个字节表示创建 **unix** 时间戳,格林尼治时间 **UTC** 时间，比北京时间晚了 8 个小时\n\n- 接下来的 3 个字节是机器标识码\n- 紧接的两个字节由进程 id 组成 PID\n- 最后三个字节是随机数\n\n![img](https://www.runoob.com/wp-content/uploads/2013/10/2875754375-5a19268f0fd9b_articlex.jpeg)\n\n​\t\tMongoDB 中存储的文档必须有一个 _id 键。这个键的值可以是任何类型的，默认是个 ObjectId 对象\n\n由于 ObjectId 中保存了创建的时间戳，可以通过 getTimestamp 函数来获取文档的创建时间:\n\n```bash\nnewObject = ObjectId()\nnewObject.getTimestamp()\nISODate(\"2017-11-25T07:21:10Z\")\n# ObjectId转字符串\nstr_objectid = ObjectId().str\ntypeof str_objectid\nstring\n```\n\n# 二、MongoDB操作\n\n## 1. 数据库操作\n\n创建数据库：`use DATABASE_NAME`\n\n查看所有数据库：`show dbs`\n\n删除数据库：`db.dropDatabase()`\n\n>  集合（数据表）在插入数据后才会被创建\n\n## 2. 集合操作\n\n创建集合：`db.createCollection(name, options)`\n\n- name：集合名称\n\n- options：可选参数，指定内存大小及索引\n\n  1. capped（布尔）：如果为 true，则创建固定集合。\n     - 固定集合是指有着固定大小的集合，当达到最大值时，它会自动覆盖最早的文档。\n       **当该值为 true 时，必须指定 size 参数。**\n\n  2. autolndexld（布尔）：如为 true，自动在 _id 字段创建索引。默认为 false。\n\n  3. size：为固定集合指定一个最大值，以千字节计（KB）\n\n  4. max：指定固定集合中包含文档的最大数量。\n\n> 在插入文档时，MongoDB 首先检查固定集合的 size 字段，然后检查 max 字段。\n\n查看已有集合：`show collections && show tables`\n\n删除集合：`db.collection.drop()`\n\n## 3. 文档操作\n\n**插入文档**：`db.COLLECTION_NAME.insert(document) && **save(document)`\n\n查看已插入的文档：\t`db.COLLECTION_NAME.find()`\n\n**更新文档**\n\n1. update()\n\n   **更新符合条件的文档**\n\n   ```bash\n   db.collection.update(\n      <query>,\t\t\t# 查询条件，≈where后面的\n      <update>,\t\t# update的对象和一些更新的操作符（如$,$set...）\n      {\n        upsert: <boolean>,\t# 如果不存在update的记录，是否插入objNew\n        multi: <boolean>,\t# 只更新找到的第一条记录，若为真全部更新\n        writeConcern: <document>\t# 异常级别\n      }\n   )\n   ```\n\n2. save()\n\n   **传入文档替换已有文档（_id一样）**\n\n   ```bash\n   db.collection.save(\n      <document>,\t# 文档数据\n      {\n        writeConcern: <document>\t# 异常级别\n      }\n   )\n   ```\n\n**删除文档**：`db.COLLECTION_NAME.deleteOne() && **.deleteMany()`\n\n**查询文档**：`db.collection.find(query, projection)`\n\n- **query** ：可选，使用查询操作符指定查询条件\n- **projection** ：可选，使用投影操作符指定返回的键。查询时返回文档中所有键值， 只需省略该参数即可（默认省略）\n\n用格式化的方式显示所有文档：`db.collection_name.find().pretty()`\n\n**MongoDB的条件操作符**\n\n|    操作    |          格式          |                   范例                    |   RDBMS中的类似语句   |\n| :--------: | :--------------------: | :---------------------------------------: | :-------------------: |\n|    等于    |    {<key>:<value>}     |  db.col.find({\"by\":\"菜鸟教程\"}).pretty()  | where by = '菜鸟教程' |\n|    小于    | {<key>:{$lt:<value>}}  | db.col.find({\"likes\":{$lt:50}}).pretty()  |   where likes < 50    |\n| 小于或等于 | {<key>:{$lte:<value>}} | db.col.find({\"likes\":{$lte:50}}).pretty() |   where likes <= 50   |\n|    大于    | {<key>:{$gt:<value>}}  | db.col.find({\"likes\":{$gt:50}}).pretty()  |   where likes > 50    |\n| 大于或等于 | {<key>:{$gte:<value>}} | db.col.find({\"likes\":{$gte:50}}).pretty() |   where likes >= 50   |\n|   不等于   | {<key>:{$ne:<value>}}  | db.col.find({\"likes\":{$ne:50}}).pretty()  |   where likes != 50   |\n\nand条件查询：`db.collection_name.find({key1:value1, key2:value2}).pretty()`\n\nor条件查询：`db.collection_name.find({$or:[{key1:value1}, {key2:value2}]}).pretty()`\n\n**模糊查询**\n\n- 查询 title 包含\"教\"字的文档：`db.col.find({\"title\":/教/})`\n\n- 查询 title 字段以\"教\"字开头的文档：`db.col.find({\"title\":/^教/})`\n\n- 查询 title字段以\"教\"字结尾的文档：`db.col.find({\"title\":/教$/})`\n\n**$type操作符**\n\n获取集合中 title 为 String 的数据：`db.col.find({\"title\": {$type: 'string'}})`\n\n**指定显示数量：**`db.collection_name.find().limit(number)`\n\n>  如果没有指定limit()方法中的参数则显示集合中的所有数据\n\n**跳过指定显示数量**：`db.collection_name.find().skip(number)`\n\n> skip默认参数为0，效率差，遍历出来的\n\n例：想要读取从 10 条记录后 100 条记录，相当于 sql 中limit (10,100)。\n\n​\t\t`db.COLLECTION_NAME.find().skip(10).limit(100)`\n\n**排序**：`db.COLLECTION_NAME.find().sort({KEY:1})`\n\n> 执行顺序：sort()  -->  skip()  -->  limit()\n\n## 4. 索引\n\n创建：`db.collection.createindex(keys, options)`\n\n创建数组索引：`db.collection.ensureIndex()`\n\n为子文档创建索引：`db.users.ensureIndex({\"address.city\":1,\"address.state\":1,\"address.pincode\":1})`\n\n- keys：创建索引的字段，可有多个，1为升序反之倒序\n- options：可选参数\n  1. background：建索会阻塞其它数据库操作，True为后台建索\n  2. unique：建立的索引是否唯一，默认false，指定true创建唯一索引\n  3. name：索引名称，未指定自动生成（字段名＋排序顺序）\n  4. sparse：对文档中不存在的字段数据不启用索引\n  5. weights：索引权重值\n\n查看集合索引：`db.col.getIndexes()`\n\n查看集合索引大小：`db.col.totalIndexSize()`\n\n删除集合所有索引：`db.col.dropIndexes()`\n\n删除集合指定索引：`db.col.dropIndex(\"索引名称\")`\n\n**定期删除**\n\n数据记录中createDate为时间类型时：设置时间180秒后自动删除\n\n`db.col.createIndex({\"createDate\": 1},{expireAfterSeconds: 180})`\n\n**定时删除**\n\nA记录中需添加 \"ClearUpDate\": new Date('Jan 22, 2019 23:00:00')\n\n`db.col.createIndex({\"ClearUpDate\": 1},{expireAfterSeconds: 0})`\n\n- 索引关键字段必须是 Date 类型。\n- 非立即执行：扫描 Document 过期数据并删除是独立线程执行，默认 60s 扫描一次，删除也不一定是立即删除成功\n\n**查询限制**\n\n索引不能被以下的查询使用：\n\n- 正则表达式及非操作符，如 $nin, $not, 等。\n- 算术运算符，如 $mod, 等。\n- $where 子句\n\n索引限制：\n\n如果现有的索引字段的值超过索引键的限制，MongoDB中不会创建索引。\n\n如果文档的索引字段值超过了索引键的限制，MongoDB不会将任何文档转换成索引的集合。\n\n最大范围：\n\n- 集合中索引不能超过64个\n- 索引名的长度不能超过128个字符\n- 一个复合索引最多可以有31个字段\n\n## 5. 聚合\n\naggregate()方法：`db.collection_name(aggregate_opeation)`\n\n| 表达式    | 描述                                           | 实例                                                         |\n| :-------- | :--------------------------------------------- | :----------------------------------------------------------- |\n| $sum      | 计算总和。                                     | db.mycol.aggregate([{$group : {_id : \"$by_user\", num_tutorial : {$sum : \"$likes\"}}}]) |\n| $avg      | 计算平均值                                     | db.mycol.aggregate([{$group : {_id : \"$by_user\", num_tutorial : {$avg : \"$likes\"}}}]) |\n| $min      | 获取集合中所有文档对应值得最小值。             | db.mycol.aggregate([{$group : {_id : \"$by_user\", num_tutorial : {$min : \"$likes\"}}}]) |\n| $max      | 获取集合中所有文档对应值得最大值。             | db.mycol.aggregate([{$group : {_id : \"$by_user\", num_tutorial : {$max : \"$likes\"}}}]) |\n| $push     | 在结果文档中插入值到一个数组中。               | db.mycol.aggregate([{$group : {_id : \"$by_user\", url : {$push: \"$url\"}}}]) |\n| $addToSet | 在结果文档中插入值到一个数组中，但不创建副本。 | db.mycol.aggregate([{$group : {_id : \"$by_user\", url : {$addToSet : \"$url\"}}}]) |\n| $first    | 根据资源文档的排序获取第一个文档数据。         | db.mycol.aggregate([{$group : {_id : \"$by_user\", first_url : {$first : \"$url\"}}}]) |\n| $last     | 根据资源文档的排序获取最后一个文档数据         | db.mycol.aggregate([{$group : {_id : \"$by_user\", last_url : {$last : \"$url\"}}}]) |\n\n> 例：通过以上集合计算每个作者所写的文章数\n>\n> `db.mycol.aggregate({$group : {_id : \"$by_user\", num_tutorial : {$sum : 1}}})`\n>\n> 相比于SQL语句：\n>\n> `select by_user as _id, count(*) as num_tutorial from mycol group by by_user`\n\n## 6. 管道\n\nMongoDB的聚合管道将MongoDB文档在一个管道处理完毕后将结果传递给下一个管道处理\n\n**$project**：修改文档将结构\n\n> `db.clo.aggregate({$project: {title: 1, author:1}})`\n>\n> 同\n>\n> `db.col.find({}, {title： 1, author:1})`\n\n**$match**：过滤数据\n\n> 例：将分数大于70小于或等于90记录，然后将符合条件的记录送到下一阶段$group管道操作符进行处理\n>\n> ```\n> db.articles.aggregate([\n> \t{ $match : { score : { $gt : 70, $lte : 90 } } },\n> \t{ $group: { _id: null, count: { $sum: 1 } } }\n> ]);\n> ```\n\n**当match和group同时存在时， 顺序会影响检索结果，必须先写 match 在前面**\n\n# 三、MongoDB优化\n\n## 1. 副本集\n\n​\t\t将数据同步在多个服务器的过程，提高了数据的可用性， 并可以保证数据的安全性。具有自动灾难恢复。没有固定的主节点\n\n**副本集设置**\n\n1. 创建一个cluster文件夹，放node1，node2，node3三个子文件夹\n\n   ```\n   节点1：\n   HOST：localhost:10001\n   Data File：F:\\MongoDB\\node1\n   \n   节点2：\n   HOST：localhost:10002\n   Data File：F:\\MongoDB\\node2\n   \n   节点3：\n   HOST：localhost:10003\n   Data File：F:\\MongoDB\\node3\n   ```\n\n2. 指定 --replSet 选项来启动mongoDB：\n\n   `mongod --port 端口 --dbpath 文件夹位置 --replSet 副本集名称`\n\n   - 启动一个新的副本集(初始化操作)：\n\n     ```\n     rs.initiate({\n     \t\"_id\":\"shinelon\",\n     \t\"members\":[ \n     \t\t{\"_id\":1,\"host\":\"localhost:10001\"},\n     \t\t{\"_id\":2,\"host\":\"localhost:10002\"},\n     \t\t{\"_id\":3,\"host\":\"localhost:10003\"} \n     \t\t\t]\n     \t})\n     ```\n\n   - 查看副本集的配置：`rs.conf()`\n\n   - 查看副本集状态： `rs.status() `\n\n   - 副本集添加成员：`rs.add(HOST_NAME:POST)`\n\n## 2. 分片\n\n​\t\t指将数据拆分，将其分散存在不同的机器上的过程，不需要功能强大的大型计算机就可以储存更多的数据，处理更多的负载\n\n**片键**：从集合里面选一个键，用该键的值作为数据拆分的依据\n\n**分片设置**\n\n1. 启动Shard Server（用于存储实际的数据块）\n\n   ```bash\n   HOST：localhost:27020\n   Data File：F:\\MongoDB\\shard\\s0\n   \n   HOST：localhost:27021\n   Data File：F:\\MongoDB\\shard\\s1\n   ...\\s3\n   Data File：F:\\MongoDB\\shard\\log\n   \n   > mongod --port 27020 --dbpath=F:\\MongoDB\\shard\\s0 --logpath=F:\\MongoDB\\shard\\log\\s0.log --logappend --fork\n   ...\n   ```\n\n2. 启动Config Server（mongodb实例）\n\n   ```\n   HOST：localhost:27100\n   Data File：F:\\MongoDB\\shard\\config\n   \n   > mongod --port 27100 --dbpath=F:\\MongoDB\\shard\\config --logpath=F:\\MongoDB\\shard\\log\\config.log --logappend --fork\n   ```\n\n3. 启动Route Process（mongos路由进程：应用连接它来发送请求，知道数据在分片中的位置，收集返回数据）\n\n   ```\n   > mongos --port 40000 --configdb localhost:27100 --fork --logpath=F:\\MongoDB\\shard\\log\\route.log --chunkSize 500\n   ```\n\n   > chunkSize这一项是用来指定chunk的大小的，单位是MB，默认大小为200MB.\n\n4. 配置Sharding\n\n   ```bash\n   mongo admin --port 40000\n   db.runCommand({ addshard:\"localhost:27020\" })\n   ...\n   db.runCommand({ enablesharding:\"test\" }) #设置分片存储的数据库\n   # 指定片键 user.name\n   db.runCommand({ shardcollection: 'test.user', key: {name: 1}})\n   ```\n\n可参考：https://blog.csdn.net/qq_37142346/java/article/details/82824132\n\n## 3. 备份与恢复\n\n数据备份：`mongodump -h dbhost -d dbname -o dbdirectory`\n\n- -h：MongoDB所在服务器地址，默认为： localhost:27017\n- -d：需要备份的数据库实例，例如：test\n- -o：备份的数据存放位置，例如：c:\\data\\dump\n\nmongodump 命令可选参数列表如下所示：\n\n| 语法                                              | 描述                           | 实例                                             |\n| :------------------------------------------------ | :----------------------------- | :----------------------------------------------- |\n| mongodump --host HOST_NAME --port PORT_NUMBER     | 该命令将备份所有MongoDB数据    | mongodump --host runoob.com --port 27017         |\n| mongodump --dbpath DB_PATH --out BACKUP_DIRECTORY |                                | mongodump --dbpath /data/db/ --out /data/backup/ |\n| mongodump --collection COLLECTION --db DB_NAME    | 该命令将备份指定数据库的集合。 | mongodump --collection mycol --db test           |\n\n数据恢复：`mongorestore -h <hostname><:port> -d dbname <path>`\n\n- --host <:port>, -h <:port>：MongoDB所在服务器地址\n\n- --db , -d ：需要恢复的数据库实例，例如：test\n\n- --drop：恢复的时候，先删除当前数据，然后恢复备份的数据。\n\n- <path>：mongorestore 最后的一个参数，设置备份数据所在位置\n\n  > 例：c:\\data\\dump\\test\n\n- --dir：指定备份的目录\n\n  > 不能同时指定 <path> 和 --dir 选项。\n\n## 4. 监控\n\n**mongostat命令**\n\n获取mongoDB的运行状态：mongostat\n\n**mongotop命令**\n\n跟踪一个MongoDB的实例，查看哪些读取和写入数据在花费大量的时间：mongotop <sleeptime>\n\n- 等待时间长度，以秒为单位\n\n# 四、MongoDB高级\n\n## 1. MongoDB关系\n\n​\t\tMongoDB的关系表示多个文档之间在逻辑上的相互关系，文档间可以通过**嵌入**和**引用**来建立联系。\n\n- 一对一\n- 一对多\n- 多对一\n- 多对多\n\n**嵌入式关系**：把用户地址嵌入到用户的文档中（一张表，数据量大的话，影响性能）\n\n> 查询用户地址：`db.users.findOne({\"name\":\"Tom Benzamin\"},{\"address\":1})`\n\n**引用式关系**：通过引用文档的 **id** 字段来建立关系，外键\n\n1. 查询用户地址对象id\n\n   `var result = db.users.findOne({\"name\":\"Tom Benzamin\"},{\"address_ids\":1})`\n\n2. 通过查询的id获取用户的详细地址信息\n\n   `var addresses = db.address.find({\"_id\":{\"$in\":result[\"address_ids\"]}})`\n\n> findOne不能写成find，find返回的是数组，findOne返回的是对象\n\n## 2. 引用操作\n\nMongoDB引用有两种：手动引用（Manual References）和DBRefs\n\n**DBRefs**\n\n形式：`{$ref : , $id : , $db : }`\n\n- $ref：集合名称\n- $id：引用的id\n- $db:数据库名称，可选参数\n\n**覆盖查询：**\n\n- 所有的查询字段是索引的一部分\n- 所有的查询返回字段在同一个索引中\n\n> 1. 在 users 集合中创建联合索引，字段为 gender 和 user_name :\n>\n>    `db.users.ensureIndex({gender:1,user_name:1})`\n>\n> 2. 该索引会覆盖以下查询：\n>\n>    `db.users.find({gender:\"M\"},{user_name:1,_id:0})`\n>\n> 3. 没有排除_id，查询就不会被覆盖\n>\n>    `db.users.find({gender:\"M\"},{user_name:1})`\n\n**查询分析：**可以确保建立的索引是否有效，是查询语句性能分析的重要工具。\n\n1. explain()：查询信息，使用索引及查询统计等\n\n   `db.users.find({gender:\"M\"},{user_name:1,_id:0}).explain()`\n\n2. hint()：指定使用某个索引字段来查询\n\n   `db.users.find({gender:\"M\"},{user_name:1,_id:0}).hint({gender:1,user_name:1})`\n\n## 3. 原子操作\n\n​\t\tmongodb不支持事务，但是mongodb提供了许多原子操作，比如文档的保存，修改，删除等，都是原子操作。要么成功要么失败，达到数据完整性\n\n### 3.1 原子操作常用命令\n\n**$set：**用来指定一个键并更新键值，若键不存在并创建。\n\n`{ $set :{ field : value}}`\n\n> 例：`db.col.update({\"gender\":\"M\"},{$set:{\"gender\": \"A\"}})`\n\n**$unset：**用来删除一个键\n\n`{ $unset : { field : 1} }`\n\n> 例：`db.col.update({\"gender\":\"A\"},{$unset:{\"gender\": 1}})`\n\n**$inc：**对文档的某个值为数字型（只能为满足要求的数字）的键进行增减的操作。\n\n`{ $inc : { field : value } }`\n\n> 例：`db.col.update({},{$inc:{\"num\": 10}})`\n\n**$push：**把value追加到field里面去，field一定要是数组类型才行\n\n`{ $push : { field : value } }`\n\n> 例：`db.col.update({\"_id\": 1},{$push:{age:22}})`\n>\n> 添加多个字段到数组\n>\n> 例：`db.col.update({\"_id\": 1},{$push:{age: {$each: [1,2,3]}}})`\n\n**$pull：**从数组field内删除一个等于value值\n\n`{ $pull: { <field1>: <value|condition>, <field2>: <value|condition>, ... } }`\n\n> 例：`db.col.update({}, {$pull:{age:24}})`\n\n**$pop：**删除数组的第一个（-1）或最后一个（1）元素\n\n`{ $pop : { field : 1 } }`\n\n> 例：`db.col.update({}, {$pop:{\"age\":1}})`\n\n**$rename:**修改字段名称\n\n`{ $rename : { old_field_name : new_field_name } }`\n\n> 例：`db.col.update({}, {$rename: {\"age\":\"age1\"}})`\n\n## 4. Map-Reduce\n\n​\t\tMap-Reduce是一种计算模型，将大批量的工作（数据）分解（MAP）执行，然后再将结果合并成最终结果（REDUCE）\n\n```javascript\ndb.collection.mapReduce(\n   function() {emit(key,value);},  // map 函数\n   function(key,values) {return reduceFunction},   // reduce 函数\n   {\n      out: collection,\n      query: document,\n      sort: document,\n      limit: number\n   }\n)\n```\n\n> 使用 MapReduce 要实现两个函数： Map 函数和 Reduce 函数。\n>\n> Map 函数调用 emit(key, value), 遍历 collection 中所有的记录, 将 key 与 value 传递给 Reduce 函数进行处理。\n\n**Map 函数必须调用 emit(key, value) 返回键值对。**\n\n参数说明:\n\n- **map** ：映射函数 (生成键值对序列,作为 reduce 函数参数)。\n- **reduce** 统计函数，reduce函数的任务就是将key-values变成key-value，也就是把values数组变成一个单一的值value。\n- **out** 统计结果存放集合 (不指定则使用临时集合,在客户端断开后自动删除)。\n  - 可选参数：inline\t`out: {inline: 1}`\n  - 不会创建集合，整个操作都在内存里运行==（结果集单个文档大小<16MB）==\n- **query** 一个筛选条件，只有满足条件的文档才会调用map函数。（query。limit，sort可以随意组合）\n- **sort** 和limit结合的sort排序参数（也是在发往map函数前给文档排序），可以优化分组机制\n- **limit** 发往map函数的文档数量的上限（要是没有limit，单独使用sort的用处不大）\n\n> 例：将在 posts 集合中使用 mapReduce 函数来选取已发布的文章(status:\"active\")，并通过user_name分组，计算每个用户的文章数：\n>\n> ```javascript\n> db.posts.mapReduce( \n>    function() { emit(this.user_name,1); }, \t// map\n>    function(key, values) {return Array.sum(values)},  // Arraty：将数组或列表或多个值存储为一个键\treduce\n>       {  \n>          query:{status:\"active\"},  \t// quert：筛选条件\n>          out:\"post_total\" \t\t\t// out：结果存储集合\n>       }\n> ).find()\n> ```\n\n## 5. 全文检索\n\n​\t\t对每一个词建立一个索引，指明该词在文章中出现的次数和位置，当用户查询时，检索程序就根据事先建立的索引进行查找，并将查找的结果反馈给用户的检索方式。\n\n1. **启动**\n\n   2.6版本后默认开启，小于2.6版本启动命令:\n\n   `db.adminCommand({setParameter:true,textSearchEnabled:true})` \n\n   &&\n\n    `mongod --setParameter textSearchEnabled=true`\n\n2. **创建**\n\n   > 创建posts集合文档数据，包含文章内容（post_text）及标签(tags)：\n   >\n   > ```\n   > {\n   >    \"post_text\": \"enjoy the mongodb articles on Runoob\",\n   >    \"tags\": [\n   >       \"mongodb\",\n   >       \"runoob\"\n   >    ]\n   > }\n   > ```\n   >\n   > \n\n   对post_text字段建立全文索引：`db.posts.ensureIndex({post_text:\"text\"})`\n\n3. 使用\n\n   搜索文章中的关键词 runoob：`db.posts.find({$text:{$search:\"runoob\"}})`\n\n   > 使用全文检索可以提高查询效率\n\n4. 删除\n\n   `db.posts.dropIndex(\"post_text_text\")`\n\n## 6. 正则表达式\n\n**使用：$regex**\n\n`db.posts.find({post_text:{$regex:\"runoob\"}})`\n\n&&\n\n`db.posts.find({post_text:/runoob/})`\n\n不区分大小写：`db.posts.find({post_text:{$regex:\"runoob\",$options:\"$i\"}})`\n\n**数组元素使用正则表达式**\n\n> 例：查找run 开头的标签数据(ru 或 run 或 runoob)\n>\n> `db.posts.find({tags:{$regex:\"run\"}})`\n\n### 6.1 优化\n\n- 索引字段查询速度高于正则匹配\n\n- 如果正则表达式是前缀表达式，所有匹配的数据将以指定的前缀字符串为开始\n\n  > 例：^tut\t\t匹配以tut为开头的字符串\n\n- 正则表达式中使用变量。一定要使用eval将组合的字符串进行转换，不能直接将字符串拼接后传入给表达式。否则没有报错信息，只是结果为空！\n\n  > 例：`name=eval(\"/\" + 变量值key +\"/i\"); `\n  >\n  > 例：模糊查询包含title关键词, 且不区分大小写`title:eval(\"/\"+title+\"/i\")`    \n  >\n  > - 同：`title:{$regex:title,$Option:\"$i\"}   `\n\n## 7. GridFS\n\n​\t\tGridFS 用于存储和恢复那些超过16M（BSON文件限制）的文件(如：图片、音频、视频等)。也是文件存储的一种方式，但是它是存储在MonoDB的集合中。将大文件对象分割成多个小的chunk(文件片段),一般为256k/个,每个chunk将作为MongoDB的一个文档(document)被存储在chunks集合中。\n\n- 用两个集合来存储一个文件\n\n  **fs.files：**每个文件的实际内容被存在chunks(二进制数据)中\n\n  **fs.chunks：**和文件有关的meta数据(filename,content_type,还有用户自定义的属性)将会被存在files集合中。\n\n**GridFS添加文件**\n\n> 例：添加mp3文件\n>\n> `mongofiles.exe -d gridfs put song.mp3`\n>\n> `-d gridfs`：指定存储文件的数据库名称，未指定会自动创建\n\n查看数据库中文件的文档：`db.fs.files.find()`\n\n根据 _id 获取区块(chunk)的数据：\n\n`db.fs.chunks.find({files_id:ObjectId('534a811bf8b4aa4d33fdf94d')})`\n\n## 8. 固定集合\n\n​\t\t固定长度，当集合空间用完后，再插入的元素就会覆盖最初始的头部的元素！可以插入及更新，但不能更新超出collection的大小，不允许删除，但是可以调用drop()删除集合中的所有行，drop后需要显式地重建集合。\n\n- 对固定集合进行插入速度极快\n- 按照插入顺序的查询输出速度极快\n- 能够在插入最新数据时,淘汰最早的数据\n\n**创建**\n\n`db.createCollection(\"cappedLogCollection\",{capped:true,size:10000})`\n\n指定文档个数\n\n`db.createCollection(\"cappedLogCollection\",{capped:true,size:10000,max:1000})`\n\n- **size(KB)：**整个集合空间的大小\n- **max(个)：**文档数上限\n\n判断集合是否为固定集合\n\n`db.cappedLogCollection.isCapped()`\n\n将已存在的集合转为固定集合\n\n`db.runCommand({\"convertToCapped\":\"posts\", size:10000})`\n\n> 将已存在的posts集合转为固定集合\n\n**查询**\n\n​\t\t固定集合文档按照插入顺序储存的,默认情况下查询就是按照插入顺序返回的,也可以使用$natural调整返回顺序。\n\n`db.cappedLogCollection.find().sort({$natural:-1})`\n\n**用法：**存储日志信息、缓存一些少量的文档","source":"_posts/MongDB.md","raw":"---\ntitle: MongDB\ndate: 2020-05-03 10:51:33\ntags: NoSQL\ntop: 0\n---\n\n# 一、MongoDB简介\n\n​\t\t**MongoDB 是由C++语言编写的，是一个基于分布式文件存储的开源数据库系统。**将数据存储为一个文档，数据结构由键值对组成，文档类似于 JSON 对象。字段值可以包含其他文档，数组及文档数组。\n\n**特点：**\n\n- 面向文档存储的数据库，操作简单\n- 可设置任何属性的索引，实现快速排序\n- 可通过本地或者网络创建数据镜像\n\n<!--more-->\n\n## 1. 安装MangoDB\n\n官网下载地址：https://www.mongodb.com/download-center/community\n\n**配置：**\n\n1. 创建D:\\mongodb\\data\\log目录，用来存放日志文件；\n2. 在D:\\mongodb\\data\\log目录里新建mongodb.log，用来存放日志信息；\n3. 创建D:\\mongodb\\data\\db目录，用来存放数据库数据，\n4. 并在D:\\mongodb目录下创建mongo.config，在文件内部复制如下文本：\n\n```bash\n# 数据文件  此处=后对应到数据所存放的目录\ndbpath=d:\\mongodb\\data\\db\n# 日志文件  此处=后对应到日志文件所在路径\nlogpath=d:\\mongodb\\data\\log\\mongodb.log\n# 错误日志采用追加模式，配置这个选项后mongodb的日志会追加到现有的日志文件，而不是从新创建一个新文件\nlogappend=true \n#启用日志文件，默认启用\njournal=true \n#这个选项可以过滤掉一些无用的日志信息，若需要调试使用请设置为false\nquiet=true \n#端口号 默认为27017\nport=27017\n```\n\n**测试是否安装成功**\n\n- 进入\\MongoDB\\Server\\3.4\\bin文件夹下，点击mongod.exe，如果闪一下退出，说明安装正常\n\n  ![](https://tupian-1300728887.cos.ap-chengdu.myqcloud.com/MangoDB%E6%88%90%E5%8A%9F.png)\n\n**安装MongoDB服务**\n\n- 执行mongod.exe，使用--install选项来安装服务，使用--config选项来指定之前创建的配置文件。\n\n  ```\n  C:\\mongodb\\bin\\mongod.exe --config \"C:\\mongodb\\mongod.cfg\" --install\n  ```\n\n**终端操作（管理员）**\n\n- 启动MongoDB服务\n\n  `net start MongoDB`\n\n- 关闭MongoDB服务\n\n  `net stop MongoDB`\n\n- 移除 MongoDB 服务\n\n  `**\\mongodb\\bin\\mongod.exe --remove`\n\n## 2. 概念\n\n| SQL术语/概念 | MongoDB术语/概念 |              解释/说明              |\n| :----------: | :--------------: | :---------------------------------: |\n|   database   |     database     |               数据库                |\n|    table     |    collection    |            数据库表/集合            |\n|     row      |     document     |           数据记录行/文档           |\n|    column    |      field       |             数据字段/域             |\n|    index     |      index       |                索引                 |\n| table joins  |                  |        表连接,MongoDB不支持         |\n| primary key  |   primary key    | 主键,MongoDB自动将_id字段设置为主键 |\n\n### 2.1 数据库\n\nMongoDB的默认数据库为\"db\"，该数据库存储在data目录中。\n\nMongoDB的单个实例可以容纳多个独立的数据库，每一个都有自己的集合和权限，不同的数据库也放置在不同的文件中。\n\n1. 显示所有数据的列表：`show dbs`\n\n2. 显示当前数据库对象或集合:`db`\n\n3. 连接到一个指定的数据库:`use`\n\n\n**自带特殊数据库：**\n\n- **admin**： 从权限的角度来看，这是\"root\"数据库。要是将一个用户添加到这个数据库，这个用户自动继承所有数据库的权限。一些特定的服务器端命令也只能从这个数据库运行，比如列出所有的数据库或者关闭服务器。\n- **local:** 这个数据永远不会被复制，可以用来存储限于本地单台服务器的任意集合\n- **config**: 当Mongo用于分片设置时，config数据库在内部使用，用于保存分片的相关信息。\n\n### 2.2 文档\n\n​\t\t文档是一组键值(key-value)对(即 BSON)。MongoDB 的文档不需要设置相同的字段，并且相同的字段不需要相同的数据类型\n\n| RDBMS  |              MongoDB              |\n| :----: | :-------------------------------: |\n| 数据库 |              数据库               |\n|  表格  |               集合                |\n|   行   |               文档                |\n|   列   |               字段                |\n| 表联合 |             嵌入文档              |\n|  主键  | 主键 (MongoDB 提供了 key 为 _id ) |\n\n1. 文档中的键/值对是有序的。\n2. 文档中的值不仅可以是在双引号里面的字符串，还可以是其他几种数据类型（甚至可以是整个嵌入的文档)。\n3. MongoDB区分类型和大小写。\n4. MongoDB的文档不能有重复的键。\n5. 文档的键是字符串。除了少数例外情况，键可以使用任意UTF-8字符。\n\n文档键命名规范：\n\n- 键不能含有\\0 (空字符)。这个字符用来表示键的结尾。\n- $有特别的意义，只有在特定环境下才能使用。\n- 以下划线\"_\"开头的键是保留的(不是严格要求的)。\n\n### 2.3 集合\n\n​\t\tMongoDB文档组，相比于表格\n\n集合命名规范：\n\n- 集合名不能是空字符串\"\"。\n- 集合名不能含有\\0字符（空字符)，这个字符表示集合名的结尾。\n- 集合名不能以\"system.\"开头，这是为系统集合保留的前缀。\n- 用户创建的集合名字不能含有保留字符。有些驱动程序的确支持在集合名里面包含，这是因为某些系统生成的集合中包含该字符。除非你要访问这种系统创建的集合，否则千万不要在名字里出现$。　\n\n### 2.4 元数据\n\n​\t\t存储数据库信息集合\n\n|       集合命名空间       |                   描述                    |\n| :----------------------: | :---------------------------------------: |\n| dbname.system.namespaces |            列出所有名字空间。             |\n|  dbname.system.indexes   |              列出所有索引。               |\n|  dbname.system.profile   |       包含数据库概要(profile)信息。       |\n|   dbname.system.users    |       列出所有可访问数据库的用户。        |\n|   dbname.local.sources   | 包含复制对端（slave）的服务器信息和状态。 |\n\n- 在indexes中插入数据，可创建索引\n- users是可以修改的\n- profile是可以删除的\n\n### 2.5 MongoDB数据类型\n\n|       String       | 字符串。存储数据常用的数据类型。在 MongoDB 中，UTF-8 编码的字符串才是合法的。 |\n| :----------------: | :----------------------------------------------------------- |\n|      Integer       | 整型数值。用于存储数值。根据你所采用的服务器，可分为 32 位或 64 位。 |\n|      Boolean       | 布尔值。用于存储布尔值（真/假）。                            |\n|       Double       | 双精度浮点值。用于存储浮点值。                               |\n|    Min/Max keys    | 将一个值与 BSON（二进制的 JSON）元素的最低值和最高值相对比。 |\n|       Array        | 用于将数组或列表或多个值存储为一个键。                       |\n|     Timestamp      | 时间戳。记录文档修改或添加的具体时间。                       |\n|       Object       | 用于内嵌文档。                                               |\n|        Null        | 用于创建空值。                                               |\n|       Symbol       | 符号。该数据类型基本上等同于字符串类型，但不同的是，它一般用于采用特殊符号类型的语言。 |\n|        Date        | 日期时间。用 UNIX 时间格式来存储当前日期或时间。你可以指定自己的日期时间：创建 Date 对象，传入年月日信息。 |\n|     Object ID      | 对象 ID。用于创建文档的 ID。                                 |\n|    Binary Data     | 二进制数据。用于存储二进制数据。                             |\n|        Code        | 代码类型。用于在文档中存储 JavaScript 代码。                 |\n| Regular expression | 正则表达式类型。用于存储正则表达式。                         |\n\n**ObjectId 类似唯一主键，可以很快的去生成和排序，**包含 12 bytes，含义是：\n\n- 前 4 个字节表示创建 **unix** 时间戳,格林尼治时间 **UTC** 时间，比北京时间晚了 8 个小时\n\n- 接下来的 3 个字节是机器标识码\n- 紧接的两个字节由进程 id 组成 PID\n- 最后三个字节是随机数\n\n![img](https://www.runoob.com/wp-content/uploads/2013/10/2875754375-5a19268f0fd9b_articlex.jpeg)\n\n​\t\tMongoDB 中存储的文档必须有一个 _id 键。这个键的值可以是任何类型的，默认是个 ObjectId 对象\n\n由于 ObjectId 中保存了创建的时间戳，可以通过 getTimestamp 函数来获取文档的创建时间:\n\n```bash\nnewObject = ObjectId()\nnewObject.getTimestamp()\nISODate(\"2017-11-25T07:21:10Z\")\n# ObjectId转字符串\nstr_objectid = ObjectId().str\ntypeof str_objectid\nstring\n```\n\n# 二、MongoDB操作\n\n## 1. 数据库操作\n\n创建数据库：`use DATABASE_NAME`\n\n查看所有数据库：`show dbs`\n\n删除数据库：`db.dropDatabase()`\n\n>  集合（数据表）在插入数据后才会被创建\n\n## 2. 集合操作\n\n创建集合：`db.createCollection(name, options)`\n\n- name：集合名称\n\n- options：可选参数，指定内存大小及索引\n\n  1. capped（布尔）：如果为 true，则创建固定集合。\n     - 固定集合是指有着固定大小的集合，当达到最大值时，它会自动覆盖最早的文档。\n       **当该值为 true 时，必须指定 size 参数。**\n\n  2. autolndexld（布尔）：如为 true，自动在 _id 字段创建索引。默认为 false。\n\n  3. size：为固定集合指定一个最大值，以千字节计（KB）\n\n  4. max：指定固定集合中包含文档的最大数量。\n\n> 在插入文档时，MongoDB 首先检查固定集合的 size 字段，然后检查 max 字段。\n\n查看已有集合：`show collections && show tables`\n\n删除集合：`db.collection.drop()`\n\n## 3. 文档操作\n\n**插入文档**：`db.COLLECTION_NAME.insert(document) && **save(document)`\n\n查看已插入的文档：\t`db.COLLECTION_NAME.find()`\n\n**更新文档**\n\n1. update()\n\n   **更新符合条件的文档**\n\n   ```bash\n   db.collection.update(\n      <query>,\t\t\t# 查询条件，≈where后面的\n      <update>,\t\t# update的对象和一些更新的操作符（如$,$set...）\n      {\n        upsert: <boolean>,\t# 如果不存在update的记录，是否插入objNew\n        multi: <boolean>,\t# 只更新找到的第一条记录，若为真全部更新\n        writeConcern: <document>\t# 异常级别\n      }\n   )\n   ```\n\n2. save()\n\n   **传入文档替换已有文档（_id一样）**\n\n   ```bash\n   db.collection.save(\n      <document>,\t# 文档数据\n      {\n        writeConcern: <document>\t# 异常级别\n      }\n   )\n   ```\n\n**删除文档**：`db.COLLECTION_NAME.deleteOne() && **.deleteMany()`\n\n**查询文档**：`db.collection.find(query, projection)`\n\n- **query** ：可选，使用查询操作符指定查询条件\n- **projection** ：可选，使用投影操作符指定返回的键。查询时返回文档中所有键值， 只需省略该参数即可（默认省略）\n\n用格式化的方式显示所有文档：`db.collection_name.find().pretty()`\n\n**MongoDB的条件操作符**\n\n|    操作    |          格式          |                   范例                    |   RDBMS中的类似语句   |\n| :--------: | :--------------------: | :---------------------------------------: | :-------------------: |\n|    等于    |    {<key>:<value>}     |  db.col.find({\"by\":\"菜鸟教程\"}).pretty()  | where by = '菜鸟教程' |\n|    小于    | {<key>:{$lt:<value>}}  | db.col.find({\"likes\":{$lt:50}}).pretty()  |   where likes < 50    |\n| 小于或等于 | {<key>:{$lte:<value>}} | db.col.find({\"likes\":{$lte:50}}).pretty() |   where likes <= 50   |\n|    大于    | {<key>:{$gt:<value>}}  | db.col.find({\"likes\":{$gt:50}}).pretty()  |   where likes > 50    |\n| 大于或等于 | {<key>:{$gte:<value>}} | db.col.find({\"likes\":{$gte:50}}).pretty() |   where likes >= 50   |\n|   不等于   | {<key>:{$ne:<value>}}  | db.col.find({\"likes\":{$ne:50}}).pretty()  |   where likes != 50   |\n\nand条件查询：`db.collection_name.find({key1:value1, key2:value2}).pretty()`\n\nor条件查询：`db.collection_name.find({$or:[{key1:value1}, {key2:value2}]}).pretty()`\n\n**模糊查询**\n\n- 查询 title 包含\"教\"字的文档：`db.col.find({\"title\":/教/})`\n\n- 查询 title 字段以\"教\"字开头的文档：`db.col.find({\"title\":/^教/})`\n\n- 查询 title字段以\"教\"字结尾的文档：`db.col.find({\"title\":/教$/})`\n\n**$type操作符**\n\n获取集合中 title 为 String 的数据：`db.col.find({\"title\": {$type: 'string'}})`\n\n**指定显示数量：**`db.collection_name.find().limit(number)`\n\n>  如果没有指定limit()方法中的参数则显示集合中的所有数据\n\n**跳过指定显示数量**：`db.collection_name.find().skip(number)`\n\n> skip默认参数为0，效率差，遍历出来的\n\n例：想要读取从 10 条记录后 100 条记录，相当于 sql 中limit (10,100)。\n\n​\t\t`db.COLLECTION_NAME.find().skip(10).limit(100)`\n\n**排序**：`db.COLLECTION_NAME.find().sort({KEY:1})`\n\n> 执行顺序：sort()  -->  skip()  -->  limit()\n\n## 4. 索引\n\n创建：`db.collection.createindex(keys, options)`\n\n创建数组索引：`db.collection.ensureIndex()`\n\n为子文档创建索引：`db.users.ensureIndex({\"address.city\":1,\"address.state\":1,\"address.pincode\":1})`\n\n- keys：创建索引的字段，可有多个，1为升序反之倒序\n- options：可选参数\n  1. background：建索会阻塞其它数据库操作，True为后台建索\n  2. unique：建立的索引是否唯一，默认false，指定true创建唯一索引\n  3. name：索引名称，未指定自动生成（字段名＋排序顺序）\n  4. sparse：对文档中不存在的字段数据不启用索引\n  5. weights：索引权重值\n\n查看集合索引：`db.col.getIndexes()`\n\n查看集合索引大小：`db.col.totalIndexSize()`\n\n删除集合所有索引：`db.col.dropIndexes()`\n\n删除集合指定索引：`db.col.dropIndex(\"索引名称\")`\n\n**定期删除**\n\n数据记录中createDate为时间类型时：设置时间180秒后自动删除\n\n`db.col.createIndex({\"createDate\": 1},{expireAfterSeconds: 180})`\n\n**定时删除**\n\nA记录中需添加 \"ClearUpDate\": new Date('Jan 22, 2019 23:00:00')\n\n`db.col.createIndex({\"ClearUpDate\": 1},{expireAfterSeconds: 0})`\n\n- 索引关键字段必须是 Date 类型。\n- 非立即执行：扫描 Document 过期数据并删除是独立线程执行，默认 60s 扫描一次，删除也不一定是立即删除成功\n\n**查询限制**\n\n索引不能被以下的查询使用：\n\n- 正则表达式及非操作符，如 $nin, $not, 等。\n- 算术运算符，如 $mod, 等。\n- $where 子句\n\n索引限制：\n\n如果现有的索引字段的值超过索引键的限制，MongoDB中不会创建索引。\n\n如果文档的索引字段值超过了索引键的限制，MongoDB不会将任何文档转换成索引的集合。\n\n最大范围：\n\n- 集合中索引不能超过64个\n- 索引名的长度不能超过128个字符\n- 一个复合索引最多可以有31个字段\n\n## 5. 聚合\n\naggregate()方法：`db.collection_name(aggregate_opeation)`\n\n| 表达式    | 描述                                           | 实例                                                         |\n| :-------- | :--------------------------------------------- | :----------------------------------------------------------- |\n| $sum      | 计算总和。                                     | db.mycol.aggregate([{$group : {_id : \"$by_user\", num_tutorial : {$sum : \"$likes\"}}}]) |\n| $avg      | 计算平均值                                     | db.mycol.aggregate([{$group : {_id : \"$by_user\", num_tutorial : {$avg : \"$likes\"}}}]) |\n| $min      | 获取集合中所有文档对应值得最小值。             | db.mycol.aggregate([{$group : {_id : \"$by_user\", num_tutorial : {$min : \"$likes\"}}}]) |\n| $max      | 获取集合中所有文档对应值得最大值。             | db.mycol.aggregate([{$group : {_id : \"$by_user\", num_tutorial : {$max : \"$likes\"}}}]) |\n| $push     | 在结果文档中插入值到一个数组中。               | db.mycol.aggregate([{$group : {_id : \"$by_user\", url : {$push: \"$url\"}}}]) |\n| $addToSet | 在结果文档中插入值到一个数组中，但不创建副本。 | db.mycol.aggregate([{$group : {_id : \"$by_user\", url : {$addToSet : \"$url\"}}}]) |\n| $first    | 根据资源文档的排序获取第一个文档数据。         | db.mycol.aggregate([{$group : {_id : \"$by_user\", first_url : {$first : \"$url\"}}}]) |\n| $last     | 根据资源文档的排序获取最后一个文档数据         | db.mycol.aggregate([{$group : {_id : \"$by_user\", last_url : {$last : \"$url\"}}}]) |\n\n> 例：通过以上集合计算每个作者所写的文章数\n>\n> `db.mycol.aggregate({$group : {_id : \"$by_user\", num_tutorial : {$sum : 1}}})`\n>\n> 相比于SQL语句：\n>\n> `select by_user as _id, count(*) as num_tutorial from mycol group by by_user`\n\n## 6. 管道\n\nMongoDB的聚合管道将MongoDB文档在一个管道处理完毕后将结果传递给下一个管道处理\n\n**$project**：修改文档将结构\n\n> `db.clo.aggregate({$project: {title: 1, author:1}})`\n>\n> 同\n>\n> `db.col.find({}, {title： 1, author:1})`\n\n**$match**：过滤数据\n\n> 例：将分数大于70小于或等于90记录，然后将符合条件的记录送到下一阶段$group管道操作符进行处理\n>\n> ```\n> db.articles.aggregate([\n> \t{ $match : { score : { $gt : 70, $lte : 90 } } },\n> \t{ $group: { _id: null, count: { $sum: 1 } } }\n> ]);\n> ```\n\n**当match和group同时存在时， 顺序会影响检索结果，必须先写 match 在前面**\n\n# 三、MongoDB优化\n\n## 1. 副本集\n\n​\t\t将数据同步在多个服务器的过程，提高了数据的可用性， 并可以保证数据的安全性。具有自动灾难恢复。没有固定的主节点\n\n**副本集设置**\n\n1. 创建一个cluster文件夹，放node1，node2，node3三个子文件夹\n\n   ```\n   节点1：\n   HOST：localhost:10001\n   Data File：F:\\MongoDB\\node1\n   \n   节点2：\n   HOST：localhost:10002\n   Data File：F:\\MongoDB\\node2\n   \n   节点3：\n   HOST：localhost:10003\n   Data File：F:\\MongoDB\\node3\n   ```\n\n2. 指定 --replSet 选项来启动mongoDB：\n\n   `mongod --port 端口 --dbpath 文件夹位置 --replSet 副本集名称`\n\n   - 启动一个新的副本集(初始化操作)：\n\n     ```\n     rs.initiate({\n     \t\"_id\":\"shinelon\",\n     \t\"members\":[ \n     \t\t{\"_id\":1,\"host\":\"localhost:10001\"},\n     \t\t{\"_id\":2,\"host\":\"localhost:10002\"},\n     \t\t{\"_id\":3,\"host\":\"localhost:10003\"} \n     \t\t\t]\n     \t})\n     ```\n\n   - 查看副本集的配置：`rs.conf()`\n\n   - 查看副本集状态： `rs.status() `\n\n   - 副本集添加成员：`rs.add(HOST_NAME:POST)`\n\n## 2. 分片\n\n​\t\t指将数据拆分，将其分散存在不同的机器上的过程，不需要功能强大的大型计算机就可以储存更多的数据，处理更多的负载\n\n**片键**：从集合里面选一个键，用该键的值作为数据拆分的依据\n\n**分片设置**\n\n1. 启动Shard Server（用于存储实际的数据块）\n\n   ```bash\n   HOST：localhost:27020\n   Data File：F:\\MongoDB\\shard\\s0\n   \n   HOST：localhost:27021\n   Data File：F:\\MongoDB\\shard\\s1\n   ...\\s3\n   Data File：F:\\MongoDB\\shard\\log\n   \n   > mongod --port 27020 --dbpath=F:\\MongoDB\\shard\\s0 --logpath=F:\\MongoDB\\shard\\log\\s0.log --logappend --fork\n   ...\n   ```\n\n2. 启动Config Server（mongodb实例）\n\n   ```\n   HOST：localhost:27100\n   Data File：F:\\MongoDB\\shard\\config\n   \n   > mongod --port 27100 --dbpath=F:\\MongoDB\\shard\\config --logpath=F:\\MongoDB\\shard\\log\\config.log --logappend --fork\n   ```\n\n3. 启动Route Process（mongos路由进程：应用连接它来发送请求，知道数据在分片中的位置，收集返回数据）\n\n   ```\n   > mongos --port 40000 --configdb localhost:27100 --fork --logpath=F:\\MongoDB\\shard\\log\\route.log --chunkSize 500\n   ```\n\n   > chunkSize这一项是用来指定chunk的大小的，单位是MB，默认大小为200MB.\n\n4. 配置Sharding\n\n   ```bash\n   mongo admin --port 40000\n   db.runCommand({ addshard:\"localhost:27020\" })\n   ...\n   db.runCommand({ enablesharding:\"test\" }) #设置分片存储的数据库\n   # 指定片键 user.name\n   db.runCommand({ shardcollection: 'test.user', key: {name: 1}})\n   ```\n\n可参考：https://blog.csdn.net/qq_37142346/java/article/details/82824132\n\n## 3. 备份与恢复\n\n数据备份：`mongodump -h dbhost -d dbname -o dbdirectory`\n\n- -h：MongoDB所在服务器地址，默认为： localhost:27017\n- -d：需要备份的数据库实例，例如：test\n- -o：备份的数据存放位置，例如：c:\\data\\dump\n\nmongodump 命令可选参数列表如下所示：\n\n| 语法                                              | 描述                           | 实例                                             |\n| :------------------------------------------------ | :----------------------------- | :----------------------------------------------- |\n| mongodump --host HOST_NAME --port PORT_NUMBER     | 该命令将备份所有MongoDB数据    | mongodump --host runoob.com --port 27017         |\n| mongodump --dbpath DB_PATH --out BACKUP_DIRECTORY |                                | mongodump --dbpath /data/db/ --out /data/backup/ |\n| mongodump --collection COLLECTION --db DB_NAME    | 该命令将备份指定数据库的集合。 | mongodump --collection mycol --db test           |\n\n数据恢复：`mongorestore -h <hostname><:port> -d dbname <path>`\n\n- --host <:port>, -h <:port>：MongoDB所在服务器地址\n\n- --db , -d ：需要恢复的数据库实例，例如：test\n\n- --drop：恢复的时候，先删除当前数据，然后恢复备份的数据。\n\n- <path>：mongorestore 最后的一个参数，设置备份数据所在位置\n\n  > 例：c:\\data\\dump\\test\n\n- --dir：指定备份的目录\n\n  > 不能同时指定 <path> 和 --dir 选项。\n\n## 4. 监控\n\n**mongostat命令**\n\n获取mongoDB的运行状态：mongostat\n\n**mongotop命令**\n\n跟踪一个MongoDB的实例，查看哪些读取和写入数据在花费大量的时间：mongotop <sleeptime>\n\n- 等待时间长度，以秒为单位\n\n# 四、MongoDB高级\n\n## 1. MongoDB关系\n\n​\t\tMongoDB的关系表示多个文档之间在逻辑上的相互关系，文档间可以通过**嵌入**和**引用**来建立联系。\n\n- 一对一\n- 一对多\n- 多对一\n- 多对多\n\n**嵌入式关系**：把用户地址嵌入到用户的文档中（一张表，数据量大的话，影响性能）\n\n> 查询用户地址：`db.users.findOne({\"name\":\"Tom Benzamin\"},{\"address\":1})`\n\n**引用式关系**：通过引用文档的 **id** 字段来建立关系，外键\n\n1. 查询用户地址对象id\n\n   `var result = db.users.findOne({\"name\":\"Tom Benzamin\"},{\"address_ids\":1})`\n\n2. 通过查询的id获取用户的详细地址信息\n\n   `var addresses = db.address.find({\"_id\":{\"$in\":result[\"address_ids\"]}})`\n\n> findOne不能写成find，find返回的是数组，findOne返回的是对象\n\n## 2. 引用操作\n\nMongoDB引用有两种：手动引用（Manual References）和DBRefs\n\n**DBRefs**\n\n形式：`{$ref : , $id : , $db : }`\n\n- $ref：集合名称\n- $id：引用的id\n- $db:数据库名称，可选参数\n\n**覆盖查询：**\n\n- 所有的查询字段是索引的一部分\n- 所有的查询返回字段在同一个索引中\n\n> 1. 在 users 集合中创建联合索引，字段为 gender 和 user_name :\n>\n>    `db.users.ensureIndex({gender:1,user_name:1})`\n>\n> 2. 该索引会覆盖以下查询：\n>\n>    `db.users.find({gender:\"M\"},{user_name:1,_id:0})`\n>\n> 3. 没有排除_id，查询就不会被覆盖\n>\n>    `db.users.find({gender:\"M\"},{user_name:1})`\n\n**查询分析：**可以确保建立的索引是否有效，是查询语句性能分析的重要工具。\n\n1. explain()：查询信息，使用索引及查询统计等\n\n   `db.users.find({gender:\"M\"},{user_name:1,_id:0}).explain()`\n\n2. hint()：指定使用某个索引字段来查询\n\n   `db.users.find({gender:\"M\"},{user_name:1,_id:0}).hint({gender:1,user_name:1})`\n\n## 3. 原子操作\n\n​\t\tmongodb不支持事务，但是mongodb提供了许多原子操作，比如文档的保存，修改，删除等，都是原子操作。要么成功要么失败，达到数据完整性\n\n### 3.1 原子操作常用命令\n\n**$set：**用来指定一个键并更新键值，若键不存在并创建。\n\n`{ $set :{ field : value}}`\n\n> 例：`db.col.update({\"gender\":\"M\"},{$set:{\"gender\": \"A\"}})`\n\n**$unset：**用来删除一个键\n\n`{ $unset : { field : 1} }`\n\n> 例：`db.col.update({\"gender\":\"A\"},{$unset:{\"gender\": 1}})`\n\n**$inc：**对文档的某个值为数字型（只能为满足要求的数字）的键进行增减的操作。\n\n`{ $inc : { field : value } }`\n\n> 例：`db.col.update({},{$inc:{\"num\": 10}})`\n\n**$push：**把value追加到field里面去，field一定要是数组类型才行\n\n`{ $push : { field : value } }`\n\n> 例：`db.col.update({\"_id\": 1},{$push:{age:22}})`\n>\n> 添加多个字段到数组\n>\n> 例：`db.col.update({\"_id\": 1},{$push:{age: {$each: [1,2,3]}}})`\n\n**$pull：**从数组field内删除一个等于value值\n\n`{ $pull: { <field1>: <value|condition>, <field2>: <value|condition>, ... } }`\n\n> 例：`db.col.update({}, {$pull:{age:24}})`\n\n**$pop：**删除数组的第一个（-1）或最后一个（1）元素\n\n`{ $pop : { field : 1 } }`\n\n> 例：`db.col.update({}, {$pop:{\"age\":1}})`\n\n**$rename:**修改字段名称\n\n`{ $rename : { old_field_name : new_field_name } }`\n\n> 例：`db.col.update({}, {$rename: {\"age\":\"age1\"}})`\n\n## 4. Map-Reduce\n\n​\t\tMap-Reduce是一种计算模型，将大批量的工作（数据）分解（MAP）执行，然后再将结果合并成最终结果（REDUCE）\n\n```javascript\ndb.collection.mapReduce(\n   function() {emit(key,value);},  // map 函数\n   function(key,values) {return reduceFunction},   // reduce 函数\n   {\n      out: collection,\n      query: document,\n      sort: document,\n      limit: number\n   }\n)\n```\n\n> 使用 MapReduce 要实现两个函数： Map 函数和 Reduce 函数。\n>\n> Map 函数调用 emit(key, value), 遍历 collection 中所有的记录, 将 key 与 value 传递给 Reduce 函数进行处理。\n\n**Map 函数必须调用 emit(key, value) 返回键值对。**\n\n参数说明:\n\n- **map** ：映射函数 (生成键值对序列,作为 reduce 函数参数)。\n- **reduce** 统计函数，reduce函数的任务就是将key-values变成key-value，也就是把values数组变成一个单一的值value。\n- **out** 统计结果存放集合 (不指定则使用临时集合,在客户端断开后自动删除)。\n  - 可选参数：inline\t`out: {inline: 1}`\n  - 不会创建集合，整个操作都在内存里运行==（结果集单个文档大小<16MB）==\n- **query** 一个筛选条件，只有满足条件的文档才会调用map函数。（query。limit，sort可以随意组合）\n- **sort** 和limit结合的sort排序参数（也是在发往map函数前给文档排序），可以优化分组机制\n- **limit** 发往map函数的文档数量的上限（要是没有limit，单独使用sort的用处不大）\n\n> 例：将在 posts 集合中使用 mapReduce 函数来选取已发布的文章(status:\"active\")，并通过user_name分组，计算每个用户的文章数：\n>\n> ```javascript\n> db.posts.mapReduce( \n>    function() { emit(this.user_name,1); }, \t// map\n>    function(key, values) {return Array.sum(values)},  // Arraty：将数组或列表或多个值存储为一个键\treduce\n>       {  \n>          query:{status:\"active\"},  \t// quert：筛选条件\n>          out:\"post_total\" \t\t\t// out：结果存储集合\n>       }\n> ).find()\n> ```\n\n## 5. 全文检索\n\n​\t\t对每一个词建立一个索引，指明该词在文章中出现的次数和位置，当用户查询时，检索程序就根据事先建立的索引进行查找，并将查找的结果反馈给用户的检索方式。\n\n1. **启动**\n\n   2.6版本后默认开启，小于2.6版本启动命令:\n\n   `db.adminCommand({setParameter:true,textSearchEnabled:true})` \n\n   &&\n\n    `mongod --setParameter textSearchEnabled=true`\n\n2. **创建**\n\n   > 创建posts集合文档数据，包含文章内容（post_text）及标签(tags)：\n   >\n   > ```\n   > {\n   >    \"post_text\": \"enjoy the mongodb articles on Runoob\",\n   >    \"tags\": [\n   >       \"mongodb\",\n   >       \"runoob\"\n   >    ]\n   > }\n   > ```\n   >\n   > \n\n   对post_text字段建立全文索引：`db.posts.ensureIndex({post_text:\"text\"})`\n\n3. 使用\n\n   搜索文章中的关键词 runoob：`db.posts.find({$text:{$search:\"runoob\"}})`\n\n   > 使用全文检索可以提高查询效率\n\n4. 删除\n\n   `db.posts.dropIndex(\"post_text_text\")`\n\n## 6. 正则表达式\n\n**使用：$regex**\n\n`db.posts.find({post_text:{$regex:\"runoob\"}})`\n\n&&\n\n`db.posts.find({post_text:/runoob/})`\n\n不区分大小写：`db.posts.find({post_text:{$regex:\"runoob\",$options:\"$i\"}})`\n\n**数组元素使用正则表达式**\n\n> 例：查找run 开头的标签数据(ru 或 run 或 runoob)\n>\n> `db.posts.find({tags:{$regex:\"run\"}})`\n\n### 6.1 优化\n\n- 索引字段查询速度高于正则匹配\n\n- 如果正则表达式是前缀表达式，所有匹配的数据将以指定的前缀字符串为开始\n\n  > 例：^tut\t\t匹配以tut为开头的字符串\n\n- 正则表达式中使用变量。一定要使用eval将组合的字符串进行转换，不能直接将字符串拼接后传入给表达式。否则没有报错信息，只是结果为空！\n\n  > 例：`name=eval(\"/\" + 变量值key +\"/i\"); `\n  >\n  > 例：模糊查询包含title关键词, 且不区分大小写`title:eval(\"/\"+title+\"/i\")`    \n  >\n  > - 同：`title:{$regex:title,$Option:\"$i\"}   `\n\n## 7. GridFS\n\n​\t\tGridFS 用于存储和恢复那些超过16M（BSON文件限制）的文件(如：图片、音频、视频等)。也是文件存储的一种方式，但是它是存储在MonoDB的集合中。将大文件对象分割成多个小的chunk(文件片段),一般为256k/个,每个chunk将作为MongoDB的一个文档(document)被存储在chunks集合中。\n\n- 用两个集合来存储一个文件\n\n  **fs.files：**每个文件的实际内容被存在chunks(二进制数据)中\n\n  **fs.chunks：**和文件有关的meta数据(filename,content_type,还有用户自定义的属性)将会被存在files集合中。\n\n**GridFS添加文件**\n\n> 例：添加mp3文件\n>\n> `mongofiles.exe -d gridfs put song.mp3`\n>\n> `-d gridfs`：指定存储文件的数据库名称，未指定会自动创建\n\n查看数据库中文件的文档：`db.fs.files.find()`\n\n根据 _id 获取区块(chunk)的数据：\n\n`db.fs.chunks.find({files_id:ObjectId('534a811bf8b4aa4d33fdf94d')})`\n\n## 8. 固定集合\n\n​\t\t固定长度，当集合空间用完后，再插入的元素就会覆盖最初始的头部的元素！可以插入及更新，但不能更新超出collection的大小，不允许删除，但是可以调用drop()删除集合中的所有行，drop后需要显式地重建集合。\n\n- 对固定集合进行插入速度极快\n- 按照插入顺序的查询输出速度极快\n- 能够在插入最新数据时,淘汰最早的数据\n\n**创建**\n\n`db.createCollection(\"cappedLogCollection\",{capped:true,size:10000})`\n\n指定文档个数\n\n`db.createCollection(\"cappedLogCollection\",{capped:true,size:10000,max:1000})`\n\n- **size(KB)：**整个集合空间的大小\n- **max(个)：**文档数上限\n\n判断集合是否为固定集合\n\n`db.cappedLogCollection.isCapped()`\n\n将已存在的集合转为固定集合\n\n`db.runCommand({\"convertToCapped\":\"posts\", size:10000})`\n\n> 将已存在的posts集合转为固定集合\n\n**查询**\n\n​\t\t固定集合文档按照插入顺序储存的,默认情况下查询就是按照插入顺序返回的,也可以使用$natural调整返回顺序。\n\n`db.cappedLogCollection.find().sort({$natural:-1})`\n\n**用法：**存储日志信息、缓存一些少量的文档","slug":"MongDB","published":1,"updated":"2020-08-11T07:15:59.653Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckfp5akf2000an8jhh0bjavzl","content":"<h1 id=\"一、MongoDB简介\"><a href=\"#一、MongoDB简介\" class=\"headerlink\" title=\"一、MongoDB简介\"></a>一、MongoDB简介</h1><p>​        <strong>MongoDB 是由C++语言编写的，是一个基于分布式文件存储的开源数据库系统。</strong>将数据存储为一个文档，数据结构由键值对组成，文档类似于 JSON 对象。字段值可以包含其他文档，数组及文档数组。</p>\n<p><strong>特点：</strong></p>\n<ul>\n<li>面向文档存储的数据库，操作简单</li>\n<li>可设置任何属性的索引，实现快速排序</li>\n<li>可通过本地或者网络创建数据镜像</li>\n</ul>\n<a id=\"more\"></a>\n\n<h2 id=\"1-安装MangoDB\"><a href=\"#1-安装MangoDB\" class=\"headerlink\" title=\"1. 安装MangoDB\"></a>1. 安装MangoDB</h2><p>官网下载地址：<a href=\"https://www.mongodb.com/download-center/community\" target=\"_blank\" rel=\"noopener\">https://www.mongodb.com/download-center/community</a></p>\n<p><strong>配置：</strong></p>\n<ol>\n<li>创建D:\\mongodb\\data\\log目录，用来存放日志文件；</li>\n<li>在D:\\mongodb\\data\\log目录里新建mongodb.log，用来存放日志信息；</li>\n<li>创建D:\\mongodb\\data\\db目录，用来存放数据库数据，</li>\n<li>并在D:\\mongodb目录下创建mongo.config，在文件内部复制如下文本：</li>\n</ol>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 数据文件  此处=后对应到数据所存放的目录</span></span><br><span class=\"line\">dbpath=d:\\mongodb\\data\\db</span><br><span class=\"line\"><span class=\"comment\"># 日志文件  此处=后对应到日志文件所在路径</span></span><br><span class=\"line\">logpath=d:\\mongodb\\data\\<span class=\"built_in\">log</span>\\mongodb.log</span><br><span class=\"line\"><span class=\"comment\"># 错误日志采用追加模式，配置这个选项后mongodb的日志会追加到现有的日志文件，而不是从新创建一个新文件</span></span><br><span class=\"line\">logappend=<span class=\"literal\">true</span> </span><br><span class=\"line\"><span class=\"comment\">#启用日志文件，默认启用</span></span><br><span class=\"line\">journal=<span class=\"literal\">true</span> </span><br><span class=\"line\"><span class=\"comment\">#这个选项可以过滤掉一些无用的日志信息，若需要调试使用请设置为false</span></span><br><span class=\"line\">quiet=<span class=\"literal\">true</span> </span><br><span class=\"line\"><span class=\"comment\">#端口号 默认为27017</span></span><br><span class=\"line\">port=27017</span><br></pre></td></tr></table></figure>\n\n<p><strong>测试是否安装成功</strong></p>\n<ul>\n<li><p>进入\\MongoDB\\Server\\3.4\\bin文件夹下，点击mongod.exe，如果闪一下退出，说明安装正常</p>\n<p><img src=\"https://tupian-1300728887.cos.ap-chengdu.myqcloud.com/MangoDB%E6%88%90%E5%8A%9F.png\" alt=\"\"></p>\n</li>\n</ul>\n<p><strong>安装MongoDB服务</strong></p>\n<ul>\n<li><p>执行mongod.exe，使用–install选项来安装服务，使用–config选项来指定之前创建的配置文件。</p>\n<figure class=\"highlight taggerscript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">C:<span class=\"symbol\">\\m</span>ongodb<span class=\"symbol\">\\b</span>in<span class=\"symbol\">\\m</span>ongod.exe --config \"C:<span class=\"symbol\">\\m</span>ongodb<span class=\"symbol\">\\m</span>ongod.cfg\" --install</span><br></pre></td></tr></table></figure>\n\n</li>\n</ul>\n<p><strong>终端操作（管理员）</strong></p>\n<ul>\n<li><p>启动MongoDB服务</p>\n<p><code>net start MongoDB</code></p>\n</li>\n<li><p>关闭MongoDB服务</p>\n<p><code>net stop MongoDB</code></p>\n</li>\n<li><p>移除 MongoDB 服务</p>\n<p><code>**\\mongodb\\bin\\mongod.exe --remove</code></p>\n</li>\n</ul>\n<h2 id=\"2-概念\"><a href=\"#2-概念\" class=\"headerlink\" title=\"2. 概念\"></a>2. 概念</h2><table>\n<thead>\n<tr>\n<th align=\"center\">SQL术语/概念</th>\n<th align=\"center\">MongoDB术语/概念</th>\n<th align=\"center\">解释/说明</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\">database</td>\n<td align=\"center\">database</td>\n<td align=\"center\">数据库</td>\n</tr>\n<tr>\n<td align=\"center\">table</td>\n<td align=\"center\">collection</td>\n<td align=\"center\">数据库表/集合</td>\n</tr>\n<tr>\n<td align=\"center\">row</td>\n<td align=\"center\">document</td>\n<td align=\"center\">数据记录行/文档</td>\n</tr>\n<tr>\n<td align=\"center\">column</td>\n<td align=\"center\">field</td>\n<td align=\"center\">数据字段/域</td>\n</tr>\n<tr>\n<td align=\"center\">index</td>\n<td align=\"center\">index</td>\n<td align=\"center\">索引</td>\n</tr>\n<tr>\n<td align=\"center\">table joins</td>\n<td align=\"center\"></td>\n<td align=\"center\">表连接,MongoDB不支持</td>\n</tr>\n<tr>\n<td align=\"center\">primary key</td>\n<td align=\"center\">primary key</td>\n<td align=\"center\">主键,MongoDB自动将_id字段设置为主键</td>\n</tr>\n</tbody></table>\n<h3 id=\"2-1-数据库\"><a href=\"#2-1-数据库\" class=\"headerlink\" title=\"2.1 数据库\"></a>2.1 数据库</h3><p>MongoDB的默认数据库为”db”，该数据库存储在data目录中。</p>\n<p>MongoDB的单个实例可以容纳多个独立的数据库，每一个都有自己的集合和权限，不同的数据库也放置在不同的文件中。</p>\n<ol>\n<li><p>显示所有数据的列表：<code>show dbs</code></p>\n</li>\n<li><p>显示当前数据库对象或集合:<code>db</code></p>\n</li>\n<li><p>连接到一个指定的数据库:<code>use</code></p>\n</li>\n</ol>\n<p><strong>自带特殊数据库：</strong></p>\n<ul>\n<li><strong>admin</strong>： 从权限的角度来看，这是”root”数据库。要是将一个用户添加到这个数据库，这个用户自动继承所有数据库的权限。一些特定的服务器端命令也只能从这个数据库运行，比如列出所有的数据库或者关闭服务器。</li>\n<li><strong>local:</strong> 这个数据永远不会被复制，可以用来存储限于本地单台服务器的任意集合</li>\n<li><strong>config</strong>: 当Mongo用于分片设置时，config数据库在内部使用，用于保存分片的相关信息。</li>\n</ul>\n<h3 id=\"2-2-文档\"><a href=\"#2-2-文档\" class=\"headerlink\" title=\"2.2 文档\"></a>2.2 文档</h3><p>​        文档是一组键值(key-value)对(即 BSON)。MongoDB 的文档不需要设置相同的字段，并且相同的字段不需要相同的数据类型</p>\n<table>\n<thead>\n<tr>\n<th align=\"center\">RDBMS</th>\n<th align=\"center\">MongoDB</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\">数据库</td>\n<td align=\"center\">数据库</td>\n</tr>\n<tr>\n<td align=\"center\">表格</td>\n<td align=\"center\">集合</td>\n</tr>\n<tr>\n<td align=\"center\">行</td>\n<td align=\"center\">文档</td>\n</tr>\n<tr>\n<td align=\"center\">列</td>\n<td align=\"center\">字段</td>\n</tr>\n<tr>\n<td align=\"center\">表联合</td>\n<td align=\"center\">嵌入文档</td>\n</tr>\n<tr>\n<td align=\"center\">主键</td>\n<td align=\"center\">主键 (MongoDB 提供了 key 为 _id )</td>\n</tr>\n</tbody></table>\n<ol>\n<li>文档中的键/值对是有序的。</li>\n<li>文档中的值不仅可以是在双引号里面的字符串，还可以是其他几种数据类型（甚至可以是整个嵌入的文档)。</li>\n<li>MongoDB区分类型和大小写。</li>\n<li>MongoDB的文档不能有重复的键。</li>\n<li>文档的键是字符串。除了少数例外情况，键可以使用任意UTF-8字符。</li>\n</ol>\n<p>文档键命名规范：</p>\n<ul>\n<li>键不能含有\\0 (空字符)。这个字符用来表示键的结尾。</li>\n<li>$有特别的意义，只有在特定环境下才能使用。</li>\n<li>以下划线”_”开头的键是保留的(不是严格要求的)。</li>\n</ul>\n<h3 id=\"2-3-集合\"><a href=\"#2-3-集合\" class=\"headerlink\" title=\"2.3 集合\"></a>2.3 集合</h3><p>​        MongoDB文档组，相比于表格</p>\n<p>集合命名规范：</p>\n<ul>\n<li>集合名不能是空字符串””。</li>\n<li>集合名不能含有\\0字符（空字符)，这个字符表示集合名的结尾。</li>\n<li>集合名不能以”system.”开头，这是为系统集合保留的前缀。</li>\n<li>用户创建的集合名字不能含有保留字符。有些驱动程序的确支持在集合名里面包含，这是因为某些系统生成的集合中包含该字符。除非你要访问这种系统创建的集合，否则千万不要在名字里出现$。　</li>\n</ul>\n<h3 id=\"2-4-元数据\"><a href=\"#2-4-元数据\" class=\"headerlink\" title=\"2.4 元数据\"></a>2.4 元数据</h3><p>​        存储数据库信息集合</p>\n<table>\n<thead>\n<tr>\n<th align=\"center\">集合命名空间</th>\n<th align=\"center\">描述</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\">dbname.system.namespaces</td>\n<td align=\"center\">列出所有名字空间。</td>\n</tr>\n<tr>\n<td align=\"center\">dbname.system.indexes</td>\n<td align=\"center\">列出所有索引。</td>\n</tr>\n<tr>\n<td align=\"center\">dbname.system.profile</td>\n<td align=\"center\">包含数据库概要(profile)信息。</td>\n</tr>\n<tr>\n<td align=\"center\">dbname.system.users</td>\n<td align=\"center\">列出所有可访问数据库的用户。</td>\n</tr>\n<tr>\n<td align=\"center\">dbname.local.sources</td>\n<td align=\"center\">包含复制对端（slave）的服务器信息和状态。</td>\n</tr>\n</tbody></table>\n<ul>\n<li>在indexes中插入数据，可创建索引</li>\n<li>users是可以修改的</li>\n<li>profile是可以删除的</li>\n</ul>\n<h3 id=\"2-5-MongoDB数据类型\"><a href=\"#2-5-MongoDB数据类型\" class=\"headerlink\" title=\"2.5 MongoDB数据类型\"></a>2.5 MongoDB数据类型</h3><table>\n<thead>\n<tr>\n<th align=\"center\">String</th>\n<th align=\"left\">字符串。存储数据常用的数据类型。在 MongoDB 中，UTF-8 编码的字符串才是合法的。</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\">Integer</td>\n<td align=\"left\">整型数值。用于存储数值。根据你所采用的服务器，可分为 32 位或 64 位。</td>\n</tr>\n<tr>\n<td align=\"center\">Boolean</td>\n<td align=\"left\">布尔值。用于存储布尔值（真/假）。</td>\n</tr>\n<tr>\n<td align=\"center\">Double</td>\n<td align=\"left\">双精度浮点值。用于存储浮点值。</td>\n</tr>\n<tr>\n<td align=\"center\">Min/Max keys</td>\n<td align=\"left\">将一个值与 BSON（二进制的 JSON）元素的最低值和最高值相对比。</td>\n</tr>\n<tr>\n<td align=\"center\">Array</td>\n<td align=\"left\">用于将数组或列表或多个值存储为一个键。</td>\n</tr>\n<tr>\n<td align=\"center\">Timestamp</td>\n<td align=\"left\">时间戳。记录文档修改或添加的具体时间。</td>\n</tr>\n<tr>\n<td align=\"center\">Object</td>\n<td align=\"left\">用于内嵌文档。</td>\n</tr>\n<tr>\n<td align=\"center\">Null</td>\n<td align=\"left\">用于创建空值。</td>\n</tr>\n<tr>\n<td align=\"center\">Symbol</td>\n<td align=\"left\">符号。该数据类型基本上等同于字符串类型，但不同的是，它一般用于采用特殊符号类型的语言。</td>\n</tr>\n<tr>\n<td align=\"center\">Date</td>\n<td align=\"left\">日期时间。用 UNIX 时间格式来存储当前日期或时间。你可以指定自己的日期时间：创建 Date 对象，传入年月日信息。</td>\n</tr>\n<tr>\n<td align=\"center\">Object ID</td>\n<td align=\"left\">对象 ID。用于创建文档的 ID。</td>\n</tr>\n<tr>\n<td align=\"center\">Binary Data</td>\n<td align=\"left\">二进制数据。用于存储二进制数据。</td>\n</tr>\n<tr>\n<td align=\"center\">Code</td>\n<td align=\"left\">代码类型。用于在文档中存储 JavaScript 代码。</td>\n</tr>\n<tr>\n<td align=\"center\">Regular expression</td>\n<td align=\"left\">正则表达式类型。用于存储正则表达式。</td>\n</tr>\n</tbody></table>\n<p><strong>ObjectId 类似唯一主键，可以很快的去生成和排序，</strong>包含 12 bytes，含义是：</p>\n<ul>\n<li><p>前 4 个字节表示创建 <strong>unix</strong> 时间戳,格林尼治时间 <strong>UTC</strong> 时间，比北京时间晚了 8 个小时</p>\n</li>\n<li><p>接下来的 3 个字节是机器标识码</p>\n</li>\n<li><p>紧接的两个字节由进程 id 组成 PID</p>\n</li>\n<li><p>最后三个字节是随机数</p>\n</li>\n</ul>\n<p><img src=\"https://www.runoob.com/wp-content/uploads/2013/10/2875754375-5a19268f0fd9b_articlex.jpeg\" alt=\"img\"></p>\n<p>​        MongoDB 中存储的文档必须有一个 _id 键。这个键的值可以是任何类型的，默认是个 ObjectId 对象</p>\n<p>由于 ObjectId 中保存了创建的时间戳，可以通过 getTimestamp 函数来获取文档的创建时间:</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">newObject = ObjectId()</span><br><span class=\"line\">newObject.getTimestamp()</span><br><span class=\"line\">ISODate(<span class=\"string\">\"2017-11-25T07:21:10Z\"</span>)</span><br><span class=\"line\"><span class=\"comment\"># ObjectId转字符串</span></span><br><span class=\"line\">str_objectid = ObjectId().str</span><br><span class=\"line\">typeof str_objectid</span><br><span class=\"line\">string</span><br></pre></td></tr></table></figure>\n\n<h1 id=\"二、MongoDB操作\"><a href=\"#二、MongoDB操作\" class=\"headerlink\" title=\"二、MongoDB操作\"></a>二、MongoDB操作</h1><h2 id=\"1-数据库操作\"><a href=\"#1-数据库操作\" class=\"headerlink\" title=\"1. 数据库操作\"></a>1. 数据库操作</h2><p>创建数据库：<code>use DATABASE_NAME</code></p>\n<p>查看所有数据库：<code>show dbs</code></p>\n<p>删除数据库：<code>db.dropDatabase()</code></p>\n<blockquote>\n<p> 集合（数据表）在插入数据后才会被创建</p>\n</blockquote>\n<h2 id=\"2-集合操作\"><a href=\"#2-集合操作\" class=\"headerlink\" title=\"2. 集合操作\"></a>2. 集合操作</h2><p>创建集合：<code>db.createCollection(name, options)</code></p>\n<ul>\n<li><p>name：集合名称</p>\n</li>\n<li><p>options：可选参数，指定内存大小及索引</p>\n<ol>\n<li><p>capped（布尔）：如果为 true，则创建固定集合。</p>\n<ul>\n<li>固定集合是指有着固定大小的集合，当达到最大值时，它会自动覆盖最早的文档。<br><strong>当该值为 true 时，必须指定 size 参数。</strong></li>\n</ul>\n</li>\n<li><p>autolndexld（布尔）：如为 true，自动在 _id 字段创建索引。默认为 false。</p>\n</li>\n<li><p>size：为固定集合指定一个最大值，以千字节计（KB）</p>\n</li>\n<li><p>max：指定固定集合中包含文档的最大数量。</p>\n</li>\n</ol>\n</li>\n</ul>\n<blockquote>\n<p>在插入文档时，MongoDB 首先检查固定集合的 size 字段，然后检查 max 字段。</p>\n</blockquote>\n<p>查看已有集合：<code>show collections &amp;&amp; show tables</code></p>\n<p>删除集合：<code>db.collection.drop()</code></p>\n<h2 id=\"3-文档操作\"><a href=\"#3-文档操作\" class=\"headerlink\" title=\"3. 文档操作\"></a>3. 文档操作</h2><p><strong>插入文档</strong>：<code>db.COLLECTION_NAME.insert(document) &amp;&amp; **save(document)</code></p>\n<p>查看已插入的文档：    <code>db.COLLECTION_NAME.find()</code></p>\n<p><strong>更新文档</strong></p>\n<ol>\n<li><p>update()</p>\n<p><strong>更新符合条件的文档</strong></p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">db.collection.update(</span><br><span class=\"line\">   &lt;query&gt;,\t\t\t<span class=\"comment\"># 查询条件，≈where后面的</span></span><br><span class=\"line\">   &lt;update&gt;,\t\t<span class=\"comment\"># update的对象和一些更新的操作符（如$,$set...）</span></span><br><span class=\"line\">   &#123;</span><br><span class=\"line\">     upsert: &lt;boolean&gt;,\t<span class=\"comment\"># 如果不存在update的记录，是否插入objNew</span></span><br><span class=\"line\">     multi: &lt;boolean&gt;,\t<span class=\"comment\"># 只更新找到的第一条记录，若为真全部更新</span></span><br><span class=\"line\">     writeConcern: &lt;document&gt;\t<span class=\"comment\"># 异常级别</span></span><br><span class=\"line\">   &#125;</span><br><span class=\"line\">)</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>save()</p>\n<p><strong>传入文档替换已有文档（_id一样）</strong></p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">db.collection.save(</span><br><span class=\"line\">   &lt;document&gt;,\t<span class=\"comment\"># 文档数据</span></span><br><span class=\"line\">   &#123;</span><br><span class=\"line\">     writeConcern: &lt;document&gt;\t<span class=\"comment\"># 异常级别</span></span><br><span class=\"line\">   &#125;</span><br><span class=\"line\">)</span><br></pre></td></tr></table></figure>\n\n</li>\n</ol>\n<p><strong>删除文档</strong>：<code>db.COLLECTION_NAME.deleteOne() &amp;&amp; **.deleteMany()</code></p>\n<p><strong>查询文档</strong>：<code>db.collection.find(query, projection)</code></p>\n<ul>\n<li><strong>query</strong> ：可选，使用查询操作符指定查询条件</li>\n<li><strong>projection</strong> ：可选，使用投影操作符指定返回的键。查询时返回文档中所有键值， 只需省略该参数即可（默认省略）</li>\n</ul>\n<p>用格式化的方式显示所有文档：<code>db.collection_name.find().pretty()</code></p>\n<p><strong>MongoDB的条件操作符</strong></p>\n<table>\n<thead>\n<tr>\n<th align=\"center\">操作</th>\n<th align=\"center\">格式</th>\n<th align=\"center\">范例</th>\n<th align=\"center\">RDBMS中的类似语句</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\">等于</td>\n<td align=\"center\">{<key>:<value>}</td>\n<td align=\"center\">db.col.find({“by”:”菜鸟教程”}).pretty()</td>\n<td align=\"center\">where by = ‘菜鸟教程’</td>\n</tr>\n<tr>\n<td align=\"center\">小于</td>\n<td align=\"center\">{<key>:{$lt:<value>}}</td>\n<td align=\"center\">db.col.find({“likes”:{$lt:50}}).pretty()</td>\n<td align=\"center\">where likes &lt; 50</td>\n</tr>\n<tr>\n<td align=\"center\">小于或等于</td>\n<td align=\"center\">{<key>:{$lte:<value>}}</td>\n<td align=\"center\">db.col.find({“likes”:{$lte:50}}).pretty()</td>\n<td align=\"center\">where likes &lt;= 50</td>\n</tr>\n<tr>\n<td align=\"center\">大于</td>\n<td align=\"center\">{<key>:{$gt:<value>}}</td>\n<td align=\"center\">db.col.find({“likes”:{$gt:50}}).pretty()</td>\n<td align=\"center\">where likes &gt; 50</td>\n</tr>\n<tr>\n<td align=\"center\">大于或等于</td>\n<td align=\"center\">{<key>:{$gte:<value>}}</td>\n<td align=\"center\">db.col.find({“likes”:{$gte:50}}).pretty()</td>\n<td align=\"center\">where likes &gt;= 50</td>\n</tr>\n<tr>\n<td align=\"center\">不等于</td>\n<td align=\"center\">{<key>:{$ne:<value>}}</td>\n<td align=\"center\">db.col.find({“likes”:{$ne:50}}).pretty()</td>\n<td align=\"center\">where likes != 50</td>\n</tr>\n</tbody></table>\n<p>and条件查询：<code>db.collection_name.find({key1:value1, key2:value2}).pretty()</code></p>\n<p>or条件查询：<code>db.collection_name.find({$or:[{key1:value1}, {key2:value2}]}).pretty()</code></p>\n<p><strong>模糊查询</strong></p>\n<ul>\n<li><p>查询 title 包含”教”字的文档：<code>db.col.find({&quot;title&quot;:/教/})</code></p>\n</li>\n<li><p>查询 title 字段以”教”字开头的文档：<code>db.col.find({&quot;title&quot;:/^教/})</code></p>\n</li>\n<li><p>查询 title字段以”教”字结尾的文档：<code>db.col.find({&quot;title&quot;:/教$/})</code></p>\n</li>\n</ul>\n<p><strong>$type操作符</strong></p>\n<p>获取集合中 title 为 String 的数据：<code>db.col.find({&quot;title&quot;: {$type: &#39;string&#39;}})</code></p>\n<p><strong>指定显示数量：</strong><code>db.collection_name.find().limit(number)</code></p>\n<blockquote>\n<p> 如果没有指定limit()方法中的参数则显示集合中的所有数据</p>\n</blockquote>\n<p><strong>跳过指定显示数量</strong>：<code>db.collection_name.find().skip(number)</code></p>\n<blockquote>\n<p>skip默认参数为0，效率差，遍历出来的</p>\n</blockquote>\n<p>例：想要读取从 10 条记录后 100 条记录，相当于 sql 中limit (10,100)。</p>\n<p>​        <code>db.COLLECTION_NAME.find().skip(10).limit(100)</code></p>\n<p><strong>排序</strong>：<code>db.COLLECTION_NAME.find().sort({KEY:1})</code></p>\n<blockquote>\n<p>执行顺序：sort()  –&gt;  skip()  –&gt;  limit()</p>\n</blockquote>\n<h2 id=\"4-索引\"><a href=\"#4-索引\" class=\"headerlink\" title=\"4. 索引\"></a>4. 索引</h2><p>创建：<code>db.collection.createindex(keys, options)</code></p>\n<p>创建数组索引：<code>db.collection.ensureIndex()</code></p>\n<p>为子文档创建索引：<code>db.users.ensureIndex({&quot;address.city&quot;:1,&quot;address.state&quot;:1,&quot;address.pincode&quot;:1})</code></p>\n<ul>\n<li>keys：创建索引的字段，可有多个，1为升序反之倒序</li>\n<li>options：可选参数<ol>\n<li>background：建索会阻塞其它数据库操作，True为后台建索</li>\n<li>unique：建立的索引是否唯一，默认false，指定true创建唯一索引</li>\n<li>name：索引名称，未指定自动生成（字段名＋排序顺序）</li>\n<li>sparse：对文档中不存在的字段数据不启用索引</li>\n<li>weights：索引权重值</li>\n</ol>\n</li>\n</ul>\n<p>查看集合索引：<code>db.col.getIndexes()</code></p>\n<p>查看集合索引大小：<code>db.col.totalIndexSize()</code></p>\n<p>删除集合所有索引：<code>db.col.dropIndexes()</code></p>\n<p>删除集合指定索引：<code>db.col.dropIndex(&quot;索引名称&quot;)</code></p>\n<p><strong>定期删除</strong></p>\n<p>数据记录中createDate为时间类型时：设置时间180秒后自动删除</p>\n<p><code>db.col.createIndex({&quot;createDate&quot;: 1},{expireAfterSeconds: 180})</code></p>\n<p><strong>定时删除</strong></p>\n<p>A记录中需添加 “ClearUpDate”: new Date(‘Jan 22, 2019 23:00:00’)</p>\n<p><code>db.col.createIndex({&quot;ClearUpDate&quot;: 1},{expireAfterSeconds: 0})</code></p>\n<ul>\n<li>索引关键字段必须是 Date 类型。</li>\n<li>非立即执行：扫描 Document 过期数据并删除是独立线程执行，默认 60s 扫描一次，删除也不一定是立即删除成功</li>\n</ul>\n<p><strong>查询限制</strong></p>\n<p>索引不能被以下的查询使用：</p>\n<ul>\n<li>正则表达式及非操作符，如 $nin, $not, 等。</li>\n<li>算术运算符，如 $mod, 等。</li>\n<li>$where 子句</li>\n</ul>\n<p>索引限制：</p>\n<p>如果现有的索引字段的值超过索引键的限制，MongoDB中不会创建索引。</p>\n<p>如果文档的索引字段值超过了索引键的限制，MongoDB不会将任何文档转换成索引的集合。</p>\n<p>最大范围：</p>\n<ul>\n<li>集合中索引不能超过64个</li>\n<li>索引名的长度不能超过128个字符</li>\n<li>一个复合索引最多可以有31个字段</li>\n</ul>\n<h2 id=\"5-聚合\"><a href=\"#5-聚合\" class=\"headerlink\" title=\"5. 聚合\"></a>5. 聚合</h2><p>aggregate()方法：<code>db.collection_name(aggregate_opeation)</code></p>\n<table>\n<thead>\n<tr>\n<th align=\"left\">表达式</th>\n<th align=\"left\">描述</th>\n<th align=\"left\">实例</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"left\">$sum</td>\n<td align=\"left\">计算总和。</td>\n<td align=\"left\">db.mycol.aggregate([{$group : {_id : “$by_user”, num_tutorial : {$sum : “$likes”}}}])</td>\n</tr>\n<tr>\n<td align=\"left\">$avg</td>\n<td align=\"left\">计算平均值</td>\n<td align=\"left\">db.mycol.aggregate([{$group : {_id : “$by_user”, num_tutorial : {$avg : “$likes”}}}])</td>\n</tr>\n<tr>\n<td align=\"left\">$min</td>\n<td align=\"left\">获取集合中所有文档对应值得最小值。</td>\n<td align=\"left\">db.mycol.aggregate([{$group : {_id : “$by_user”, num_tutorial : {$min : “$likes”}}}])</td>\n</tr>\n<tr>\n<td align=\"left\">$max</td>\n<td align=\"left\">获取集合中所有文档对应值得最大值。</td>\n<td align=\"left\">db.mycol.aggregate([{$group : {_id : “$by_user”, num_tutorial : {$max : “$likes”}}}])</td>\n</tr>\n<tr>\n<td align=\"left\">$push</td>\n<td align=\"left\">在结果文档中插入值到一个数组中。</td>\n<td align=\"left\">db.mycol.aggregate([{$group : {_id : “$by_user”, url : {$push: “$url”}}}])</td>\n</tr>\n<tr>\n<td align=\"left\">$addToSet</td>\n<td align=\"left\">在结果文档中插入值到一个数组中，但不创建副本。</td>\n<td align=\"left\">db.mycol.aggregate([{$group : {_id : “$by_user”, url : {$addToSet : “$url”}}}])</td>\n</tr>\n<tr>\n<td align=\"left\">$first</td>\n<td align=\"left\">根据资源文档的排序获取第一个文档数据。</td>\n<td align=\"left\">db.mycol.aggregate([{$group : {_id : “$by_user”, first_url : {$first : “$url”}}}])</td>\n</tr>\n<tr>\n<td align=\"left\">$last</td>\n<td align=\"left\">根据资源文档的排序获取最后一个文档数据</td>\n<td align=\"left\">db.mycol.aggregate([{$group : {_id : “$by_user”, last_url : {$last : “$url”}}}])</td>\n</tr>\n</tbody></table>\n<blockquote>\n<p>例：通过以上集合计算每个作者所写的文章数</p>\n<p><code>db.mycol.aggregate({$group : {_id : &quot;$by_user&quot;, num_tutorial : {$sum : 1}}})</code></p>\n<p>相比于SQL语句：</p>\n<p><code>select by_user as _id, count(*) as num_tutorial from mycol group by by_user</code></p>\n</blockquote>\n<h2 id=\"6-管道\"><a href=\"#6-管道\" class=\"headerlink\" title=\"6. 管道\"></a>6. 管道</h2><p>MongoDB的聚合管道将MongoDB文档在一个管道处理完毕后将结果传递给下一个管道处理</p>\n<p><strong>$project</strong>：修改文档将结构</p>\n<blockquote>\n<p><code>db.clo.aggregate({$project: {title: 1, author:1}})</code></p>\n<p>同</p>\n<p><code>db.col.find({}, {title： 1, author:1})</code></p>\n</blockquote>\n<p><strong>$match</strong>：过滤数据</p>\n<blockquote>\n<p>例：将分数大于70小于或等于90记录，然后将符合条件的记录送到下一阶段$group管道操作符进行处理</p>\n<figure class=\"highlight groovy\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">db.articles.aggregate([</span><br><span class=\"line\">\t&#123; <span class=\"string\">$match :</span> &#123; <span class=\"string\">score :</span> &#123; <span class=\"string\">$gt :</span> <span class=\"number\">70</span>, <span class=\"string\">$lte :</span> <span class=\"number\">90</span> &#125; &#125; &#125;,</span><br><span class=\"line\">\t&#123; <span class=\"string\">$group:</span> &#123; <span class=\"string\">_id:</span> <span class=\"literal\">null</span>, <span class=\"string\">count:</span> &#123; <span class=\"string\">$sum:</span> <span class=\"number\">1</span> &#125; &#125; &#125;</span><br><span class=\"line\">]);</span><br></pre></td></tr></table></figure>\n</blockquote>\n<p><strong>当match和group同时存在时， 顺序会影响检索结果，必须先写 match 在前面</strong></p>\n<h1 id=\"三、MongoDB优化\"><a href=\"#三、MongoDB优化\" class=\"headerlink\" title=\"三、MongoDB优化\"></a>三、MongoDB优化</h1><h2 id=\"1-副本集\"><a href=\"#1-副本集\" class=\"headerlink\" title=\"1. 副本集\"></a>1. 副本集</h2><p>​        将数据同步在多个服务器的过程，提高了数据的可用性， 并可以保证数据的安全性。具有自动灾难恢复。没有固定的主节点</p>\n<p><strong>副本集设置</strong></p>\n<ol>\n<li><p>创建一个cluster文件夹，放node1，node2，node3三个子文件夹</p>\n<figure class=\"highlight angelscript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">节点<span class=\"number\">1</span>：</span><br><span class=\"line\">HOST：localhost:<span class=\"number\">10001</span></span><br><span class=\"line\">Data File：F:\\MongoDB\\node1</span><br><span class=\"line\"></span><br><span class=\"line\">节点<span class=\"number\">2</span>：</span><br><span class=\"line\">HOST：localhost:<span class=\"number\">10002</span></span><br><span class=\"line\">Data File：F:\\MongoDB\\node2</span><br><span class=\"line\"></span><br><span class=\"line\">节点<span class=\"number\">3</span>：</span><br><span class=\"line\">HOST：localhost:<span class=\"number\">10003</span></span><br><span class=\"line\">Data File：F:\\MongoDB\\node3</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>指定 –replSet 选项来启动mongoDB：</p>\n<p><code>mongod --port 端口 --dbpath 文件夹位置 --replSet 副本集名称</code></p>\n<ul>\n<li><p>启动一个新的副本集(初始化操作)：</p>\n<figure class=\"highlight prolog\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">rs.initiate(&#123;</span><br><span class=\"line\">\t<span class=\"string\">\"_id\"</span>:<span class=\"string\">\"shinelon\"</span>,</span><br><span class=\"line\">\t<span class=\"string\">\"members\"</span>:[ </span><br><span class=\"line\">\t\t&#123;<span class=\"string\">\"_id\"</span>:<span class=\"number\">1</span>,<span class=\"string\">\"host\"</span>:<span class=\"string\">\"localhost:10001\"</span>&#125;,</span><br><span class=\"line\">\t\t&#123;<span class=\"string\">\"_id\"</span>:<span class=\"number\">2</span>,<span class=\"string\">\"host\"</span>:<span class=\"string\">\"localhost:10002\"</span>&#125;,</span><br><span class=\"line\">\t\t&#123;<span class=\"string\">\"_id\"</span>:<span class=\"number\">3</span>,<span class=\"string\">\"host\"</span>:<span class=\"string\">\"localhost:10003\"</span>&#125; </span><br><span class=\"line\">\t\t\t]</span><br><span class=\"line\">\t&#125;)</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>查看副本集的配置：<code>rs.conf()</code></p>\n</li>\n<li><p>查看副本集状态： <code>rs.status()</code></p>\n</li>\n<li><p>副本集添加成员：<code>rs.add(HOST_NAME:POST)</code></p>\n</li>\n</ul>\n</li>\n</ol>\n<h2 id=\"2-分片\"><a href=\"#2-分片\" class=\"headerlink\" title=\"2. 分片\"></a>2. 分片</h2><p>​        指将数据拆分，将其分散存在不同的机器上的过程，不需要功能强大的大型计算机就可以储存更多的数据，处理更多的负载</p>\n<p><strong>片键</strong>：从集合里面选一个键，用该键的值作为数据拆分的依据</p>\n<p><strong>分片设置</strong></p>\n<ol>\n<li><p>启动Shard Server（用于存储实际的数据块）</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">HOST：localhost:27020</span><br><span class=\"line\">Data File：F:\\MongoDB\\shard\\s0</span><br><span class=\"line\"></span><br><span class=\"line\">HOST：localhost:27021</span><br><span class=\"line\">Data File：F:\\MongoDB\\shard\\s1</span><br><span class=\"line\">...\\s3</span><br><span class=\"line\">Data File：F:\\MongoDB\\shard\\<span class=\"built_in\">log</span></span><br><span class=\"line\"></span><br><span class=\"line\">&gt; mongod --port 27020 --dbpath=F:\\MongoDB\\shard\\s0 --logpath=F:\\MongoDB\\shard\\<span class=\"built_in\">log</span>\\s0.log --logappend --fork</span><br><span class=\"line\">...</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>启动Config Server（mongodb实例）</p>\n<figure class=\"highlight taggerscript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">HOST：localhost:27100</span><br><span class=\"line\">Data File：F:<span class=\"symbol\">\\M</span>ongoDB<span class=\"symbol\">\\s</span>hard<span class=\"symbol\">\\c</span>onfig</span><br><span class=\"line\"></span><br><span class=\"line\">&gt; mongod --port 27100 --dbpath=F:<span class=\"symbol\">\\M</span>ongoDB<span class=\"symbol\">\\s</span>hard<span class=\"symbol\">\\c</span>onfig --logpath=F:<span class=\"symbol\">\\M</span>ongoDB<span class=\"symbol\">\\s</span>hard<span class=\"symbol\">\\l</span>og<span class=\"symbol\">\\c</span>onfig.log --logappend --fork</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>启动Route Process（mongos路由进程：应用连接它来发送请求，知道数据在分片中的位置，收集返回数据）</p>\n<figure class=\"highlight brainfuck\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&gt; <span class=\"comment\">mongos</span> --<span class=\"comment\">port</span> <span class=\"comment\">40000</span> --<span class=\"comment\">configdb</span> <span class=\"comment\">localhost:27100</span> --<span class=\"comment\">fork</span> --<span class=\"comment\">logpath=F:\\MongoDB\\shard\\log\\route</span><span class=\"string\">.</span><span class=\"comment\">log</span> --<span class=\"comment\">chunkSize</span> <span class=\"comment\">500</span></span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>chunkSize这一项是用来指定chunk的大小的，单位是MB，默认大小为200MB.</p>\n</blockquote>\n</li>\n<li><p>配置Sharding</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mongo admin --port 40000</span><br><span class=\"line\">db.runCommand(&#123; addshard:<span class=\"string\">\"localhost:27020\"</span> &#125;)</span><br><span class=\"line\">...</span><br><span class=\"line\">db.runCommand(&#123; enablesharding:<span class=\"string\">\"test\"</span> &#125;) <span class=\"comment\">#设置分片存储的数据库</span></span><br><span class=\"line\"><span class=\"comment\"># 指定片键 user.name</span></span><br><span class=\"line\">db.runCommand(&#123; shardcollection: <span class=\"string\">'test.user'</span>, key: &#123;name: 1&#125;&#125;)</span><br></pre></td></tr></table></figure>\n\n</li>\n</ol>\n<p>可参考：<a href=\"https://blog.csdn.net/qq_37142346/java/article/details/82824132\" target=\"_blank\" rel=\"noopener\">https://blog.csdn.net/qq_37142346/java/article/details/82824132</a></p>\n<h2 id=\"3-备份与恢复\"><a href=\"#3-备份与恢复\" class=\"headerlink\" title=\"3. 备份与恢复\"></a>3. 备份与恢复</h2><p>数据备份：<code>mongodump -h dbhost -d dbname -o dbdirectory</code></p>\n<ul>\n<li>-h：MongoDB所在服务器地址，默认为： localhost:27017</li>\n<li>-d：需要备份的数据库实例，例如：test</li>\n<li>-o：备份的数据存放位置，例如：c:\\data\\dump</li>\n</ul>\n<p>mongodump 命令可选参数列表如下所示：</p>\n<table>\n<thead>\n<tr>\n<th align=\"left\">语法</th>\n<th align=\"left\">描述</th>\n<th align=\"left\">实例</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"left\">mongodump –host HOST_NAME –port PORT_NUMBER</td>\n<td align=\"left\">该命令将备份所有MongoDB数据</td>\n<td align=\"left\">mongodump –host runoob.com –port 27017</td>\n</tr>\n<tr>\n<td align=\"left\">mongodump –dbpath DB_PATH –out BACKUP_DIRECTORY</td>\n<td align=\"left\"></td>\n<td align=\"left\">mongodump –dbpath /data/db/ –out /data/backup/</td>\n</tr>\n<tr>\n<td align=\"left\">mongodump –collection COLLECTION –db DB_NAME</td>\n<td align=\"left\">该命令将备份指定数据库的集合。</td>\n<td align=\"left\">mongodump –collection mycol –db test</td>\n</tr>\n</tbody></table>\n<p>数据恢复：<code>mongorestore -h &lt;hostname&gt;&lt;:port&gt; -d dbname &lt;path&gt;</code></p>\n<ul>\n<li><p>–host &lt;:port&gt;, -h &lt;:port&gt;：MongoDB所在服务器地址</p>\n</li>\n<li><p>–db , -d ：需要恢复的数据库实例，例如：test</p>\n</li>\n<li><p>–drop：恢复的时候，先删除当前数据，然后恢复备份的数据。</p>\n</li>\n<li><p><path>：mongorestore 最后的一个参数，设置备份数据所在位置</p>\n<blockquote>\n<p>例：c:\\data\\dump\\test</p>\n</blockquote>\n</li>\n<li><p>–dir：指定备份的目录</p>\n<blockquote>\n<p>不能同时指定 <path> 和 –dir 选项。</p>\n</blockquote>\n</li>\n</ul>\n<h2 id=\"4-监控\"><a href=\"#4-监控\" class=\"headerlink\" title=\"4. 监控\"></a>4. 监控</h2><p><strong>mongostat命令</strong></p>\n<p>获取mongoDB的运行状态：mongostat</p>\n<p><strong>mongotop命令</strong></p>\n<p>跟踪一个MongoDB的实例，查看哪些读取和写入数据在花费大量的时间：mongotop <sleeptime></p>\n<ul>\n<li>等待时间长度，以秒为单位</li>\n</ul>\n<h1 id=\"四、MongoDB高级\"><a href=\"#四、MongoDB高级\" class=\"headerlink\" title=\"四、MongoDB高级\"></a>四、MongoDB高级</h1><h2 id=\"1-MongoDB关系\"><a href=\"#1-MongoDB关系\" class=\"headerlink\" title=\"1. MongoDB关系\"></a>1. MongoDB关系</h2><p>​        MongoDB的关系表示多个文档之间在逻辑上的相互关系，文档间可以通过<strong>嵌入</strong>和<strong>引用</strong>来建立联系。</p>\n<ul>\n<li>一对一</li>\n<li>一对多</li>\n<li>多对一</li>\n<li>多对多</li>\n</ul>\n<p><strong>嵌入式关系</strong>：把用户地址嵌入到用户的文档中（一张表，数据量大的话，影响性能）</p>\n<blockquote>\n<p>查询用户地址：<code>db.users.findOne({&quot;name&quot;:&quot;Tom Benzamin&quot;},{&quot;address&quot;:1})</code></p>\n</blockquote>\n<p><strong>引用式关系</strong>：通过引用文档的 <strong>id</strong> 字段来建立关系，外键</p>\n<ol>\n<li><p>查询用户地址对象id</p>\n<p><code>var result = db.users.findOne({&quot;name&quot;:&quot;Tom Benzamin&quot;},{&quot;address_ids&quot;:1})</code></p>\n</li>\n<li><p>通过查询的id获取用户的详细地址信息</p>\n<p><code>var addresses = db.address.find({&quot;_id&quot;:{&quot;$in&quot;:result[&quot;address_ids&quot;]}})</code></p>\n</li>\n</ol>\n<blockquote>\n<p>findOne不能写成find，find返回的是数组，findOne返回的是对象</p>\n</blockquote>\n<h2 id=\"2-引用操作\"><a href=\"#2-引用操作\" class=\"headerlink\" title=\"2. 引用操作\"></a>2. 引用操作</h2><p>MongoDB引用有两种：手动引用（Manual References）和DBRefs</p>\n<p><strong>DBRefs</strong></p>\n<p>形式：<code>{$ref : , $id : , $db : }</code></p>\n<ul>\n<li>$ref：集合名称</li>\n<li>$id：引用的id</li>\n<li>$db:数据库名称，可选参数</li>\n</ul>\n<p><strong>覆盖查询：</strong></p>\n<ul>\n<li>所有的查询字段是索引的一部分</li>\n<li>所有的查询返回字段在同一个索引中</li>\n</ul>\n<blockquote>\n<ol>\n<li><p>在 users 集合中创建联合索引，字段为 gender 和 user_name :</p>\n<p><code>db.users.ensureIndex({gender:1,user_name:1})</code></p>\n</li>\n<li><p>该索引会覆盖以下查询：</p>\n<p><code>db.users.find({gender:&quot;M&quot;},{user_name:1,_id:0})</code></p>\n</li>\n<li><p>没有排除_id，查询就不会被覆盖</p>\n<p><code>db.users.find({gender:&quot;M&quot;},{user_name:1})</code></p>\n</li>\n</ol>\n</blockquote>\n<p><strong>查询分析：</strong>可以确保建立的索引是否有效，是查询语句性能分析的重要工具。</p>\n<ol>\n<li><p>explain()：查询信息，使用索引及查询统计等</p>\n<p><code>db.users.find({gender:&quot;M&quot;},{user_name:1,_id:0}).explain()</code></p>\n</li>\n<li><p>hint()：指定使用某个索引字段来查询</p>\n<p><code>db.users.find({gender:&quot;M&quot;},{user_name:1,_id:0}).hint({gender:1,user_name:1})</code></p>\n</li>\n</ol>\n<h2 id=\"3-原子操作\"><a href=\"#3-原子操作\" class=\"headerlink\" title=\"3. 原子操作\"></a>3. 原子操作</h2><p>​        mongodb不支持事务，但是mongodb提供了许多原子操作，比如文档的保存，修改，删除等，都是原子操作。要么成功要么失败，达到数据完整性</p>\n<h3 id=\"3-1-原子操作常用命令\"><a href=\"#3-1-原子操作常用命令\" class=\"headerlink\" title=\"3.1 原子操作常用命令\"></a>3.1 原子操作常用命令</h3><p><strong>$set：</strong>用来指定一个键并更新键值，若键不存在并创建。</p>\n<p><code>{ $set :{ field : value}}</code></p>\n<blockquote>\n<p>例：<code>db.col.update({&quot;gender&quot;:&quot;M&quot;},{$set:{&quot;gender&quot;: &quot;A&quot;}})</code></p>\n</blockquote>\n<p><strong>$unset：</strong>用来删除一个键</p>\n<p><code>{ $unset : { field : 1} }</code></p>\n<blockquote>\n<p>例：<code>db.col.update({&quot;gender&quot;:&quot;A&quot;},{$unset:{&quot;gender&quot;: 1}})</code></p>\n</blockquote>\n<p><strong>$inc：</strong>对文档的某个值为数字型（只能为满足要求的数字）的键进行增减的操作。</p>\n<p><code>{ $inc : { field : value } }</code></p>\n<blockquote>\n<p>例：<code>db.col.update({},{$inc:{&quot;num&quot;: 10}})</code></p>\n</blockquote>\n<p><strong>$push：</strong>把value追加到field里面去，field一定要是数组类型才行</p>\n<p><code>{ $push : { field : value } }</code></p>\n<blockquote>\n<p>例：<code>db.col.update({&quot;_id&quot;: 1},{$push:{age:22}})</code></p>\n<p>添加多个字段到数组</p>\n<p>例：<code>db.col.update({&quot;_id&quot;: 1},{$push:{age: {$each: [1,2,3]}}})</code></p>\n</blockquote>\n<p><strong>$pull：</strong>从数组field内删除一个等于value值</p>\n<p><code>{ $pull: { &lt;field1&gt;: &lt;value|condition&gt;, &lt;field2&gt;: &lt;value|condition&gt;, ... } }</code></p>\n<blockquote>\n<p>例：<code>db.col.update({}, {$pull:{age:24}})</code></p>\n</blockquote>\n<p><strong>$pop：</strong>删除数组的第一个（-1）或最后一个（1）元素</p>\n<p><code>{ $pop : { field : 1 } }</code></p>\n<blockquote>\n<p>例：<code>db.col.update({}, {$pop:{&quot;age&quot;:1}})</code></p>\n</blockquote>\n<p><strong>$rename:</strong>修改字段名称</p>\n<p><code>{ $rename : { old_field_name : new_field_name } }</code></p>\n<blockquote>\n<p>例：<code>db.col.update({}, {$rename: {&quot;age&quot;:&quot;age1&quot;}})</code></p>\n</blockquote>\n<h2 id=\"4-Map-Reduce\"><a href=\"#4-Map-Reduce\" class=\"headerlink\" title=\"4. Map-Reduce\"></a>4. Map-Reduce</h2><p>​        Map-Reduce是一种计算模型，将大批量的工作（数据）分解（MAP）执行，然后再将结果合并成最终结果（REDUCE）</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">db.collection.mapReduce(</span><br><span class=\"line\">   <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;emit(key,value);&#125;,  <span class=\"comment\">// map 函数</span></span><br><span class=\"line\">   <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">key,values</span>) </span>&#123;<span class=\"keyword\">return</span> reduceFunction&#125;,   <span class=\"comment\">// reduce 函数</span></span><br><span class=\"line\">   &#123;</span><br><span class=\"line\">      out: collection,</span><br><span class=\"line\">      query: <span class=\"built_in\">document</span>,</span><br><span class=\"line\">      sort: <span class=\"built_in\">document</span>,</span><br><span class=\"line\">      limit: number</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\">)</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>使用 MapReduce 要实现两个函数： Map 函数和 Reduce 函数。</p>\n<p>Map 函数调用 emit(key, value), 遍历 collection 中所有的记录, 将 key 与 value 传递给 Reduce 函数进行处理。</p>\n</blockquote>\n<p><strong>Map 函数必须调用 emit(key, value) 返回键值对。</strong></p>\n<p>参数说明:</p>\n<ul>\n<li><strong>map</strong> ：映射函数 (生成键值对序列,作为 reduce 函数参数)。</li>\n<li><strong>reduce</strong> 统计函数，reduce函数的任务就是将key-values变成key-value，也就是把values数组变成一个单一的值value。</li>\n<li><strong>out</strong> 统计结果存放集合 (不指定则使用临时集合,在客户端断开后自动删除)。<ul>\n<li>可选参数：inline    <code>out: {inline: 1}</code></li>\n<li>不会创建集合，整个操作都在内存里运行==（结果集单个文档大小&lt;16MB）==</li>\n</ul>\n</li>\n<li><strong>query</strong> 一个筛选条件，只有满足条件的文档才会调用map函数。（query。limit，sort可以随意组合）</li>\n<li><strong>sort</strong> 和limit结合的sort排序参数（也是在发往map函数前给文档排序），可以优化分组机制</li>\n<li><strong>limit</strong> 发往map函数的文档数量的上限（要是没有limit，单独使用sort的用处不大）</li>\n</ul>\n<blockquote>\n<p>例：将在 posts 集合中使用 mapReduce 函数来选取已发布的文章(status:”active”)，并通过user_name分组，计算每个用户的文章数：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">db.posts.mapReduce( </span><br><span class=\"line\">   <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123; emit(<span class=\"keyword\">this</span>.user_name,<span class=\"number\">1</span>); &#125;, \t<span class=\"comment\">// map</span></span><br><span class=\"line\">   <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">key, values</span>) </span>&#123;<span class=\"keyword\">return</span> <span class=\"built_in\">Array</span>.sum(values)&#125;,  <span class=\"comment\">// Arraty：将数组或列表或多个值存储为一个键\treduce</span></span><br><span class=\"line\">      &#123;  </span><br><span class=\"line\">         query:&#123;<span class=\"attr\">status</span>:<span class=\"string\">\"active\"</span>&#125;,  \t<span class=\"comment\">// quert：筛选条件</span></span><br><span class=\"line\">         out:<span class=\"string\">\"post_total\"</span> \t\t\t<span class=\"comment\">// out：结果存储集合</span></span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">).find()</span><br></pre></td></tr></table></figure>\n</blockquote>\n<h2 id=\"5-全文检索\"><a href=\"#5-全文检索\" class=\"headerlink\" title=\"5. 全文检索\"></a>5. 全文检索</h2><p>​        对每一个词建立一个索引，指明该词在文章中出现的次数和位置，当用户查询时，检索程序就根据事先建立的索引进行查找，并将查找的结果反馈给用户的检索方式。</p>\n<ol>\n<li><p><strong>启动</strong></p>\n<p>2.6版本后默认开启，小于2.6版本启动命令:</p>\n<p><code>db.adminCommand({setParameter:true,textSearchEnabled:true})</code> </p>\n<p>&amp;&amp;</p>\n<p> <code>mongod --setParameter textSearchEnabled=true</code></p>\n</li>\n<li><p><strong>创建</strong></p>\n<blockquote>\n<p>创建posts集合文档数据，包含文章内容（post_text）及标签(tags)：</p>\n<figure class=\"highlight json\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">   <span class=\"attr\">\"post_text\"</span>: <span class=\"string\">\"enjoy the mongodb articles on Runoob\"</span>,</span><br><span class=\"line\">   <span class=\"attr\">\"tags\"</span>: [</span><br><span class=\"line\">      <span class=\"string\">\"mongodb\"</span>,</span><br><span class=\"line\">      <span class=\"string\">\"runoob\"</span></span><br><span class=\"line\">   ]</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n</blockquote>\n<p>对post_text字段建立全文索引：<code>db.posts.ensureIndex({post_text:&quot;text&quot;})</code></p>\n</li>\n<li><p>使用</p>\n<p>搜索文章中的关键词 runoob：<code>db.posts.find({$text:{$search:&quot;runoob&quot;}})</code></p>\n<blockquote>\n<p>使用全文检索可以提高查询效率</p>\n</blockquote>\n</li>\n<li><p>删除</p>\n<p><code>db.posts.dropIndex(&quot;post_text_text&quot;)</code></p>\n</li>\n</ol>\n<h2 id=\"6-正则表达式\"><a href=\"#6-正则表达式\" class=\"headerlink\" title=\"6. 正则表达式\"></a>6. 正则表达式</h2><p><strong>使用：$regex</strong></p>\n<p><code>db.posts.find({post_text:{$regex:&quot;runoob&quot;}})</code></p>\n<p>&amp;&amp;</p>\n<p><code>db.posts.find({post_text:/runoob/})</code></p>\n<p>不区分大小写：<code>db.posts.find({post_text:{$regex:&quot;runoob&quot;,$options:&quot;$i&quot;}})</code></p>\n<p><strong>数组元素使用正则表达式</strong></p>\n<blockquote>\n<p>例：查找run 开头的标签数据(ru 或 run 或 runoob)</p>\n<p><code>db.posts.find({tags:{$regex:&quot;run&quot;}})</code></p>\n</blockquote>\n<h3 id=\"6-1-优化\"><a href=\"#6-1-优化\" class=\"headerlink\" title=\"6.1 优化\"></a>6.1 优化</h3><ul>\n<li><p>索引字段查询速度高于正则匹配</p>\n</li>\n<li><p>如果正则表达式是前缀表达式，所有匹配的数据将以指定的前缀字符串为开始</p>\n<blockquote>\n<p>例：^tut        匹配以tut为开头的字符串</p>\n</blockquote>\n</li>\n<li><p>正则表达式中使用变量。一定要使用eval将组合的字符串进行转换，不能直接将字符串拼接后传入给表达式。否则没有报错信息，只是结果为空！</p>\n<blockquote>\n<p>例：<code>name=eval(&quot;/&quot; + 变量值key +&quot;/i&quot;);</code></p>\n<p>例：模糊查询包含title关键词, 且不区分大小写<code>title:eval(&quot;/&quot;+title+&quot;/i&quot;)</code>    </p>\n<ul>\n<li>同：<code>title:{$regex:title,$Option:&quot;$i&quot;}</code></li>\n</ul>\n</blockquote>\n</li>\n</ul>\n<h2 id=\"7-GridFS\"><a href=\"#7-GridFS\" class=\"headerlink\" title=\"7. GridFS\"></a>7. GridFS</h2><p>​        GridFS 用于存储和恢复那些超过16M（BSON文件限制）的文件(如：图片、音频、视频等)。也是文件存储的一种方式，但是它是存储在MonoDB的集合中。将大文件对象分割成多个小的chunk(文件片段),一般为256k/个,每个chunk将作为MongoDB的一个文档(document)被存储在chunks集合中。</p>\n<ul>\n<li><p>用两个集合来存储一个文件</p>\n<p><strong>fs.files：</strong>每个文件的实际内容被存在chunks(二进制数据)中</p>\n<p><strong>fs.chunks：</strong>和文件有关的meta数据(filename,content_type,还有用户自定义的属性)将会被存在files集合中。</p>\n</li>\n</ul>\n<p><strong>GridFS添加文件</strong></p>\n<blockquote>\n<p>例：添加mp3文件</p>\n<p><code>mongofiles.exe -d gridfs put song.mp3</code></p>\n<p><code>-d gridfs</code>：指定存储文件的数据库名称，未指定会自动创建</p>\n</blockquote>\n<p>查看数据库中文件的文档：<code>db.fs.files.find()</code></p>\n<p>根据 _id 获取区块(chunk)的数据：</p>\n<p><code>db.fs.chunks.find({files_id:ObjectId(&#39;534a811bf8b4aa4d33fdf94d&#39;)})</code></p>\n<h2 id=\"8-固定集合\"><a href=\"#8-固定集合\" class=\"headerlink\" title=\"8. 固定集合\"></a>8. 固定集合</h2><p>​        固定长度，当集合空间用完后，再插入的元素就会覆盖最初始的头部的元素！可以插入及更新，但不能更新超出collection的大小，不允许删除，但是可以调用drop()删除集合中的所有行，drop后需要显式地重建集合。</p>\n<ul>\n<li>对固定集合进行插入速度极快</li>\n<li>按照插入顺序的查询输出速度极快</li>\n<li>能够在插入最新数据时,淘汰最早的数据</li>\n</ul>\n<p><strong>创建</strong></p>\n<p><code>db.createCollection(&quot;cappedLogCollection&quot;,{capped:true,size:10000})</code></p>\n<p>指定文档个数</p>\n<p><code>db.createCollection(&quot;cappedLogCollection&quot;,{capped:true,size:10000,max:1000})</code></p>\n<ul>\n<li><strong>size(KB)：</strong>整个集合空间的大小</li>\n<li><strong>max(个)：</strong>文档数上限</li>\n</ul>\n<p>判断集合是否为固定集合</p>\n<p><code>db.cappedLogCollection.isCapped()</code></p>\n<p>将已存在的集合转为固定集合</p>\n<p><code>db.runCommand({&quot;convertToCapped&quot;:&quot;posts&quot;, size:10000})</code></p>\n<blockquote>\n<p>将已存在的posts集合转为固定集合</p>\n</blockquote>\n<p><strong>查询</strong></p>\n<p>​        固定集合文档按照插入顺序储存的,默认情况下查询就是按照插入顺序返回的,也可以使用$natural调整返回顺序。</p>\n<p><code>db.cappedLogCollection.find().sort({$natural:-1})</code></p>\n<p><strong>用法：</strong>存储日志信息、缓存一些少量的文档</p>\n","site":{"data":{}},"excerpt":"<h1 id=\"一、MongoDB简介\"><a href=\"#一、MongoDB简介\" class=\"headerlink\" title=\"一、MongoDB简介\"></a>一、MongoDB简介</h1><p>​        <strong>MongoDB 是由C++语言编写的，是一个基于分布式文件存储的开源数据库系统。</strong>将数据存储为一个文档，数据结构由键值对组成，文档类似于 JSON 对象。字段值可以包含其他文档，数组及文档数组。</p>\n<p><strong>特点：</strong></p>\n<ul>\n<li>面向文档存储的数据库，操作简单</li>\n<li>可设置任何属性的索引，实现快速排序</li>\n<li>可通过本地或者网络创建数据镜像</li>\n</ul>","more":"<h2 id=\"1-安装MangoDB\"><a href=\"#1-安装MangoDB\" class=\"headerlink\" title=\"1. 安装MangoDB\"></a>1. 安装MangoDB</h2><p>官网下载地址：<a href=\"https://www.mongodb.com/download-center/community\" target=\"_blank\" rel=\"noopener\">https://www.mongodb.com/download-center/community</a></p>\n<p><strong>配置：</strong></p>\n<ol>\n<li>创建D:\\mongodb\\data\\log目录，用来存放日志文件；</li>\n<li>在D:\\mongodb\\data\\log目录里新建mongodb.log，用来存放日志信息；</li>\n<li>创建D:\\mongodb\\data\\db目录，用来存放数据库数据，</li>\n<li>并在D:\\mongodb目录下创建mongo.config，在文件内部复制如下文本：</li>\n</ol>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 数据文件  此处=后对应到数据所存放的目录</span></span><br><span class=\"line\">dbpath=d:\\mongodb\\data\\db</span><br><span class=\"line\"><span class=\"comment\"># 日志文件  此处=后对应到日志文件所在路径</span></span><br><span class=\"line\">logpath=d:\\mongodb\\data\\<span class=\"built_in\">log</span>\\mongodb.log</span><br><span class=\"line\"><span class=\"comment\"># 错误日志采用追加模式，配置这个选项后mongodb的日志会追加到现有的日志文件，而不是从新创建一个新文件</span></span><br><span class=\"line\">logappend=<span class=\"literal\">true</span> </span><br><span class=\"line\"><span class=\"comment\">#启用日志文件，默认启用</span></span><br><span class=\"line\">journal=<span class=\"literal\">true</span> </span><br><span class=\"line\"><span class=\"comment\">#这个选项可以过滤掉一些无用的日志信息，若需要调试使用请设置为false</span></span><br><span class=\"line\">quiet=<span class=\"literal\">true</span> </span><br><span class=\"line\"><span class=\"comment\">#端口号 默认为27017</span></span><br><span class=\"line\">port=27017</span><br></pre></td></tr></table></figure>\n\n<p><strong>测试是否安装成功</strong></p>\n<ul>\n<li><p>进入\\MongoDB\\Server\\3.4\\bin文件夹下，点击mongod.exe，如果闪一下退出，说明安装正常</p>\n<p><img src=\"https://tupian-1300728887.cos.ap-chengdu.myqcloud.com/MangoDB%E6%88%90%E5%8A%9F.png\" alt=\"\"></p>\n</li>\n</ul>\n<p><strong>安装MongoDB服务</strong></p>\n<ul>\n<li><p>执行mongod.exe，使用–install选项来安装服务，使用–config选项来指定之前创建的配置文件。</p>\n<figure class=\"highlight taggerscript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">C:<span class=\"symbol\">\\m</span>ongodb<span class=\"symbol\">\\b</span>in<span class=\"symbol\">\\m</span>ongod.exe --config \"C:<span class=\"symbol\">\\m</span>ongodb<span class=\"symbol\">\\m</span>ongod.cfg\" --install</span><br></pre></td></tr></table></figure>\n\n</li>\n</ul>\n<p><strong>终端操作（管理员）</strong></p>\n<ul>\n<li><p>启动MongoDB服务</p>\n<p><code>net start MongoDB</code></p>\n</li>\n<li><p>关闭MongoDB服务</p>\n<p><code>net stop MongoDB</code></p>\n</li>\n<li><p>移除 MongoDB 服务</p>\n<p><code>**\\mongodb\\bin\\mongod.exe --remove</code></p>\n</li>\n</ul>\n<h2 id=\"2-概念\"><a href=\"#2-概念\" class=\"headerlink\" title=\"2. 概念\"></a>2. 概念</h2><table>\n<thead>\n<tr>\n<th align=\"center\">SQL术语/概念</th>\n<th align=\"center\">MongoDB术语/概念</th>\n<th align=\"center\">解释/说明</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\">database</td>\n<td align=\"center\">database</td>\n<td align=\"center\">数据库</td>\n</tr>\n<tr>\n<td align=\"center\">table</td>\n<td align=\"center\">collection</td>\n<td align=\"center\">数据库表/集合</td>\n</tr>\n<tr>\n<td align=\"center\">row</td>\n<td align=\"center\">document</td>\n<td align=\"center\">数据记录行/文档</td>\n</tr>\n<tr>\n<td align=\"center\">column</td>\n<td align=\"center\">field</td>\n<td align=\"center\">数据字段/域</td>\n</tr>\n<tr>\n<td align=\"center\">index</td>\n<td align=\"center\">index</td>\n<td align=\"center\">索引</td>\n</tr>\n<tr>\n<td align=\"center\">table joins</td>\n<td align=\"center\"></td>\n<td align=\"center\">表连接,MongoDB不支持</td>\n</tr>\n<tr>\n<td align=\"center\">primary key</td>\n<td align=\"center\">primary key</td>\n<td align=\"center\">主键,MongoDB自动将_id字段设置为主键</td>\n</tr>\n</tbody></table>\n<h3 id=\"2-1-数据库\"><a href=\"#2-1-数据库\" class=\"headerlink\" title=\"2.1 数据库\"></a>2.1 数据库</h3><p>MongoDB的默认数据库为”db”，该数据库存储在data目录中。</p>\n<p>MongoDB的单个实例可以容纳多个独立的数据库，每一个都有自己的集合和权限，不同的数据库也放置在不同的文件中。</p>\n<ol>\n<li><p>显示所有数据的列表：<code>show dbs</code></p>\n</li>\n<li><p>显示当前数据库对象或集合:<code>db</code></p>\n</li>\n<li><p>连接到一个指定的数据库:<code>use</code></p>\n</li>\n</ol>\n<p><strong>自带特殊数据库：</strong></p>\n<ul>\n<li><strong>admin</strong>： 从权限的角度来看，这是”root”数据库。要是将一个用户添加到这个数据库，这个用户自动继承所有数据库的权限。一些特定的服务器端命令也只能从这个数据库运行，比如列出所有的数据库或者关闭服务器。</li>\n<li><strong>local:</strong> 这个数据永远不会被复制，可以用来存储限于本地单台服务器的任意集合</li>\n<li><strong>config</strong>: 当Mongo用于分片设置时，config数据库在内部使用，用于保存分片的相关信息。</li>\n</ul>\n<h3 id=\"2-2-文档\"><a href=\"#2-2-文档\" class=\"headerlink\" title=\"2.2 文档\"></a>2.2 文档</h3><p>​        文档是一组键值(key-value)对(即 BSON)。MongoDB 的文档不需要设置相同的字段，并且相同的字段不需要相同的数据类型</p>\n<table>\n<thead>\n<tr>\n<th align=\"center\">RDBMS</th>\n<th align=\"center\">MongoDB</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\">数据库</td>\n<td align=\"center\">数据库</td>\n</tr>\n<tr>\n<td align=\"center\">表格</td>\n<td align=\"center\">集合</td>\n</tr>\n<tr>\n<td align=\"center\">行</td>\n<td align=\"center\">文档</td>\n</tr>\n<tr>\n<td align=\"center\">列</td>\n<td align=\"center\">字段</td>\n</tr>\n<tr>\n<td align=\"center\">表联合</td>\n<td align=\"center\">嵌入文档</td>\n</tr>\n<tr>\n<td align=\"center\">主键</td>\n<td align=\"center\">主键 (MongoDB 提供了 key 为 _id )</td>\n</tr>\n</tbody></table>\n<ol>\n<li>文档中的键/值对是有序的。</li>\n<li>文档中的值不仅可以是在双引号里面的字符串，还可以是其他几种数据类型（甚至可以是整个嵌入的文档)。</li>\n<li>MongoDB区分类型和大小写。</li>\n<li>MongoDB的文档不能有重复的键。</li>\n<li>文档的键是字符串。除了少数例外情况，键可以使用任意UTF-8字符。</li>\n</ol>\n<p>文档键命名规范：</p>\n<ul>\n<li>键不能含有\\0 (空字符)。这个字符用来表示键的结尾。</li>\n<li>$有特别的意义，只有在特定环境下才能使用。</li>\n<li>以下划线”_”开头的键是保留的(不是严格要求的)。</li>\n</ul>\n<h3 id=\"2-3-集合\"><a href=\"#2-3-集合\" class=\"headerlink\" title=\"2.3 集合\"></a>2.3 集合</h3><p>​        MongoDB文档组，相比于表格</p>\n<p>集合命名规范：</p>\n<ul>\n<li>集合名不能是空字符串””。</li>\n<li>集合名不能含有\\0字符（空字符)，这个字符表示集合名的结尾。</li>\n<li>集合名不能以”system.”开头，这是为系统集合保留的前缀。</li>\n<li>用户创建的集合名字不能含有保留字符。有些驱动程序的确支持在集合名里面包含，这是因为某些系统生成的集合中包含该字符。除非你要访问这种系统创建的集合，否则千万不要在名字里出现$。　</li>\n</ul>\n<h3 id=\"2-4-元数据\"><a href=\"#2-4-元数据\" class=\"headerlink\" title=\"2.4 元数据\"></a>2.4 元数据</h3><p>​        存储数据库信息集合</p>\n<table>\n<thead>\n<tr>\n<th align=\"center\">集合命名空间</th>\n<th align=\"center\">描述</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\">dbname.system.namespaces</td>\n<td align=\"center\">列出所有名字空间。</td>\n</tr>\n<tr>\n<td align=\"center\">dbname.system.indexes</td>\n<td align=\"center\">列出所有索引。</td>\n</tr>\n<tr>\n<td align=\"center\">dbname.system.profile</td>\n<td align=\"center\">包含数据库概要(profile)信息。</td>\n</tr>\n<tr>\n<td align=\"center\">dbname.system.users</td>\n<td align=\"center\">列出所有可访问数据库的用户。</td>\n</tr>\n<tr>\n<td align=\"center\">dbname.local.sources</td>\n<td align=\"center\">包含复制对端（slave）的服务器信息和状态。</td>\n</tr>\n</tbody></table>\n<ul>\n<li>在indexes中插入数据，可创建索引</li>\n<li>users是可以修改的</li>\n<li>profile是可以删除的</li>\n</ul>\n<h3 id=\"2-5-MongoDB数据类型\"><a href=\"#2-5-MongoDB数据类型\" class=\"headerlink\" title=\"2.5 MongoDB数据类型\"></a>2.5 MongoDB数据类型</h3><table>\n<thead>\n<tr>\n<th align=\"center\">String</th>\n<th align=\"left\">字符串。存储数据常用的数据类型。在 MongoDB 中，UTF-8 编码的字符串才是合法的。</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\">Integer</td>\n<td align=\"left\">整型数值。用于存储数值。根据你所采用的服务器，可分为 32 位或 64 位。</td>\n</tr>\n<tr>\n<td align=\"center\">Boolean</td>\n<td align=\"left\">布尔值。用于存储布尔值（真/假）。</td>\n</tr>\n<tr>\n<td align=\"center\">Double</td>\n<td align=\"left\">双精度浮点值。用于存储浮点值。</td>\n</tr>\n<tr>\n<td align=\"center\">Min/Max keys</td>\n<td align=\"left\">将一个值与 BSON（二进制的 JSON）元素的最低值和最高值相对比。</td>\n</tr>\n<tr>\n<td align=\"center\">Array</td>\n<td align=\"left\">用于将数组或列表或多个值存储为一个键。</td>\n</tr>\n<tr>\n<td align=\"center\">Timestamp</td>\n<td align=\"left\">时间戳。记录文档修改或添加的具体时间。</td>\n</tr>\n<tr>\n<td align=\"center\">Object</td>\n<td align=\"left\">用于内嵌文档。</td>\n</tr>\n<tr>\n<td align=\"center\">Null</td>\n<td align=\"left\">用于创建空值。</td>\n</tr>\n<tr>\n<td align=\"center\">Symbol</td>\n<td align=\"left\">符号。该数据类型基本上等同于字符串类型，但不同的是，它一般用于采用特殊符号类型的语言。</td>\n</tr>\n<tr>\n<td align=\"center\">Date</td>\n<td align=\"left\">日期时间。用 UNIX 时间格式来存储当前日期或时间。你可以指定自己的日期时间：创建 Date 对象，传入年月日信息。</td>\n</tr>\n<tr>\n<td align=\"center\">Object ID</td>\n<td align=\"left\">对象 ID。用于创建文档的 ID。</td>\n</tr>\n<tr>\n<td align=\"center\">Binary Data</td>\n<td align=\"left\">二进制数据。用于存储二进制数据。</td>\n</tr>\n<tr>\n<td align=\"center\">Code</td>\n<td align=\"left\">代码类型。用于在文档中存储 JavaScript 代码。</td>\n</tr>\n<tr>\n<td align=\"center\">Regular expression</td>\n<td align=\"left\">正则表达式类型。用于存储正则表达式。</td>\n</tr>\n</tbody></table>\n<p><strong>ObjectId 类似唯一主键，可以很快的去生成和排序，</strong>包含 12 bytes，含义是：</p>\n<ul>\n<li><p>前 4 个字节表示创建 <strong>unix</strong> 时间戳,格林尼治时间 <strong>UTC</strong> 时间，比北京时间晚了 8 个小时</p>\n</li>\n<li><p>接下来的 3 个字节是机器标识码</p>\n</li>\n<li><p>紧接的两个字节由进程 id 组成 PID</p>\n</li>\n<li><p>最后三个字节是随机数</p>\n</li>\n</ul>\n<p><img src=\"https://www.runoob.com/wp-content/uploads/2013/10/2875754375-5a19268f0fd9b_articlex.jpeg\" alt=\"img\"></p>\n<p>​        MongoDB 中存储的文档必须有一个 _id 键。这个键的值可以是任何类型的，默认是个 ObjectId 对象</p>\n<p>由于 ObjectId 中保存了创建的时间戳，可以通过 getTimestamp 函数来获取文档的创建时间:</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">newObject = ObjectId()</span><br><span class=\"line\">newObject.getTimestamp()</span><br><span class=\"line\">ISODate(<span class=\"string\">\"2017-11-25T07:21:10Z\"</span>)</span><br><span class=\"line\"><span class=\"comment\"># ObjectId转字符串</span></span><br><span class=\"line\">str_objectid = ObjectId().str</span><br><span class=\"line\">typeof str_objectid</span><br><span class=\"line\">string</span><br></pre></td></tr></table></figure>\n\n<h1 id=\"二、MongoDB操作\"><a href=\"#二、MongoDB操作\" class=\"headerlink\" title=\"二、MongoDB操作\"></a>二、MongoDB操作</h1><h2 id=\"1-数据库操作\"><a href=\"#1-数据库操作\" class=\"headerlink\" title=\"1. 数据库操作\"></a>1. 数据库操作</h2><p>创建数据库：<code>use DATABASE_NAME</code></p>\n<p>查看所有数据库：<code>show dbs</code></p>\n<p>删除数据库：<code>db.dropDatabase()</code></p>\n<blockquote>\n<p> 集合（数据表）在插入数据后才会被创建</p>\n</blockquote>\n<h2 id=\"2-集合操作\"><a href=\"#2-集合操作\" class=\"headerlink\" title=\"2. 集合操作\"></a>2. 集合操作</h2><p>创建集合：<code>db.createCollection(name, options)</code></p>\n<ul>\n<li><p>name：集合名称</p>\n</li>\n<li><p>options：可选参数，指定内存大小及索引</p>\n<ol>\n<li><p>capped（布尔）：如果为 true，则创建固定集合。</p>\n<ul>\n<li>固定集合是指有着固定大小的集合，当达到最大值时，它会自动覆盖最早的文档。<br><strong>当该值为 true 时，必须指定 size 参数。</strong></li>\n</ul>\n</li>\n<li><p>autolndexld（布尔）：如为 true，自动在 _id 字段创建索引。默认为 false。</p>\n</li>\n<li><p>size：为固定集合指定一个最大值，以千字节计（KB）</p>\n</li>\n<li><p>max：指定固定集合中包含文档的最大数量。</p>\n</li>\n</ol>\n</li>\n</ul>\n<blockquote>\n<p>在插入文档时，MongoDB 首先检查固定集合的 size 字段，然后检查 max 字段。</p>\n</blockquote>\n<p>查看已有集合：<code>show collections &amp;&amp; show tables</code></p>\n<p>删除集合：<code>db.collection.drop()</code></p>\n<h2 id=\"3-文档操作\"><a href=\"#3-文档操作\" class=\"headerlink\" title=\"3. 文档操作\"></a>3. 文档操作</h2><p><strong>插入文档</strong>：<code>db.COLLECTION_NAME.insert(document) &amp;&amp; **save(document)</code></p>\n<p>查看已插入的文档：    <code>db.COLLECTION_NAME.find()</code></p>\n<p><strong>更新文档</strong></p>\n<ol>\n<li><p>update()</p>\n<p><strong>更新符合条件的文档</strong></p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">db.collection.update(</span><br><span class=\"line\">   &lt;query&gt;,\t\t\t<span class=\"comment\"># 查询条件，≈where后面的</span></span><br><span class=\"line\">   &lt;update&gt;,\t\t<span class=\"comment\"># update的对象和一些更新的操作符（如$,$set...）</span></span><br><span class=\"line\">   &#123;</span><br><span class=\"line\">     upsert: &lt;boolean&gt;,\t<span class=\"comment\"># 如果不存在update的记录，是否插入objNew</span></span><br><span class=\"line\">     multi: &lt;boolean&gt;,\t<span class=\"comment\"># 只更新找到的第一条记录，若为真全部更新</span></span><br><span class=\"line\">     writeConcern: &lt;document&gt;\t<span class=\"comment\"># 异常级别</span></span><br><span class=\"line\">   &#125;</span><br><span class=\"line\">)</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>save()</p>\n<p><strong>传入文档替换已有文档（_id一样）</strong></p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">db.collection.save(</span><br><span class=\"line\">   &lt;document&gt;,\t<span class=\"comment\"># 文档数据</span></span><br><span class=\"line\">   &#123;</span><br><span class=\"line\">     writeConcern: &lt;document&gt;\t<span class=\"comment\"># 异常级别</span></span><br><span class=\"line\">   &#125;</span><br><span class=\"line\">)</span><br></pre></td></tr></table></figure>\n\n</li>\n</ol>\n<p><strong>删除文档</strong>：<code>db.COLLECTION_NAME.deleteOne() &amp;&amp; **.deleteMany()</code></p>\n<p><strong>查询文档</strong>：<code>db.collection.find(query, projection)</code></p>\n<ul>\n<li><strong>query</strong> ：可选，使用查询操作符指定查询条件</li>\n<li><strong>projection</strong> ：可选，使用投影操作符指定返回的键。查询时返回文档中所有键值， 只需省略该参数即可（默认省略）</li>\n</ul>\n<p>用格式化的方式显示所有文档：<code>db.collection_name.find().pretty()</code></p>\n<p><strong>MongoDB的条件操作符</strong></p>\n<table>\n<thead>\n<tr>\n<th align=\"center\">操作</th>\n<th align=\"center\">格式</th>\n<th align=\"center\">范例</th>\n<th align=\"center\">RDBMS中的类似语句</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\">等于</td>\n<td align=\"center\">{<key>:<value>}</td>\n<td align=\"center\">db.col.find({“by”:”菜鸟教程”}).pretty()</td>\n<td align=\"center\">where by = ‘菜鸟教程’</td>\n</tr>\n<tr>\n<td align=\"center\">小于</td>\n<td align=\"center\">{<key>:{$lt:<value>}}</td>\n<td align=\"center\">db.col.find({“likes”:{$lt:50}}).pretty()</td>\n<td align=\"center\">where likes &lt; 50</td>\n</tr>\n<tr>\n<td align=\"center\">小于或等于</td>\n<td align=\"center\">{<key>:{$lte:<value>}}</td>\n<td align=\"center\">db.col.find({“likes”:{$lte:50}}).pretty()</td>\n<td align=\"center\">where likes &lt;= 50</td>\n</tr>\n<tr>\n<td align=\"center\">大于</td>\n<td align=\"center\">{<key>:{$gt:<value>}}</td>\n<td align=\"center\">db.col.find({“likes”:{$gt:50}}).pretty()</td>\n<td align=\"center\">where likes &gt; 50</td>\n</tr>\n<tr>\n<td align=\"center\">大于或等于</td>\n<td align=\"center\">{<key>:{$gte:<value>}}</td>\n<td align=\"center\">db.col.find({“likes”:{$gte:50}}).pretty()</td>\n<td align=\"center\">where likes &gt;= 50</td>\n</tr>\n<tr>\n<td align=\"center\">不等于</td>\n<td align=\"center\">{<key>:{$ne:<value>}}</td>\n<td align=\"center\">db.col.find({“likes”:{$ne:50}}).pretty()</td>\n<td align=\"center\">where likes != 50</td>\n</tr>\n</tbody></table>\n<p>and条件查询：<code>db.collection_name.find({key1:value1, key2:value2}).pretty()</code></p>\n<p>or条件查询：<code>db.collection_name.find({$or:[{key1:value1}, {key2:value2}]}).pretty()</code></p>\n<p><strong>模糊查询</strong></p>\n<ul>\n<li><p>查询 title 包含”教”字的文档：<code>db.col.find({&quot;title&quot;:/教/})</code></p>\n</li>\n<li><p>查询 title 字段以”教”字开头的文档：<code>db.col.find({&quot;title&quot;:/^教/})</code></p>\n</li>\n<li><p>查询 title字段以”教”字结尾的文档：<code>db.col.find({&quot;title&quot;:/教$/})</code></p>\n</li>\n</ul>\n<p><strong>$type操作符</strong></p>\n<p>获取集合中 title 为 String 的数据：<code>db.col.find({&quot;title&quot;: {$type: &#39;string&#39;}})</code></p>\n<p><strong>指定显示数量：</strong><code>db.collection_name.find().limit(number)</code></p>\n<blockquote>\n<p> 如果没有指定limit()方法中的参数则显示集合中的所有数据</p>\n</blockquote>\n<p><strong>跳过指定显示数量</strong>：<code>db.collection_name.find().skip(number)</code></p>\n<blockquote>\n<p>skip默认参数为0，效率差，遍历出来的</p>\n</blockquote>\n<p>例：想要读取从 10 条记录后 100 条记录，相当于 sql 中limit (10,100)。</p>\n<p>​        <code>db.COLLECTION_NAME.find().skip(10).limit(100)</code></p>\n<p><strong>排序</strong>：<code>db.COLLECTION_NAME.find().sort({KEY:1})</code></p>\n<blockquote>\n<p>执行顺序：sort()  –&gt;  skip()  –&gt;  limit()</p>\n</blockquote>\n<h2 id=\"4-索引\"><a href=\"#4-索引\" class=\"headerlink\" title=\"4. 索引\"></a>4. 索引</h2><p>创建：<code>db.collection.createindex(keys, options)</code></p>\n<p>创建数组索引：<code>db.collection.ensureIndex()</code></p>\n<p>为子文档创建索引：<code>db.users.ensureIndex({&quot;address.city&quot;:1,&quot;address.state&quot;:1,&quot;address.pincode&quot;:1})</code></p>\n<ul>\n<li>keys：创建索引的字段，可有多个，1为升序反之倒序</li>\n<li>options：可选参数<ol>\n<li>background：建索会阻塞其它数据库操作，True为后台建索</li>\n<li>unique：建立的索引是否唯一，默认false，指定true创建唯一索引</li>\n<li>name：索引名称，未指定自动生成（字段名＋排序顺序）</li>\n<li>sparse：对文档中不存在的字段数据不启用索引</li>\n<li>weights：索引权重值</li>\n</ol>\n</li>\n</ul>\n<p>查看集合索引：<code>db.col.getIndexes()</code></p>\n<p>查看集合索引大小：<code>db.col.totalIndexSize()</code></p>\n<p>删除集合所有索引：<code>db.col.dropIndexes()</code></p>\n<p>删除集合指定索引：<code>db.col.dropIndex(&quot;索引名称&quot;)</code></p>\n<p><strong>定期删除</strong></p>\n<p>数据记录中createDate为时间类型时：设置时间180秒后自动删除</p>\n<p><code>db.col.createIndex({&quot;createDate&quot;: 1},{expireAfterSeconds: 180})</code></p>\n<p><strong>定时删除</strong></p>\n<p>A记录中需添加 “ClearUpDate”: new Date(‘Jan 22, 2019 23:00:00’)</p>\n<p><code>db.col.createIndex({&quot;ClearUpDate&quot;: 1},{expireAfterSeconds: 0})</code></p>\n<ul>\n<li>索引关键字段必须是 Date 类型。</li>\n<li>非立即执行：扫描 Document 过期数据并删除是独立线程执行，默认 60s 扫描一次，删除也不一定是立即删除成功</li>\n</ul>\n<p><strong>查询限制</strong></p>\n<p>索引不能被以下的查询使用：</p>\n<ul>\n<li>正则表达式及非操作符，如 $nin, $not, 等。</li>\n<li>算术运算符，如 $mod, 等。</li>\n<li>$where 子句</li>\n</ul>\n<p>索引限制：</p>\n<p>如果现有的索引字段的值超过索引键的限制，MongoDB中不会创建索引。</p>\n<p>如果文档的索引字段值超过了索引键的限制，MongoDB不会将任何文档转换成索引的集合。</p>\n<p>最大范围：</p>\n<ul>\n<li>集合中索引不能超过64个</li>\n<li>索引名的长度不能超过128个字符</li>\n<li>一个复合索引最多可以有31个字段</li>\n</ul>\n<h2 id=\"5-聚合\"><a href=\"#5-聚合\" class=\"headerlink\" title=\"5. 聚合\"></a>5. 聚合</h2><p>aggregate()方法：<code>db.collection_name(aggregate_opeation)</code></p>\n<table>\n<thead>\n<tr>\n<th align=\"left\">表达式</th>\n<th align=\"left\">描述</th>\n<th align=\"left\">实例</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"left\">$sum</td>\n<td align=\"left\">计算总和。</td>\n<td align=\"left\">db.mycol.aggregate([{$group : {_id : “$by_user”, num_tutorial : {$sum : “$likes”}}}])</td>\n</tr>\n<tr>\n<td align=\"left\">$avg</td>\n<td align=\"left\">计算平均值</td>\n<td align=\"left\">db.mycol.aggregate([{$group : {_id : “$by_user”, num_tutorial : {$avg : “$likes”}}}])</td>\n</tr>\n<tr>\n<td align=\"left\">$min</td>\n<td align=\"left\">获取集合中所有文档对应值得最小值。</td>\n<td align=\"left\">db.mycol.aggregate([{$group : {_id : “$by_user”, num_tutorial : {$min : “$likes”}}}])</td>\n</tr>\n<tr>\n<td align=\"left\">$max</td>\n<td align=\"left\">获取集合中所有文档对应值得最大值。</td>\n<td align=\"left\">db.mycol.aggregate([{$group : {_id : “$by_user”, num_tutorial : {$max : “$likes”}}}])</td>\n</tr>\n<tr>\n<td align=\"left\">$push</td>\n<td align=\"left\">在结果文档中插入值到一个数组中。</td>\n<td align=\"left\">db.mycol.aggregate([{$group : {_id : “$by_user”, url : {$push: “$url”}}}])</td>\n</tr>\n<tr>\n<td align=\"left\">$addToSet</td>\n<td align=\"left\">在结果文档中插入值到一个数组中，但不创建副本。</td>\n<td align=\"left\">db.mycol.aggregate([{$group : {_id : “$by_user”, url : {$addToSet : “$url”}}}])</td>\n</tr>\n<tr>\n<td align=\"left\">$first</td>\n<td align=\"left\">根据资源文档的排序获取第一个文档数据。</td>\n<td align=\"left\">db.mycol.aggregate([{$group : {_id : “$by_user”, first_url : {$first : “$url”}}}])</td>\n</tr>\n<tr>\n<td align=\"left\">$last</td>\n<td align=\"left\">根据资源文档的排序获取最后一个文档数据</td>\n<td align=\"left\">db.mycol.aggregate([{$group : {_id : “$by_user”, last_url : {$last : “$url”}}}])</td>\n</tr>\n</tbody></table>\n<blockquote>\n<p>例：通过以上集合计算每个作者所写的文章数</p>\n<p><code>db.mycol.aggregate({$group : {_id : &quot;$by_user&quot;, num_tutorial : {$sum : 1}}})</code></p>\n<p>相比于SQL语句：</p>\n<p><code>select by_user as _id, count(*) as num_tutorial from mycol group by by_user</code></p>\n</blockquote>\n<h2 id=\"6-管道\"><a href=\"#6-管道\" class=\"headerlink\" title=\"6. 管道\"></a>6. 管道</h2><p>MongoDB的聚合管道将MongoDB文档在一个管道处理完毕后将结果传递给下一个管道处理</p>\n<p><strong>$project</strong>：修改文档将结构</p>\n<blockquote>\n<p><code>db.clo.aggregate({$project: {title: 1, author:1}})</code></p>\n<p>同</p>\n<p><code>db.col.find({}, {title： 1, author:1})</code></p>\n</blockquote>\n<p><strong>$match</strong>：过滤数据</p>\n<blockquote>\n<p>例：将分数大于70小于或等于90记录，然后将符合条件的记录送到下一阶段$group管道操作符进行处理</p>\n<figure class=\"highlight groovy\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">db.articles.aggregate([</span><br><span class=\"line\">\t&#123; <span class=\"string\">$match :</span> &#123; <span class=\"string\">score :</span> &#123; <span class=\"string\">$gt :</span> <span class=\"number\">70</span>, <span class=\"string\">$lte :</span> <span class=\"number\">90</span> &#125; &#125; &#125;,</span><br><span class=\"line\">\t&#123; <span class=\"string\">$group:</span> &#123; <span class=\"string\">_id:</span> <span class=\"literal\">null</span>, <span class=\"string\">count:</span> &#123; <span class=\"string\">$sum:</span> <span class=\"number\">1</span> &#125; &#125; &#125;</span><br><span class=\"line\">]);</span><br></pre></td></tr></table></figure>\n</blockquote>\n<p><strong>当match和group同时存在时， 顺序会影响检索结果，必须先写 match 在前面</strong></p>\n<h1 id=\"三、MongoDB优化\"><a href=\"#三、MongoDB优化\" class=\"headerlink\" title=\"三、MongoDB优化\"></a>三、MongoDB优化</h1><h2 id=\"1-副本集\"><a href=\"#1-副本集\" class=\"headerlink\" title=\"1. 副本集\"></a>1. 副本集</h2><p>​        将数据同步在多个服务器的过程，提高了数据的可用性， 并可以保证数据的安全性。具有自动灾难恢复。没有固定的主节点</p>\n<p><strong>副本集设置</strong></p>\n<ol>\n<li><p>创建一个cluster文件夹，放node1，node2，node3三个子文件夹</p>\n<figure class=\"highlight angelscript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">节点<span class=\"number\">1</span>：</span><br><span class=\"line\">HOST：localhost:<span class=\"number\">10001</span></span><br><span class=\"line\">Data File：F:\\MongoDB\\node1</span><br><span class=\"line\"></span><br><span class=\"line\">节点<span class=\"number\">2</span>：</span><br><span class=\"line\">HOST：localhost:<span class=\"number\">10002</span></span><br><span class=\"line\">Data File：F:\\MongoDB\\node2</span><br><span class=\"line\"></span><br><span class=\"line\">节点<span class=\"number\">3</span>：</span><br><span class=\"line\">HOST：localhost:<span class=\"number\">10003</span></span><br><span class=\"line\">Data File：F:\\MongoDB\\node3</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>指定 –replSet 选项来启动mongoDB：</p>\n<p><code>mongod --port 端口 --dbpath 文件夹位置 --replSet 副本集名称</code></p>\n<ul>\n<li><p>启动一个新的副本集(初始化操作)：</p>\n<figure class=\"highlight prolog\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">rs.initiate(&#123;</span><br><span class=\"line\">\t<span class=\"string\">\"_id\"</span>:<span class=\"string\">\"shinelon\"</span>,</span><br><span class=\"line\">\t<span class=\"string\">\"members\"</span>:[ </span><br><span class=\"line\">\t\t&#123;<span class=\"string\">\"_id\"</span>:<span class=\"number\">1</span>,<span class=\"string\">\"host\"</span>:<span class=\"string\">\"localhost:10001\"</span>&#125;,</span><br><span class=\"line\">\t\t&#123;<span class=\"string\">\"_id\"</span>:<span class=\"number\">2</span>,<span class=\"string\">\"host\"</span>:<span class=\"string\">\"localhost:10002\"</span>&#125;,</span><br><span class=\"line\">\t\t&#123;<span class=\"string\">\"_id\"</span>:<span class=\"number\">3</span>,<span class=\"string\">\"host\"</span>:<span class=\"string\">\"localhost:10003\"</span>&#125; </span><br><span class=\"line\">\t\t\t]</span><br><span class=\"line\">\t&#125;)</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>查看副本集的配置：<code>rs.conf()</code></p>\n</li>\n<li><p>查看副本集状态： <code>rs.status()</code></p>\n</li>\n<li><p>副本集添加成员：<code>rs.add(HOST_NAME:POST)</code></p>\n</li>\n</ul>\n</li>\n</ol>\n<h2 id=\"2-分片\"><a href=\"#2-分片\" class=\"headerlink\" title=\"2. 分片\"></a>2. 分片</h2><p>​        指将数据拆分，将其分散存在不同的机器上的过程，不需要功能强大的大型计算机就可以储存更多的数据，处理更多的负载</p>\n<p><strong>片键</strong>：从集合里面选一个键，用该键的值作为数据拆分的依据</p>\n<p><strong>分片设置</strong></p>\n<ol>\n<li><p>启动Shard Server（用于存储实际的数据块）</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">HOST：localhost:27020</span><br><span class=\"line\">Data File：F:\\MongoDB\\shard\\s0</span><br><span class=\"line\"></span><br><span class=\"line\">HOST：localhost:27021</span><br><span class=\"line\">Data File：F:\\MongoDB\\shard\\s1</span><br><span class=\"line\">...\\s3</span><br><span class=\"line\">Data File：F:\\MongoDB\\shard\\<span class=\"built_in\">log</span></span><br><span class=\"line\"></span><br><span class=\"line\">&gt; mongod --port 27020 --dbpath=F:\\MongoDB\\shard\\s0 --logpath=F:\\MongoDB\\shard\\<span class=\"built_in\">log</span>\\s0.log --logappend --fork</span><br><span class=\"line\">...</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>启动Config Server（mongodb实例）</p>\n<figure class=\"highlight taggerscript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">HOST：localhost:27100</span><br><span class=\"line\">Data File：F:<span class=\"symbol\">\\M</span>ongoDB<span class=\"symbol\">\\s</span>hard<span class=\"symbol\">\\c</span>onfig</span><br><span class=\"line\"></span><br><span class=\"line\">&gt; mongod --port 27100 --dbpath=F:<span class=\"symbol\">\\M</span>ongoDB<span class=\"symbol\">\\s</span>hard<span class=\"symbol\">\\c</span>onfig --logpath=F:<span class=\"symbol\">\\M</span>ongoDB<span class=\"symbol\">\\s</span>hard<span class=\"symbol\">\\l</span>og<span class=\"symbol\">\\c</span>onfig.log --logappend --fork</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>启动Route Process（mongos路由进程：应用连接它来发送请求，知道数据在分片中的位置，收集返回数据）</p>\n<figure class=\"highlight brainfuck\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&gt; <span class=\"comment\">mongos</span> --<span class=\"comment\">port</span> <span class=\"comment\">40000</span> --<span class=\"comment\">configdb</span> <span class=\"comment\">localhost:27100</span> --<span class=\"comment\">fork</span> --<span class=\"comment\">logpath=F:\\MongoDB\\shard\\log\\route</span><span class=\"string\">.</span><span class=\"comment\">log</span> --<span class=\"comment\">chunkSize</span> <span class=\"comment\">500</span></span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>chunkSize这一项是用来指定chunk的大小的，单位是MB，默认大小为200MB.</p>\n</blockquote>\n</li>\n<li><p>配置Sharding</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mongo admin --port 40000</span><br><span class=\"line\">db.runCommand(&#123; addshard:<span class=\"string\">\"localhost:27020\"</span> &#125;)</span><br><span class=\"line\">...</span><br><span class=\"line\">db.runCommand(&#123; enablesharding:<span class=\"string\">\"test\"</span> &#125;) <span class=\"comment\">#设置分片存储的数据库</span></span><br><span class=\"line\"><span class=\"comment\"># 指定片键 user.name</span></span><br><span class=\"line\">db.runCommand(&#123; shardcollection: <span class=\"string\">'test.user'</span>, key: &#123;name: 1&#125;&#125;)</span><br></pre></td></tr></table></figure>\n\n</li>\n</ol>\n<p>可参考：<a href=\"https://blog.csdn.net/qq_37142346/java/article/details/82824132\" target=\"_blank\" rel=\"noopener\">https://blog.csdn.net/qq_37142346/java/article/details/82824132</a></p>\n<h2 id=\"3-备份与恢复\"><a href=\"#3-备份与恢复\" class=\"headerlink\" title=\"3. 备份与恢复\"></a>3. 备份与恢复</h2><p>数据备份：<code>mongodump -h dbhost -d dbname -o dbdirectory</code></p>\n<ul>\n<li>-h：MongoDB所在服务器地址，默认为： localhost:27017</li>\n<li>-d：需要备份的数据库实例，例如：test</li>\n<li>-o：备份的数据存放位置，例如：c:\\data\\dump</li>\n</ul>\n<p>mongodump 命令可选参数列表如下所示：</p>\n<table>\n<thead>\n<tr>\n<th align=\"left\">语法</th>\n<th align=\"left\">描述</th>\n<th align=\"left\">实例</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"left\">mongodump –host HOST_NAME –port PORT_NUMBER</td>\n<td align=\"left\">该命令将备份所有MongoDB数据</td>\n<td align=\"left\">mongodump –host runoob.com –port 27017</td>\n</tr>\n<tr>\n<td align=\"left\">mongodump –dbpath DB_PATH –out BACKUP_DIRECTORY</td>\n<td align=\"left\"></td>\n<td align=\"left\">mongodump –dbpath /data/db/ –out /data/backup/</td>\n</tr>\n<tr>\n<td align=\"left\">mongodump –collection COLLECTION –db DB_NAME</td>\n<td align=\"left\">该命令将备份指定数据库的集合。</td>\n<td align=\"left\">mongodump –collection mycol –db test</td>\n</tr>\n</tbody></table>\n<p>数据恢复：<code>mongorestore -h &lt;hostname&gt;&lt;:port&gt; -d dbname &lt;path&gt;</code></p>\n<ul>\n<li><p>–host &lt;:port&gt;, -h &lt;:port&gt;：MongoDB所在服务器地址</p>\n</li>\n<li><p>–db , -d ：需要恢复的数据库实例，例如：test</p>\n</li>\n<li><p>–drop：恢复的时候，先删除当前数据，然后恢复备份的数据。</p>\n</li>\n<li><p><path>：mongorestore 最后的一个参数，设置备份数据所在位置</p>\n<blockquote>\n<p>例：c:\\data\\dump\\test</p>\n</blockquote>\n</li>\n<li><p>–dir：指定备份的目录</p>\n<blockquote>\n<p>不能同时指定 <path> 和 –dir 选项。</p>\n</blockquote>\n</li>\n</ul>\n<h2 id=\"4-监控\"><a href=\"#4-监控\" class=\"headerlink\" title=\"4. 监控\"></a>4. 监控</h2><p><strong>mongostat命令</strong></p>\n<p>获取mongoDB的运行状态：mongostat</p>\n<p><strong>mongotop命令</strong></p>\n<p>跟踪一个MongoDB的实例，查看哪些读取和写入数据在花费大量的时间：mongotop <sleeptime></p>\n<ul>\n<li>等待时间长度，以秒为单位</li>\n</ul>\n<h1 id=\"四、MongoDB高级\"><a href=\"#四、MongoDB高级\" class=\"headerlink\" title=\"四、MongoDB高级\"></a>四、MongoDB高级</h1><h2 id=\"1-MongoDB关系\"><a href=\"#1-MongoDB关系\" class=\"headerlink\" title=\"1. MongoDB关系\"></a>1. MongoDB关系</h2><p>​        MongoDB的关系表示多个文档之间在逻辑上的相互关系，文档间可以通过<strong>嵌入</strong>和<strong>引用</strong>来建立联系。</p>\n<ul>\n<li>一对一</li>\n<li>一对多</li>\n<li>多对一</li>\n<li>多对多</li>\n</ul>\n<p><strong>嵌入式关系</strong>：把用户地址嵌入到用户的文档中（一张表，数据量大的话，影响性能）</p>\n<blockquote>\n<p>查询用户地址：<code>db.users.findOne({&quot;name&quot;:&quot;Tom Benzamin&quot;},{&quot;address&quot;:1})</code></p>\n</blockquote>\n<p><strong>引用式关系</strong>：通过引用文档的 <strong>id</strong> 字段来建立关系，外键</p>\n<ol>\n<li><p>查询用户地址对象id</p>\n<p><code>var result = db.users.findOne({&quot;name&quot;:&quot;Tom Benzamin&quot;},{&quot;address_ids&quot;:1})</code></p>\n</li>\n<li><p>通过查询的id获取用户的详细地址信息</p>\n<p><code>var addresses = db.address.find({&quot;_id&quot;:{&quot;$in&quot;:result[&quot;address_ids&quot;]}})</code></p>\n</li>\n</ol>\n<blockquote>\n<p>findOne不能写成find，find返回的是数组，findOne返回的是对象</p>\n</blockquote>\n<h2 id=\"2-引用操作\"><a href=\"#2-引用操作\" class=\"headerlink\" title=\"2. 引用操作\"></a>2. 引用操作</h2><p>MongoDB引用有两种：手动引用（Manual References）和DBRefs</p>\n<p><strong>DBRefs</strong></p>\n<p>形式：<code>{$ref : , $id : , $db : }</code></p>\n<ul>\n<li>$ref：集合名称</li>\n<li>$id：引用的id</li>\n<li>$db:数据库名称，可选参数</li>\n</ul>\n<p><strong>覆盖查询：</strong></p>\n<ul>\n<li>所有的查询字段是索引的一部分</li>\n<li>所有的查询返回字段在同一个索引中</li>\n</ul>\n<blockquote>\n<ol>\n<li><p>在 users 集合中创建联合索引，字段为 gender 和 user_name :</p>\n<p><code>db.users.ensureIndex({gender:1,user_name:1})</code></p>\n</li>\n<li><p>该索引会覆盖以下查询：</p>\n<p><code>db.users.find({gender:&quot;M&quot;},{user_name:1,_id:0})</code></p>\n</li>\n<li><p>没有排除_id，查询就不会被覆盖</p>\n<p><code>db.users.find({gender:&quot;M&quot;},{user_name:1})</code></p>\n</li>\n</ol>\n</blockquote>\n<p><strong>查询分析：</strong>可以确保建立的索引是否有效，是查询语句性能分析的重要工具。</p>\n<ol>\n<li><p>explain()：查询信息，使用索引及查询统计等</p>\n<p><code>db.users.find({gender:&quot;M&quot;},{user_name:1,_id:0}).explain()</code></p>\n</li>\n<li><p>hint()：指定使用某个索引字段来查询</p>\n<p><code>db.users.find({gender:&quot;M&quot;},{user_name:1,_id:0}).hint({gender:1,user_name:1})</code></p>\n</li>\n</ol>\n<h2 id=\"3-原子操作\"><a href=\"#3-原子操作\" class=\"headerlink\" title=\"3. 原子操作\"></a>3. 原子操作</h2><p>​        mongodb不支持事务，但是mongodb提供了许多原子操作，比如文档的保存，修改，删除等，都是原子操作。要么成功要么失败，达到数据完整性</p>\n<h3 id=\"3-1-原子操作常用命令\"><a href=\"#3-1-原子操作常用命令\" class=\"headerlink\" title=\"3.1 原子操作常用命令\"></a>3.1 原子操作常用命令</h3><p><strong>$set：</strong>用来指定一个键并更新键值，若键不存在并创建。</p>\n<p><code>{ $set :{ field : value}}</code></p>\n<blockquote>\n<p>例：<code>db.col.update({&quot;gender&quot;:&quot;M&quot;},{$set:{&quot;gender&quot;: &quot;A&quot;}})</code></p>\n</blockquote>\n<p><strong>$unset：</strong>用来删除一个键</p>\n<p><code>{ $unset : { field : 1} }</code></p>\n<blockquote>\n<p>例：<code>db.col.update({&quot;gender&quot;:&quot;A&quot;},{$unset:{&quot;gender&quot;: 1}})</code></p>\n</blockquote>\n<p><strong>$inc：</strong>对文档的某个值为数字型（只能为满足要求的数字）的键进行增减的操作。</p>\n<p><code>{ $inc : { field : value } }</code></p>\n<blockquote>\n<p>例：<code>db.col.update({},{$inc:{&quot;num&quot;: 10}})</code></p>\n</blockquote>\n<p><strong>$push：</strong>把value追加到field里面去，field一定要是数组类型才行</p>\n<p><code>{ $push : { field : value } }</code></p>\n<blockquote>\n<p>例：<code>db.col.update({&quot;_id&quot;: 1},{$push:{age:22}})</code></p>\n<p>添加多个字段到数组</p>\n<p>例：<code>db.col.update({&quot;_id&quot;: 1},{$push:{age: {$each: [1,2,3]}}})</code></p>\n</blockquote>\n<p><strong>$pull：</strong>从数组field内删除一个等于value值</p>\n<p><code>{ $pull: { &lt;field1&gt;: &lt;value|condition&gt;, &lt;field2&gt;: &lt;value|condition&gt;, ... } }</code></p>\n<blockquote>\n<p>例：<code>db.col.update({}, {$pull:{age:24}})</code></p>\n</blockquote>\n<p><strong>$pop：</strong>删除数组的第一个（-1）或最后一个（1）元素</p>\n<p><code>{ $pop : { field : 1 } }</code></p>\n<blockquote>\n<p>例：<code>db.col.update({}, {$pop:{&quot;age&quot;:1}})</code></p>\n</blockquote>\n<p><strong>$rename:</strong>修改字段名称</p>\n<p><code>{ $rename : { old_field_name : new_field_name } }</code></p>\n<blockquote>\n<p>例：<code>db.col.update({}, {$rename: {&quot;age&quot;:&quot;age1&quot;}})</code></p>\n</blockquote>\n<h2 id=\"4-Map-Reduce\"><a href=\"#4-Map-Reduce\" class=\"headerlink\" title=\"4. Map-Reduce\"></a>4. Map-Reduce</h2><p>​        Map-Reduce是一种计算模型，将大批量的工作（数据）分解（MAP）执行，然后再将结果合并成最终结果（REDUCE）</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">db.collection.mapReduce(</span><br><span class=\"line\">   <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;emit(key,value);&#125;,  <span class=\"comment\">// map 函数</span></span><br><span class=\"line\">   <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">key,values</span>) </span>&#123;<span class=\"keyword\">return</span> reduceFunction&#125;,   <span class=\"comment\">// reduce 函数</span></span><br><span class=\"line\">   &#123;</span><br><span class=\"line\">      out: collection,</span><br><span class=\"line\">      query: <span class=\"built_in\">document</span>,</span><br><span class=\"line\">      sort: <span class=\"built_in\">document</span>,</span><br><span class=\"line\">      limit: number</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\">)</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>使用 MapReduce 要实现两个函数： Map 函数和 Reduce 函数。</p>\n<p>Map 函数调用 emit(key, value), 遍历 collection 中所有的记录, 将 key 与 value 传递给 Reduce 函数进行处理。</p>\n</blockquote>\n<p><strong>Map 函数必须调用 emit(key, value) 返回键值对。</strong></p>\n<p>参数说明:</p>\n<ul>\n<li><strong>map</strong> ：映射函数 (生成键值对序列,作为 reduce 函数参数)。</li>\n<li><strong>reduce</strong> 统计函数，reduce函数的任务就是将key-values变成key-value，也就是把values数组变成一个单一的值value。</li>\n<li><strong>out</strong> 统计结果存放集合 (不指定则使用临时集合,在客户端断开后自动删除)。<ul>\n<li>可选参数：inline    <code>out: {inline: 1}</code></li>\n<li>不会创建集合，整个操作都在内存里运行==（结果集单个文档大小&lt;16MB）==</li>\n</ul>\n</li>\n<li><strong>query</strong> 一个筛选条件，只有满足条件的文档才会调用map函数。（query。limit，sort可以随意组合）</li>\n<li><strong>sort</strong> 和limit结合的sort排序参数（也是在发往map函数前给文档排序），可以优化分组机制</li>\n<li><strong>limit</strong> 发往map函数的文档数量的上限（要是没有limit，单独使用sort的用处不大）</li>\n</ul>\n<blockquote>\n<p>例：将在 posts 集合中使用 mapReduce 函数来选取已发布的文章(status:”active”)，并通过user_name分组，计算每个用户的文章数：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">db.posts.mapReduce( </span><br><span class=\"line\">   <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123; emit(<span class=\"keyword\">this</span>.user_name,<span class=\"number\">1</span>); &#125;, \t<span class=\"comment\">// map</span></span><br><span class=\"line\">   <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">key, values</span>) </span>&#123;<span class=\"keyword\">return</span> <span class=\"built_in\">Array</span>.sum(values)&#125;,  <span class=\"comment\">// Arraty：将数组或列表或多个值存储为一个键\treduce</span></span><br><span class=\"line\">      &#123;  </span><br><span class=\"line\">         query:&#123;<span class=\"attr\">status</span>:<span class=\"string\">\"active\"</span>&#125;,  \t<span class=\"comment\">// quert：筛选条件</span></span><br><span class=\"line\">         out:<span class=\"string\">\"post_total\"</span> \t\t\t<span class=\"comment\">// out：结果存储集合</span></span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">).find()</span><br></pre></td></tr></table></figure>\n</blockquote>\n<h2 id=\"5-全文检索\"><a href=\"#5-全文检索\" class=\"headerlink\" title=\"5. 全文检索\"></a>5. 全文检索</h2><p>​        对每一个词建立一个索引，指明该词在文章中出现的次数和位置，当用户查询时，检索程序就根据事先建立的索引进行查找，并将查找的结果反馈给用户的检索方式。</p>\n<ol>\n<li><p><strong>启动</strong></p>\n<p>2.6版本后默认开启，小于2.6版本启动命令:</p>\n<p><code>db.adminCommand({setParameter:true,textSearchEnabled:true})</code> </p>\n<p>&amp;&amp;</p>\n<p> <code>mongod --setParameter textSearchEnabled=true</code></p>\n</li>\n<li><p><strong>创建</strong></p>\n<blockquote>\n<p>创建posts集合文档数据，包含文章内容（post_text）及标签(tags)：</p>\n<figure class=\"highlight json\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">   <span class=\"attr\">\"post_text\"</span>: <span class=\"string\">\"enjoy the mongodb articles on Runoob\"</span>,</span><br><span class=\"line\">   <span class=\"attr\">\"tags\"</span>: [</span><br><span class=\"line\">      <span class=\"string\">\"mongodb\"</span>,</span><br><span class=\"line\">      <span class=\"string\">\"runoob\"</span></span><br><span class=\"line\">   ]</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n</blockquote>\n<p>对post_text字段建立全文索引：<code>db.posts.ensureIndex({post_text:&quot;text&quot;})</code></p>\n</li>\n<li><p>使用</p>\n<p>搜索文章中的关键词 runoob：<code>db.posts.find({$text:{$search:&quot;runoob&quot;}})</code></p>\n<blockquote>\n<p>使用全文检索可以提高查询效率</p>\n</blockquote>\n</li>\n<li><p>删除</p>\n<p><code>db.posts.dropIndex(&quot;post_text_text&quot;)</code></p>\n</li>\n</ol>\n<h2 id=\"6-正则表达式\"><a href=\"#6-正则表达式\" class=\"headerlink\" title=\"6. 正则表达式\"></a>6. 正则表达式</h2><p><strong>使用：$regex</strong></p>\n<p><code>db.posts.find({post_text:{$regex:&quot;runoob&quot;}})</code></p>\n<p>&amp;&amp;</p>\n<p><code>db.posts.find({post_text:/runoob/})</code></p>\n<p>不区分大小写：<code>db.posts.find({post_text:{$regex:&quot;runoob&quot;,$options:&quot;$i&quot;}})</code></p>\n<p><strong>数组元素使用正则表达式</strong></p>\n<blockquote>\n<p>例：查找run 开头的标签数据(ru 或 run 或 runoob)</p>\n<p><code>db.posts.find({tags:{$regex:&quot;run&quot;}})</code></p>\n</blockquote>\n<h3 id=\"6-1-优化\"><a href=\"#6-1-优化\" class=\"headerlink\" title=\"6.1 优化\"></a>6.1 优化</h3><ul>\n<li><p>索引字段查询速度高于正则匹配</p>\n</li>\n<li><p>如果正则表达式是前缀表达式，所有匹配的数据将以指定的前缀字符串为开始</p>\n<blockquote>\n<p>例：^tut        匹配以tut为开头的字符串</p>\n</blockquote>\n</li>\n<li><p>正则表达式中使用变量。一定要使用eval将组合的字符串进行转换，不能直接将字符串拼接后传入给表达式。否则没有报错信息，只是结果为空！</p>\n<blockquote>\n<p>例：<code>name=eval(&quot;/&quot; + 变量值key +&quot;/i&quot;);</code></p>\n<p>例：模糊查询包含title关键词, 且不区分大小写<code>title:eval(&quot;/&quot;+title+&quot;/i&quot;)</code>    </p>\n<ul>\n<li>同：<code>title:{$regex:title,$Option:&quot;$i&quot;}</code></li>\n</ul>\n</blockquote>\n</li>\n</ul>\n<h2 id=\"7-GridFS\"><a href=\"#7-GridFS\" class=\"headerlink\" title=\"7. GridFS\"></a>7. GridFS</h2><p>​        GridFS 用于存储和恢复那些超过16M（BSON文件限制）的文件(如：图片、音频、视频等)。也是文件存储的一种方式，但是它是存储在MonoDB的集合中。将大文件对象分割成多个小的chunk(文件片段),一般为256k/个,每个chunk将作为MongoDB的一个文档(document)被存储在chunks集合中。</p>\n<ul>\n<li><p>用两个集合来存储一个文件</p>\n<p><strong>fs.files：</strong>每个文件的实际内容被存在chunks(二进制数据)中</p>\n<p><strong>fs.chunks：</strong>和文件有关的meta数据(filename,content_type,还有用户自定义的属性)将会被存在files集合中。</p>\n</li>\n</ul>\n<p><strong>GridFS添加文件</strong></p>\n<blockquote>\n<p>例：添加mp3文件</p>\n<p><code>mongofiles.exe -d gridfs put song.mp3</code></p>\n<p><code>-d gridfs</code>：指定存储文件的数据库名称，未指定会自动创建</p>\n</blockquote>\n<p>查看数据库中文件的文档：<code>db.fs.files.find()</code></p>\n<p>根据 _id 获取区块(chunk)的数据：</p>\n<p><code>db.fs.chunks.find({files_id:ObjectId(&#39;534a811bf8b4aa4d33fdf94d&#39;)})</code></p>\n<h2 id=\"8-固定集合\"><a href=\"#8-固定集合\" class=\"headerlink\" title=\"8. 固定集合\"></a>8. 固定集合</h2><p>​        固定长度，当集合空间用完后，再插入的元素就会覆盖最初始的头部的元素！可以插入及更新，但不能更新超出collection的大小，不允许删除，但是可以调用drop()删除集合中的所有行，drop后需要显式地重建集合。</p>\n<ul>\n<li>对固定集合进行插入速度极快</li>\n<li>按照插入顺序的查询输出速度极快</li>\n<li>能够在插入最新数据时,淘汰最早的数据</li>\n</ul>\n<p><strong>创建</strong></p>\n<p><code>db.createCollection(&quot;cappedLogCollection&quot;,{capped:true,size:10000})</code></p>\n<p>指定文档个数</p>\n<p><code>db.createCollection(&quot;cappedLogCollection&quot;,{capped:true,size:10000,max:1000})</code></p>\n<ul>\n<li><strong>size(KB)：</strong>整个集合空间的大小</li>\n<li><strong>max(个)：</strong>文档数上限</li>\n</ul>\n<p>判断集合是否为固定集合</p>\n<p><code>db.cappedLogCollection.isCapped()</code></p>\n<p>将已存在的集合转为固定集合</p>\n<p><code>db.runCommand({&quot;convertToCapped&quot;:&quot;posts&quot;, size:10000})</code></p>\n<blockquote>\n<p>将已存在的posts集合转为固定集合</p>\n</blockquote>\n<p><strong>查询</strong></p>\n<p>​        固定集合文档按照插入顺序储存的,默认情况下查询就是按照插入顺序返回的,也可以使用$natural调整返回顺序。</p>\n<p><code>db.cappedLogCollection.find().sort({$natural:-1})</code></p>\n<p><strong>用法：</strong>存储日志信息、缓存一些少量的文档</p>"},{"title":"Python补充","date":"2020-09-30T08:14:15.000Z","top":0,"_content":"\n## python中的魔法方法\n\n```python\n__init__(self)\t# 在创建一个对象是默认被调用，不需要手动调用\n__str__(self)\t# 用来显示信息，需要return一个数据\n__del__(self)\t# 当删除对象时，默认被调用\n__new__(self)\t# 才是实例化对象调用的第一个方法，它只取下 cls 参数，并把 其他参数传给 __init__\n__call__(self)\t# 允许一个类的实例像函数一样被调用 。\n__getitem__(self)\t\t# 定义获取容器中指定元素的行为，相当于 self[key] 。\n__getattr__(self) \t# 定义当用户试图访问一个不存在属性的时候的行为 。\n__setattr__(self) \t# 定义当一个属性被设置的时候的行为 。\n__getattribute__(self) \t# 定义当一个属性被访问的时候的行为 。\n```\n\n<!--more-->\n\n## 可变与不可变类型\n\n- **指内存中的那块内容（value）是否可以发生改变**\n- 可变类型：不需要申请新内存，在原有基础上改变\n- 不可变类型：必须在内存中新申请一块区域\n\n## 冒泡排序\n\n```python\ndef bubble_sort(alist):\n    for j in range(len(alist)-1, 0, -1):\n        for i in range(j):\n            if alist[i] > alist[i+1]:\n                alist[i], alist[i+1] = alist[i+1], alist[i]\n```\n\n## is和==的区别\n\n-  都是对对象进行比较判断作用的\n-  ==（比较运算法），用来判断两个对象的value值\n-  is（同一性运算符），用来判断两个对象的唯一身份标识，id地址\n\n只有**数值型（-5~256）和字符串**型的情况下，a is b才为True，当a和b是**tuple，list，dict**或**set**型时，a is b为False。 \n\n## python默认递归限制1000or998\n\n- 修改限制\n\n  ```python\n  import sys\n  sys.setrecursionlimit(1500)\n  ```\n\n## 数据量大情况下Paginator的缺点\n\n- 查询效率慢的问题\n- **PageHelper的分页功能是通过Limit拼接SQL实现的** \n\n## 装饰器\n\n作用：在不改变已有函数源代码及调用方式的前提下，对已有函数进行功能的扩展\n\n```python\n# 不改变原有函数__name__\\备注信息\nfrom functools import wraps\ndef check(fu):  # fu:目标函数\n    \n    @wraps(fu)\n    def inner():\n        '''执行函数之前'''\n        fu()\n        '''执行函数之后'''\n    return inner\n\n# 语法糖写法\n@check\ndef comment():\n    print('发表评论')\n    \ncomment()\n# check等价与  comment = check(comment)\n```\n","source":"_posts/Python补充.md","raw":"---\ntitle: Python补充\ndate: 2020-09-30 16:14:15\ntags: Python\ntop: 0\n---\n\n## python中的魔法方法\n\n```python\n__init__(self)\t# 在创建一个对象是默认被调用，不需要手动调用\n__str__(self)\t# 用来显示信息，需要return一个数据\n__del__(self)\t# 当删除对象时，默认被调用\n__new__(self)\t# 才是实例化对象调用的第一个方法，它只取下 cls 参数，并把 其他参数传给 __init__\n__call__(self)\t# 允许一个类的实例像函数一样被调用 。\n__getitem__(self)\t\t# 定义获取容器中指定元素的行为，相当于 self[key] 。\n__getattr__(self) \t# 定义当用户试图访问一个不存在属性的时候的行为 。\n__setattr__(self) \t# 定义当一个属性被设置的时候的行为 。\n__getattribute__(self) \t# 定义当一个属性被访问的时候的行为 。\n```\n\n<!--more-->\n\n## 可变与不可变类型\n\n- **指内存中的那块内容（value）是否可以发生改变**\n- 可变类型：不需要申请新内存，在原有基础上改变\n- 不可变类型：必须在内存中新申请一块区域\n\n## 冒泡排序\n\n```python\ndef bubble_sort(alist):\n    for j in range(len(alist)-1, 0, -1):\n        for i in range(j):\n            if alist[i] > alist[i+1]:\n                alist[i], alist[i+1] = alist[i+1], alist[i]\n```\n\n## is和==的区别\n\n-  都是对对象进行比较判断作用的\n-  ==（比较运算法），用来判断两个对象的value值\n-  is（同一性运算符），用来判断两个对象的唯一身份标识，id地址\n\n只有**数值型（-5~256）和字符串**型的情况下，a is b才为True，当a和b是**tuple，list，dict**或**set**型时，a is b为False。 \n\n## python默认递归限制1000or998\n\n- 修改限制\n\n  ```python\n  import sys\n  sys.setrecursionlimit(1500)\n  ```\n\n## 数据量大情况下Paginator的缺点\n\n- 查询效率慢的问题\n- **PageHelper的分页功能是通过Limit拼接SQL实现的** \n\n## 装饰器\n\n作用：在不改变已有函数源代码及调用方式的前提下，对已有函数进行功能的扩展\n\n```python\n# 不改变原有函数__name__\\备注信息\nfrom functools import wraps\ndef check(fu):  # fu:目标函数\n    \n    @wraps(fu)\n    def inner():\n        '''执行函数之前'''\n        fu()\n        '''执行函数之后'''\n    return inner\n\n# 语法糖写法\n@check\ndef comment():\n    print('发表评论')\n    \ncomment()\n# check等价与  comment = check(comment)\n```\n","slug":"Python补充","published":1,"updated":"2020-09-30T08:45:18.861Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckfp5akf3000dn8jh2dge4ed3","content":"<h2 id=\"python中的魔法方法\"><a href=\"#python中的魔法方法\" class=\"headerlink\" title=\"python中的魔法方法\"></a>python中的魔法方法</h2><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">__init__(self)\t<span class=\"comment\"># 在创建一个对象是默认被调用，不需要手动调用</span></span><br><span class=\"line\">__str__(self)\t<span class=\"comment\"># 用来显示信息，需要return一个数据</span></span><br><span class=\"line\">__del__(self)\t<span class=\"comment\"># 当删除对象时，默认被调用</span></span><br><span class=\"line\">__new__(self)\t<span class=\"comment\"># 才是实例化对象调用的第一个方法，它只取下 cls 参数，并把 其他参数传给 __init__</span></span><br><span class=\"line\">__call__(self)\t<span class=\"comment\"># 允许一个类的实例像函数一样被调用 。</span></span><br><span class=\"line\">__getitem__(self)\t\t<span class=\"comment\"># 定义获取容器中指定元素的行为，相当于 self[key] 。</span></span><br><span class=\"line\">__getattr__(self) \t<span class=\"comment\"># 定义当用户试图访问一个不存在属性的时候的行为 。</span></span><br><span class=\"line\">__setattr__(self) \t<span class=\"comment\"># 定义当一个属性被设置的时候的行为 。</span></span><br><span class=\"line\">__getattribute__(self) \t<span class=\"comment\"># 定义当一个属性被访问的时候的行为 。</span></span><br></pre></td></tr></table></figure>\n\n<a id=\"more\"></a>\n\n<h2 id=\"可变与不可变类型\"><a href=\"#可变与不可变类型\" class=\"headerlink\" title=\"可变与不可变类型\"></a>可变与不可变类型</h2><ul>\n<li><strong>指内存中的那块内容（value）是否可以发生改变</strong></li>\n<li>可变类型：不需要申请新内存，在原有基础上改变</li>\n<li>不可变类型：必须在内存中新申请一块区域</li>\n</ul>\n<h2 id=\"冒泡排序\"><a href=\"#冒泡排序\" class=\"headerlink\" title=\"冒泡排序\"></a>冒泡排序</h2><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">bubble_sort</span><span class=\"params\">(alist)</span>:</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> j <span class=\"keyword\">in</span> range(len(alist)<span class=\"number\">-1</span>, <span class=\"number\">0</span>, <span class=\"number\">-1</span>):</span><br><span class=\"line\">        <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> range(j):</span><br><span class=\"line\">            <span class=\"keyword\">if</span> alist[i] &gt; alist[i+<span class=\"number\">1</span>]:</span><br><span class=\"line\">                alist[i], alist[i+<span class=\"number\">1</span>] = alist[i+<span class=\"number\">1</span>], alist[i]</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"is和-的区别\"><a href=\"#is和-的区别\" class=\"headerlink\" title=\"is和==的区别\"></a>is和==的区别</h2><ul>\n<li>都是对对象进行比较判断作用的</li>\n<li>==（比较运算法），用来判断两个对象的value值</li>\n<li>is（同一性运算符），用来判断两个对象的唯一身份标识，id地址</li>\n</ul>\n<p>只有<strong>数值型（-5~256）和字符串</strong>型的情况下，a is b才为True，当a和b是<strong>tuple，list，dict</strong>或<strong>set</strong>型时，a is b为False。 </p>\n<h2 id=\"python默认递归限制1000or998\"><a href=\"#python默认递归限制1000or998\" class=\"headerlink\" title=\"python默认递归限制1000or998\"></a>python默认递归限制1000or998</h2><ul>\n<li><p>修改限制</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> sys</span><br><span class=\"line\">sys.setrecursionlimit(<span class=\"number\">1500</span>)</span><br></pre></td></tr></table></figure>\n\n</li>\n</ul>\n<h2 id=\"数据量大情况下Paginator的缺点\"><a href=\"#数据量大情况下Paginator的缺点\" class=\"headerlink\" title=\"数据量大情况下Paginator的缺点\"></a>数据量大情况下Paginator的缺点</h2><ul>\n<li>查询效率慢的问题</li>\n<li><strong>PageHelper的分页功能是通过Limit拼接SQL实现的</strong> </li>\n</ul>\n<h2 id=\"装饰器\"><a href=\"#装饰器\" class=\"headerlink\" title=\"装饰器\"></a>装饰器</h2><p>作用：在不改变已有函数源代码及调用方式的前提下，对已有函数进行功能的扩展</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 不改变原有函数__name__\\备注信息</span></span><br><span class=\"line\"><span class=\"keyword\">from</span> functools <span class=\"keyword\">import</span> wraps</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">check</span><span class=\"params\">(fu)</span>:</span>  <span class=\"comment\"># fu:目标函数</span></span><br><span class=\"line\">    </span><br><span class=\"line\"><span class=\"meta\">    @wraps(fu)</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">inner</span><span class=\"params\">()</span>:</span></span><br><span class=\"line\">        <span class=\"string\">'''执行函数之前'''</span></span><br><span class=\"line\">        fu()</span><br><span class=\"line\">        <span class=\"string\">'''执行函数之后'''</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> inner</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 语法糖写法</span></span><br><span class=\"line\"><span class=\"meta\">@check</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">comment</span><span class=\"params\">()</span>:</span></span><br><span class=\"line\">    print(<span class=\"string\">'发表评论'</span>)</span><br><span class=\"line\">    </span><br><span class=\"line\">comment()</span><br><span class=\"line\"><span class=\"comment\"># check等价与  comment = check(comment)</span></span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"<h2 id=\"python中的魔法方法\"><a href=\"#python中的魔法方法\" class=\"headerlink\" title=\"python中的魔法方法\"></a>python中的魔法方法</h2><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">__init__(self)\t<span class=\"comment\"># 在创建一个对象是默认被调用，不需要手动调用</span></span><br><span class=\"line\">__str__(self)\t<span class=\"comment\"># 用来显示信息，需要return一个数据</span></span><br><span class=\"line\">__del__(self)\t<span class=\"comment\"># 当删除对象时，默认被调用</span></span><br><span class=\"line\">__new__(self)\t<span class=\"comment\"># 才是实例化对象调用的第一个方法，它只取下 cls 参数，并把 其他参数传给 __init__</span></span><br><span class=\"line\">__call__(self)\t<span class=\"comment\"># 允许一个类的实例像函数一样被调用 。</span></span><br><span class=\"line\">__getitem__(self)\t\t<span class=\"comment\"># 定义获取容器中指定元素的行为，相当于 self[key] 。</span></span><br><span class=\"line\">__getattr__(self) \t<span class=\"comment\"># 定义当用户试图访问一个不存在属性的时候的行为 。</span></span><br><span class=\"line\">__setattr__(self) \t<span class=\"comment\"># 定义当一个属性被设置的时候的行为 。</span></span><br><span class=\"line\">__getattribute__(self) \t<span class=\"comment\"># 定义当一个属性被访问的时候的行为 。</span></span><br></pre></td></tr></table></figure>","more":"<h2 id=\"可变与不可变类型\"><a href=\"#可变与不可变类型\" class=\"headerlink\" title=\"可变与不可变类型\"></a>可变与不可变类型</h2><ul>\n<li><strong>指内存中的那块内容（value）是否可以发生改变</strong></li>\n<li>可变类型：不需要申请新内存，在原有基础上改变</li>\n<li>不可变类型：必须在内存中新申请一块区域</li>\n</ul>\n<h2 id=\"冒泡排序\"><a href=\"#冒泡排序\" class=\"headerlink\" title=\"冒泡排序\"></a>冒泡排序</h2><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">bubble_sort</span><span class=\"params\">(alist)</span>:</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> j <span class=\"keyword\">in</span> range(len(alist)<span class=\"number\">-1</span>, <span class=\"number\">0</span>, <span class=\"number\">-1</span>):</span><br><span class=\"line\">        <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> range(j):</span><br><span class=\"line\">            <span class=\"keyword\">if</span> alist[i] &gt; alist[i+<span class=\"number\">1</span>]:</span><br><span class=\"line\">                alist[i], alist[i+<span class=\"number\">1</span>] = alist[i+<span class=\"number\">1</span>], alist[i]</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"is和-的区别\"><a href=\"#is和-的区别\" class=\"headerlink\" title=\"is和==的区别\"></a>is和==的区别</h2><ul>\n<li>都是对对象进行比较判断作用的</li>\n<li>==（比较运算法），用来判断两个对象的value值</li>\n<li>is（同一性运算符），用来判断两个对象的唯一身份标识，id地址</li>\n</ul>\n<p>只有<strong>数值型（-5~256）和字符串</strong>型的情况下，a is b才为True，当a和b是<strong>tuple，list，dict</strong>或<strong>set</strong>型时，a is b为False。 </p>\n<h2 id=\"python默认递归限制1000or998\"><a href=\"#python默认递归限制1000or998\" class=\"headerlink\" title=\"python默认递归限制1000or998\"></a>python默认递归限制1000or998</h2><ul>\n<li><p>修改限制</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> sys</span><br><span class=\"line\">sys.setrecursionlimit(<span class=\"number\">1500</span>)</span><br></pre></td></tr></table></figure>\n\n</li>\n</ul>\n<h2 id=\"数据量大情况下Paginator的缺点\"><a href=\"#数据量大情况下Paginator的缺点\" class=\"headerlink\" title=\"数据量大情况下Paginator的缺点\"></a>数据量大情况下Paginator的缺点</h2><ul>\n<li>查询效率慢的问题</li>\n<li><strong>PageHelper的分页功能是通过Limit拼接SQL实现的</strong> </li>\n</ul>\n<h2 id=\"装饰器\"><a href=\"#装饰器\" class=\"headerlink\" title=\"装饰器\"></a>装饰器</h2><p>作用：在不改变已有函数源代码及调用方式的前提下，对已有函数进行功能的扩展</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 不改变原有函数__name__\\备注信息</span></span><br><span class=\"line\"><span class=\"keyword\">from</span> functools <span class=\"keyword\">import</span> wraps</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">check</span><span class=\"params\">(fu)</span>:</span>  <span class=\"comment\"># fu:目标函数</span></span><br><span class=\"line\">    </span><br><span class=\"line\"><span class=\"meta\">    @wraps(fu)</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">inner</span><span class=\"params\">()</span>:</span></span><br><span class=\"line\">        <span class=\"string\">'''执行函数之前'''</span></span><br><span class=\"line\">        fu()</span><br><span class=\"line\">        <span class=\"string\">'''执行函数之后'''</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> inner</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 语法糖写法</span></span><br><span class=\"line\"><span class=\"meta\">@check</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">comment</span><span class=\"params\">()</span>:</span></span><br><span class=\"line\">    print(<span class=\"string\">'发表评论'</span>)</span><br><span class=\"line\">    </span><br><span class=\"line\">comment()</span><br><span class=\"line\"><span class=\"comment\"># check等价与  comment = check(comment)</span></span><br></pre></td></tr></table></figure>"},{"title":"MySQL操作","date":"2020-09-30T03:25:25.000Z","top":0,"_content":"\n# 一、MySQL操作\n\n# 二、SQL特性\n\n### 1  [复制集与分布式](https://handout-1300728887.cos.ap-beijing.myqcloud.com/%E8%AE%B2%E4%B9%89/%E9%BB%91%E9%A9%AC%E5%A4%B4%E6%9D%A1%E9%A1%B9%E7%9B%AE%E8%AF%BE%E4%BB%B6/C02-Database/DatabaseTheory.html)\n\n- 复制集：\n  1. 数据库中数据相同，起到备份作用\n  2. 高可用\n\n- 分布式：\n  1. 数据库中数据不同，共同组成完整的数据集合\n  2. 高吞吐\n  \n  <!--more-->\n\n### 2  主从复制\n\n1. 主服务器的数据发生改变时，会将改变的记录写在本地二进制log日志中\n2. 从服务器的一个线程会把更新的数据拷贝中继log日志中\n3. 从服务器读取中继文件并执行，达到主从一致\n\n **利用主从在达到高可用的同时，也可以通过读写分离提供吞吐量。** \n\n### 3  [事务](https://handout-1300728887.cos.ap-beijing.myqcloud.com/%E8%AE%B2%E4%B9%89/python-web%E5%9F%BA%E7%A1%80(5.1.2%E7%89%88%E6%9C%AC)/mysqlhigh/%E4%BA%8B%E5%8A%A1.html)\n\n- 四大特性：\n  - 原子性：强调事务中的多个操作时一个整体\n  - 一致性：强调数据库中不会保存不一致状态\n  - 隔离性：强调数据库中事务之间相互不可见\n  - 持久性：强调数据库能永久保存数据，一旦提交就不可撤销\n- 隔离级别：\n  - 读已提交：一个事务要等另一个事务提交后才能读取数据，可避免脏读的发生。\n  - 读未提交：一个事务可以读取另一个未提交事务的数据，最低级别，任何情况都无法保证。\n  - **可重复读(MySQL默认)**：就是在开始读取数据（事务开启）时，不再允许修改操作，可避免脏读、不可重复读的发生。\n  - 串行化：最高的事务隔离级别，事务串行化顺序执行，可以避免脏读、不可重复读与幻读。效率抵消，耗性能\n\n# 二、Mysql优化\n\n### 1  [索引](https://handout-1300728887.cos.ap-beijing.myqcloud.com/%E8%AE%B2%E4%B9%89/python-web%E5%9F%BA%E7%A1%80(5.1.2%E7%89%88%E6%9C%AC)/mysqlhigh/%E7%B4%A2%E5%BC%95.html)\n\n也叫“键”，保存数据库中所有记录的位置信息，相比于目录\n\n优点：加快查询速度\n\n缺点：耗费时间空间（不是越多越好）\n\n**优化**\n\n1. 不是越多越好，而是需要自己合理的使用\n\n### 2  [sql语句优化](https://handout-1300728887.cos.ap-beijing.myqcloud.com/%E8%AE%B2%E4%B9%89/%E9%BB%91%E9%A9%AC%E5%A4%B4%E6%9D%A1%E9%A1%B9%E7%9B%AE%E8%AF%BE%E4%BB%B6/C02-Database/DatabaseOptimize.html)\n\n- 1.避免全表扫描 \n- 2.查询时使⽤select明确指明所要查询的字段，避免使⽤ select * 的操作； \n- 3.SQL语句尽量⼤写 \n- 4.尽量避免在 where ⼦句中使⽤!=或<>操作符， \n- 5.遵循最左原则，在where⼦句中写查询条件时把索引字段放在前⾯ \n- 6.能使⽤关联查询解决的，尽量不要使⽤⼦查询 \n- 7.能不使⽤关联查询的尽量不要使⽤关联查询 \n- 8.不需要获取全表数据的时候，不要查询全表数据，使⽤LIMIT来限制数据 \n\n### 3  数据库的优化\n\n- 在进⾏表设计时，可适度增加冗余字段(反范式设计)，减少JOIN操作；\n- 多字段表可以进⾏垂直分表优化，多数据表可以进⾏⽔平分表优化；\n- 选择恰当的数据类型，如整型的选择；\n- 对于强调快速读取的操作，可以考虑使⽤MyISAM数据库引擎；\n- 对较频繁的作为查询条件的字段创建索引；唯⼀性太差的字段不适合单独创建索引，即使频繁作为查询条件；更新⾮常频繁的字段不适合创建索引；\n- 编写SQL时使⽤上⾯的⽅式对SQL语句进⾏优化；\n- 使⽤慢查询⼯具找出效率低下的SQL语句进⾏优化；\n- 构建缓存，减少数据库磁盘操作；\n- 可以考虑结合使⽤内存型数据库，如Redis，进⾏混合存储。\n\n### 4  数据库存储过程与触发器\n\n存储过程：完成特定功能的SOL语句集\n\n触发器：对表进行（插入、删除、更新）触发一系列预定好的SQL语句\n\n### 5  [数据库设计](https://handout-1300728887.cos.ap-beijing.myqcloud.com/%E8%AE%B2%E4%B9%89/%E9%BB%91%E9%A9%AC%E5%A4%B4%E6%9D%A1%E9%A1%B9%E7%9B%AE%E8%AF%BE%E4%BB%B6/C02-Database/DatabaseDesign.html)\n\n库设计：\n\n1. 数据库名要明确\n2. 不同类型的数据分开管理\n\n表设计：\n\n1. 命名，业务表跟基础表区分，驼峰命名法\n2. 词性分析法，**名词体现表或字段，动词体现关系**\n   - 一对一、一对多、多对多\n3. 不要用物理删除，以防后悔\n4. 三范式：\n   - 字段不可分割、原子性\n   - 满足范式一，表有主键依赖\n   - 满足范式二，表非主字段之间没有依赖关系。\n5. 反范式：**利用冗余字段存储数据，节省数据查询的时间，本质是空间换时间。**\n6. 字段类型、是否允许为null、是否有默认值\n   - 整形：int长度并不影响精度，长度只和显示有关\n     - **存储范围相同**\n   - 字符串：char和varchar\n     - char不可变，查询效率高，可能造成存储浪费\n     - varchar可变，查询效率不如char，节省空间\n7. 索引设计\n   - 主键、外键、唯一约束；\n   - key/value，提高查询效率的字段；\n   - **外键：作用是维护数据的完整性。**\n     - 应用：在实际开发项目过程中，用不用外键？\n     - 建议：项目开发初期可以利用外键帮助维护数据的完整性，但是，项目的中后期，建议移除外键。\n8. 数据库引擎（MySQL的核心）的选择：决定数据存储和增删改查方式，争对表\n   - **InnoDB**（事务、安全能力）\n     1. **支持事务，安全性级别较高，查询效率相对较低。**\n     2. 为处理巨大数据量的最大性能设计\n     3. **InnoDB支持外键完整性约束**\n   - **MyISAM**（主要用来插入和查询）\n     1. **不支持事务，插入、查询效率较高，增删改效率较低。**\n     2. 产生三个文件（名字一表名字开始）：\n        1. frm：文件存储表定义\n        2. .MYD：数据文件\n        3. .MYI：索引文件\n   - **MEMORY**（存放临时数据）\n     1. 将表中数据存储到内存中，未查询和引用其他表数据提供快速访问\n\n#### 5.1  分库分表\n\n**垂直拆分**\n\n- 垂直分表：\"大表拆小表\"，基于列字段进行，将不常用，数据较大，长度较长拆分\n- 垂直分库：根据业务切分成不同的库\n\n**水平拆分**\n\n- 水平分表：针对数据量巨大的单张表， 按照某种规则（RANGE,HASH取模等），切分到多张表里面去,有IO瓶颈\n- 水平分库分表：将表数据切分到多个服务器上，分布式，有效解决瓶颈、突破IO\n\n**先垂直分在水平分**\n\n##### 分库分表后面临的问题\n\n- 事务支持\n- 多库结果集合并\n- 跨库join\n\n**分库分表方案产品中间件**：官方MySQL Fabric、阿里TDDL，Cobar、360Atlas\n\n### 6  where和having哪个执行更快\n\nSQL语句执行顺序：\n\n`from -> where -> group by -> having -> select -> order by`\n\n两者区别：\n\nwhere：是一个约束声明，结果返回之前起作用，不能使用聚合函数\n\nhaving：是一个过滤声明，过滤分组数据，只能用于group by，可以使用聚合函数","source":"_posts/MySQL操作.md","raw":"---\ntitle: MySQL操作\ndate: 2020-09-30 11:25:25\ntags: SQL\ntop: 0\n---\n\n# 一、MySQL操作\n\n# 二、SQL特性\n\n### 1  [复制集与分布式](https://handout-1300728887.cos.ap-beijing.myqcloud.com/%E8%AE%B2%E4%B9%89/%E9%BB%91%E9%A9%AC%E5%A4%B4%E6%9D%A1%E9%A1%B9%E7%9B%AE%E8%AF%BE%E4%BB%B6/C02-Database/DatabaseTheory.html)\n\n- 复制集：\n  1. 数据库中数据相同，起到备份作用\n  2. 高可用\n\n- 分布式：\n  1. 数据库中数据不同，共同组成完整的数据集合\n  2. 高吞吐\n  \n  <!--more-->\n\n### 2  主从复制\n\n1. 主服务器的数据发生改变时，会将改变的记录写在本地二进制log日志中\n2. 从服务器的一个线程会把更新的数据拷贝中继log日志中\n3. 从服务器读取中继文件并执行，达到主从一致\n\n **利用主从在达到高可用的同时，也可以通过读写分离提供吞吐量。** \n\n### 3  [事务](https://handout-1300728887.cos.ap-beijing.myqcloud.com/%E8%AE%B2%E4%B9%89/python-web%E5%9F%BA%E7%A1%80(5.1.2%E7%89%88%E6%9C%AC)/mysqlhigh/%E4%BA%8B%E5%8A%A1.html)\n\n- 四大特性：\n  - 原子性：强调事务中的多个操作时一个整体\n  - 一致性：强调数据库中不会保存不一致状态\n  - 隔离性：强调数据库中事务之间相互不可见\n  - 持久性：强调数据库能永久保存数据，一旦提交就不可撤销\n- 隔离级别：\n  - 读已提交：一个事务要等另一个事务提交后才能读取数据，可避免脏读的发生。\n  - 读未提交：一个事务可以读取另一个未提交事务的数据，最低级别，任何情况都无法保证。\n  - **可重复读(MySQL默认)**：就是在开始读取数据（事务开启）时，不再允许修改操作，可避免脏读、不可重复读的发生。\n  - 串行化：最高的事务隔离级别，事务串行化顺序执行，可以避免脏读、不可重复读与幻读。效率抵消，耗性能\n\n# 二、Mysql优化\n\n### 1  [索引](https://handout-1300728887.cos.ap-beijing.myqcloud.com/%E8%AE%B2%E4%B9%89/python-web%E5%9F%BA%E7%A1%80(5.1.2%E7%89%88%E6%9C%AC)/mysqlhigh/%E7%B4%A2%E5%BC%95.html)\n\n也叫“键”，保存数据库中所有记录的位置信息，相比于目录\n\n优点：加快查询速度\n\n缺点：耗费时间空间（不是越多越好）\n\n**优化**\n\n1. 不是越多越好，而是需要自己合理的使用\n\n### 2  [sql语句优化](https://handout-1300728887.cos.ap-beijing.myqcloud.com/%E8%AE%B2%E4%B9%89/%E9%BB%91%E9%A9%AC%E5%A4%B4%E6%9D%A1%E9%A1%B9%E7%9B%AE%E8%AF%BE%E4%BB%B6/C02-Database/DatabaseOptimize.html)\n\n- 1.避免全表扫描 \n- 2.查询时使⽤select明确指明所要查询的字段，避免使⽤ select * 的操作； \n- 3.SQL语句尽量⼤写 \n- 4.尽量避免在 where ⼦句中使⽤!=或<>操作符， \n- 5.遵循最左原则，在where⼦句中写查询条件时把索引字段放在前⾯ \n- 6.能使⽤关联查询解决的，尽量不要使⽤⼦查询 \n- 7.能不使⽤关联查询的尽量不要使⽤关联查询 \n- 8.不需要获取全表数据的时候，不要查询全表数据，使⽤LIMIT来限制数据 \n\n### 3  数据库的优化\n\n- 在进⾏表设计时，可适度增加冗余字段(反范式设计)，减少JOIN操作；\n- 多字段表可以进⾏垂直分表优化，多数据表可以进⾏⽔平分表优化；\n- 选择恰当的数据类型，如整型的选择；\n- 对于强调快速读取的操作，可以考虑使⽤MyISAM数据库引擎；\n- 对较频繁的作为查询条件的字段创建索引；唯⼀性太差的字段不适合单独创建索引，即使频繁作为查询条件；更新⾮常频繁的字段不适合创建索引；\n- 编写SQL时使⽤上⾯的⽅式对SQL语句进⾏优化；\n- 使⽤慢查询⼯具找出效率低下的SQL语句进⾏优化；\n- 构建缓存，减少数据库磁盘操作；\n- 可以考虑结合使⽤内存型数据库，如Redis，进⾏混合存储。\n\n### 4  数据库存储过程与触发器\n\n存储过程：完成特定功能的SOL语句集\n\n触发器：对表进行（插入、删除、更新）触发一系列预定好的SQL语句\n\n### 5  [数据库设计](https://handout-1300728887.cos.ap-beijing.myqcloud.com/%E8%AE%B2%E4%B9%89/%E9%BB%91%E9%A9%AC%E5%A4%B4%E6%9D%A1%E9%A1%B9%E7%9B%AE%E8%AF%BE%E4%BB%B6/C02-Database/DatabaseDesign.html)\n\n库设计：\n\n1. 数据库名要明确\n2. 不同类型的数据分开管理\n\n表设计：\n\n1. 命名，业务表跟基础表区分，驼峰命名法\n2. 词性分析法，**名词体现表或字段，动词体现关系**\n   - 一对一、一对多、多对多\n3. 不要用物理删除，以防后悔\n4. 三范式：\n   - 字段不可分割、原子性\n   - 满足范式一，表有主键依赖\n   - 满足范式二，表非主字段之间没有依赖关系。\n5. 反范式：**利用冗余字段存储数据，节省数据查询的时间，本质是空间换时间。**\n6. 字段类型、是否允许为null、是否有默认值\n   - 整形：int长度并不影响精度，长度只和显示有关\n     - **存储范围相同**\n   - 字符串：char和varchar\n     - char不可变，查询效率高，可能造成存储浪费\n     - varchar可变，查询效率不如char，节省空间\n7. 索引设计\n   - 主键、外键、唯一约束；\n   - key/value，提高查询效率的字段；\n   - **外键：作用是维护数据的完整性。**\n     - 应用：在实际开发项目过程中，用不用外键？\n     - 建议：项目开发初期可以利用外键帮助维护数据的完整性，但是，项目的中后期，建议移除外键。\n8. 数据库引擎（MySQL的核心）的选择：决定数据存储和增删改查方式，争对表\n   - **InnoDB**（事务、安全能力）\n     1. **支持事务，安全性级别较高，查询效率相对较低。**\n     2. 为处理巨大数据量的最大性能设计\n     3. **InnoDB支持外键完整性约束**\n   - **MyISAM**（主要用来插入和查询）\n     1. **不支持事务，插入、查询效率较高，增删改效率较低。**\n     2. 产生三个文件（名字一表名字开始）：\n        1. frm：文件存储表定义\n        2. .MYD：数据文件\n        3. .MYI：索引文件\n   - **MEMORY**（存放临时数据）\n     1. 将表中数据存储到内存中，未查询和引用其他表数据提供快速访问\n\n#### 5.1  分库分表\n\n**垂直拆分**\n\n- 垂直分表：\"大表拆小表\"，基于列字段进行，将不常用，数据较大，长度较长拆分\n- 垂直分库：根据业务切分成不同的库\n\n**水平拆分**\n\n- 水平分表：针对数据量巨大的单张表， 按照某种规则（RANGE,HASH取模等），切分到多张表里面去,有IO瓶颈\n- 水平分库分表：将表数据切分到多个服务器上，分布式，有效解决瓶颈、突破IO\n\n**先垂直分在水平分**\n\n##### 分库分表后面临的问题\n\n- 事务支持\n- 多库结果集合并\n- 跨库join\n\n**分库分表方案产品中间件**：官方MySQL Fabric、阿里TDDL，Cobar、360Atlas\n\n### 6  where和having哪个执行更快\n\nSQL语句执行顺序：\n\n`from -> where -> group by -> having -> select -> order by`\n\n两者区别：\n\nwhere：是一个约束声明，结果返回之前起作用，不能使用聚合函数\n\nhaving：是一个过滤声明，过滤分组数据，只能用于group by，可以使用聚合函数","slug":"MySQL操作","published":1,"updated":"2020-09-30T07:12:17.546Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckfp5akf4000fn8jh48zqf762","content":"<h1 id=\"一、MySQL操作\"><a href=\"#一、MySQL操作\" class=\"headerlink\" title=\"一、MySQL操作\"></a>一、MySQL操作</h1><h1 id=\"二、SQL特性\"><a href=\"#二、SQL特性\" class=\"headerlink\" title=\"二、SQL特性\"></a>二、SQL特性</h1><h3 id=\"1-复制集与分布式\"><a href=\"#1-复制集与分布式\" class=\"headerlink\" title=\"1  复制集与分布式\"></a>1  <a href=\"https://handout-1300728887.cos.ap-beijing.myqcloud.com/%E8%AE%B2%E4%B9%89/%E9%BB%91%E9%A9%AC%E5%A4%B4%E6%9D%A1%E9%A1%B9%E7%9B%AE%E8%AF%BE%E4%BB%B6/C02-Database/DatabaseTheory.html\" target=\"_blank\" rel=\"noopener\">复制集与分布式</a></h3><ul>\n<li><p>复制集：</p>\n<ol>\n<li>数据库中数据相同，起到备份作用</li>\n<li>高可用</li>\n</ol>\n</li>\n<li><p>分布式：</p>\n<ol>\n<li>数据库中数据不同，共同组成完整的数据集合</li>\n<li>高吞吐</li>\n</ol>\n<a id=\"more\"></a>\n\n</li>\n</ul>\n<h3 id=\"2-主从复制\"><a href=\"#2-主从复制\" class=\"headerlink\" title=\"2  主从复制\"></a>2  主从复制</h3><ol>\n<li><p>主服务器的数据发生改变时，会将改变的记录写在本地二进制log日志中</p>\n</li>\n<li><p>从服务器的一个线程会把更新的数据拷贝中继log日志中</p>\n</li>\n<li><p>从服务器读取中继文件并执行，达到主从一致</p>\n<p><strong>利用主从在达到高可用的同时，也可以通过读写分离提供吞吐量。</strong> </p>\n</li>\n</ol>\n<h3 id=\"3-事务\"><a href=\"#3-事务\" class=\"headerlink\" title=\"3  事务\"></a>3  <a href=\"https://handout-1300728887.cos.ap-beijing.myqcloud.com/%E8%AE%B2%E4%B9%89/python-web%E5%9F%BA%E7%A1%80(5.1.2%E7%89%88%E6%9C%AC)/mysqlhigh/%E4%BA%8B%E5%8A%A1.html\" target=\"_blank\" rel=\"noopener\">事务</a></h3><ul>\n<li>四大特性：<ul>\n<li>原子性：强调事务中的多个操作时一个整体</li>\n<li>一致性：强调数据库中不会保存不一致状态</li>\n<li>隔离性：强调数据库中事务之间相互不可见</li>\n<li>持久性：强调数据库能永久保存数据，一旦提交就不可撤销</li>\n</ul>\n</li>\n<li>隔离级别：<ul>\n<li>读已提交：一个事务要等另一个事务提交后才能读取数据，可避免脏读的发生。</li>\n<li>读未提交：一个事务可以读取另一个未提交事务的数据，最低级别，任何情况都无法保证。</li>\n<li><strong>可重复读(MySQL默认)</strong>：就是在开始读取数据（事务开启）时，不再允许修改操作，可避免脏读、不可重复读的发生。</li>\n<li>串行化：最高的事务隔离级别，事务串行化顺序执行，可以避免脏读、不可重复读与幻读。效率抵消，耗性能</li>\n</ul>\n</li>\n</ul>\n<h1 id=\"二、Mysql优化\"><a href=\"#二、Mysql优化\" class=\"headerlink\" title=\"二、Mysql优化\"></a>二、Mysql优化</h1><h3 id=\"1-索引\"><a href=\"#1-索引\" class=\"headerlink\" title=\"1  索引\"></a>1  <a href=\"https://handout-1300728887.cos.ap-beijing.myqcloud.com/%E8%AE%B2%E4%B9%89/python-web%E5%9F%BA%E7%A1%80(5.1.2%E7%89%88%E6%9C%AC)/mysqlhigh/%E7%B4%A2%E5%BC%95.html\" target=\"_blank\" rel=\"noopener\">索引</a></h3><p>也叫“键”，保存数据库中所有记录的位置信息，相比于目录</p>\n<p>优点：加快查询速度</p>\n<p>缺点：耗费时间空间（不是越多越好）</p>\n<p><strong>优化</strong></p>\n<ol>\n<li>不是越多越好，而是需要自己合理的使用</li>\n</ol>\n<h3 id=\"2-sql语句优化\"><a href=\"#2-sql语句优化\" class=\"headerlink\" title=\"2  sql语句优化\"></a>2  <a href=\"https://handout-1300728887.cos.ap-beijing.myqcloud.com/%E8%AE%B2%E4%B9%89/%E9%BB%91%E9%A9%AC%E5%A4%B4%E6%9D%A1%E9%A1%B9%E7%9B%AE%E8%AF%BE%E4%BB%B6/C02-Database/DatabaseOptimize.html\" target=\"_blank\" rel=\"noopener\">sql语句优化</a></h3><ul>\n<li>1.避免全表扫描 </li>\n<li>2.查询时使⽤select明确指明所要查询的字段，避免使⽤ select * 的操作； </li>\n<li>3.SQL语句尽量⼤写 </li>\n<li>4.尽量避免在 where ⼦句中使⽤!=或&lt;&gt;操作符， </li>\n<li>5.遵循最左原则，在where⼦句中写查询条件时把索引字段放在前⾯ </li>\n<li>6.能使⽤关联查询解决的，尽量不要使⽤⼦查询 </li>\n<li>7.能不使⽤关联查询的尽量不要使⽤关联查询 </li>\n<li>8.不需要获取全表数据的时候，不要查询全表数据，使⽤LIMIT来限制数据 </li>\n</ul>\n<h3 id=\"3-数据库的优化\"><a href=\"#3-数据库的优化\" class=\"headerlink\" title=\"3  数据库的优化\"></a>3  数据库的优化</h3><ul>\n<li>在进⾏表设计时，可适度增加冗余字段(反范式设计)，减少JOIN操作；</li>\n<li>多字段表可以进⾏垂直分表优化，多数据表可以进⾏⽔平分表优化；</li>\n<li>选择恰当的数据类型，如整型的选择；</li>\n<li>对于强调快速读取的操作，可以考虑使⽤MyISAM数据库引擎；</li>\n<li>对较频繁的作为查询条件的字段创建索引；唯⼀性太差的字段不适合单独创建索引，即使频繁作为查询条件；更新⾮常频繁的字段不适合创建索引；</li>\n<li>编写SQL时使⽤上⾯的⽅式对SQL语句进⾏优化；</li>\n<li>使⽤慢查询⼯具找出效率低下的SQL语句进⾏优化；</li>\n<li>构建缓存，减少数据库磁盘操作；</li>\n<li>可以考虑结合使⽤内存型数据库，如Redis，进⾏混合存储。</li>\n</ul>\n<h3 id=\"4-数据库存储过程与触发器\"><a href=\"#4-数据库存储过程与触发器\" class=\"headerlink\" title=\"4  数据库存储过程与触发器\"></a>4  数据库存储过程与触发器</h3><p>存储过程：完成特定功能的SOL语句集</p>\n<p>触发器：对表进行（插入、删除、更新）触发一系列预定好的SQL语句</p>\n<h3 id=\"5-数据库设计\"><a href=\"#5-数据库设计\" class=\"headerlink\" title=\"5  数据库设计\"></a>5  <a href=\"https://handout-1300728887.cos.ap-beijing.myqcloud.com/%E8%AE%B2%E4%B9%89/%E9%BB%91%E9%A9%AC%E5%A4%B4%E6%9D%A1%E9%A1%B9%E7%9B%AE%E8%AF%BE%E4%BB%B6/C02-Database/DatabaseDesign.html\" target=\"_blank\" rel=\"noopener\">数据库设计</a></h3><p>库设计：</p>\n<ol>\n<li>数据库名要明确</li>\n<li>不同类型的数据分开管理</li>\n</ol>\n<p>表设计：</p>\n<ol>\n<li>命名，业务表跟基础表区分，驼峰命名法</li>\n<li>词性分析法，<strong>名词体现表或字段，动词体现关系</strong><ul>\n<li>一对一、一对多、多对多</li>\n</ul>\n</li>\n<li>不要用物理删除，以防后悔</li>\n<li>三范式：<ul>\n<li>字段不可分割、原子性</li>\n<li>满足范式一，表有主键依赖</li>\n<li>满足范式二，表非主字段之间没有依赖关系。</li>\n</ul>\n</li>\n<li>反范式：<strong>利用冗余字段存储数据，节省数据查询的时间，本质是空间换时间。</strong></li>\n<li>字段类型、是否允许为null、是否有默认值<ul>\n<li>整形：int长度并不影响精度，长度只和显示有关<ul>\n<li><strong>存储范围相同</strong></li>\n</ul>\n</li>\n<li>字符串：char和varchar<ul>\n<li>char不可变，查询效率高，可能造成存储浪费</li>\n<li>varchar可变，查询效率不如char，节省空间</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>索引设计<ul>\n<li>主键、外键、唯一约束；</li>\n<li>key/value，提高查询效率的字段；</li>\n<li><strong>外键：作用是维护数据的完整性。</strong><ul>\n<li>应用：在实际开发项目过程中，用不用外键？</li>\n<li>建议：项目开发初期可以利用外键帮助维护数据的完整性，但是，项目的中后期，建议移除外键。</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>数据库引擎（MySQL的核心）的选择：决定数据存储和增删改查方式，争对表<ul>\n<li><strong>InnoDB</strong>（事务、安全能力）<ol>\n<li><strong>支持事务，安全性级别较高，查询效率相对较低。</strong></li>\n<li>为处理巨大数据量的最大性能设计</li>\n<li><strong>InnoDB支持外键完整性约束</strong></li>\n</ol>\n</li>\n<li><strong>MyISAM</strong>（主要用来插入和查询）<ol>\n<li><strong>不支持事务，插入、查询效率较高，增删改效率较低。</strong></li>\n<li>产生三个文件（名字一表名字开始）：<ol>\n<li>frm：文件存储表定义</li>\n<li>.MYD：数据文件</li>\n<li>.MYI：索引文件</li>\n</ol>\n</li>\n</ol>\n</li>\n<li><strong>MEMORY</strong>（存放临时数据）<ol>\n<li>将表中数据存储到内存中，未查询和引用其他表数据提供快速访问</li>\n</ol>\n</li>\n</ul>\n</li>\n</ol>\n<h4 id=\"5-1-分库分表\"><a href=\"#5-1-分库分表\" class=\"headerlink\" title=\"5.1  分库分表\"></a>5.1  分库分表</h4><p><strong>垂直拆分</strong></p>\n<ul>\n<li>垂直分表：”大表拆小表”，基于列字段进行，将不常用，数据较大，长度较长拆分</li>\n<li>垂直分库：根据业务切分成不同的库</li>\n</ul>\n<p><strong>水平拆分</strong></p>\n<ul>\n<li>水平分表：针对数据量巨大的单张表， 按照某种规则（RANGE,HASH取模等），切分到多张表里面去,有IO瓶颈</li>\n<li>水平分库分表：将表数据切分到多个服务器上，分布式，有效解决瓶颈、突破IO</li>\n</ul>\n<p><strong>先垂直分在水平分</strong></p>\n<h5 id=\"分库分表后面临的问题\"><a href=\"#分库分表后面临的问题\" class=\"headerlink\" title=\"分库分表后面临的问题\"></a>分库分表后面临的问题</h5><ul>\n<li>事务支持</li>\n<li>多库结果集合并</li>\n<li>跨库join</li>\n</ul>\n<p><strong>分库分表方案产品中间件</strong>：官方MySQL Fabric、阿里TDDL，Cobar、360Atlas</p>\n<h3 id=\"6-where和having哪个执行更快\"><a href=\"#6-where和having哪个执行更快\" class=\"headerlink\" title=\"6  where和having哪个执行更快\"></a>6  where和having哪个执行更快</h3><p>SQL语句执行顺序：</p>\n<p><code>from -&gt; where -&gt; group by -&gt; having -&gt; select -&gt; order by</code></p>\n<p>两者区别：</p>\n<p>where：是一个约束声明，结果返回之前起作用，不能使用聚合函数</p>\n<p>having：是一个过滤声明，过滤分组数据，只能用于group by，可以使用聚合函数</p>\n","site":{"data":{}},"excerpt":"<h1 id=\"一、MySQL操作\"><a href=\"#一、MySQL操作\" class=\"headerlink\" title=\"一、MySQL操作\"></a>一、MySQL操作</h1><h1 id=\"二、SQL特性\"><a href=\"#二、SQL特性\" class=\"headerlink\" title=\"二、SQL特性\"></a>二、SQL特性</h1><h3 id=\"1-复制集与分布式\"><a href=\"#1-复制集与分布式\" class=\"headerlink\" title=\"1  复制集与分布式\"></a>1  <a href=\"https://handout-1300728887.cos.ap-beijing.myqcloud.com/%E8%AE%B2%E4%B9%89/%E9%BB%91%E9%A9%AC%E5%A4%B4%E6%9D%A1%E9%A1%B9%E7%9B%AE%E8%AF%BE%E4%BB%B6/C02-Database/DatabaseTheory.html\" target=\"_blank\" rel=\"noopener\">复制集与分布式</a></h3><ul>\n<li><p>复制集：</p>\n<ol>\n<li>数据库中数据相同，起到备份作用</li>\n<li>高可用</li>\n</ol>\n</li>\n<li><p>分布式：</p>\n<ol>\n<li>数据库中数据不同，共同组成完整的数据集合</li>\n<li>高吞吐</li>\n</ol>","more":"</li>\n</ul>\n<h3 id=\"2-主从复制\"><a href=\"#2-主从复制\" class=\"headerlink\" title=\"2  主从复制\"></a>2  主从复制</h3><ol>\n<li><p>主服务器的数据发生改变时，会将改变的记录写在本地二进制log日志中</p>\n</li>\n<li><p>从服务器的一个线程会把更新的数据拷贝中继log日志中</p>\n</li>\n<li><p>从服务器读取中继文件并执行，达到主从一致</p>\n<p><strong>利用主从在达到高可用的同时，也可以通过读写分离提供吞吐量。</strong> </p>\n</li>\n</ol>\n<h3 id=\"3-事务\"><a href=\"#3-事务\" class=\"headerlink\" title=\"3  事务\"></a>3  <a href=\"https://handout-1300728887.cos.ap-beijing.myqcloud.com/%E8%AE%B2%E4%B9%89/python-web%E5%9F%BA%E7%A1%80(5.1.2%E7%89%88%E6%9C%AC)/mysqlhigh/%E4%BA%8B%E5%8A%A1.html\" target=\"_blank\" rel=\"noopener\">事务</a></h3><ul>\n<li>四大特性：<ul>\n<li>原子性：强调事务中的多个操作时一个整体</li>\n<li>一致性：强调数据库中不会保存不一致状态</li>\n<li>隔离性：强调数据库中事务之间相互不可见</li>\n<li>持久性：强调数据库能永久保存数据，一旦提交就不可撤销</li>\n</ul>\n</li>\n<li>隔离级别：<ul>\n<li>读已提交：一个事务要等另一个事务提交后才能读取数据，可避免脏读的发生。</li>\n<li>读未提交：一个事务可以读取另一个未提交事务的数据，最低级别，任何情况都无法保证。</li>\n<li><strong>可重复读(MySQL默认)</strong>：就是在开始读取数据（事务开启）时，不再允许修改操作，可避免脏读、不可重复读的发生。</li>\n<li>串行化：最高的事务隔离级别，事务串行化顺序执行，可以避免脏读、不可重复读与幻读。效率抵消，耗性能</li>\n</ul>\n</li>\n</ul>\n<h1 id=\"二、Mysql优化\"><a href=\"#二、Mysql优化\" class=\"headerlink\" title=\"二、Mysql优化\"></a>二、Mysql优化</h1><h3 id=\"1-索引\"><a href=\"#1-索引\" class=\"headerlink\" title=\"1  索引\"></a>1  <a href=\"https://handout-1300728887.cos.ap-beijing.myqcloud.com/%E8%AE%B2%E4%B9%89/python-web%E5%9F%BA%E7%A1%80(5.1.2%E7%89%88%E6%9C%AC)/mysqlhigh/%E7%B4%A2%E5%BC%95.html\" target=\"_blank\" rel=\"noopener\">索引</a></h3><p>也叫“键”，保存数据库中所有记录的位置信息，相比于目录</p>\n<p>优点：加快查询速度</p>\n<p>缺点：耗费时间空间（不是越多越好）</p>\n<p><strong>优化</strong></p>\n<ol>\n<li>不是越多越好，而是需要自己合理的使用</li>\n</ol>\n<h3 id=\"2-sql语句优化\"><a href=\"#2-sql语句优化\" class=\"headerlink\" title=\"2  sql语句优化\"></a>2  <a href=\"https://handout-1300728887.cos.ap-beijing.myqcloud.com/%E8%AE%B2%E4%B9%89/%E9%BB%91%E9%A9%AC%E5%A4%B4%E6%9D%A1%E9%A1%B9%E7%9B%AE%E8%AF%BE%E4%BB%B6/C02-Database/DatabaseOptimize.html\" target=\"_blank\" rel=\"noopener\">sql语句优化</a></h3><ul>\n<li>1.避免全表扫描 </li>\n<li>2.查询时使⽤select明确指明所要查询的字段，避免使⽤ select * 的操作； </li>\n<li>3.SQL语句尽量⼤写 </li>\n<li>4.尽量避免在 where ⼦句中使⽤!=或&lt;&gt;操作符， </li>\n<li>5.遵循最左原则，在where⼦句中写查询条件时把索引字段放在前⾯ </li>\n<li>6.能使⽤关联查询解决的，尽量不要使⽤⼦查询 </li>\n<li>7.能不使⽤关联查询的尽量不要使⽤关联查询 </li>\n<li>8.不需要获取全表数据的时候，不要查询全表数据，使⽤LIMIT来限制数据 </li>\n</ul>\n<h3 id=\"3-数据库的优化\"><a href=\"#3-数据库的优化\" class=\"headerlink\" title=\"3  数据库的优化\"></a>3  数据库的优化</h3><ul>\n<li>在进⾏表设计时，可适度增加冗余字段(反范式设计)，减少JOIN操作；</li>\n<li>多字段表可以进⾏垂直分表优化，多数据表可以进⾏⽔平分表优化；</li>\n<li>选择恰当的数据类型，如整型的选择；</li>\n<li>对于强调快速读取的操作，可以考虑使⽤MyISAM数据库引擎；</li>\n<li>对较频繁的作为查询条件的字段创建索引；唯⼀性太差的字段不适合单独创建索引，即使频繁作为查询条件；更新⾮常频繁的字段不适合创建索引；</li>\n<li>编写SQL时使⽤上⾯的⽅式对SQL语句进⾏优化；</li>\n<li>使⽤慢查询⼯具找出效率低下的SQL语句进⾏优化；</li>\n<li>构建缓存，减少数据库磁盘操作；</li>\n<li>可以考虑结合使⽤内存型数据库，如Redis，进⾏混合存储。</li>\n</ul>\n<h3 id=\"4-数据库存储过程与触发器\"><a href=\"#4-数据库存储过程与触发器\" class=\"headerlink\" title=\"4  数据库存储过程与触发器\"></a>4  数据库存储过程与触发器</h3><p>存储过程：完成特定功能的SOL语句集</p>\n<p>触发器：对表进行（插入、删除、更新）触发一系列预定好的SQL语句</p>\n<h3 id=\"5-数据库设计\"><a href=\"#5-数据库设计\" class=\"headerlink\" title=\"5  数据库设计\"></a>5  <a href=\"https://handout-1300728887.cos.ap-beijing.myqcloud.com/%E8%AE%B2%E4%B9%89/%E9%BB%91%E9%A9%AC%E5%A4%B4%E6%9D%A1%E9%A1%B9%E7%9B%AE%E8%AF%BE%E4%BB%B6/C02-Database/DatabaseDesign.html\" target=\"_blank\" rel=\"noopener\">数据库设计</a></h3><p>库设计：</p>\n<ol>\n<li>数据库名要明确</li>\n<li>不同类型的数据分开管理</li>\n</ol>\n<p>表设计：</p>\n<ol>\n<li>命名，业务表跟基础表区分，驼峰命名法</li>\n<li>词性分析法，<strong>名词体现表或字段，动词体现关系</strong><ul>\n<li>一对一、一对多、多对多</li>\n</ul>\n</li>\n<li>不要用物理删除，以防后悔</li>\n<li>三范式：<ul>\n<li>字段不可分割、原子性</li>\n<li>满足范式一，表有主键依赖</li>\n<li>满足范式二，表非主字段之间没有依赖关系。</li>\n</ul>\n</li>\n<li>反范式：<strong>利用冗余字段存储数据，节省数据查询的时间，本质是空间换时间。</strong></li>\n<li>字段类型、是否允许为null、是否有默认值<ul>\n<li>整形：int长度并不影响精度，长度只和显示有关<ul>\n<li><strong>存储范围相同</strong></li>\n</ul>\n</li>\n<li>字符串：char和varchar<ul>\n<li>char不可变，查询效率高，可能造成存储浪费</li>\n<li>varchar可变，查询效率不如char，节省空间</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>索引设计<ul>\n<li>主键、外键、唯一约束；</li>\n<li>key/value，提高查询效率的字段；</li>\n<li><strong>外键：作用是维护数据的完整性。</strong><ul>\n<li>应用：在实际开发项目过程中，用不用外键？</li>\n<li>建议：项目开发初期可以利用外键帮助维护数据的完整性，但是，项目的中后期，建议移除外键。</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>数据库引擎（MySQL的核心）的选择：决定数据存储和增删改查方式，争对表<ul>\n<li><strong>InnoDB</strong>（事务、安全能力）<ol>\n<li><strong>支持事务，安全性级别较高，查询效率相对较低。</strong></li>\n<li>为处理巨大数据量的最大性能设计</li>\n<li><strong>InnoDB支持外键完整性约束</strong></li>\n</ol>\n</li>\n<li><strong>MyISAM</strong>（主要用来插入和查询）<ol>\n<li><strong>不支持事务，插入、查询效率较高，增删改效率较低。</strong></li>\n<li>产生三个文件（名字一表名字开始）：<ol>\n<li>frm：文件存储表定义</li>\n<li>.MYD：数据文件</li>\n<li>.MYI：索引文件</li>\n</ol>\n</li>\n</ol>\n</li>\n<li><strong>MEMORY</strong>（存放临时数据）<ol>\n<li>将表中数据存储到内存中，未查询和引用其他表数据提供快速访问</li>\n</ol>\n</li>\n</ul>\n</li>\n</ol>\n<h4 id=\"5-1-分库分表\"><a href=\"#5-1-分库分表\" class=\"headerlink\" title=\"5.1  分库分表\"></a>5.1  分库分表</h4><p><strong>垂直拆分</strong></p>\n<ul>\n<li>垂直分表：”大表拆小表”，基于列字段进行，将不常用，数据较大，长度较长拆分</li>\n<li>垂直分库：根据业务切分成不同的库</li>\n</ul>\n<p><strong>水平拆分</strong></p>\n<ul>\n<li>水平分表：针对数据量巨大的单张表， 按照某种规则（RANGE,HASH取模等），切分到多张表里面去,有IO瓶颈</li>\n<li>水平分库分表：将表数据切分到多个服务器上，分布式，有效解决瓶颈、突破IO</li>\n</ul>\n<p><strong>先垂直分在水平分</strong></p>\n<h5 id=\"分库分表后面临的问题\"><a href=\"#分库分表后面临的问题\" class=\"headerlink\" title=\"分库分表后面临的问题\"></a>分库分表后面临的问题</h5><ul>\n<li>事务支持</li>\n<li>多库结果集合并</li>\n<li>跨库join</li>\n</ul>\n<p><strong>分库分表方案产品中间件</strong>：官方MySQL Fabric、阿里TDDL，Cobar、360Atlas</p>\n<h3 id=\"6-where和having哪个执行更快\"><a href=\"#6-where和having哪个执行更快\" class=\"headerlink\" title=\"6  where和having哪个执行更快\"></a>6  where和having哪个执行更快</h3><p>SQL语句执行顺序：</p>\n<p><code>from -&gt; where -&gt; group by -&gt; having -&gt; select -&gt; order by</code></p>\n<p>两者区别：</p>\n<p>where：是一个约束声明，结果返回之前起作用，不能使用聚合函数</p>\n<p>having：是一个过滤声明，过滤分组数据，只能用于group by，可以使用聚合函数</p>"},{"title":"Redis操作","date":"2020-09-30T03:23:28.000Z","top":0,"_content":"\n# 一、Redis概括\n\n### 1  [Redis特点](https://handout-1300728887.cos.ap-beijing.myqcloud.com/%E8%AE%B2%E4%B9%89/%E9%BB%91%E9%A9%AC%E5%A4%B4%E6%9D%A1%E9%A1%B9%E7%9B%AE%E8%AF%BE%E4%BB%B6/C02-Database/Redis.html)\n\n1. 速度快：C语言实现，存储在内存中以键值对形式保存\n2. **持久化:**\n   \n   - redis可以将数据写入到磁盘中，在停机后，再次启动redis时，将磁盘中的备份数据加载到redis中\n   \n   - 两种机制：\n     \n     1. RDB快照持久化（默认开启）\n        - 将内存中的数据存入磁盘\n        - 缺点：一旦数据库出现问题，rdb文件数据不是全新的\n        \n        <!--more-->\n     2. AOF追加文件持久化\n        \n        - 文件会变大，自动压缩\n3. 多种数据结构：string  hash  list  set  zset\n4. 支持多种编程语言\n5. 支持事务、流水线、消息队列\n6. [主从复制](https://handout-1300728887.cos.ap-beijing.myqcloud.com/%E8%AE%B2%E4%B9%89/redis%E8%AE%B2%E4%B9%89/redis%E8%AE%B2%E4%B9%89/redis/da-jian-zhu-cong.html)\n7. 高可用、分布式\n\n### 2  redis宕机\n\n- slave从宕机\n\n  - 重启后会自动加入到主从架构中，完成数据同步\n\n- master主宕机（主从都没持久化）\n\n  1. 不要立马重启服务\n  2. slave执行`SLAVEOF ON ONE`断开主从关系并升级为主库\n  3. 重启主，`SLAVEOF`设为从\n\n  可使用简单方法：**哨兵**\n\n### 3  redis高可用\n\n**提供了主从同步＋哨兵机制（ Sentinel ）**\n\n- 哨兵机制：实现故障转移，当检测到主服务器发生故障时，把从服务器升级为主，保证数据正常使用\n  - 原理：心跳机制＋投票裁决＋故障转移\n    - 定时给master/slave发送消息，若指定时间内无响应（主观宕机 SDOWN）\n    - Sentinel群都报告某一master无响应（客观宕机 SDOWN）\n    - 通过一定vote算法，将从升为主\n\n### 4  为什么Redis比MySQL快\n\n|            |     Redis      |          MySQL           |\n| :--------: | :------------: | :----------------------: |\n|  数据格式  |      k-v       |          B+TREE          |\n| 时间复杂度 | 0(1)（常数阶） |    0(logn)（对数阶）     |\n|  存储位置  | 从内存直接取出 | 磁盘表（全局扫或索引查） |\n\nRedis是单线程的多路复用IO，单线程避免线程切换开销；多路复用避免IO等待开销；多核处理器下对数据进行分区，各处理器处理不同的数据（分着干）\n\n# 二、Redis缓存\n\n### 1  有效期TTL（Time to live）\n\n- 作用：\n  - 节省空间\n  - 做到数据有效性，失效后，做到数据一致性\n\n#### 1.1  过期策略\n\n- 定时过期：时间一到立即清除，对内存友好，但会占用大量CPU资源\n- 惰性过期：当访问时才去判断是否过期，节省CPU，占用内存\n- 定期过期：每隔一段时间，随机清除\n\n **Redis中同时使用了惰性过期和定期过期两种过期策略。** \n\n#### 1.2  缓存淘汰 （eviction）\n\n-  LRU（Least recently used，最近最少使用）\n   -  新数据插入到表头部\n   -  缓存命中时，将其移到头部\n   -  缓存满的时候将尾部的数据丢掉\n-  LFU（Least Frequently Used 最近最少使用算法）\n   -  如果数据在一段时间内使用次数很少，那么将来也会很少\n\n### 2  缓存模式\n\n- **先更新数据库，再删除缓存** \n\n#### 2.1  缓存穿透\n\n- 频繁请求缓存中不存在的数据，增大数据库压力\n\n  - 解决方案：\n    1. 返回缓存伪造数据\n    2. 限制请求参数\n    3. 借助第三方过滤器：布隆过滤器...\n\n- 布隆过滤器\n\n  本质上是一种**概率型数据结构， 由一个很长的bit数组和一系列哈希函数组成的 **\n\n  特点：**高效地插入和查询**\n\n  算法的核心： **某样东西一定不存在或者可能存在**\n\n  缺点：**数据只能插入不能删除**\n\n  - 存储原理：经过多次不同维度的hash计算，将数据映射到二进制向量里\n  - 服务流程：\n    1. 当用户访问时，去布隆过滤器中判断key值是否存在，否则直接返回\n    2. 如果key值存在，则访问redis，由于存在误判率，redis中也可能不存在\n    3. 再访问数据库，若也不存在，直接返回空\n\n![](https://img-blog.csdnimg.cn/20190306043938625.?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0lUX3Rvd25sZXQ=,size_16,color_FFFFFF,t_70)\n\n#### 2.2  缓存雪崩\n\n- 同一时间内，大量缓存失效，造成数据库压力剧增\n  - 解决方案：\n    1. 设置不同的有效期值\n    2. 采用多级缓存\n    3. 利用加锁或者队列\n\n# 三、Redis操作\n\n## 1. 键操作\n\n键的判断和操作方法\n\n| 方法               | 作用                                         | 参数说明                   | 示例                             | 示例说明                     | 示例结果  |\n| ------------------ | -------------------------------------------- | -------------------------- | -------------------------------- | ---------------------------- | --------- |\n| exists(name)       | 判断一个键是否存在                           | name：键名                 | redis.exists('name')             | 是否存在name这个键           | True      |\n| delete(name)       | 删除一个键                                   | name：键名                 | redis.delete('name')             | 删除name这个键               | 1         |\n| type(name)         | 判断键类型                                   | name：键名                 | redis.type('name')               | 判断name这个键类型           | b'string' |\n| keys(pattern)      | 获取所有符合规则的键                         | pattern：匹配规则          | redis.keys('n*')                 | 获取所有以n开头的键          | [b'name'] |\n| randomkey()        | 获取随机的一个键                             |                            | randomkey()                      | 获取随机的一个键             | b'name'   |\n| rename(src, dst)   | 重命名键                                     | src：原键名；dst：新键名   | redis.rename('name', 'nickname') | 将name重命名为nickname       | True      |\n| dbsize()           | 获取当前数据库中键的数目                     |                            | dbsize()                         | 获取当前数据库中键的数目     | 100       |\n| expire(name, time) | 设定键的过期时间，单位为秒                   | name：键名；time：秒数     | redis.expire('name', 2)          | 将name键的过期时间设置为2秒  | True      |\n| ttl(name)          | 获取键的过期时间，单位为秒，-1表示永久不过期 | name：键名                 | redis.ttl('name')                | 获取name这个键的过期时间     | -1        |\n| move(name, db)     | 将键移动到其他数据库                         | name：键名；db：数据库代号 | move('name', 2)                  | 将name移动到2号数据库        | True      |\n| flushdb()          | 删除当前选择数据库中的所有键                 |                            | flushdb()                        | 删除当前选择数据库中的所有键 | True      |\n| flushall()         | 删除所有数据库中的所有键                     |                            | flushall()                       | 删除所有数据库中的所有键     | True      |\n\n## 2. 字符串操作\n\nRedis支持最基本的键值对形式存储，用法总结如下表所示。\n\n| 方法                          | 作用                                                         | 参数说明                                                     | 示例                                                         | 示例说明                                         | 示例结果                                    |\n| ----------------------------- | ------------------------------------------------------------ | ------------------------------------------------------------ | ------------------------------------------------------------ | ------------------------------------------------ | ------------------------------------------- |\n| set(name, value)              | 给数据库中键为name的string赋予值value                        | name: 键名；value: 值                                        | redis.set('name', 'Bob')                                     | 给name这个键的value赋值为Bob                     | True                                        |\n| get(name)                     | 返回数据库中键为name的string的value                          | name：键名                                                   | redis.get('name')                                            | 返回name这个键的value                            | b'Bob'                                      |\n| getset(name, value)           | 给数据库中键为name的string赋予值value并返回上次的value       | name：键名；value：新值                                      | redis.getset('name', 'Mike')                                 | 赋值name为Mike并得到上次的value                  | b'Bob'                                      |\n| mget(keys, *args)             | 返回多个键对应的value                                        | keys：键的列表                                               | redis.mget(['name', 'nickname'])                             | 返回name和nickname的value                        | [b'Mike', b'Miker']                         |\n| setnx(name, value)            | 如果不存在这个键值对，则更新value，否则不变                  | name：键名                                                   | redis.setnx('newname', 'James')                              | 如果newname这个键不存在，则设置值为James         | 第一次运行结果是True，第二次运行结果是False |\n| setex(name, time, value)      | 设置可以对应的值为string类型的value，并指定此键值对应的有效期 | name: 键名；time: 有效期； value：值                         | redis.setex('name', 1, 'James')                              | 将name这个键的值设为James，有效期为1秒           | True                                        |\n| setrange(name, offset, value) | 设置指定键的value值的子字符串                                | name：键名；offset：偏移量；value：值                        | redis.set('name', 'Hello') redis.setrange('name', 6, 'World') | 设置name为Hello字符串，并在index为6的位置补World | 11，修改后的字符串长度                      |\n| mset(mapping)                 | 批量赋值                                                     | mapping：字典                                                | redis.mset({'name1': 'Durant', 'name2': 'James'})            | 将name1设为Durant，name2设为James                | True                                        |\n| msetnx(mapping)               | 键均不存在时才批量赋值                                       | mapping：字典                                                | redis.msetnx({'name3': 'Smith', 'name4': 'Curry'})           | 在name3和name4均不存在的情况下才设置二者值       | True                                        |\n| incr(name, amount=1)          | 键为name的value增值操作，默认为1，键不存在则被创建并设为amount | name：键名；amount：增长的值                                 | redis.incr('age', 1)                                         | age对应的值增1，若不存在，则会创建并设置为1      | 1，即修改后的值                             |\n| decr(name, amount=1)          | 键为name的value减值操作，默认为1，键不存在则被创建并将value设置为-amount | name：键名； amount：减少的值                                | redis.decr('age', 1)                                         | age对应的值减1，若不存在，则会创建并设置为-1     | -1，即修改后的值                            |\n| append(key, value)            | 键为name的string的值附加value                                | key：键名                                                    | redis.append('nickname', 'OK')                               | 向键为nickname的值后追加OK                       | 13，即修改后的字符串长度                    |\n| substr(name, start, end=-1)   | 返回键为name的string的子串                                   | name：键名；start：起始索引；end：终止索引，默认为-1，表示截取到末尾 | redis.substr('name', 1, 4)                                   | 返回键为name的值的字符串，截取索引为1~4的字符    | b'ello'                                     |\n| getrange(key, start, end)     | 获取键的value值从start到end的子字符串                        | key：键名；start：起始索引；end：终止索引                    | redis.getrange('name', 1, 4)                                 | 返回键为name的值的字符串，截取索引为1~4的字符    | b'ello'                                     |\n\n## 3. 列表操作\n\nRedis还提供了列表存储，列表内的元素可以重复，而且可以从两端存储，用法如下表所示。\n\n| 方法                     | 作用                                                         | 参数说明                                          | 示例                             | 示例说明                                                     | 示例结果           |\n| ------------------------ | ------------------------------------------------------------ | ------------------------------------------------- | -------------------------------- | ------------------------------------------------------------ | ------------------ |\n| rpush(name, *values)     | 在键为name的列表末尾添加值为value的元素，可以传多个          | name：键名；values：值                            | redis.rpush('list', 1, 2, 3)     | 向键为list的列表尾添加1、2、3                                | 3，列表大小        |\n| lpush(name, *values)     | 在键为name的列表头添加值为value的元素，可以传多个            | name：键名；values：值                            | redis.lpush('list', 0)           | 向键为list的列表头部添加0                                    | 4，列表大小        |\n| llen(name)               | 返回键为name的列表的长度                                     | name：键名                                        | redis.llen('list')               | 返回键为list的列表的长度                                     | 4                  |\n| lrange(name, start, end) | 返回键为name的列表中start至end之间的元素                     | name：键名；start：起始索引；end：终止索引        | redis.lrange('list', 1, 3)       | 返回起始索引为1终止索引为3的索引范围对应的列表               | [b'3', b'2', b'1'] |\n| ltrim(name, start, end)  | 截取键为name的列表，保留索引为start到end的内容               | name：键名；start：起始索引；end：终止索引        | ltrim('list', 1, 3)              | 保留键为list的索引为1到3的元素                               | True               |\n| lindex(name, index)      | 返回键为name的列表中index位置的元素                          | name：键名；index：索引                           | redis.lindex('list', 1)          | 返回键为list的列表索引为1的元素                              | b’2’               |\n| lset(name, index, value) | 给键为name的列表中index位置的元素赋值，越界则报错            | name：键名；index：索引位置；value：值            | redis.lset('list', 1, 5)         | 将键为list的列表中索引为1的位置赋值为5                       | True               |\n| lrem(name, count, value) | 删除count个键的列表中值为value的元素                         | name：键名；count：删除个数；value：值            | redis.lrem('list', 2, 3)         | 将键为list的列表删除两个3                                    | 1，即删除的个数    |\n| lpop(name)               | 返回并删除键为name的列表中的首元素                           | name：键名                                        | redis.lpop('list')               | 返回并删除名为list的列表中的第一个元素                       | b'5'               |\n| rpop(name)               | 返回并删除键为name的列表中的尾元素                           | name：键名                                        | redis.rpop('list')               | 返回并删除名为list的列表中的最后一个元素                     | b'2'               |\n| blpop(keys, timeout=0)   | 返回并删除名称在keys中的list中的首个元素，如果列表为空，则会一直阻塞等待 | keys：键列表；timeout： 超时等待时间，0为一直等待 | redis.blpop('list')              | 返回并删除键为list的列表中的第一个元素                       | [b'5']             |\n| brpop(keys, timeout=0)   | 返回并删除键为name的列表中的尾元素，如果list为空，则会一直阻塞等待 | keys：键列表；timeout：超时等待时间，0为一直等待  | redis.brpop('list')              | 返回并删除名为list的列表中的最后一个元素                     | [b'2']             |\n| rpoplpush(src, dst)      | 返回并删除名称为src的列表的尾元素，并将该元素添加到名称为dst的列表头部 | src：源列表的键；dst：目标列表的key               | redis.rpoplpush('list', 'list2') | 将键为list的列表尾元素删除并将其添加到键为list2的列表头部，然后返回 | b'2'               |\n\n## 4. 集合操作\n\nRedis还提供了集合存储，集合中的元素都是不重复的，用法如下表所示。\n\n| 方法                           | 作用                                                 | 参数说明                                  | 示例                                           | 示例说明                                                    | 示例结果                     |\n| ------------------------------ | ---------------------------------------------------- | ----------------------------------------- | ---------------------------------------------- | ----------------------------------------------------------- | ---------------------------- |\n| sadd(name, *values)            | 向键为name的集合中添加元素                           | name：键名；values：值，可为多个          | redis.sadd('tags', 'Book', 'Tea', 'Coffee')    | 向键为tags的集合中添加Book、Tea和Coffee这3个内容            | 3，即插入的数据个数          |\n| srem(name, *values)            | 从键为name的集合中删除元素                           | name：键名；values：值，可为多个          | redis.srem('tags', 'Book')                     | 从键为tags的集合中删除Book                                  | 1，即删除的数据个数          |\n| spop(name)                     | 随机返回并删除键为name的集合中的一个元素             | name：键名                                | redis.spop('tags')                             | 从键为tags的集合中随机删除并返回该元素                      | b'Tea'                       |\n| smove(src, dst, value)         | 从src对应的集合中移除元素并将其添加到dst对应的集合中 | src：源集合；dst：目标集合；value：元素值 | redis.smove('tags', 'tags2', 'Coffee')         | 从键为tags的集合中删除元素Coffee并将其添加到键为tags2的集合 | True                         |\n| scard(name)                    | 返回键为name的集合的元素个数                         | name：键名                                | redis.scard('tags')                            | 获取键为tags的集合中的元素个数                              | 3                            |\n| sismember(name, value)         | 测试member是否是键为name的集合的元素                 | name：键值                                | redis.sismember('tags', 'Book')                | 判断Book是否是键为tags的集合元素                            | True                         |\n| sinter(keys, *args)            | 返回所有给定键的集合的交集                           | keys：键列表                              | redis.sinter(['tags', 'tags2'])                | 返回键为tags的集合和键为tags2的集合的交集                   | {b'Coffee'}                  |\n| sinterstore(dest, keys, *args) | 求交集并将交集保存到dest的集合                       | dest：结果集合；keys：键列表              | redis.sinterstore('inttag', ['tags', 'tags2']) | 求键为tags的集合和键为tags2的集合的交集并将其保存为inttag   | 1                            |\n| sunion(keys, *args)            | 返回所有给定键的集合的并集                           | keys：键列表                              | redis.sunion(['tags', 'tags2'])                | 返回键为tags的集合和键为tags2的集合的并集                   | {b'Coffee', b'Book', b'Pen'} |\n| sunionstore(dest, keys, *args) | 求并集并将并集保存到dest的集合                       | dest：结果集合；keys：键列表              | redis.sunionstore('inttag', ['tags', 'tags2']) | 求键为tags的集合和键为tags2的集合的并集并将其保存为inttag   | 3                            |\n| sdiff(keys, *args)             | 返回所有给定键的集合的差集                           | keys：键列表                              | redis.sdiff(['tags', 'tags2'])                 | 返回键为tags的集合和键为tags2的集合的差集                   | {b'Book', b'Pen'}            |\n| sdiffstore(dest, keys, *args)  | 求差集并将差集保存到dest集合                         | dest：结果集合；keys：键列表              | redis.sdiffstore('inttag', ['tags', 'tags2'])  | 求键为tags的集合和键为tags2的集合的差集并将其保存为inttag`  | 3                            |\n| smembers(name)                 | 返回键为name的集合的所有元素                         | name：键名                                | redis.smembers('tags')                         | 返回键为tags的集合的所有元素                                | {b'Pen', b'Book', b'Coffee'} |\n| srandmember(name)              | 随机返回键为name的集合中的一个元素，但不删除元素     | name：键值                                | redis.srandmember('tags')                      | 随机返回键为tags的集合中的一个元素                          |                              |\n\n## 5. 有序集合操作\n\n有序集合比集合多了一个分数字段，利用它可以对集合中的数据进行排序，其用法总结如下表所示。\n\n| 方法                                                         | 作用                                                         | 参数说明                                                     | 示例                                        | 示例说明                                                     | 示例结果                            |\n| ------------------------------------------------------------ | ------------------------------------------------------------ | ------------------------------------------------------------ | ------------------------------------------- | ------------------------------------------------------------ | ----------------------------------- |\n| zadd(name, *args, **kwargs)                                  | 向键为name的zset中添加元素member，score用于排序。如果该元素存在，则更新其顺序 | name： 键名；args：可变参数                                  | redis.zadd('grade', 100, 'Bob', 98, 'Mike') | 向键为grade的zset中添加Bob（其score为100），并添加Mike（其score为98） | 2，即添加的元素个数                 |\n| zrem(name, *values)                                          | 删除键为name的zset中的元素                                   | name：键名；values：元素                                     | redis.zrem('grade', 'Mike')                 | 从键为grade的zset中删除Mike                                  | 1，即删除的元素个数                 |\n| zincrby(name, value, amount=1)                               | 如果在键为name的zset中已经存在元素value，则将该元素的score增加amount；否则向该集合中添加该元素，其score的值为amount | name：key名；value：元素；amount：增长的score值              | redis.zincrby('grade', 'Bob', -2)           | 键为grade的zset中Bob的score减2                               | 98.0，即修改后的值                  |\n| zrank(name, value)                                           | 返回键为name的zset中元素的排名，按score从小到大排序，即名次  | name：键名；value：元素值                                    | redis.zrank('grade', 'Amy')                 | 得到键为grade的zset中Amy的排名                               | 1                                   |\n| zrevrank(name, value)                                        | 返回键为name的zset中元素的倒数排名（按score从大到小排序），即名次 | name：键名；value：元素值                                    | redis.zrevrank('grade', 'Amy')              | 得到键为grade的zset中Amy的倒数排名                           | 2                                   |\n| zrevrange(name, start, end, withscores=False)                | 返回键为name的zset（按score从大到小排序）中index从start到end的所有元素 | name：键值；start：开始索引；end：结束索引；withscores：是否带score | redis.zrevrange('grade', 0, 3)              | 返回键为grade的zset中前四名元素                              | [b'Bob', b'Mike', b'Amy', b'James'] |\n| zrangebyscore(name, min, max, start=None, num=None, withscores=False) | 返回键为name的zset中score在给定区间的元素                    | name：键名；min：最低score；max：最高score； start：起始索引；num：个数；withscores：是否带score | redis.zrangebyscore('grade', 80, 95)        | 返回键为grade的zset中score在80和95之间的元素                 | [b'Bob', b'Mike', b'Amy', b'James'] |\n| zcount(name, min, max)                                       | 返回键为name的zset中score在给定区间的数量                    | name：键名；min：最低score；max：最高score                   | redis.zcount('grade', 80, 95)               | 返回键为grade的zset中score在80到95的元素个数                 | 2                                   |\n| zcard(name)                                                  | 返回键为name的zset的元素个数                                 | name：键名                                                   | redis.zcard('grade')                        | 获取键为grade的zset中元素的个数                              | 3                                   |\n| zremrangebyrank(name, min, max)                              | 删除键为name的zset中排名在给定区间的元素                     | name：键名；min：最低位次；max：最高位次                     | redis.zremrangebyrank('grade', 0, 0)        | 删除键为grade的zset中排名第一的元素                          | 1，即删除的元素个数                 |\n| zremrangebyscore(name, min, max)                             | 删除键为name的zset中score在给定区间的元素                    | name：键名；min：最低score；max：最高score                   | redis.zremrangebyscore('grade', 80, 90)     | 删除score在80到90之间的元素                                  | 1，即删除的元素个数                 |\n\n## 6. 散列操作\n\nRedis还提供了散列表的数据结构，我们可以用`name`指定一个散列表的名称，表内存储了各个键值对，用法总结如下表所示。\n\n| 方法                         | 作用                                               | 参数说明                                   | 示例                                           | 示例说明                                       | 示例结果                                                     |\n| ---------------------------- | -------------------------------------------------- | ------------------------------------------ | ---------------------------------------------- | ---------------------------------------------- | ------------------------------------------------------------ |\n| hset(name, key, value)       | 向键为name的散列表中添加映射                       | name：键名；key：映射键名；value：映射键值 | hset('price', 'cake', 5)                       | 向键为price的散列表中添加映射关系，cake的值为5 | 1，即添加的映射个数                                          |\n| hsetnx(name, key, value)     | 如果映射键名不存在，则向键为name的散列表中添加映射 | name：键名；key：映射键名；value：映射键值 | hsetnx('price', 'book', 6)                     | 向键为price的散列表中添加映射关系，book的值为6 | 1，即添加的映射个数                                          |\n| hget(name, key)              | 返回键为name的散列表中key对应的值                  | name：键名；key：映射键名                  | redis.hget('price', 'cake')                    | 获取键为price的散列表中键名为cake的值          | 5                                                            |\n| hmget(name, keys, *args)     | 返回键为name的散列表中各个键对应的值               | name：键名；keys：映射键名列表             | redis.hmget('price', ['apple', 'orange'])      | 获取键为price的散列表中apple和orange的值       | [b'3', b'7']                                                 |\n| hmset(name, mapping)         | 向键为name的散列表中批量添加映射                   | name：键名；mapping：映射字典              | redis.hmset('price', {'banana': 2, 'pear': 6}) | 向键为price的散列表中批量添加映射              | True                                                         |\n| hincrby(name, key, amount=1) | 将键为name的散列表中映射的值增加amount             | name：键名；key：映射键名；amount：增长量  | redis.hincrby('price', 'apple', 3)             | key为price的散列表中apple的值增加3             | 6，修改后的值                                                |\n| hexists(name, key)           | 键为name的散列表中是否存在键名为键的映射           | name：键名；key：映射键名                  | redis.hexists('price', 'banana')               | 键为price的散列表中banana的值是否存在          | True                                                         |\n| hdel(name, *keys)            | 在键为name的散列表中，删除键名为键的映射           | name：键名；keys：映射键名                 | redis.hdel('price', 'banana')                  | 从键为price的散列表中删除键名为banana的映射    | True                                                         |\n| hlen(name)                   | 从键为name的散列表中获取映射个数                   | name： 键名                                | redis.hlen('price')                            | 从键为price的散列表中获取映射个数              | 6                                                            |\n| hkeys(name)                  | 从键为name的散列表中获取所有映射键名               | name：键名                                 | redis.hkeys('price')                           | 从键为price的散列表中获取所有映射键名          | [b'cake', b'book', b'banana', b'pear']                       |\n| hvals(name)                  | 从键为name的散列表中获取所有映射键值               | name：键名                                 | redis.hvals('price')                           | 从键为price的散列表中获取所有映射键值          | [b'5', b'6', b'2', b'6']                                     |\n| hgetall(name)                | 从键为name的散列表中获取所有映射键值对             | name：键名                                 | redis.hgetall('price')                         | 从键为price的散列表中获取所有映射键值对        | {b'cake': b'5', b'book': b'6', b'orange': b'7', b'pear': b'6'} |\n\n> 具体操作参考官方文档：\n>\n> 1. http://doc.redisfans.com/\n> 2. http://redis.cn/","source":"_posts/Redis操作.md","raw":"---\ntitle: Redis操作\ndate: 2020-09-30 11:23:28\ntags: NoSQL\ntop: 0\n---\n\n# 一、Redis概括\n\n### 1  [Redis特点](https://handout-1300728887.cos.ap-beijing.myqcloud.com/%E8%AE%B2%E4%B9%89/%E9%BB%91%E9%A9%AC%E5%A4%B4%E6%9D%A1%E9%A1%B9%E7%9B%AE%E8%AF%BE%E4%BB%B6/C02-Database/Redis.html)\n\n1. 速度快：C语言实现，存储在内存中以键值对形式保存\n2. **持久化:**\n   \n   - redis可以将数据写入到磁盘中，在停机后，再次启动redis时，将磁盘中的备份数据加载到redis中\n   \n   - 两种机制：\n     \n     1. RDB快照持久化（默认开启）\n        - 将内存中的数据存入磁盘\n        - 缺点：一旦数据库出现问题，rdb文件数据不是全新的\n        \n        <!--more-->\n     2. AOF追加文件持久化\n        \n        - 文件会变大，自动压缩\n3. 多种数据结构：string  hash  list  set  zset\n4. 支持多种编程语言\n5. 支持事务、流水线、消息队列\n6. [主从复制](https://handout-1300728887.cos.ap-beijing.myqcloud.com/%E8%AE%B2%E4%B9%89/redis%E8%AE%B2%E4%B9%89/redis%E8%AE%B2%E4%B9%89/redis/da-jian-zhu-cong.html)\n7. 高可用、分布式\n\n### 2  redis宕机\n\n- slave从宕机\n\n  - 重启后会自动加入到主从架构中，完成数据同步\n\n- master主宕机（主从都没持久化）\n\n  1. 不要立马重启服务\n  2. slave执行`SLAVEOF ON ONE`断开主从关系并升级为主库\n  3. 重启主，`SLAVEOF`设为从\n\n  可使用简单方法：**哨兵**\n\n### 3  redis高可用\n\n**提供了主从同步＋哨兵机制（ Sentinel ）**\n\n- 哨兵机制：实现故障转移，当检测到主服务器发生故障时，把从服务器升级为主，保证数据正常使用\n  - 原理：心跳机制＋投票裁决＋故障转移\n    - 定时给master/slave发送消息，若指定时间内无响应（主观宕机 SDOWN）\n    - Sentinel群都报告某一master无响应（客观宕机 SDOWN）\n    - 通过一定vote算法，将从升为主\n\n### 4  为什么Redis比MySQL快\n\n|            |     Redis      |          MySQL           |\n| :--------: | :------------: | :----------------------: |\n|  数据格式  |      k-v       |          B+TREE          |\n| 时间复杂度 | 0(1)（常数阶） |    0(logn)（对数阶）     |\n|  存储位置  | 从内存直接取出 | 磁盘表（全局扫或索引查） |\n\nRedis是单线程的多路复用IO，单线程避免线程切换开销；多路复用避免IO等待开销；多核处理器下对数据进行分区，各处理器处理不同的数据（分着干）\n\n# 二、Redis缓存\n\n### 1  有效期TTL（Time to live）\n\n- 作用：\n  - 节省空间\n  - 做到数据有效性，失效后，做到数据一致性\n\n#### 1.1  过期策略\n\n- 定时过期：时间一到立即清除，对内存友好，但会占用大量CPU资源\n- 惰性过期：当访问时才去判断是否过期，节省CPU，占用内存\n- 定期过期：每隔一段时间，随机清除\n\n **Redis中同时使用了惰性过期和定期过期两种过期策略。** \n\n#### 1.2  缓存淘汰 （eviction）\n\n-  LRU（Least recently used，最近最少使用）\n   -  新数据插入到表头部\n   -  缓存命中时，将其移到头部\n   -  缓存满的时候将尾部的数据丢掉\n-  LFU（Least Frequently Used 最近最少使用算法）\n   -  如果数据在一段时间内使用次数很少，那么将来也会很少\n\n### 2  缓存模式\n\n- **先更新数据库，再删除缓存** \n\n#### 2.1  缓存穿透\n\n- 频繁请求缓存中不存在的数据，增大数据库压力\n\n  - 解决方案：\n    1. 返回缓存伪造数据\n    2. 限制请求参数\n    3. 借助第三方过滤器：布隆过滤器...\n\n- 布隆过滤器\n\n  本质上是一种**概率型数据结构， 由一个很长的bit数组和一系列哈希函数组成的 **\n\n  特点：**高效地插入和查询**\n\n  算法的核心： **某样东西一定不存在或者可能存在**\n\n  缺点：**数据只能插入不能删除**\n\n  - 存储原理：经过多次不同维度的hash计算，将数据映射到二进制向量里\n  - 服务流程：\n    1. 当用户访问时，去布隆过滤器中判断key值是否存在，否则直接返回\n    2. 如果key值存在，则访问redis，由于存在误判率，redis中也可能不存在\n    3. 再访问数据库，若也不存在，直接返回空\n\n![](https://img-blog.csdnimg.cn/20190306043938625.?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0lUX3Rvd25sZXQ=,size_16,color_FFFFFF,t_70)\n\n#### 2.2  缓存雪崩\n\n- 同一时间内，大量缓存失效，造成数据库压力剧增\n  - 解决方案：\n    1. 设置不同的有效期值\n    2. 采用多级缓存\n    3. 利用加锁或者队列\n\n# 三、Redis操作\n\n## 1. 键操作\n\n键的判断和操作方法\n\n| 方法               | 作用                                         | 参数说明                   | 示例                             | 示例说明                     | 示例结果  |\n| ------------------ | -------------------------------------------- | -------------------------- | -------------------------------- | ---------------------------- | --------- |\n| exists(name)       | 判断一个键是否存在                           | name：键名                 | redis.exists('name')             | 是否存在name这个键           | True      |\n| delete(name)       | 删除一个键                                   | name：键名                 | redis.delete('name')             | 删除name这个键               | 1         |\n| type(name)         | 判断键类型                                   | name：键名                 | redis.type('name')               | 判断name这个键类型           | b'string' |\n| keys(pattern)      | 获取所有符合规则的键                         | pattern：匹配规则          | redis.keys('n*')                 | 获取所有以n开头的键          | [b'name'] |\n| randomkey()        | 获取随机的一个键                             |                            | randomkey()                      | 获取随机的一个键             | b'name'   |\n| rename(src, dst)   | 重命名键                                     | src：原键名；dst：新键名   | redis.rename('name', 'nickname') | 将name重命名为nickname       | True      |\n| dbsize()           | 获取当前数据库中键的数目                     |                            | dbsize()                         | 获取当前数据库中键的数目     | 100       |\n| expire(name, time) | 设定键的过期时间，单位为秒                   | name：键名；time：秒数     | redis.expire('name', 2)          | 将name键的过期时间设置为2秒  | True      |\n| ttl(name)          | 获取键的过期时间，单位为秒，-1表示永久不过期 | name：键名                 | redis.ttl('name')                | 获取name这个键的过期时间     | -1        |\n| move(name, db)     | 将键移动到其他数据库                         | name：键名；db：数据库代号 | move('name', 2)                  | 将name移动到2号数据库        | True      |\n| flushdb()          | 删除当前选择数据库中的所有键                 |                            | flushdb()                        | 删除当前选择数据库中的所有键 | True      |\n| flushall()         | 删除所有数据库中的所有键                     |                            | flushall()                       | 删除所有数据库中的所有键     | True      |\n\n## 2. 字符串操作\n\nRedis支持最基本的键值对形式存储，用法总结如下表所示。\n\n| 方法                          | 作用                                                         | 参数说明                                                     | 示例                                                         | 示例说明                                         | 示例结果                                    |\n| ----------------------------- | ------------------------------------------------------------ | ------------------------------------------------------------ | ------------------------------------------------------------ | ------------------------------------------------ | ------------------------------------------- |\n| set(name, value)              | 给数据库中键为name的string赋予值value                        | name: 键名；value: 值                                        | redis.set('name', 'Bob')                                     | 给name这个键的value赋值为Bob                     | True                                        |\n| get(name)                     | 返回数据库中键为name的string的value                          | name：键名                                                   | redis.get('name')                                            | 返回name这个键的value                            | b'Bob'                                      |\n| getset(name, value)           | 给数据库中键为name的string赋予值value并返回上次的value       | name：键名；value：新值                                      | redis.getset('name', 'Mike')                                 | 赋值name为Mike并得到上次的value                  | b'Bob'                                      |\n| mget(keys, *args)             | 返回多个键对应的value                                        | keys：键的列表                                               | redis.mget(['name', 'nickname'])                             | 返回name和nickname的value                        | [b'Mike', b'Miker']                         |\n| setnx(name, value)            | 如果不存在这个键值对，则更新value，否则不变                  | name：键名                                                   | redis.setnx('newname', 'James')                              | 如果newname这个键不存在，则设置值为James         | 第一次运行结果是True，第二次运行结果是False |\n| setex(name, time, value)      | 设置可以对应的值为string类型的value，并指定此键值对应的有效期 | name: 键名；time: 有效期； value：值                         | redis.setex('name', 1, 'James')                              | 将name这个键的值设为James，有效期为1秒           | True                                        |\n| setrange(name, offset, value) | 设置指定键的value值的子字符串                                | name：键名；offset：偏移量；value：值                        | redis.set('name', 'Hello') redis.setrange('name', 6, 'World') | 设置name为Hello字符串，并在index为6的位置补World | 11，修改后的字符串长度                      |\n| mset(mapping)                 | 批量赋值                                                     | mapping：字典                                                | redis.mset({'name1': 'Durant', 'name2': 'James'})            | 将name1设为Durant，name2设为James                | True                                        |\n| msetnx(mapping)               | 键均不存在时才批量赋值                                       | mapping：字典                                                | redis.msetnx({'name3': 'Smith', 'name4': 'Curry'})           | 在name3和name4均不存在的情况下才设置二者值       | True                                        |\n| incr(name, amount=1)          | 键为name的value增值操作，默认为1，键不存在则被创建并设为amount | name：键名；amount：增长的值                                 | redis.incr('age', 1)                                         | age对应的值增1，若不存在，则会创建并设置为1      | 1，即修改后的值                             |\n| decr(name, amount=1)          | 键为name的value减值操作，默认为1，键不存在则被创建并将value设置为-amount | name：键名； amount：减少的值                                | redis.decr('age', 1)                                         | age对应的值减1，若不存在，则会创建并设置为-1     | -1，即修改后的值                            |\n| append(key, value)            | 键为name的string的值附加value                                | key：键名                                                    | redis.append('nickname', 'OK')                               | 向键为nickname的值后追加OK                       | 13，即修改后的字符串长度                    |\n| substr(name, start, end=-1)   | 返回键为name的string的子串                                   | name：键名；start：起始索引；end：终止索引，默认为-1，表示截取到末尾 | redis.substr('name', 1, 4)                                   | 返回键为name的值的字符串，截取索引为1~4的字符    | b'ello'                                     |\n| getrange(key, start, end)     | 获取键的value值从start到end的子字符串                        | key：键名；start：起始索引；end：终止索引                    | redis.getrange('name', 1, 4)                                 | 返回键为name的值的字符串，截取索引为1~4的字符    | b'ello'                                     |\n\n## 3. 列表操作\n\nRedis还提供了列表存储，列表内的元素可以重复，而且可以从两端存储，用法如下表所示。\n\n| 方法                     | 作用                                                         | 参数说明                                          | 示例                             | 示例说明                                                     | 示例结果           |\n| ------------------------ | ------------------------------------------------------------ | ------------------------------------------------- | -------------------------------- | ------------------------------------------------------------ | ------------------ |\n| rpush(name, *values)     | 在键为name的列表末尾添加值为value的元素，可以传多个          | name：键名；values：值                            | redis.rpush('list', 1, 2, 3)     | 向键为list的列表尾添加1、2、3                                | 3，列表大小        |\n| lpush(name, *values)     | 在键为name的列表头添加值为value的元素，可以传多个            | name：键名；values：值                            | redis.lpush('list', 0)           | 向键为list的列表头部添加0                                    | 4，列表大小        |\n| llen(name)               | 返回键为name的列表的长度                                     | name：键名                                        | redis.llen('list')               | 返回键为list的列表的长度                                     | 4                  |\n| lrange(name, start, end) | 返回键为name的列表中start至end之间的元素                     | name：键名；start：起始索引；end：终止索引        | redis.lrange('list', 1, 3)       | 返回起始索引为1终止索引为3的索引范围对应的列表               | [b'3', b'2', b'1'] |\n| ltrim(name, start, end)  | 截取键为name的列表，保留索引为start到end的内容               | name：键名；start：起始索引；end：终止索引        | ltrim('list', 1, 3)              | 保留键为list的索引为1到3的元素                               | True               |\n| lindex(name, index)      | 返回键为name的列表中index位置的元素                          | name：键名；index：索引                           | redis.lindex('list', 1)          | 返回键为list的列表索引为1的元素                              | b’2’               |\n| lset(name, index, value) | 给键为name的列表中index位置的元素赋值，越界则报错            | name：键名；index：索引位置；value：值            | redis.lset('list', 1, 5)         | 将键为list的列表中索引为1的位置赋值为5                       | True               |\n| lrem(name, count, value) | 删除count个键的列表中值为value的元素                         | name：键名；count：删除个数；value：值            | redis.lrem('list', 2, 3)         | 将键为list的列表删除两个3                                    | 1，即删除的个数    |\n| lpop(name)               | 返回并删除键为name的列表中的首元素                           | name：键名                                        | redis.lpop('list')               | 返回并删除名为list的列表中的第一个元素                       | b'5'               |\n| rpop(name)               | 返回并删除键为name的列表中的尾元素                           | name：键名                                        | redis.rpop('list')               | 返回并删除名为list的列表中的最后一个元素                     | b'2'               |\n| blpop(keys, timeout=0)   | 返回并删除名称在keys中的list中的首个元素，如果列表为空，则会一直阻塞等待 | keys：键列表；timeout： 超时等待时间，0为一直等待 | redis.blpop('list')              | 返回并删除键为list的列表中的第一个元素                       | [b'5']             |\n| brpop(keys, timeout=0)   | 返回并删除键为name的列表中的尾元素，如果list为空，则会一直阻塞等待 | keys：键列表；timeout：超时等待时间，0为一直等待  | redis.brpop('list')              | 返回并删除名为list的列表中的最后一个元素                     | [b'2']             |\n| rpoplpush(src, dst)      | 返回并删除名称为src的列表的尾元素，并将该元素添加到名称为dst的列表头部 | src：源列表的键；dst：目标列表的key               | redis.rpoplpush('list', 'list2') | 将键为list的列表尾元素删除并将其添加到键为list2的列表头部，然后返回 | b'2'               |\n\n## 4. 集合操作\n\nRedis还提供了集合存储，集合中的元素都是不重复的，用法如下表所示。\n\n| 方法                           | 作用                                                 | 参数说明                                  | 示例                                           | 示例说明                                                    | 示例结果                     |\n| ------------------------------ | ---------------------------------------------------- | ----------------------------------------- | ---------------------------------------------- | ----------------------------------------------------------- | ---------------------------- |\n| sadd(name, *values)            | 向键为name的集合中添加元素                           | name：键名；values：值，可为多个          | redis.sadd('tags', 'Book', 'Tea', 'Coffee')    | 向键为tags的集合中添加Book、Tea和Coffee这3个内容            | 3，即插入的数据个数          |\n| srem(name, *values)            | 从键为name的集合中删除元素                           | name：键名；values：值，可为多个          | redis.srem('tags', 'Book')                     | 从键为tags的集合中删除Book                                  | 1，即删除的数据个数          |\n| spop(name)                     | 随机返回并删除键为name的集合中的一个元素             | name：键名                                | redis.spop('tags')                             | 从键为tags的集合中随机删除并返回该元素                      | b'Tea'                       |\n| smove(src, dst, value)         | 从src对应的集合中移除元素并将其添加到dst对应的集合中 | src：源集合；dst：目标集合；value：元素值 | redis.smove('tags', 'tags2', 'Coffee')         | 从键为tags的集合中删除元素Coffee并将其添加到键为tags2的集合 | True                         |\n| scard(name)                    | 返回键为name的集合的元素个数                         | name：键名                                | redis.scard('tags')                            | 获取键为tags的集合中的元素个数                              | 3                            |\n| sismember(name, value)         | 测试member是否是键为name的集合的元素                 | name：键值                                | redis.sismember('tags', 'Book')                | 判断Book是否是键为tags的集合元素                            | True                         |\n| sinter(keys, *args)            | 返回所有给定键的集合的交集                           | keys：键列表                              | redis.sinter(['tags', 'tags2'])                | 返回键为tags的集合和键为tags2的集合的交集                   | {b'Coffee'}                  |\n| sinterstore(dest, keys, *args) | 求交集并将交集保存到dest的集合                       | dest：结果集合；keys：键列表              | redis.sinterstore('inttag', ['tags', 'tags2']) | 求键为tags的集合和键为tags2的集合的交集并将其保存为inttag   | 1                            |\n| sunion(keys, *args)            | 返回所有给定键的集合的并集                           | keys：键列表                              | redis.sunion(['tags', 'tags2'])                | 返回键为tags的集合和键为tags2的集合的并集                   | {b'Coffee', b'Book', b'Pen'} |\n| sunionstore(dest, keys, *args) | 求并集并将并集保存到dest的集合                       | dest：结果集合；keys：键列表              | redis.sunionstore('inttag', ['tags', 'tags2']) | 求键为tags的集合和键为tags2的集合的并集并将其保存为inttag   | 3                            |\n| sdiff(keys, *args)             | 返回所有给定键的集合的差集                           | keys：键列表                              | redis.sdiff(['tags', 'tags2'])                 | 返回键为tags的集合和键为tags2的集合的差集                   | {b'Book', b'Pen'}            |\n| sdiffstore(dest, keys, *args)  | 求差集并将差集保存到dest集合                         | dest：结果集合；keys：键列表              | redis.sdiffstore('inttag', ['tags', 'tags2'])  | 求键为tags的集合和键为tags2的集合的差集并将其保存为inttag`  | 3                            |\n| smembers(name)                 | 返回键为name的集合的所有元素                         | name：键名                                | redis.smembers('tags')                         | 返回键为tags的集合的所有元素                                | {b'Pen', b'Book', b'Coffee'} |\n| srandmember(name)              | 随机返回键为name的集合中的一个元素，但不删除元素     | name：键值                                | redis.srandmember('tags')                      | 随机返回键为tags的集合中的一个元素                          |                              |\n\n## 5. 有序集合操作\n\n有序集合比集合多了一个分数字段，利用它可以对集合中的数据进行排序，其用法总结如下表所示。\n\n| 方法                                                         | 作用                                                         | 参数说明                                                     | 示例                                        | 示例说明                                                     | 示例结果                            |\n| ------------------------------------------------------------ | ------------------------------------------------------------ | ------------------------------------------------------------ | ------------------------------------------- | ------------------------------------------------------------ | ----------------------------------- |\n| zadd(name, *args, **kwargs)                                  | 向键为name的zset中添加元素member，score用于排序。如果该元素存在，则更新其顺序 | name： 键名；args：可变参数                                  | redis.zadd('grade', 100, 'Bob', 98, 'Mike') | 向键为grade的zset中添加Bob（其score为100），并添加Mike（其score为98） | 2，即添加的元素个数                 |\n| zrem(name, *values)                                          | 删除键为name的zset中的元素                                   | name：键名；values：元素                                     | redis.zrem('grade', 'Mike')                 | 从键为grade的zset中删除Mike                                  | 1，即删除的元素个数                 |\n| zincrby(name, value, amount=1)                               | 如果在键为name的zset中已经存在元素value，则将该元素的score增加amount；否则向该集合中添加该元素，其score的值为amount | name：key名；value：元素；amount：增长的score值              | redis.zincrby('grade', 'Bob', -2)           | 键为grade的zset中Bob的score减2                               | 98.0，即修改后的值                  |\n| zrank(name, value)                                           | 返回键为name的zset中元素的排名，按score从小到大排序，即名次  | name：键名；value：元素值                                    | redis.zrank('grade', 'Amy')                 | 得到键为grade的zset中Amy的排名                               | 1                                   |\n| zrevrank(name, value)                                        | 返回键为name的zset中元素的倒数排名（按score从大到小排序），即名次 | name：键名；value：元素值                                    | redis.zrevrank('grade', 'Amy')              | 得到键为grade的zset中Amy的倒数排名                           | 2                                   |\n| zrevrange(name, start, end, withscores=False)                | 返回键为name的zset（按score从大到小排序）中index从start到end的所有元素 | name：键值；start：开始索引；end：结束索引；withscores：是否带score | redis.zrevrange('grade', 0, 3)              | 返回键为grade的zset中前四名元素                              | [b'Bob', b'Mike', b'Amy', b'James'] |\n| zrangebyscore(name, min, max, start=None, num=None, withscores=False) | 返回键为name的zset中score在给定区间的元素                    | name：键名；min：最低score；max：最高score； start：起始索引；num：个数；withscores：是否带score | redis.zrangebyscore('grade', 80, 95)        | 返回键为grade的zset中score在80和95之间的元素                 | [b'Bob', b'Mike', b'Amy', b'James'] |\n| zcount(name, min, max)                                       | 返回键为name的zset中score在给定区间的数量                    | name：键名；min：最低score；max：最高score                   | redis.zcount('grade', 80, 95)               | 返回键为grade的zset中score在80到95的元素个数                 | 2                                   |\n| zcard(name)                                                  | 返回键为name的zset的元素个数                                 | name：键名                                                   | redis.zcard('grade')                        | 获取键为grade的zset中元素的个数                              | 3                                   |\n| zremrangebyrank(name, min, max)                              | 删除键为name的zset中排名在给定区间的元素                     | name：键名；min：最低位次；max：最高位次                     | redis.zremrangebyrank('grade', 0, 0)        | 删除键为grade的zset中排名第一的元素                          | 1，即删除的元素个数                 |\n| zremrangebyscore(name, min, max)                             | 删除键为name的zset中score在给定区间的元素                    | name：键名；min：最低score；max：最高score                   | redis.zremrangebyscore('grade', 80, 90)     | 删除score在80到90之间的元素                                  | 1，即删除的元素个数                 |\n\n## 6. 散列操作\n\nRedis还提供了散列表的数据结构，我们可以用`name`指定一个散列表的名称，表内存储了各个键值对，用法总结如下表所示。\n\n| 方法                         | 作用                                               | 参数说明                                   | 示例                                           | 示例说明                                       | 示例结果                                                     |\n| ---------------------------- | -------------------------------------------------- | ------------------------------------------ | ---------------------------------------------- | ---------------------------------------------- | ------------------------------------------------------------ |\n| hset(name, key, value)       | 向键为name的散列表中添加映射                       | name：键名；key：映射键名；value：映射键值 | hset('price', 'cake', 5)                       | 向键为price的散列表中添加映射关系，cake的值为5 | 1，即添加的映射个数                                          |\n| hsetnx(name, key, value)     | 如果映射键名不存在，则向键为name的散列表中添加映射 | name：键名；key：映射键名；value：映射键值 | hsetnx('price', 'book', 6)                     | 向键为price的散列表中添加映射关系，book的值为6 | 1，即添加的映射个数                                          |\n| hget(name, key)              | 返回键为name的散列表中key对应的值                  | name：键名；key：映射键名                  | redis.hget('price', 'cake')                    | 获取键为price的散列表中键名为cake的值          | 5                                                            |\n| hmget(name, keys, *args)     | 返回键为name的散列表中各个键对应的值               | name：键名；keys：映射键名列表             | redis.hmget('price', ['apple', 'orange'])      | 获取键为price的散列表中apple和orange的值       | [b'3', b'7']                                                 |\n| hmset(name, mapping)         | 向键为name的散列表中批量添加映射                   | name：键名；mapping：映射字典              | redis.hmset('price', {'banana': 2, 'pear': 6}) | 向键为price的散列表中批量添加映射              | True                                                         |\n| hincrby(name, key, amount=1) | 将键为name的散列表中映射的值增加amount             | name：键名；key：映射键名；amount：增长量  | redis.hincrby('price', 'apple', 3)             | key为price的散列表中apple的值增加3             | 6，修改后的值                                                |\n| hexists(name, key)           | 键为name的散列表中是否存在键名为键的映射           | name：键名；key：映射键名                  | redis.hexists('price', 'banana')               | 键为price的散列表中banana的值是否存在          | True                                                         |\n| hdel(name, *keys)            | 在键为name的散列表中，删除键名为键的映射           | name：键名；keys：映射键名                 | redis.hdel('price', 'banana')                  | 从键为price的散列表中删除键名为banana的映射    | True                                                         |\n| hlen(name)                   | 从键为name的散列表中获取映射个数                   | name： 键名                                | redis.hlen('price')                            | 从键为price的散列表中获取映射个数              | 6                                                            |\n| hkeys(name)                  | 从键为name的散列表中获取所有映射键名               | name：键名                                 | redis.hkeys('price')                           | 从键为price的散列表中获取所有映射键名          | [b'cake', b'book', b'banana', b'pear']                       |\n| hvals(name)                  | 从键为name的散列表中获取所有映射键值               | name：键名                                 | redis.hvals('price')                           | 从键为price的散列表中获取所有映射键值          | [b'5', b'6', b'2', b'6']                                     |\n| hgetall(name)                | 从键为name的散列表中获取所有映射键值对             | name：键名                                 | redis.hgetall('price')                         | 从键为price的散列表中获取所有映射键值对        | {b'cake': b'5', b'book': b'6', b'orange': b'7', b'pear': b'6'} |\n\n> 具体操作参考官方文档：\n>\n> 1. http://doc.redisfans.com/\n> 2. http://redis.cn/","slug":"Redis操作","published":1,"updated":"2020-09-30T07:45:33.652Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckfp5akfe000in8jhh8b893n3","content":"<h1 id=\"一、Redis概括\"><a href=\"#一、Redis概括\" class=\"headerlink\" title=\"一、Redis概括\"></a>一、Redis概括</h1><h3 id=\"1-Redis特点\"><a href=\"#1-Redis特点\" class=\"headerlink\" title=\"1  Redis特点\"></a>1  <a href=\"https://handout-1300728887.cos.ap-beijing.myqcloud.com/%E8%AE%B2%E4%B9%89/%E9%BB%91%E9%A9%AC%E5%A4%B4%E6%9D%A1%E9%A1%B9%E7%9B%AE%E8%AF%BE%E4%BB%B6/C02-Database/Redis.html\" target=\"_blank\" rel=\"noopener\">Redis特点</a></h3><ol>\n<li><p>速度快：C语言实现，存储在内存中以键值对形式保存</p>\n</li>\n<li><p><strong>持久化:</strong></p>\n<ul>\n<li><p>redis可以将数据写入到磁盘中，在停机后，再次启动redis时，将磁盘中的备份数据加载到redis中</p>\n</li>\n<li><p>两种机制：</p>\n<ol>\n<li><p>RDB快照持久化（默认开启）</p>\n<ul>\n<li>将内存中的数据存入磁盘</li>\n<li>缺点：一旦数据库出现问题，rdb文件数据不是全新的</li>\n</ul>\n<a id=\"more\"></a></li>\n<li><p>AOF追加文件持久化</p>\n<ul>\n<li>文件会变大，自动压缩</li>\n</ul>\n</li>\n</ol>\n</li>\n</ul>\n</li>\n<li><p>多种数据结构：string  hash  list  set  zset</p>\n</li>\n<li><p>支持多种编程语言</p>\n</li>\n<li><p>支持事务、流水线、消息队列</p>\n</li>\n<li><p><a href=\"https://handout-1300728887.cos.ap-beijing.myqcloud.com/%E8%AE%B2%E4%B9%89/redis%E8%AE%B2%E4%B9%89/redis%E8%AE%B2%E4%B9%89/redis/da-jian-zhu-cong.html\" target=\"_blank\" rel=\"noopener\">主从复制</a></p>\n</li>\n<li><p>高可用、分布式</p>\n</li>\n</ol>\n<h3 id=\"2-redis宕机\"><a href=\"#2-redis宕机\" class=\"headerlink\" title=\"2  redis宕机\"></a>2  redis宕机</h3><ul>\n<li><p>slave从宕机</p>\n<ul>\n<li>重启后会自动加入到主从架构中，完成数据同步</li>\n</ul>\n</li>\n<li><p>master主宕机（主从都没持久化）</p>\n<ol>\n<li>不要立马重启服务</li>\n<li>slave执行<code>SLAVEOF ON ONE</code>断开主从关系并升级为主库</li>\n<li>重启主，<code>SLAVEOF</code>设为从</li>\n</ol>\n<p>可使用简单方法：<strong>哨兵</strong></p>\n</li>\n</ul>\n<h3 id=\"3-redis高可用\"><a href=\"#3-redis高可用\" class=\"headerlink\" title=\"3  redis高可用\"></a>3  redis高可用</h3><p><strong>提供了主从同步＋哨兵机制（ Sentinel ）</strong></p>\n<ul>\n<li>哨兵机制：实现故障转移，当检测到主服务器发生故障时，把从服务器升级为主，保证数据正常使用<ul>\n<li>原理：心跳机制＋投票裁决＋故障转移<ul>\n<li>定时给master/slave发送消息，若指定时间内无响应（主观宕机 SDOWN）</li>\n<li>Sentinel群都报告某一master无响应（客观宕机 SDOWN）</li>\n<li>通过一定vote算法，将从升为主</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"4-为什么Redis比MySQL快\"><a href=\"#4-为什么Redis比MySQL快\" class=\"headerlink\" title=\"4  为什么Redis比MySQL快\"></a>4  为什么Redis比MySQL快</h3><table>\n<thead>\n<tr>\n<th align=\"center\"></th>\n<th align=\"center\">Redis</th>\n<th align=\"center\">MySQL</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\">数据格式</td>\n<td align=\"center\">k-v</td>\n<td align=\"center\">B+TREE</td>\n</tr>\n<tr>\n<td align=\"center\">时间复杂度</td>\n<td align=\"center\">0(1)（常数阶）</td>\n<td align=\"center\">0(logn)（对数阶）</td>\n</tr>\n<tr>\n<td align=\"center\">存储位置</td>\n<td align=\"center\">从内存直接取出</td>\n<td align=\"center\">磁盘表（全局扫或索引查）</td>\n</tr>\n</tbody></table>\n<p>Redis是单线程的多路复用IO，单线程避免线程切换开销；多路复用避免IO等待开销；多核处理器下对数据进行分区，各处理器处理不同的数据（分着干）</p>\n<h1 id=\"二、Redis缓存\"><a href=\"#二、Redis缓存\" class=\"headerlink\" title=\"二、Redis缓存\"></a>二、Redis缓存</h1><h3 id=\"1-有效期TTL（Time-to-live）\"><a href=\"#1-有效期TTL（Time-to-live）\" class=\"headerlink\" title=\"1  有效期TTL（Time to live）\"></a>1  有效期TTL（Time to live）</h3><ul>\n<li>作用：<ul>\n<li>节省空间</li>\n<li>做到数据有效性，失效后，做到数据一致性</li>\n</ul>\n</li>\n</ul>\n<h4 id=\"1-1-过期策略\"><a href=\"#1-1-过期策略\" class=\"headerlink\" title=\"1.1  过期策略\"></a>1.1  过期策略</h4><ul>\n<li><p>定时过期：时间一到立即清除，对内存友好，但会占用大量CPU资源</p>\n</li>\n<li><p>惰性过期：当访问时才去判断是否过期，节省CPU，占用内存</p>\n</li>\n<li><p>定期过期：每隔一段时间，随机清除</p>\n<p><strong>Redis中同时使用了惰性过期和定期过期两种过期策略。</strong> </p>\n</li>\n</ul>\n<h4 id=\"1-2-缓存淘汰-（eviction）\"><a href=\"#1-2-缓存淘汰-（eviction）\" class=\"headerlink\" title=\"1.2  缓存淘汰 （eviction）\"></a>1.2  缓存淘汰 （eviction）</h4><ul>\n<li>LRU（Least recently used，最近最少使用）<ul>\n<li>新数据插入到表头部</li>\n<li>缓存命中时，将其移到头部</li>\n<li>缓存满的时候将尾部的数据丢掉</li>\n</ul>\n</li>\n<li>LFU（Least Frequently Used 最近最少使用算法）<ul>\n<li>如果数据在一段时间内使用次数很少，那么将来也会很少</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"2-缓存模式\"><a href=\"#2-缓存模式\" class=\"headerlink\" title=\"2  缓存模式\"></a>2  缓存模式</h3><ul>\n<li><strong>先更新数据库，再删除缓存</strong> </li>\n</ul>\n<h4 id=\"2-1-缓存穿透\"><a href=\"#2-1-缓存穿透\" class=\"headerlink\" title=\"2.1  缓存穿透\"></a>2.1  缓存穿透</h4><ul>\n<li><p>频繁请求缓存中不存在的数据，增大数据库压力</p>\n<ul>\n<li>解决方案：<ol>\n<li>返回缓存伪造数据</li>\n<li>限制请求参数</li>\n<li>借助第三方过滤器：布隆过滤器…</li>\n</ol>\n</li>\n</ul>\n</li>\n<li><p>布隆过滤器</p>\n<p>本质上是一种*<em>概率型数据结构， 由一个很长的bit数组和一系列哈希函数组成的 *</em></p>\n<p>特点：<strong>高效地插入和查询</strong></p>\n<p>算法的核心： <strong>某样东西一定不存在或者可能存在</strong></p>\n<p>缺点：<strong>数据只能插入不能删除</strong></p>\n<ul>\n<li>存储原理：经过多次不同维度的hash计算，将数据映射到二进制向量里</li>\n<li>服务流程：<ol>\n<li>当用户访问时，去布隆过滤器中判断key值是否存在，否则直接返回</li>\n<li>如果key值存在，则访问redis，由于存在误判率，redis中也可能不存在</li>\n<li>再访问数据库，若也不存在，直接返回空</li>\n</ol>\n</li>\n</ul>\n</li>\n</ul>\n<p><img src=\"https://img-blog.csdnimg.cn/20190306043938625.?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0lUX3Rvd25sZXQ=,size_16,color_FFFFFF,t_70\" alt=\"\"></p>\n<h4 id=\"2-2-缓存雪崩\"><a href=\"#2-2-缓存雪崩\" class=\"headerlink\" title=\"2.2  缓存雪崩\"></a>2.2  缓存雪崩</h4><ul>\n<li>同一时间内，大量缓存失效，造成数据库压力剧增<ul>\n<li>解决方案：<ol>\n<li>设置不同的有效期值</li>\n<li>采用多级缓存</li>\n<li>利用加锁或者队列</li>\n</ol>\n</li>\n</ul>\n</li>\n</ul>\n<h1 id=\"三、Redis操作\"><a href=\"#三、Redis操作\" class=\"headerlink\" title=\"三、Redis操作\"></a>三、Redis操作</h1><h2 id=\"1-键操作\"><a href=\"#1-键操作\" class=\"headerlink\" title=\"1. 键操作\"></a>1. 键操作</h2><p>键的判断和操作方法</p>\n<table>\n<thead>\n<tr>\n<th>方法</th>\n<th>作用</th>\n<th>参数说明</th>\n<th>示例</th>\n<th>示例说明</th>\n<th>示例结果</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>exists(name)</td>\n<td>判断一个键是否存在</td>\n<td>name：键名</td>\n<td>redis.exists(‘name’)</td>\n<td>是否存在name这个键</td>\n<td>True</td>\n</tr>\n<tr>\n<td>delete(name)</td>\n<td>删除一个键</td>\n<td>name：键名</td>\n<td>redis.delete(‘name’)</td>\n<td>删除name这个键</td>\n<td>1</td>\n</tr>\n<tr>\n<td>type(name)</td>\n<td>判断键类型</td>\n<td>name：键名</td>\n<td>redis.type(‘name’)</td>\n<td>判断name这个键类型</td>\n<td>b’string’</td>\n</tr>\n<tr>\n<td>keys(pattern)</td>\n<td>获取所有符合规则的键</td>\n<td>pattern：匹配规则</td>\n<td>redis.keys(‘n*’)</td>\n<td>获取所有以n开头的键</td>\n<td>[b’name’]</td>\n</tr>\n<tr>\n<td>randomkey()</td>\n<td>获取随机的一个键</td>\n<td></td>\n<td>randomkey()</td>\n<td>获取随机的一个键</td>\n<td>b’name’</td>\n</tr>\n<tr>\n<td>rename(src, dst)</td>\n<td>重命名键</td>\n<td>src：原键名；dst：新键名</td>\n<td>redis.rename(‘name’, ‘nickname’)</td>\n<td>将name重命名为nickname</td>\n<td>True</td>\n</tr>\n<tr>\n<td>dbsize()</td>\n<td>获取当前数据库中键的数目</td>\n<td></td>\n<td>dbsize()</td>\n<td>获取当前数据库中键的数目</td>\n<td>100</td>\n</tr>\n<tr>\n<td>expire(name, time)</td>\n<td>设定键的过期时间，单位为秒</td>\n<td>name：键名；time：秒数</td>\n<td>redis.expire(‘name’, 2)</td>\n<td>将name键的过期时间设置为2秒</td>\n<td>True</td>\n</tr>\n<tr>\n<td>ttl(name)</td>\n<td>获取键的过期时间，单位为秒，-1表示永久不过期</td>\n<td>name：键名</td>\n<td>redis.ttl(‘name’)</td>\n<td>获取name这个键的过期时间</td>\n<td>-1</td>\n</tr>\n<tr>\n<td>move(name, db)</td>\n<td>将键移动到其他数据库</td>\n<td>name：键名；db：数据库代号</td>\n<td>move(‘name’, 2)</td>\n<td>将name移动到2号数据库</td>\n<td>True</td>\n</tr>\n<tr>\n<td>flushdb()</td>\n<td>删除当前选择数据库中的所有键</td>\n<td></td>\n<td>flushdb()</td>\n<td>删除当前选择数据库中的所有键</td>\n<td>True</td>\n</tr>\n<tr>\n<td>flushall()</td>\n<td>删除所有数据库中的所有键</td>\n<td></td>\n<td>flushall()</td>\n<td>删除所有数据库中的所有键</td>\n<td>True</td>\n</tr>\n</tbody></table>\n<h2 id=\"2-字符串操作\"><a href=\"#2-字符串操作\" class=\"headerlink\" title=\"2. 字符串操作\"></a>2. 字符串操作</h2><p>Redis支持最基本的键值对形式存储，用法总结如下表所示。</p>\n<table>\n<thead>\n<tr>\n<th>方法</th>\n<th>作用</th>\n<th>参数说明</th>\n<th>示例</th>\n<th>示例说明</th>\n<th>示例结果</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>set(name, value)</td>\n<td>给数据库中键为name的string赋予值value</td>\n<td>name: 键名；value: 值</td>\n<td>redis.set(‘name’, ‘Bob’)</td>\n<td>给name这个键的value赋值为Bob</td>\n<td>True</td>\n</tr>\n<tr>\n<td>get(name)</td>\n<td>返回数据库中键为name的string的value</td>\n<td>name：键名</td>\n<td>redis.get(‘name’)</td>\n<td>返回name这个键的value</td>\n<td>b’Bob’</td>\n</tr>\n<tr>\n<td>getset(name, value)</td>\n<td>给数据库中键为name的string赋予值value并返回上次的value</td>\n<td>name：键名；value：新值</td>\n<td>redis.getset(‘name’, ‘Mike’)</td>\n<td>赋值name为Mike并得到上次的value</td>\n<td>b’Bob’</td>\n</tr>\n<tr>\n<td>mget(keys, *args)</td>\n<td>返回多个键对应的value</td>\n<td>keys：键的列表</td>\n<td>redis.mget([‘name’, ‘nickname’])</td>\n<td>返回name和nickname的value</td>\n<td>[b’Mike’, b’Miker’]</td>\n</tr>\n<tr>\n<td>setnx(name, value)</td>\n<td>如果不存在这个键值对，则更新value，否则不变</td>\n<td>name：键名</td>\n<td>redis.setnx(‘newname’, ‘James’)</td>\n<td>如果newname这个键不存在，则设置值为James</td>\n<td>第一次运行结果是True，第二次运行结果是False</td>\n</tr>\n<tr>\n<td>setex(name, time, value)</td>\n<td>设置可以对应的值为string类型的value，并指定此键值对应的有效期</td>\n<td>name: 键名；time: 有效期； value：值</td>\n<td>redis.setex(‘name’, 1, ‘James’)</td>\n<td>将name这个键的值设为James，有效期为1秒</td>\n<td>True</td>\n</tr>\n<tr>\n<td>setrange(name, offset, value)</td>\n<td>设置指定键的value值的子字符串</td>\n<td>name：键名；offset：偏移量；value：值</td>\n<td>redis.set(‘name’, ‘Hello’) redis.setrange(‘name’, 6, ‘World’)</td>\n<td>设置name为Hello字符串，并在index为6的位置补World</td>\n<td>11，修改后的字符串长度</td>\n</tr>\n<tr>\n<td>mset(mapping)</td>\n<td>批量赋值</td>\n<td>mapping：字典</td>\n<td>redis.mset({‘name1’: ‘Durant’, ‘name2’: ‘James’})</td>\n<td>将name1设为Durant，name2设为James</td>\n<td>True</td>\n</tr>\n<tr>\n<td>msetnx(mapping)</td>\n<td>键均不存在时才批量赋值</td>\n<td>mapping：字典</td>\n<td>redis.msetnx({‘name3’: ‘Smith’, ‘name4’: ‘Curry’})</td>\n<td>在name3和name4均不存在的情况下才设置二者值</td>\n<td>True</td>\n</tr>\n<tr>\n<td>incr(name, amount=1)</td>\n<td>键为name的value增值操作，默认为1，键不存在则被创建并设为amount</td>\n<td>name：键名；amount：增长的值</td>\n<td>redis.incr(‘age’, 1)</td>\n<td>age对应的值增1，若不存在，则会创建并设置为1</td>\n<td>1，即修改后的值</td>\n</tr>\n<tr>\n<td>decr(name, amount=1)</td>\n<td>键为name的value减值操作，默认为1，键不存在则被创建并将value设置为-amount</td>\n<td>name：键名； amount：减少的值</td>\n<td>redis.decr(‘age’, 1)</td>\n<td>age对应的值减1，若不存在，则会创建并设置为-1</td>\n<td>-1，即修改后的值</td>\n</tr>\n<tr>\n<td>append(key, value)</td>\n<td>键为name的string的值附加value</td>\n<td>key：键名</td>\n<td>redis.append(‘nickname’, ‘OK’)</td>\n<td>向键为nickname的值后追加OK</td>\n<td>13，即修改后的字符串长度</td>\n</tr>\n<tr>\n<td>substr(name, start, end=-1)</td>\n<td>返回键为name的string的子串</td>\n<td>name：键名；start：起始索引；end：终止索引，默认为-1，表示截取到末尾</td>\n<td>redis.substr(‘name’, 1, 4)</td>\n<td>返回键为name的值的字符串，截取索引为1~4的字符</td>\n<td>b’ello’</td>\n</tr>\n<tr>\n<td>getrange(key, start, end)</td>\n<td>获取键的value值从start到end的子字符串</td>\n<td>key：键名；start：起始索引；end：终止索引</td>\n<td>redis.getrange(‘name’, 1, 4)</td>\n<td>返回键为name的值的字符串，截取索引为1~4的字符</td>\n<td>b’ello’</td>\n</tr>\n</tbody></table>\n<h2 id=\"3-列表操作\"><a href=\"#3-列表操作\" class=\"headerlink\" title=\"3. 列表操作\"></a>3. 列表操作</h2><p>Redis还提供了列表存储，列表内的元素可以重复，而且可以从两端存储，用法如下表所示。</p>\n<table>\n<thead>\n<tr>\n<th>方法</th>\n<th>作用</th>\n<th>参数说明</th>\n<th>示例</th>\n<th>示例说明</th>\n<th>示例结果</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>rpush(name, *values)</td>\n<td>在键为name的列表末尾添加值为value的元素，可以传多个</td>\n<td>name：键名；values：值</td>\n<td>redis.rpush(‘list’, 1, 2, 3)</td>\n<td>向键为list的列表尾添加1、2、3</td>\n<td>3，列表大小</td>\n</tr>\n<tr>\n<td>lpush(name, *values)</td>\n<td>在键为name的列表头添加值为value的元素，可以传多个</td>\n<td>name：键名；values：值</td>\n<td>redis.lpush(‘list’, 0)</td>\n<td>向键为list的列表头部添加0</td>\n<td>4，列表大小</td>\n</tr>\n<tr>\n<td>llen(name)</td>\n<td>返回键为name的列表的长度</td>\n<td>name：键名</td>\n<td>redis.llen(‘list’)</td>\n<td>返回键为list的列表的长度</td>\n<td>4</td>\n</tr>\n<tr>\n<td>lrange(name, start, end)</td>\n<td>返回键为name的列表中start至end之间的元素</td>\n<td>name：键名；start：起始索引；end：终止索引</td>\n<td>redis.lrange(‘list’, 1, 3)</td>\n<td>返回起始索引为1终止索引为3的索引范围对应的列表</td>\n<td>[b’3’, b’2’, b’1’]</td>\n</tr>\n<tr>\n<td>ltrim(name, start, end)</td>\n<td>截取键为name的列表，保留索引为start到end的内容</td>\n<td>name：键名；start：起始索引；end：终止索引</td>\n<td>ltrim(‘list’, 1, 3)</td>\n<td>保留键为list的索引为1到3的元素</td>\n<td>True</td>\n</tr>\n<tr>\n<td>lindex(name, index)</td>\n<td>返回键为name的列表中index位置的元素</td>\n<td>name：键名；index：索引</td>\n<td>redis.lindex(‘list’, 1)</td>\n<td>返回键为list的列表索引为1的元素</td>\n<td>b’2’</td>\n</tr>\n<tr>\n<td>lset(name, index, value)</td>\n<td>给键为name的列表中index位置的元素赋值，越界则报错</td>\n<td>name：键名；index：索引位置；value：值</td>\n<td>redis.lset(‘list’, 1, 5)</td>\n<td>将键为list的列表中索引为1的位置赋值为5</td>\n<td>True</td>\n</tr>\n<tr>\n<td>lrem(name, count, value)</td>\n<td>删除count个键的列表中值为value的元素</td>\n<td>name：键名；count：删除个数；value：值</td>\n<td>redis.lrem(‘list’, 2, 3)</td>\n<td>将键为list的列表删除两个3</td>\n<td>1，即删除的个数</td>\n</tr>\n<tr>\n<td>lpop(name)</td>\n<td>返回并删除键为name的列表中的首元素</td>\n<td>name：键名</td>\n<td>redis.lpop(‘list’)</td>\n<td>返回并删除名为list的列表中的第一个元素</td>\n<td>b’5’</td>\n</tr>\n<tr>\n<td>rpop(name)</td>\n<td>返回并删除键为name的列表中的尾元素</td>\n<td>name：键名</td>\n<td>redis.rpop(‘list’)</td>\n<td>返回并删除名为list的列表中的最后一个元素</td>\n<td>b’2’</td>\n</tr>\n<tr>\n<td>blpop(keys, timeout=0)</td>\n<td>返回并删除名称在keys中的list中的首个元素，如果列表为空，则会一直阻塞等待</td>\n<td>keys：键列表；timeout： 超时等待时间，0为一直等待</td>\n<td>redis.blpop(‘list’)</td>\n<td>返回并删除键为list的列表中的第一个元素</td>\n<td>[b’5’]</td>\n</tr>\n<tr>\n<td>brpop(keys, timeout=0)</td>\n<td>返回并删除键为name的列表中的尾元素，如果list为空，则会一直阻塞等待</td>\n<td>keys：键列表；timeout：超时等待时间，0为一直等待</td>\n<td>redis.brpop(‘list’)</td>\n<td>返回并删除名为list的列表中的最后一个元素</td>\n<td>[b’2’]</td>\n</tr>\n<tr>\n<td>rpoplpush(src, dst)</td>\n<td>返回并删除名称为src的列表的尾元素，并将该元素添加到名称为dst的列表头部</td>\n<td>src：源列表的键；dst：目标列表的key</td>\n<td>redis.rpoplpush(‘list’, ‘list2’)</td>\n<td>将键为list的列表尾元素删除并将其添加到键为list2的列表头部，然后返回</td>\n<td>b’2’</td>\n</tr>\n</tbody></table>\n<h2 id=\"4-集合操作\"><a href=\"#4-集合操作\" class=\"headerlink\" title=\"4. 集合操作\"></a>4. 集合操作</h2><p>Redis还提供了集合存储，集合中的元素都是不重复的，用法如下表所示。</p>\n<table>\n<thead>\n<tr>\n<th>方法</th>\n<th>作用</th>\n<th>参数说明</th>\n<th>示例</th>\n<th>示例说明</th>\n<th>示例结果</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>sadd(name, *values)</td>\n<td>向键为name的集合中添加元素</td>\n<td>name：键名；values：值，可为多个</td>\n<td>redis.sadd(‘tags’, ‘Book’, ‘Tea’, ‘Coffee’)</td>\n<td>向键为tags的集合中添加Book、Tea和Coffee这3个内容</td>\n<td>3，即插入的数据个数</td>\n</tr>\n<tr>\n<td>srem(name, *values)</td>\n<td>从键为name的集合中删除元素</td>\n<td>name：键名；values：值，可为多个</td>\n<td>redis.srem(‘tags’, ‘Book’)</td>\n<td>从键为tags的集合中删除Book</td>\n<td>1，即删除的数据个数</td>\n</tr>\n<tr>\n<td>spop(name)</td>\n<td>随机返回并删除键为name的集合中的一个元素</td>\n<td>name：键名</td>\n<td>redis.spop(‘tags’)</td>\n<td>从键为tags的集合中随机删除并返回该元素</td>\n<td>b’Tea’</td>\n</tr>\n<tr>\n<td>smove(src, dst, value)</td>\n<td>从src对应的集合中移除元素并将其添加到dst对应的集合中</td>\n<td>src：源集合；dst：目标集合；value：元素值</td>\n<td>redis.smove(‘tags’, ‘tags2’, ‘Coffee’)</td>\n<td>从键为tags的集合中删除元素Coffee并将其添加到键为tags2的集合</td>\n<td>True</td>\n</tr>\n<tr>\n<td>scard(name)</td>\n<td>返回键为name的集合的元素个数</td>\n<td>name：键名</td>\n<td>redis.scard(‘tags’)</td>\n<td>获取键为tags的集合中的元素个数</td>\n<td>3</td>\n</tr>\n<tr>\n<td>sismember(name, value)</td>\n<td>测试member是否是键为name的集合的元素</td>\n<td>name：键值</td>\n<td>redis.sismember(‘tags’, ‘Book’)</td>\n<td>判断Book是否是键为tags的集合元素</td>\n<td>True</td>\n</tr>\n<tr>\n<td>sinter(keys, *args)</td>\n<td>返回所有给定键的集合的交集</td>\n<td>keys：键列表</td>\n<td>redis.sinter([‘tags’, ‘tags2’])</td>\n<td>返回键为tags的集合和键为tags2的集合的交集</td>\n<td>{b’Coffee’}</td>\n</tr>\n<tr>\n<td>sinterstore(dest, keys, *args)</td>\n<td>求交集并将交集保存到dest的集合</td>\n<td>dest：结果集合；keys：键列表</td>\n<td>redis.sinterstore(‘inttag’, [‘tags’, ‘tags2’])</td>\n<td>求键为tags的集合和键为tags2的集合的交集并将其保存为inttag</td>\n<td>1</td>\n</tr>\n<tr>\n<td>sunion(keys, *args)</td>\n<td>返回所有给定键的集合的并集</td>\n<td>keys：键列表</td>\n<td>redis.sunion([‘tags’, ‘tags2’])</td>\n<td>返回键为tags的集合和键为tags2的集合的并集</td>\n<td>{b’Coffee’, b’Book’, b’Pen’}</td>\n</tr>\n<tr>\n<td>sunionstore(dest, keys, *args)</td>\n<td>求并集并将并集保存到dest的集合</td>\n<td>dest：结果集合；keys：键列表</td>\n<td>redis.sunionstore(‘inttag’, [‘tags’, ‘tags2’])</td>\n<td>求键为tags的集合和键为tags2的集合的并集并将其保存为inttag</td>\n<td>3</td>\n</tr>\n<tr>\n<td>sdiff(keys, *args)</td>\n<td>返回所有给定键的集合的差集</td>\n<td>keys：键列表</td>\n<td>redis.sdiff([‘tags’, ‘tags2’])</td>\n<td>返回键为tags的集合和键为tags2的集合的差集</td>\n<td>{b’Book’, b’Pen’}</td>\n</tr>\n<tr>\n<td>sdiffstore(dest, keys, *args)</td>\n<td>求差集并将差集保存到dest集合</td>\n<td>dest：结果集合；keys：键列表</td>\n<td>redis.sdiffstore(‘inttag’, [‘tags’, ‘tags2’])</td>\n<td>求键为tags的集合和键为tags2的集合的差集并将其保存为inttag`</td>\n<td>3</td>\n</tr>\n<tr>\n<td>smembers(name)</td>\n<td>返回键为name的集合的所有元素</td>\n<td>name：键名</td>\n<td>redis.smembers(‘tags’)</td>\n<td>返回键为tags的集合的所有元素</td>\n<td>{b’Pen’, b’Book’, b’Coffee’}</td>\n</tr>\n<tr>\n<td>srandmember(name)</td>\n<td>随机返回键为name的集合中的一个元素，但不删除元素</td>\n<td>name：键值</td>\n<td>redis.srandmember(‘tags’)</td>\n<td>随机返回键为tags的集合中的一个元素</td>\n<td></td>\n</tr>\n</tbody></table>\n<h2 id=\"5-有序集合操作\"><a href=\"#5-有序集合操作\" class=\"headerlink\" title=\"5. 有序集合操作\"></a>5. 有序集合操作</h2><p>有序集合比集合多了一个分数字段，利用它可以对集合中的数据进行排序，其用法总结如下表所示。</p>\n<table>\n<thead>\n<tr>\n<th>方法</th>\n<th>作用</th>\n<th>参数说明</th>\n<th>示例</th>\n<th>示例说明</th>\n<th>示例结果</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>zadd(name, <em>args, *</em>kwargs)</td>\n<td>向键为name的zset中添加元素member，score用于排序。如果该元素存在，则更新其顺序</td>\n<td>name： 键名；args：可变参数</td>\n<td>redis.zadd(‘grade’, 100, ‘Bob’, 98, ‘Mike’)</td>\n<td>向键为grade的zset中添加Bob（其score为100），并添加Mike（其score为98）</td>\n<td>2，即添加的元素个数</td>\n</tr>\n<tr>\n<td>zrem(name, *values)</td>\n<td>删除键为name的zset中的元素</td>\n<td>name：键名；values：元素</td>\n<td>redis.zrem(‘grade’, ‘Mike’)</td>\n<td>从键为grade的zset中删除Mike</td>\n<td>1，即删除的元素个数</td>\n</tr>\n<tr>\n<td>zincrby(name, value, amount=1)</td>\n<td>如果在键为name的zset中已经存在元素value，则将该元素的score增加amount；否则向该集合中添加该元素，其score的值为amount</td>\n<td>name：key名；value：元素；amount：增长的score值</td>\n<td>redis.zincrby(‘grade’, ‘Bob’, -2)</td>\n<td>键为grade的zset中Bob的score减2</td>\n<td>98.0，即修改后的值</td>\n</tr>\n<tr>\n<td>zrank(name, value)</td>\n<td>返回键为name的zset中元素的排名，按score从小到大排序，即名次</td>\n<td>name：键名；value：元素值</td>\n<td>redis.zrank(‘grade’, ‘Amy’)</td>\n<td>得到键为grade的zset中Amy的排名</td>\n<td>1</td>\n</tr>\n<tr>\n<td>zrevrank(name, value)</td>\n<td>返回键为name的zset中元素的倒数排名（按score从大到小排序），即名次</td>\n<td>name：键名；value：元素值</td>\n<td>redis.zrevrank(‘grade’, ‘Amy’)</td>\n<td>得到键为grade的zset中Amy的倒数排名</td>\n<td>2</td>\n</tr>\n<tr>\n<td>zrevrange(name, start, end, withscores=False)</td>\n<td>返回键为name的zset（按score从大到小排序）中index从start到end的所有元素</td>\n<td>name：键值；start：开始索引；end：结束索引；withscores：是否带score</td>\n<td>redis.zrevrange(‘grade’, 0, 3)</td>\n<td>返回键为grade的zset中前四名元素</td>\n<td>[b’Bob’, b’Mike’, b’Amy’, b’James’]</td>\n</tr>\n<tr>\n<td>zrangebyscore(name, min, max, start=None, num=None, withscores=False)</td>\n<td>返回键为name的zset中score在给定区间的元素</td>\n<td>name：键名；min：最低score；max：最高score； start：起始索引；num：个数；withscores：是否带score</td>\n<td>redis.zrangebyscore(‘grade’, 80, 95)</td>\n<td>返回键为grade的zset中score在80和95之间的元素</td>\n<td>[b’Bob’, b’Mike’, b’Amy’, b’James’]</td>\n</tr>\n<tr>\n<td>zcount(name, min, max)</td>\n<td>返回键为name的zset中score在给定区间的数量</td>\n<td>name：键名；min：最低score；max：最高score</td>\n<td>redis.zcount(‘grade’, 80, 95)</td>\n<td>返回键为grade的zset中score在80到95的元素个数</td>\n<td>2</td>\n</tr>\n<tr>\n<td>zcard(name)</td>\n<td>返回键为name的zset的元素个数</td>\n<td>name：键名</td>\n<td>redis.zcard(‘grade’)</td>\n<td>获取键为grade的zset中元素的个数</td>\n<td>3</td>\n</tr>\n<tr>\n<td>zremrangebyrank(name, min, max)</td>\n<td>删除键为name的zset中排名在给定区间的元素</td>\n<td>name：键名；min：最低位次；max：最高位次</td>\n<td>redis.zremrangebyrank(‘grade’, 0, 0)</td>\n<td>删除键为grade的zset中排名第一的元素</td>\n<td>1，即删除的元素个数</td>\n</tr>\n<tr>\n<td>zremrangebyscore(name, min, max)</td>\n<td>删除键为name的zset中score在给定区间的元素</td>\n<td>name：键名；min：最低score；max：最高score</td>\n<td>redis.zremrangebyscore(‘grade’, 80, 90)</td>\n<td>删除score在80到90之间的元素</td>\n<td>1，即删除的元素个数</td>\n</tr>\n</tbody></table>\n<h2 id=\"6-散列操作\"><a href=\"#6-散列操作\" class=\"headerlink\" title=\"6. 散列操作\"></a>6. 散列操作</h2><p>Redis还提供了散列表的数据结构，我们可以用<code>name</code>指定一个散列表的名称，表内存储了各个键值对，用法总结如下表所示。</p>\n<table>\n<thead>\n<tr>\n<th>方法</th>\n<th>作用</th>\n<th>参数说明</th>\n<th>示例</th>\n<th>示例说明</th>\n<th>示例结果</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>hset(name, key, value)</td>\n<td>向键为name的散列表中添加映射</td>\n<td>name：键名；key：映射键名；value：映射键值</td>\n<td>hset(‘price’, ‘cake’, 5)</td>\n<td>向键为price的散列表中添加映射关系，cake的值为5</td>\n<td>1，即添加的映射个数</td>\n</tr>\n<tr>\n<td>hsetnx(name, key, value)</td>\n<td>如果映射键名不存在，则向键为name的散列表中添加映射</td>\n<td>name：键名；key：映射键名；value：映射键值</td>\n<td>hsetnx(‘price’, ‘book’, 6)</td>\n<td>向键为price的散列表中添加映射关系，book的值为6</td>\n<td>1，即添加的映射个数</td>\n</tr>\n<tr>\n<td>hget(name, key)</td>\n<td>返回键为name的散列表中key对应的值</td>\n<td>name：键名；key：映射键名</td>\n<td>redis.hget(‘price’, ‘cake’)</td>\n<td>获取键为price的散列表中键名为cake的值</td>\n<td>5</td>\n</tr>\n<tr>\n<td>hmget(name, keys, *args)</td>\n<td>返回键为name的散列表中各个键对应的值</td>\n<td>name：键名；keys：映射键名列表</td>\n<td>redis.hmget(‘price’, [‘apple’, ‘orange’])</td>\n<td>获取键为price的散列表中apple和orange的值</td>\n<td>[b’3’, b’7’]</td>\n</tr>\n<tr>\n<td>hmset(name, mapping)</td>\n<td>向键为name的散列表中批量添加映射</td>\n<td>name：键名；mapping：映射字典</td>\n<td>redis.hmset(‘price’, {‘banana’: 2, ‘pear’: 6})</td>\n<td>向键为price的散列表中批量添加映射</td>\n<td>True</td>\n</tr>\n<tr>\n<td>hincrby(name, key, amount=1)</td>\n<td>将键为name的散列表中映射的值增加amount</td>\n<td>name：键名；key：映射键名；amount：增长量</td>\n<td>redis.hincrby(‘price’, ‘apple’, 3)</td>\n<td>key为price的散列表中apple的值增加3</td>\n<td>6，修改后的值</td>\n</tr>\n<tr>\n<td>hexists(name, key)</td>\n<td>键为name的散列表中是否存在键名为键的映射</td>\n<td>name：键名；key：映射键名</td>\n<td>redis.hexists(‘price’, ‘banana’)</td>\n<td>键为price的散列表中banana的值是否存在</td>\n<td>True</td>\n</tr>\n<tr>\n<td>hdel(name, *keys)</td>\n<td>在键为name的散列表中，删除键名为键的映射</td>\n<td>name：键名；keys：映射键名</td>\n<td>redis.hdel(‘price’, ‘banana’)</td>\n<td>从键为price的散列表中删除键名为banana的映射</td>\n<td>True</td>\n</tr>\n<tr>\n<td>hlen(name)</td>\n<td>从键为name的散列表中获取映射个数</td>\n<td>name： 键名</td>\n<td>redis.hlen(‘price’)</td>\n<td>从键为price的散列表中获取映射个数</td>\n<td>6</td>\n</tr>\n<tr>\n<td>hkeys(name)</td>\n<td>从键为name的散列表中获取所有映射键名</td>\n<td>name：键名</td>\n<td>redis.hkeys(‘price’)</td>\n<td>从键为price的散列表中获取所有映射键名</td>\n<td>[b’cake’, b’book’, b’banana’, b’pear’]</td>\n</tr>\n<tr>\n<td>hvals(name)</td>\n<td>从键为name的散列表中获取所有映射键值</td>\n<td>name：键名</td>\n<td>redis.hvals(‘price’)</td>\n<td>从键为price的散列表中获取所有映射键值</td>\n<td>[b’5’, b’6’, b’2’, b’6’]</td>\n</tr>\n<tr>\n<td>hgetall(name)</td>\n<td>从键为name的散列表中获取所有映射键值对</td>\n<td>name：键名</td>\n<td>redis.hgetall(‘price’)</td>\n<td>从键为price的散列表中获取所有映射键值对</td>\n<td>{b’cake’: b’5’, b’book’: b’6’, b’orange’: b’7’, b’pear’: b’6’}</td>\n</tr>\n</tbody></table>\n<blockquote>\n<p>具体操作参考官方文档：</p>\n<ol>\n<li><a href=\"http://doc.redisfans.com/\" target=\"_blank\" rel=\"noopener\">http://doc.redisfans.com/</a></li>\n<li><a href=\"http://redis.cn/\" target=\"_blank\" rel=\"noopener\">http://redis.cn/</a></li>\n</ol>\n</blockquote>\n","site":{"data":{}},"excerpt":"<h1 id=\"一、Redis概括\"><a href=\"#一、Redis概括\" class=\"headerlink\" title=\"一、Redis概括\"></a>一、Redis概括</h1><h3 id=\"1-Redis特点\"><a href=\"#1-Redis特点\" class=\"headerlink\" title=\"1  Redis特点\"></a>1  <a href=\"https://handout-1300728887.cos.ap-beijing.myqcloud.com/%E8%AE%B2%E4%B9%89/%E9%BB%91%E9%A9%AC%E5%A4%B4%E6%9D%A1%E9%A1%B9%E7%9B%AE%E8%AF%BE%E4%BB%B6/C02-Database/Redis.html\" target=\"_blank\" rel=\"noopener\">Redis特点</a></h3><ol>\n<li><p>速度快：C语言实现，存储在内存中以键值对形式保存</p>\n</li>\n<li><p><strong>持久化:</strong></p>\n<ul>\n<li><p>redis可以将数据写入到磁盘中，在停机后，再次启动redis时，将磁盘中的备份数据加载到redis中</p>\n</li>\n<li><p>两种机制：</p>\n<ol>\n<li><p>RDB快照持久化（默认开启）</p>\n<ul>\n<li>将内存中的数据存入磁盘</li>\n<li>缺点：一旦数据库出现问题，rdb文件数据不是全新的</li>\n</ul>","more":"</li>\n<li><p>AOF追加文件持久化</p>\n<ul>\n<li>文件会变大，自动压缩</li>\n</ul>\n</li>\n</ol>\n</li>\n</ul>\n</li>\n<li><p>多种数据结构：string  hash  list  set  zset</p>\n</li>\n<li><p>支持多种编程语言</p>\n</li>\n<li><p>支持事务、流水线、消息队列</p>\n</li>\n<li><p><a href=\"https://handout-1300728887.cos.ap-beijing.myqcloud.com/%E8%AE%B2%E4%B9%89/redis%E8%AE%B2%E4%B9%89/redis%E8%AE%B2%E4%B9%89/redis/da-jian-zhu-cong.html\" target=\"_blank\" rel=\"noopener\">主从复制</a></p>\n</li>\n<li><p>高可用、分布式</p>\n</li>\n</ol>\n<h3 id=\"2-redis宕机\"><a href=\"#2-redis宕机\" class=\"headerlink\" title=\"2  redis宕机\"></a>2  redis宕机</h3><ul>\n<li><p>slave从宕机</p>\n<ul>\n<li>重启后会自动加入到主从架构中，完成数据同步</li>\n</ul>\n</li>\n<li><p>master主宕机（主从都没持久化）</p>\n<ol>\n<li>不要立马重启服务</li>\n<li>slave执行<code>SLAVEOF ON ONE</code>断开主从关系并升级为主库</li>\n<li>重启主，<code>SLAVEOF</code>设为从</li>\n</ol>\n<p>可使用简单方法：<strong>哨兵</strong></p>\n</li>\n</ul>\n<h3 id=\"3-redis高可用\"><a href=\"#3-redis高可用\" class=\"headerlink\" title=\"3  redis高可用\"></a>3  redis高可用</h3><p><strong>提供了主从同步＋哨兵机制（ Sentinel ）</strong></p>\n<ul>\n<li>哨兵机制：实现故障转移，当检测到主服务器发生故障时，把从服务器升级为主，保证数据正常使用<ul>\n<li>原理：心跳机制＋投票裁决＋故障转移<ul>\n<li>定时给master/slave发送消息，若指定时间内无响应（主观宕机 SDOWN）</li>\n<li>Sentinel群都报告某一master无响应（客观宕机 SDOWN）</li>\n<li>通过一定vote算法，将从升为主</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"4-为什么Redis比MySQL快\"><a href=\"#4-为什么Redis比MySQL快\" class=\"headerlink\" title=\"4  为什么Redis比MySQL快\"></a>4  为什么Redis比MySQL快</h3><table>\n<thead>\n<tr>\n<th align=\"center\"></th>\n<th align=\"center\">Redis</th>\n<th align=\"center\">MySQL</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\">数据格式</td>\n<td align=\"center\">k-v</td>\n<td align=\"center\">B+TREE</td>\n</tr>\n<tr>\n<td align=\"center\">时间复杂度</td>\n<td align=\"center\">0(1)（常数阶）</td>\n<td align=\"center\">0(logn)（对数阶）</td>\n</tr>\n<tr>\n<td align=\"center\">存储位置</td>\n<td align=\"center\">从内存直接取出</td>\n<td align=\"center\">磁盘表（全局扫或索引查）</td>\n</tr>\n</tbody></table>\n<p>Redis是单线程的多路复用IO，单线程避免线程切换开销；多路复用避免IO等待开销；多核处理器下对数据进行分区，各处理器处理不同的数据（分着干）</p>\n<h1 id=\"二、Redis缓存\"><a href=\"#二、Redis缓存\" class=\"headerlink\" title=\"二、Redis缓存\"></a>二、Redis缓存</h1><h3 id=\"1-有效期TTL（Time-to-live）\"><a href=\"#1-有效期TTL（Time-to-live）\" class=\"headerlink\" title=\"1  有效期TTL（Time to live）\"></a>1  有效期TTL（Time to live）</h3><ul>\n<li>作用：<ul>\n<li>节省空间</li>\n<li>做到数据有效性，失效后，做到数据一致性</li>\n</ul>\n</li>\n</ul>\n<h4 id=\"1-1-过期策略\"><a href=\"#1-1-过期策略\" class=\"headerlink\" title=\"1.1  过期策略\"></a>1.1  过期策略</h4><ul>\n<li><p>定时过期：时间一到立即清除，对内存友好，但会占用大量CPU资源</p>\n</li>\n<li><p>惰性过期：当访问时才去判断是否过期，节省CPU，占用内存</p>\n</li>\n<li><p>定期过期：每隔一段时间，随机清除</p>\n<p><strong>Redis中同时使用了惰性过期和定期过期两种过期策略。</strong> </p>\n</li>\n</ul>\n<h4 id=\"1-2-缓存淘汰-（eviction）\"><a href=\"#1-2-缓存淘汰-（eviction）\" class=\"headerlink\" title=\"1.2  缓存淘汰 （eviction）\"></a>1.2  缓存淘汰 （eviction）</h4><ul>\n<li>LRU（Least recently used，最近最少使用）<ul>\n<li>新数据插入到表头部</li>\n<li>缓存命中时，将其移到头部</li>\n<li>缓存满的时候将尾部的数据丢掉</li>\n</ul>\n</li>\n<li>LFU（Least Frequently Used 最近最少使用算法）<ul>\n<li>如果数据在一段时间内使用次数很少，那么将来也会很少</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"2-缓存模式\"><a href=\"#2-缓存模式\" class=\"headerlink\" title=\"2  缓存模式\"></a>2  缓存模式</h3><ul>\n<li><strong>先更新数据库，再删除缓存</strong> </li>\n</ul>\n<h4 id=\"2-1-缓存穿透\"><a href=\"#2-1-缓存穿透\" class=\"headerlink\" title=\"2.1  缓存穿透\"></a>2.1  缓存穿透</h4><ul>\n<li><p>频繁请求缓存中不存在的数据，增大数据库压力</p>\n<ul>\n<li>解决方案：<ol>\n<li>返回缓存伪造数据</li>\n<li>限制请求参数</li>\n<li>借助第三方过滤器：布隆过滤器…</li>\n</ol>\n</li>\n</ul>\n</li>\n<li><p>布隆过滤器</p>\n<p>本质上是一种*<em>概率型数据结构， 由一个很长的bit数组和一系列哈希函数组成的 *</em></p>\n<p>特点：<strong>高效地插入和查询</strong></p>\n<p>算法的核心： <strong>某样东西一定不存在或者可能存在</strong></p>\n<p>缺点：<strong>数据只能插入不能删除</strong></p>\n<ul>\n<li>存储原理：经过多次不同维度的hash计算，将数据映射到二进制向量里</li>\n<li>服务流程：<ol>\n<li>当用户访问时，去布隆过滤器中判断key值是否存在，否则直接返回</li>\n<li>如果key值存在，则访问redis，由于存在误判率，redis中也可能不存在</li>\n<li>再访问数据库，若也不存在，直接返回空</li>\n</ol>\n</li>\n</ul>\n</li>\n</ul>\n<p><img src=\"https://img-blog.csdnimg.cn/20190306043938625.?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0lUX3Rvd25sZXQ=,size_16,color_FFFFFF,t_70\" alt=\"\"></p>\n<h4 id=\"2-2-缓存雪崩\"><a href=\"#2-2-缓存雪崩\" class=\"headerlink\" title=\"2.2  缓存雪崩\"></a>2.2  缓存雪崩</h4><ul>\n<li>同一时间内，大量缓存失效，造成数据库压力剧增<ul>\n<li>解决方案：<ol>\n<li>设置不同的有效期值</li>\n<li>采用多级缓存</li>\n<li>利用加锁或者队列</li>\n</ol>\n</li>\n</ul>\n</li>\n</ul>\n<h1 id=\"三、Redis操作\"><a href=\"#三、Redis操作\" class=\"headerlink\" title=\"三、Redis操作\"></a>三、Redis操作</h1><h2 id=\"1-键操作\"><a href=\"#1-键操作\" class=\"headerlink\" title=\"1. 键操作\"></a>1. 键操作</h2><p>键的判断和操作方法</p>\n<table>\n<thead>\n<tr>\n<th>方法</th>\n<th>作用</th>\n<th>参数说明</th>\n<th>示例</th>\n<th>示例说明</th>\n<th>示例结果</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>exists(name)</td>\n<td>判断一个键是否存在</td>\n<td>name：键名</td>\n<td>redis.exists(‘name’)</td>\n<td>是否存在name这个键</td>\n<td>True</td>\n</tr>\n<tr>\n<td>delete(name)</td>\n<td>删除一个键</td>\n<td>name：键名</td>\n<td>redis.delete(‘name’)</td>\n<td>删除name这个键</td>\n<td>1</td>\n</tr>\n<tr>\n<td>type(name)</td>\n<td>判断键类型</td>\n<td>name：键名</td>\n<td>redis.type(‘name’)</td>\n<td>判断name这个键类型</td>\n<td>b’string’</td>\n</tr>\n<tr>\n<td>keys(pattern)</td>\n<td>获取所有符合规则的键</td>\n<td>pattern：匹配规则</td>\n<td>redis.keys(‘n*’)</td>\n<td>获取所有以n开头的键</td>\n<td>[b’name’]</td>\n</tr>\n<tr>\n<td>randomkey()</td>\n<td>获取随机的一个键</td>\n<td></td>\n<td>randomkey()</td>\n<td>获取随机的一个键</td>\n<td>b’name’</td>\n</tr>\n<tr>\n<td>rename(src, dst)</td>\n<td>重命名键</td>\n<td>src：原键名；dst：新键名</td>\n<td>redis.rename(‘name’, ‘nickname’)</td>\n<td>将name重命名为nickname</td>\n<td>True</td>\n</tr>\n<tr>\n<td>dbsize()</td>\n<td>获取当前数据库中键的数目</td>\n<td></td>\n<td>dbsize()</td>\n<td>获取当前数据库中键的数目</td>\n<td>100</td>\n</tr>\n<tr>\n<td>expire(name, time)</td>\n<td>设定键的过期时间，单位为秒</td>\n<td>name：键名；time：秒数</td>\n<td>redis.expire(‘name’, 2)</td>\n<td>将name键的过期时间设置为2秒</td>\n<td>True</td>\n</tr>\n<tr>\n<td>ttl(name)</td>\n<td>获取键的过期时间，单位为秒，-1表示永久不过期</td>\n<td>name：键名</td>\n<td>redis.ttl(‘name’)</td>\n<td>获取name这个键的过期时间</td>\n<td>-1</td>\n</tr>\n<tr>\n<td>move(name, db)</td>\n<td>将键移动到其他数据库</td>\n<td>name：键名；db：数据库代号</td>\n<td>move(‘name’, 2)</td>\n<td>将name移动到2号数据库</td>\n<td>True</td>\n</tr>\n<tr>\n<td>flushdb()</td>\n<td>删除当前选择数据库中的所有键</td>\n<td></td>\n<td>flushdb()</td>\n<td>删除当前选择数据库中的所有键</td>\n<td>True</td>\n</tr>\n<tr>\n<td>flushall()</td>\n<td>删除所有数据库中的所有键</td>\n<td></td>\n<td>flushall()</td>\n<td>删除所有数据库中的所有键</td>\n<td>True</td>\n</tr>\n</tbody></table>\n<h2 id=\"2-字符串操作\"><a href=\"#2-字符串操作\" class=\"headerlink\" title=\"2. 字符串操作\"></a>2. 字符串操作</h2><p>Redis支持最基本的键值对形式存储，用法总结如下表所示。</p>\n<table>\n<thead>\n<tr>\n<th>方法</th>\n<th>作用</th>\n<th>参数说明</th>\n<th>示例</th>\n<th>示例说明</th>\n<th>示例结果</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>set(name, value)</td>\n<td>给数据库中键为name的string赋予值value</td>\n<td>name: 键名；value: 值</td>\n<td>redis.set(‘name’, ‘Bob’)</td>\n<td>给name这个键的value赋值为Bob</td>\n<td>True</td>\n</tr>\n<tr>\n<td>get(name)</td>\n<td>返回数据库中键为name的string的value</td>\n<td>name：键名</td>\n<td>redis.get(‘name’)</td>\n<td>返回name这个键的value</td>\n<td>b’Bob’</td>\n</tr>\n<tr>\n<td>getset(name, value)</td>\n<td>给数据库中键为name的string赋予值value并返回上次的value</td>\n<td>name：键名；value：新值</td>\n<td>redis.getset(‘name’, ‘Mike’)</td>\n<td>赋值name为Mike并得到上次的value</td>\n<td>b’Bob’</td>\n</tr>\n<tr>\n<td>mget(keys, *args)</td>\n<td>返回多个键对应的value</td>\n<td>keys：键的列表</td>\n<td>redis.mget([‘name’, ‘nickname’])</td>\n<td>返回name和nickname的value</td>\n<td>[b’Mike’, b’Miker’]</td>\n</tr>\n<tr>\n<td>setnx(name, value)</td>\n<td>如果不存在这个键值对，则更新value，否则不变</td>\n<td>name：键名</td>\n<td>redis.setnx(‘newname’, ‘James’)</td>\n<td>如果newname这个键不存在，则设置值为James</td>\n<td>第一次运行结果是True，第二次运行结果是False</td>\n</tr>\n<tr>\n<td>setex(name, time, value)</td>\n<td>设置可以对应的值为string类型的value，并指定此键值对应的有效期</td>\n<td>name: 键名；time: 有效期； value：值</td>\n<td>redis.setex(‘name’, 1, ‘James’)</td>\n<td>将name这个键的值设为James，有效期为1秒</td>\n<td>True</td>\n</tr>\n<tr>\n<td>setrange(name, offset, value)</td>\n<td>设置指定键的value值的子字符串</td>\n<td>name：键名；offset：偏移量；value：值</td>\n<td>redis.set(‘name’, ‘Hello’) redis.setrange(‘name’, 6, ‘World’)</td>\n<td>设置name为Hello字符串，并在index为6的位置补World</td>\n<td>11，修改后的字符串长度</td>\n</tr>\n<tr>\n<td>mset(mapping)</td>\n<td>批量赋值</td>\n<td>mapping：字典</td>\n<td>redis.mset({‘name1’: ‘Durant’, ‘name2’: ‘James’})</td>\n<td>将name1设为Durant，name2设为James</td>\n<td>True</td>\n</tr>\n<tr>\n<td>msetnx(mapping)</td>\n<td>键均不存在时才批量赋值</td>\n<td>mapping：字典</td>\n<td>redis.msetnx({‘name3’: ‘Smith’, ‘name4’: ‘Curry’})</td>\n<td>在name3和name4均不存在的情况下才设置二者值</td>\n<td>True</td>\n</tr>\n<tr>\n<td>incr(name, amount=1)</td>\n<td>键为name的value增值操作，默认为1，键不存在则被创建并设为amount</td>\n<td>name：键名；amount：增长的值</td>\n<td>redis.incr(‘age’, 1)</td>\n<td>age对应的值增1，若不存在，则会创建并设置为1</td>\n<td>1，即修改后的值</td>\n</tr>\n<tr>\n<td>decr(name, amount=1)</td>\n<td>键为name的value减值操作，默认为1，键不存在则被创建并将value设置为-amount</td>\n<td>name：键名； amount：减少的值</td>\n<td>redis.decr(‘age’, 1)</td>\n<td>age对应的值减1，若不存在，则会创建并设置为-1</td>\n<td>-1，即修改后的值</td>\n</tr>\n<tr>\n<td>append(key, value)</td>\n<td>键为name的string的值附加value</td>\n<td>key：键名</td>\n<td>redis.append(‘nickname’, ‘OK’)</td>\n<td>向键为nickname的值后追加OK</td>\n<td>13，即修改后的字符串长度</td>\n</tr>\n<tr>\n<td>substr(name, start, end=-1)</td>\n<td>返回键为name的string的子串</td>\n<td>name：键名；start：起始索引；end：终止索引，默认为-1，表示截取到末尾</td>\n<td>redis.substr(‘name’, 1, 4)</td>\n<td>返回键为name的值的字符串，截取索引为1~4的字符</td>\n<td>b’ello’</td>\n</tr>\n<tr>\n<td>getrange(key, start, end)</td>\n<td>获取键的value值从start到end的子字符串</td>\n<td>key：键名；start：起始索引；end：终止索引</td>\n<td>redis.getrange(‘name’, 1, 4)</td>\n<td>返回键为name的值的字符串，截取索引为1~4的字符</td>\n<td>b’ello’</td>\n</tr>\n</tbody></table>\n<h2 id=\"3-列表操作\"><a href=\"#3-列表操作\" class=\"headerlink\" title=\"3. 列表操作\"></a>3. 列表操作</h2><p>Redis还提供了列表存储，列表内的元素可以重复，而且可以从两端存储，用法如下表所示。</p>\n<table>\n<thead>\n<tr>\n<th>方法</th>\n<th>作用</th>\n<th>参数说明</th>\n<th>示例</th>\n<th>示例说明</th>\n<th>示例结果</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>rpush(name, *values)</td>\n<td>在键为name的列表末尾添加值为value的元素，可以传多个</td>\n<td>name：键名；values：值</td>\n<td>redis.rpush(‘list’, 1, 2, 3)</td>\n<td>向键为list的列表尾添加1、2、3</td>\n<td>3，列表大小</td>\n</tr>\n<tr>\n<td>lpush(name, *values)</td>\n<td>在键为name的列表头添加值为value的元素，可以传多个</td>\n<td>name：键名；values：值</td>\n<td>redis.lpush(‘list’, 0)</td>\n<td>向键为list的列表头部添加0</td>\n<td>4，列表大小</td>\n</tr>\n<tr>\n<td>llen(name)</td>\n<td>返回键为name的列表的长度</td>\n<td>name：键名</td>\n<td>redis.llen(‘list’)</td>\n<td>返回键为list的列表的长度</td>\n<td>4</td>\n</tr>\n<tr>\n<td>lrange(name, start, end)</td>\n<td>返回键为name的列表中start至end之间的元素</td>\n<td>name：键名；start：起始索引；end：终止索引</td>\n<td>redis.lrange(‘list’, 1, 3)</td>\n<td>返回起始索引为1终止索引为3的索引范围对应的列表</td>\n<td>[b’3’, b’2’, b’1’]</td>\n</tr>\n<tr>\n<td>ltrim(name, start, end)</td>\n<td>截取键为name的列表，保留索引为start到end的内容</td>\n<td>name：键名；start：起始索引；end：终止索引</td>\n<td>ltrim(‘list’, 1, 3)</td>\n<td>保留键为list的索引为1到3的元素</td>\n<td>True</td>\n</tr>\n<tr>\n<td>lindex(name, index)</td>\n<td>返回键为name的列表中index位置的元素</td>\n<td>name：键名；index：索引</td>\n<td>redis.lindex(‘list’, 1)</td>\n<td>返回键为list的列表索引为1的元素</td>\n<td>b’2’</td>\n</tr>\n<tr>\n<td>lset(name, index, value)</td>\n<td>给键为name的列表中index位置的元素赋值，越界则报错</td>\n<td>name：键名；index：索引位置；value：值</td>\n<td>redis.lset(‘list’, 1, 5)</td>\n<td>将键为list的列表中索引为1的位置赋值为5</td>\n<td>True</td>\n</tr>\n<tr>\n<td>lrem(name, count, value)</td>\n<td>删除count个键的列表中值为value的元素</td>\n<td>name：键名；count：删除个数；value：值</td>\n<td>redis.lrem(‘list’, 2, 3)</td>\n<td>将键为list的列表删除两个3</td>\n<td>1，即删除的个数</td>\n</tr>\n<tr>\n<td>lpop(name)</td>\n<td>返回并删除键为name的列表中的首元素</td>\n<td>name：键名</td>\n<td>redis.lpop(‘list’)</td>\n<td>返回并删除名为list的列表中的第一个元素</td>\n<td>b’5’</td>\n</tr>\n<tr>\n<td>rpop(name)</td>\n<td>返回并删除键为name的列表中的尾元素</td>\n<td>name：键名</td>\n<td>redis.rpop(‘list’)</td>\n<td>返回并删除名为list的列表中的最后一个元素</td>\n<td>b’2’</td>\n</tr>\n<tr>\n<td>blpop(keys, timeout=0)</td>\n<td>返回并删除名称在keys中的list中的首个元素，如果列表为空，则会一直阻塞等待</td>\n<td>keys：键列表；timeout： 超时等待时间，0为一直等待</td>\n<td>redis.blpop(‘list’)</td>\n<td>返回并删除键为list的列表中的第一个元素</td>\n<td>[b’5’]</td>\n</tr>\n<tr>\n<td>brpop(keys, timeout=0)</td>\n<td>返回并删除键为name的列表中的尾元素，如果list为空，则会一直阻塞等待</td>\n<td>keys：键列表；timeout：超时等待时间，0为一直等待</td>\n<td>redis.brpop(‘list’)</td>\n<td>返回并删除名为list的列表中的最后一个元素</td>\n<td>[b’2’]</td>\n</tr>\n<tr>\n<td>rpoplpush(src, dst)</td>\n<td>返回并删除名称为src的列表的尾元素，并将该元素添加到名称为dst的列表头部</td>\n<td>src：源列表的键；dst：目标列表的key</td>\n<td>redis.rpoplpush(‘list’, ‘list2’)</td>\n<td>将键为list的列表尾元素删除并将其添加到键为list2的列表头部，然后返回</td>\n<td>b’2’</td>\n</tr>\n</tbody></table>\n<h2 id=\"4-集合操作\"><a href=\"#4-集合操作\" class=\"headerlink\" title=\"4. 集合操作\"></a>4. 集合操作</h2><p>Redis还提供了集合存储，集合中的元素都是不重复的，用法如下表所示。</p>\n<table>\n<thead>\n<tr>\n<th>方法</th>\n<th>作用</th>\n<th>参数说明</th>\n<th>示例</th>\n<th>示例说明</th>\n<th>示例结果</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>sadd(name, *values)</td>\n<td>向键为name的集合中添加元素</td>\n<td>name：键名；values：值，可为多个</td>\n<td>redis.sadd(‘tags’, ‘Book’, ‘Tea’, ‘Coffee’)</td>\n<td>向键为tags的集合中添加Book、Tea和Coffee这3个内容</td>\n<td>3，即插入的数据个数</td>\n</tr>\n<tr>\n<td>srem(name, *values)</td>\n<td>从键为name的集合中删除元素</td>\n<td>name：键名；values：值，可为多个</td>\n<td>redis.srem(‘tags’, ‘Book’)</td>\n<td>从键为tags的集合中删除Book</td>\n<td>1，即删除的数据个数</td>\n</tr>\n<tr>\n<td>spop(name)</td>\n<td>随机返回并删除键为name的集合中的一个元素</td>\n<td>name：键名</td>\n<td>redis.spop(‘tags’)</td>\n<td>从键为tags的集合中随机删除并返回该元素</td>\n<td>b’Tea’</td>\n</tr>\n<tr>\n<td>smove(src, dst, value)</td>\n<td>从src对应的集合中移除元素并将其添加到dst对应的集合中</td>\n<td>src：源集合；dst：目标集合；value：元素值</td>\n<td>redis.smove(‘tags’, ‘tags2’, ‘Coffee’)</td>\n<td>从键为tags的集合中删除元素Coffee并将其添加到键为tags2的集合</td>\n<td>True</td>\n</tr>\n<tr>\n<td>scard(name)</td>\n<td>返回键为name的集合的元素个数</td>\n<td>name：键名</td>\n<td>redis.scard(‘tags’)</td>\n<td>获取键为tags的集合中的元素个数</td>\n<td>3</td>\n</tr>\n<tr>\n<td>sismember(name, value)</td>\n<td>测试member是否是键为name的集合的元素</td>\n<td>name：键值</td>\n<td>redis.sismember(‘tags’, ‘Book’)</td>\n<td>判断Book是否是键为tags的集合元素</td>\n<td>True</td>\n</tr>\n<tr>\n<td>sinter(keys, *args)</td>\n<td>返回所有给定键的集合的交集</td>\n<td>keys：键列表</td>\n<td>redis.sinter([‘tags’, ‘tags2’])</td>\n<td>返回键为tags的集合和键为tags2的集合的交集</td>\n<td>{b’Coffee’}</td>\n</tr>\n<tr>\n<td>sinterstore(dest, keys, *args)</td>\n<td>求交集并将交集保存到dest的集合</td>\n<td>dest：结果集合；keys：键列表</td>\n<td>redis.sinterstore(‘inttag’, [‘tags’, ‘tags2’])</td>\n<td>求键为tags的集合和键为tags2的集合的交集并将其保存为inttag</td>\n<td>1</td>\n</tr>\n<tr>\n<td>sunion(keys, *args)</td>\n<td>返回所有给定键的集合的并集</td>\n<td>keys：键列表</td>\n<td>redis.sunion([‘tags’, ‘tags2’])</td>\n<td>返回键为tags的集合和键为tags2的集合的并集</td>\n<td>{b’Coffee’, b’Book’, b’Pen’}</td>\n</tr>\n<tr>\n<td>sunionstore(dest, keys, *args)</td>\n<td>求并集并将并集保存到dest的集合</td>\n<td>dest：结果集合；keys：键列表</td>\n<td>redis.sunionstore(‘inttag’, [‘tags’, ‘tags2’])</td>\n<td>求键为tags的集合和键为tags2的集合的并集并将其保存为inttag</td>\n<td>3</td>\n</tr>\n<tr>\n<td>sdiff(keys, *args)</td>\n<td>返回所有给定键的集合的差集</td>\n<td>keys：键列表</td>\n<td>redis.sdiff([‘tags’, ‘tags2’])</td>\n<td>返回键为tags的集合和键为tags2的集合的差集</td>\n<td>{b’Book’, b’Pen’}</td>\n</tr>\n<tr>\n<td>sdiffstore(dest, keys, *args)</td>\n<td>求差集并将差集保存到dest集合</td>\n<td>dest：结果集合；keys：键列表</td>\n<td>redis.sdiffstore(‘inttag’, [‘tags’, ‘tags2’])</td>\n<td>求键为tags的集合和键为tags2的集合的差集并将其保存为inttag`</td>\n<td>3</td>\n</tr>\n<tr>\n<td>smembers(name)</td>\n<td>返回键为name的集合的所有元素</td>\n<td>name：键名</td>\n<td>redis.smembers(‘tags’)</td>\n<td>返回键为tags的集合的所有元素</td>\n<td>{b’Pen’, b’Book’, b’Coffee’}</td>\n</tr>\n<tr>\n<td>srandmember(name)</td>\n<td>随机返回键为name的集合中的一个元素，但不删除元素</td>\n<td>name：键值</td>\n<td>redis.srandmember(‘tags’)</td>\n<td>随机返回键为tags的集合中的一个元素</td>\n<td></td>\n</tr>\n</tbody></table>\n<h2 id=\"5-有序集合操作\"><a href=\"#5-有序集合操作\" class=\"headerlink\" title=\"5. 有序集合操作\"></a>5. 有序集合操作</h2><p>有序集合比集合多了一个分数字段，利用它可以对集合中的数据进行排序，其用法总结如下表所示。</p>\n<table>\n<thead>\n<tr>\n<th>方法</th>\n<th>作用</th>\n<th>参数说明</th>\n<th>示例</th>\n<th>示例说明</th>\n<th>示例结果</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>zadd(name, <em>args, *</em>kwargs)</td>\n<td>向键为name的zset中添加元素member，score用于排序。如果该元素存在，则更新其顺序</td>\n<td>name： 键名；args：可变参数</td>\n<td>redis.zadd(‘grade’, 100, ‘Bob’, 98, ‘Mike’)</td>\n<td>向键为grade的zset中添加Bob（其score为100），并添加Mike（其score为98）</td>\n<td>2，即添加的元素个数</td>\n</tr>\n<tr>\n<td>zrem(name, *values)</td>\n<td>删除键为name的zset中的元素</td>\n<td>name：键名；values：元素</td>\n<td>redis.zrem(‘grade’, ‘Mike’)</td>\n<td>从键为grade的zset中删除Mike</td>\n<td>1，即删除的元素个数</td>\n</tr>\n<tr>\n<td>zincrby(name, value, amount=1)</td>\n<td>如果在键为name的zset中已经存在元素value，则将该元素的score增加amount；否则向该集合中添加该元素，其score的值为amount</td>\n<td>name：key名；value：元素；amount：增长的score值</td>\n<td>redis.zincrby(‘grade’, ‘Bob’, -2)</td>\n<td>键为grade的zset中Bob的score减2</td>\n<td>98.0，即修改后的值</td>\n</tr>\n<tr>\n<td>zrank(name, value)</td>\n<td>返回键为name的zset中元素的排名，按score从小到大排序，即名次</td>\n<td>name：键名；value：元素值</td>\n<td>redis.zrank(‘grade’, ‘Amy’)</td>\n<td>得到键为grade的zset中Amy的排名</td>\n<td>1</td>\n</tr>\n<tr>\n<td>zrevrank(name, value)</td>\n<td>返回键为name的zset中元素的倒数排名（按score从大到小排序），即名次</td>\n<td>name：键名；value：元素值</td>\n<td>redis.zrevrank(‘grade’, ‘Amy’)</td>\n<td>得到键为grade的zset中Amy的倒数排名</td>\n<td>2</td>\n</tr>\n<tr>\n<td>zrevrange(name, start, end, withscores=False)</td>\n<td>返回键为name的zset（按score从大到小排序）中index从start到end的所有元素</td>\n<td>name：键值；start：开始索引；end：结束索引；withscores：是否带score</td>\n<td>redis.zrevrange(‘grade’, 0, 3)</td>\n<td>返回键为grade的zset中前四名元素</td>\n<td>[b’Bob’, b’Mike’, b’Amy’, b’James’]</td>\n</tr>\n<tr>\n<td>zrangebyscore(name, min, max, start=None, num=None, withscores=False)</td>\n<td>返回键为name的zset中score在给定区间的元素</td>\n<td>name：键名；min：最低score；max：最高score； start：起始索引；num：个数；withscores：是否带score</td>\n<td>redis.zrangebyscore(‘grade’, 80, 95)</td>\n<td>返回键为grade的zset中score在80和95之间的元素</td>\n<td>[b’Bob’, b’Mike’, b’Amy’, b’James’]</td>\n</tr>\n<tr>\n<td>zcount(name, min, max)</td>\n<td>返回键为name的zset中score在给定区间的数量</td>\n<td>name：键名；min：最低score；max：最高score</td>\n<td>redis.zcount(‘grade’, 80, 95)</td>\n<td>返回键为grade的zset中score在80到95的元素个数</td>\n<td>2</td>\n</tr>\n<tr>\n<td>zcard(name)</td>\n<td>返回键为name的zset的元素个数</td>\n<td>name：键名</td>\n<td>redis.zcard(‘grade’)</td>\n<td>获取键为grade的zset中元素的个数</td>\n<td>3</td>\n</tr>\n<tr>\n<td>zremrangebyrank(name, min, max)</td>\n<td>删除键为name的zset中排名在给定区间的元素</td>\n<td>name：键名；min：最低位次；max：最高位次</td>\n<td>redis.zremrangebyrank(‘grade’, 0, 0)</td>\n<td>删除键为grade的zset中排名第一的元素</td>\n<td>1，即删除的元素个数</td>\n</tr>\n<tr>\n<td>zremrangebyscore(name, min, max)</td>\n<td>删除键为name的zset中score在给定区间的元素</td>\n<td>name：键名；min：最低score；max：最高score</td>\n<td>redis.zremrangebyscore(‘grade’, 80, 90)</td>\n<td>删除score在80到90之间的元素</td>\n<td>1，即删除的元素个数</td>\n</tr>\n</tbody></table>\n<h2 id=\"6-散列操作\"><a href=\"#6-散列操作\" class=\"headerlink\" title=\"6. 散列操作\"></a>6. 散列操作</h2><p>Redis还提供了散列表的数据结构，我们可以用<code>name</code>指定一个散列表的名称，表内存储了各个键值对，用法总结如下表所示。</p>\n<table>\n<thead>\n<tr>\n<th>方法</th>\n<th>作用</th>\n<th>参数说明</th>\n<th>示例</th>\n<th>示例说明</th>\n<th>示例结果</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>hset(name, key, value)</td>\n<td>向键为name的散列表中添加映射</td>\n<td>name：键名；key：映射键名；value：映射键值</td>\n<td>hset(‘price’, ‘cake’, 5)</td>\n<td>向键为price的散列表中添加映射关系，cake的值为5</td>\n<td>1，即添加的映射个数</td>\n</tr>\n<tr>\n<td>hsetnx(name, key, value)</td>\n<td>如果映射键名不存在，则向键为name的散列表中添加映射</td>\n<td>name：键名；key：映射键名；value：映射键值</td>\n<td>hsetnx(‘price’, ‘book’, 6)</td>\n<td>向键为price的散列表中添加映射关系，book的值为6</td>\n<td>1，即添加的映射个数</td>\n</tr>\n<tr>\n<td>hget(name, key)</td>\n<td>返回键为name的散列表中key对应的值</td>\n<td>name：键名；key：映射键名</td>\n<td>redis.hget(‘price’, ‘cake’)</td>\n<td>获取键为price的散列表中键名为cake的值</td>\n<td>5</td>\n</tr>\n<tr>\n<td>hmget(name, keys, *args)</td>\n<td>返回键为name的散列表中各个键对应的值</td>\n<td>name：键名；keys：映射键名列表</td>\n<td>redis.hmget(‘price’, [‘apple’, ‘orange’])</td>\n<td>获取键为price的散列表中apple和orange的值</td>\n<td>[b’3’, b’7’]</td>\n</tr>\n<tr>\n<td>hmset(name, mapping)</td>\n<td>向键为name的散列表中批量添加映射</td>\n<td>name：键名；mapping：映射字典</td>\n<td>redis.hmset(‘price’, {‘banana’: 2, ‘pear’: 6})</td>\n<td>向键为price的散列表中批量添加映射</td>\n<td>True</td>\n</tr>\n<tr>\n<td>hincrby(name, key, amount=1)</td>\n<td>将键为name的散列表中映射的值增加amount</td>\n<td>name：键名；key：映射键名；amount：增长量</td>\n<td>redis.hincrby(‘price’, ‘apple’, 3)</td>\n<td>key为price的散列表中apple的值增加3</td>\n<td>6，修改后的值</td>\n</tr>\n<tr>\n<td>hexists(name, key)</td>\n<td>键为name的散列表中是否存在键名为键的映射</td>\n<td>name：键名；key：映射键名</td>\n<td>redis.hexists(‘price’, ‘banana’)</td>\n<td>键为price的散列表中banana的值是否存在</td>\n<td>True</td>\n</tr>\n<tr>\n<td>hdel(name, *keys)</td>\n<td>在键为name的散列表中，删除键名为键的映射</td>\n<td>name：键名；keys：映射键名</td>\n<td>redis.hdel(‘price’, ‘banana’)</td>\n<td>从键为price的散列表中删除键名为banana的映射</td>\n<td>True</td>\n</tr>\n<tr>\n<td>hlen(name)</td>\n<td>从键为name的散列表中获取映射个数</td>\n<td>name： 键名</td>\n<td>redis.hlen(‘price’)</td>\n<td>从键为price的散列表中获取映射个数</td>\n<td>6</td>\n</tr>\n<tr>\n<td>hkeys(name)</td>\n<td>从键为name的散列表中获取所有映射键名</td>\n<td>name：键名</td>\n<td>redis.hkeys(‘price’)</td>\n<td>从键为price的散列表中获取所有映射键名</td>\n<td>[b’cake’, b’book’, b’banana’, b’pear’]</td>\n</tr>\n<tr>\n<td>hvals(name)</td>\n<td>从键为name的散列表中获取所有映射键值</td>\n<td>name：键名</td>\n<td>redis.hvals(‘price’)</td>\n<td>从键为price的散列表中获取所有映射键值</td>\n<td>[b’5’, b’6’, b’2’, b’6’]</td>\n</tr>\n<tr>\n<td>hgetall(name)</td>\n<td>从键为name的散列表中获取所有映射键值对</td>\n<td>name：键名</td>\n<td>redis.hgetall(‘price’)</td>\n<td>从键为price的散列表中获取所有映射键值对</td>\n<td>{b’cake’: b’5’, b’book’: b’6’, b’orange’: b’7’, b’pear’: b’6’}</td>\n</tr>\n</tbody></table>\n<blockquote>\n<p>具体操作参考官方文档：</p>\n<ol>\n<li><a href=\"http://doc.redisfans.com/\" target=\"_blank\" rel=\"noopener\">http://doc.redisfans.com/</a></li>\n<li><a href=\"http://redis.cn/\" target=\"_blank\" rel=\"noopener\">http://redis.cn/</a></li>\n</ol>\n</blockquote>"},{"title":"Python高并发场景","date":"2020-09-30T03:29:59.000Z","top":0,"_content":"\n# 一、celery异步\n\ncelery是异步任务的调度工具，主要解决耗时任务，通过**消息队列**在客户端与消费者间协调\n\n- 消息中间件（消息队列Broker）：客户端把任务放入队列中，消费者从队列中取出任务执行，第三方队列服务：RabbitMQ\\redis\\kafka\\MetaMQ\\RocketMQ\n  \n  <!--more-->\n  \n  - **RabbitMQ：**是一个消息代理。工作是接收和转发消息类似邮局，处理消息\n    - 异步消息：支持多种传递协议，消息排队，传递确认，到队列的灵活路由，多种交换类型\n    - 分布式部署：部署为集群以实现高可用和吞吐量\n    - 可靠性：可在性能和可靠性之间进行权衡\n    - 灵活的路由：通过交换机进行路由\n    - 多协议：多种消息协议的消息传递\n    - 管理与监控：HTTP-API，命令行工具\n  - **基本慨念：**\n    - Producer：生产者，投递消息的程序：创建消息（消息体和标签），RabbitMQ会根据标签把消息发送给消费者\n    - Consumer：消费者，接收消息的程序：丢弃标签，消费消息体\n    - Broker：消息中间件的服务节点：RabbitMQ服务实例\n    - Queue：队列：内部对象，用于存储信息，生产者投递，消费者取出消费\n    - Xchange：交换器。指定消息按什么规则，路由到哪个队列，如果路由不到或返回或丢弃\n    - RoutingKey：路由键关键字，Xchange根据此来进行邮递，需要与交换器类型和绑定键联合使用，决定消息流向哪里\n    - Binding：绑定，把Xchange和Queue按照路由规则绑定起来，指定绑定键（BindingKey）\n  \n- 任务执行单元（消费者worker）：可以有多个并发，实时监控消息队列，获取任务并执行它\n\n- 任务执行结果存储（task result store）：由于是由主任务中解耦出来的，主任务想要知道执行结果，必须通过中间件存储\n\n\n\n# 二、Q&F\n\n## 1  消息队列的理解\n\n**消息队列**：保存消息的容器\n\n消息:传输的数据单位\n\n消息源与目标间的中间人，主要目的是**提供路由保证消息的传递**，\n\n## 2  为什么使用消息队列\n\n在高并发情况下，来不及同步处理，请求会发生堵塞。通过消息队列，可以异步处理请求，缓解系统压力\n\n应用场景：\n\n- 异步处理、应用解耦、流量削锋和消息通讯等  \n\n**使用消息队列，把不是必须的业务逻辑，异步处理**\n\n消息队列的缺点：\n\n- 系统可用性降低\n- 系统复杂性提高\n- 一致性问题\n\n## 3  多线程在web中的使用\n\n一般在使用IO操作时\n\n使用场景：\n\n- 需要并行操作几个文件的读写，同步不能异步的情况下\n- 视图中需要多个第三方接口\n- 订单提交后，修改库存销量\n\n## 4  为什么使用celery而不使用线程发送耗时任务\n\n因为并发量较大的时候，线程切换会有开销时间，也会降低并发的数量、共享数据维护麻烦\n\ncelery是通过消息队列进行异步任务处理，不用担心并发量高是负载过大，也可以处理复杂系统性能问题，相对灵活\n\n## 5 什么是乐观锁\n\n每次拿数据的时候都认为别人不会修改，所以不会上锁\n\n在更新的时候判断此时的库存是否是之前查询出的库存，如果相同，表示没人修改，可以更新库存，否则表示别人抢过资源，不再执行库存更新\n\n**实现方式：**利用时间戳、数据版本version字段，数据被修改＋1\n\n使用场景：高并发，减少数据冲突，保证数据一致性\n\n## 6 高并发与分布式的应用场景\n\n处理网站并发量\n\n1. 减少数据库访问次数\n2. 文件和数据库分离（静态化页面）\n3. 大数据分布式存储（主从配置读写分离）\n4. 服务器集群，负载均衡\n5. 页面缓存的使用\n6. 内存数据库代替关系型数据库\n\n例子：省市区三级联动、首页部分数据（广告）局部缓存\n\n分布式案例\n\n1. MySQL主从配置读写分离\n\n## 7  处理抢购高并发\n\n1. 将请求尽量拦截在上游\n2. 充分利用缓存\n\n前端方面：\n\n- 把详情页部署到CDN节点上，做页面静态化处理\n  - CDN：内容分发网络，将源站内容分发到离用户最近的节点，提高访问速度\n- 禁止重复提交请求、对用户请求限流\n\n后端方面：\n\n- 根据用户id限制访问频率\n- 缓存的应用\n\n## 8  如何解决celery队列阻塞问题\n\n- 队列阻塞的原因：\n\n  1. 队列中有耗时任务，且任务量大于celery并发数（Celery没有足够的worker去执行耗时任务）\n  2. 队列中有耗时任务，且Celery启动了**预取机制**\n     - 任务会有指定的worker去执行，就算其worker是空闲状态，也不会执行其它任务\n\n- 解决：\n\n  - **指定进程数**\n\n    `celery -A project worker --concurrency=4`\n\n  - **改变进程池方式为协程方式**\n\n    `pip install eventlet `\n\n    `celery -A project worker -P eventlet -c 1000`\n\n  - **增加并发数**\n\n  `celery -A project worker -n 进程名字 --concurrencu=并发数 -l info`\n\n  - **取消预取机制**\n\n    ```python\n    # 任务发送完成时是否需要确认，对性能会稍有影响\n    celery_app.conf.CELERY_LATE = True\n    # Celery worker每次去队列取任务的数量，默认值为4\n    celery_app.conf.CELERY_PREFETCH_MULTIPLIER = 1\n    ```\n\n    `celery -A project worker -n 进程名字 -Ofair -l info`\n\n  - **错误重试机制**\n\n    ```python\n    # 重连时间间隔\n    @celery_app.task(bind=True, retry_backoff=3)\n    try:\n        ...\n    except Exception as e:\n        # 有异常自动重连三次\n        raise self.retry(exc=e, max_retries=3)\n    ```\n\n## 9  进程和线程的对比\n\n[参考文档](https://handout-1300728887.cos.ap-beijing.myqcloud.com/%E8%AE%B2%E4%B9%89/python-web%E5%9F%BA%E7%A1%80(5.1.2%E7%89%88%E6%9C%AC)/multitasking/%E8%BF%9B%E7%A8%8B%E5%92%8C%E7%BA%BF%E7%A8%8B%E5%AF%B9%E6%AF%94.html)\n\n进程：CPU的一种执行单元\n\n- 密集CPU任务（大量并行计算）\n\n线程：进程执行程序的最小调度单位\n\n- 密集I/O任务\n\n协程：微线程，可以在单线程上执行多个任务，用函数切换，开销极小\n\n#### 关系对比\n\n1. 线程是依附在进程里面的，没有进程就没有线程\n2. 一个进程默认提供一条线程，进程可以创建多个线程\n\n#### 区别对比\n\n1. 进程之间不共享全局变量\n2. 线程之间共享全局变量，但是要注意资源竞争的问题，解决办法: 互斥锁或者线程同步\n3. 创建进程的资源开销要比创建线程的资源开销要大\n4. 进程是操作系统资源分配的基本单位，线程是CPU调度的基本单位\n5. 线程不能够独立执行，必须依存在进程中\n6. 多进程开发比单进程多线程开发稳定性要强\n\n#### 优缺点\n\n- 进程优缺点:\n  - 优点：可以用多核\n  - 缺点：资源开销大\n- 线程优缺点:\n  - 优点：资源开销小\n  - 缺点：不能使用多核做到高并行","source":"_posts/Python高并发场景.md","raw":"---\ntitle: Python高并发场景\ndate: 2020-09-30 11:29:59\ntags: Python\ntop: 0\n---\n\n# 一、celery异步\n\ncelery是异步任务的调度工具，主要解决耗时任务，通过**消息队列**在客户端与消费者间协调\n\n- 消息中间件（消息队列Broker）：客户端把任务放入队列中，消费者从队列中取出任务执行，第三方队列服务：RabbitMQ\\redis\\kafka\\MetaMQ\\RocketMQ\n  \n  <!--more-->\n  \n  - **RabbitMQ：**是一个消息代理。工作是接收和转发消息类似邮局，处理消息\n    - 异步消息：支持多种传递协议，消息排队，传递确认，到队列的灵活路由，多种交换类型\n    - 分布式部署：部署为集群以实现高可用和吞吐量\n    - 可靠性：可在性能和可靠性之间进行权衡\n    - 灵活的路由：通过交换机进行路由\n    - 多协议：多种消息协议的消息传递\n    - 管理与监控：HTTP-API，命令行工具\n  - **基本慨念：**\n    - Producer：生产者，投递消息的程序：创建消息（消息体和标签），RabbitMQ会根据标签把消息发送给消费者\n    - Consumer：消费者，接收消息的程序：丢弃标签，消费消息体\n    - Broker：消息中间件的服务节点：RabbitMQ服务实例\n    - Queue：队列：内部对象，用于存储信息，生产者投递，消费者取出消费\n    - Xchange：交换器。指定消息按什么规则，路由到哪个队列，如果路由不到或返回或丢弃\n    - RoutingKey：路由键关键字，Xchange根据此来进行邮递，需要与交换器类型和绑定键联合使用，决定消息流向哪里\n    - Binding：绑定，把Xchange和Queue按照路由规则绑定起来，指定绑定键（BindingKey）\n  \n- 任务执行单元（消费者worker）：可以有多个并发，实时监控消息队列，获取任务并执行它\n\n- 任务执行结果存储（task result store）：由于是由主任务中解耦出来的，主任务想要知道执行结果，必须通过中间件存储\n\n\n\n# 二、Q&F\n\n## 1  消息队列的理解\n\n**消息队列**：保存消息的容器\n\n消息:传输的数据单位\n\n消息源与目标间的中间人，主要目的是**提供路由保证消息的传递**，\n\n## 2  为什么使用消息队列\n\n在高并发情况下，来不及同步处理，请求会发生堵塞。通过消息队列，可以异步处理请求，缓解系统压力\n\n应用场景：\n\n- 异步处理、应用解耦、流量削锋和消息通讯等  \n\n**使用消息队列，把不是必须的业务逻辑，异步处理**\n\n消息队列的缺点：\n\n- 系统可用性降低\n- 系统复杂性提高\n- 一致性问题\n\n## 3  多线程在web中的使用\n\n一般在使用IO操作时\n\n使用场景：\n\n- 需要并行操作几个文件的读写，同步不能异步的情况下\n- 视图中需要多个第三方接口\n- 订单提交后，修改库存销量\n\n## 4  为什么使用celery而不使用线程发送耗时任务\n\n因为并发量较大的时候，线程切换会有开销时间，也会降低并发的数量、共享数据维护麻烦\n\ncelery是通过消息队列进行异步任务处理，不用担心并发量高是负载过大，也可以处理复杂系统性能问题，相对灵活\n\n## 5 什么是乐观锁\n\n每次拿数据的时候都认为别人不会修改，所以不会上锁\n\n在更新的时候判断此时的库存是否是之前查询出的库存，如果相同，表示没人修改，可以更新库存，否则表示别人抢过资源，不再执行库存更新\n\n**实现方式：**利用时间戳、数据版本version字段，数据被修改＋1\n\n使用场景：高并发，减少数据冲突，保证数据一致性\n\n## 6 高并发与分布式的应用场景\n\n处理网站并发量\n\n1. 减少数据库访问次数\n2. 文件和数据库分离（静态化页面）\n3. 大数据分布式存储（主从配置读写分离）\n4. 服务器集群，负载均衡\n5. 页面缓存的使用\n6. 内存数据库代替关系型数据库\n\n例子：省市区三级联动、首页部分数据（广告）局部缓存\n\n分布式案例\n\n1. MySQL主从配置读写分离\n\n## 7  处理抢购高并发\n\n1. 将请求尽量拦截在上游\n2. 充分利用缓存\n\n前端方面：\n\n- 把详情页部署到CDN节点上，做页面静态化处理\n  - CDN：内容分发网络，将源站内容分发到离用户最近的节点，提高访问速度\n- 禁止重复提交请求、对用户请求限流\n\n后端方面：\n\n- 根据用户id限制访问频率\n- 缓存的应用\n\n## 8  如何解决celery队列阻塞问题\n\n- 队列阻塞的原因：\n\n  1. 队列中有耗时任务，且任务量大于celery并发数（Celery没有足够的worker去执行耗时任务）\n  2. 队列中有耗时任务，且Celery启动了**预取机制**\n     - 任务会有指定的worker去执行，就算其worker是空闲状态，也不会执行其它任务\n\n- 解决：\n\n  - **指定进程数**\n\n    `celery -A project worker --concurrency=4`\n\n  - **改变进程池方式为协程方式**\n\n    `pip install eventlet `\n\n    `celery -A project worker -P eventlet -c 1000`\n\n  - **增加并发数**\n\n  `celery -A project worker -n 进程名字 --concurrencu=并发数 -l info`\n\n  - **取消预取机制**\n\n    ```python\n    # 任务发送完成时是否需要确认，对性能会稍有影响\n    celery_app.conf.CELERY_LATE = True\n    # Celery worker每次去队列取任务的数量，默认值为4\n    celery_app.conf.CELERY_PREFETCH_MULTIPLIER = 1\n    ```\n\n    `celery -A project worker -n 进程名字 -Ofair -l info`\n\n  - **错误重试机制**\n\n    ```python\n    # 重连时间间隔\n    @celery_app.task(bind=True, retry_backoff=3)\n    try:\n        ...\n    except Exception as e:\n        # 有异常自动重连三次\n        raise self.retry(exc=e, max_retries=3)\n    ```\n\n## 9  进程和线程的对比\n\n[参考文档](https://handout-1300728887.cos.ap-beijing.myqcloud.com/%E8%AE%B2%E4%B9%89/python-web%E5%9F%BA%E7%A1%80(5.1.2%E7%89%88%E6%9C%AC)/multitasking/%E8%BF%9B%E7%A8%8B%E5%92%8C%E7%BA%BF%E7%A8%8B%E5%AF%B9%E6%AF%94.html)\n\n进程：CPU的一种执行单元\n\n- 密集CPU任务（大量并行计算）\n\n线程：进程执行程序的最小调度单位\n\n- 密集I/O任务\n\n协程：微线程，可以在单线程上执行多个任务，用函数切换，开销极小\n\n#### 关系对比\n\n1. 线程是依附在进程里面的，没有进程就没有线程\n2. 一个进程默认提供一条线程，进程可以创建多个线程\n\n#### 区别对比\n\n1. 进程之间不共享全局变量\n2. 线程之间共享全局变量，但是要注意资源竞争的问题，解决办法: 互斥锁或者线程同步\n3. 创建进程的资源开销要比创建线程的资源开销要大\n4. 进程是操作系统资源分配的基本单位，线程是CPU调度的基本单位\n5. 线程不能够独立执行，必须依存在进程中\n6. 多进程开发比单进程多线程开发稳定性要强\n\n#### 优缺点\n\n- 进程优缺点:\n  - 优点：可以用多核\n  - 缺点：资源开销大\n- 线程优缺点:\n  - 优点：资源开销小\n  - 缺点：不能使用多核做到高并行","slug":"Python高并发场景","published":1,"updated":"2020-09-30T08:04:03.601Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckfp5akff000kn8jhddcm5ujn","content":"<h1 id=\"一、celery异步\"><a href=\"#一、celery异步\" class=\"headerlink\" title=\"一、celery异步\"></a>一、celery异步</h1><p>celery是异步任务的调度工具，主要解决耗时任务，通过<strong>消息队列</strong>在客户端与消费者间协调</p>\n<ul>\n<li><p>消息中间件（消息队列Broker）：客户端把任务放入队列中，消费者从队列中取出任务执行，第三方队列服务：RabbitMQ\\redis\\kafka\\MetaMQ\\RocketMQ</p>\n<a id=\"more\"></a>\n\n<ul>\n<li><strong>RabbitMQ：</strong>是一个消息代理。工作是接收和转发消息类似邮局，处理消息<ul>\n<li>异步消息：支持多种传递协议，消息排队，传递确认，到队列的灵活路由，多种交换类型</li>\n<li>分布式部署：部署为集群以实现高可用和吞吐量</li>\n<li>可靠性：可在性能和可靠性之间进行权衡</li>\n<li>灵活的路由：通过交换机进行路由</li>\n<li>多协议：多种消息协议的消息传递</li>\n<li>管理与监控：HTTP-API，命令行工具</li>\n</ul>\n</li>\n<li><strong>基本慨念：</strong><ul>\n<li>Producer：生产者，投递消息的程序：创建消息（消息体和标签），RabbitMQ会根据标签把消息发送给消费者</li>\n<li>Consumer：消费者，接收消息的程序：丢弃标签，消费消息体</li>\n<li>Broker：消息中间件的服务节点：RabbitMQ服务实例</li>\n<li>Queue：队列：内部对象，用于存储信息，生产者投递，消费者取出消费</li>\n<li>Xchange：交换器。指定消息按什么规则，路由到哪个队列，如果路由不到或返回或丢弃</li>\n<li>RoutingKey：路由键关键字，Xchange根据此来进行邮递，需要与交换器类型和绑定键联合使用，决定消息流向哪里</li>\n<li>Binding：绑定，把Xchange和Queue按照路由规则绑定起来，指定绑定键（BindingKey）</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>任务执行单元（消费者worker）：可以有多个并发，实时监控消息队列，获取任务并执行它</p>\n</li>\n<li><p>任务执行结果存储（task result store）：由于是由主任务中解耦出来的，主任务想要知道执行结果，必须通过中间件存储</p>\n</li>\n</ul>\n<h1 id=\"二、Q-amp-F\"><a href=\"#二、Q-amp-F\" class=\"headerlink\" title=\"二、Q&amp;F\"></a>二、Q&amp;F</h1><h2 id=\"1-消息队列的理解\"><a href=\"#1-消息队列的理解\" class=\"headerlink\" title=\"1  消息队列的理解\"></a>1  消息队列的理解</h2><p><strong>消息队列</strong>：保存消息的容器</p>\n<p>消息:传输的数据单位</p>\n<p>消息源与目标间的中间人，主要目的是<strong>提供路由保证消息的传递</strong>，</p>\n<h2 id=\"2-为什么使用消息队列\"><a href=\"#2-为什么使用消息队列\" class=\"headerlink\" title=\"2  为什么使用消息队列\"></a>2  为什么使用消息队列</h2><p>在高并发情况下，来不及同步处理，请求会发生堵塞。通过消息队列，可以异步处理请求，缓解系统压力</p>\n<p>应用场景：</p>\n<ul>\n<li>异步处理、应用解耦、流量削锋和消息通讯等  </li>\n</ul>\n<p><strong>使用消息队列，把不是必须的业务逻辑，异步处理</strong></p>\n<p>消息队列的缺点：</p>\n<ul>\n<li>系统可用性降低</li>\n<li>系统复杂性提高</li>\n<li>一致性问题</li>\n</ul>\n<h2 id=\"3-多线程在web中的使用\"><a href=\"#3-多线程在web中的使用\" class=\"headerlink\" title=\"3  多线程在web中的使用\"></a>3  多线程在web中的使用</h2><p>一般在使用IO操作时</p>\n<p>使用场景：</p>\n<ul>\n<li>需要并行操作几个文件的读写，同步不能异步的情况下</li>\n<li>视图中需要多个第三方接口</li>\n<li>订单提交后，修改库存销量</li>\n</ul>\n<h2 id=\"4-为什么使用celery而不使用线程发送耗时任务\"><a href=\"#4-为什么使用celery而不使用线程发送耗时任务\" class=\"headerlink\" title=\"4  为什么使用celery而不使用线程发送耗时任务\"></a>4  为什么使用celery而不使用线程发送耗时任务</h2><p>因为并发量较大的时候，线程切换会有开销时间，也会降低并发的数量、共享数据维护麻烦</p>\n<p>celery是通过消息队列进行异步任务处理，不用担心并发量高是负载过大，也可以处理复杂系统性能问题，相对灵活</p>\n<h2 id=\"5-什么是乐观锁\"><a href=\"#5-什么是乐观锁\" class=\"headerlink\" title=\"5 什么是乐观锁\"></a>5 什么是乐观锁</h2><p>每次拿数据的时候都认为别人不会修改，所以不会上锁</p>\n<p>在更新的时候判断此时的库存是否是之前查询出的库存，如果相同，表示没人修改，可以更新库存，否则表示别人抢过资源，不再执行库存更新</p>\n<p><strong>实现方式：</strong>利用时间戳、数据版本version字段，数据被修改＋1</p>\n<p>使用场景：高并发，减少数据冲突，保证数据一致性</p>\n<h2 id=\"6-高并发与分布式的应用场景\"><a href=\"#6-高并发与分布式的应用场景\" class=\"headerlink\" title=\"6 高并发与分布式的应用场景\"></a>6 高并发与分布式的应用场景</h2><p>处理网站并发量</p>\n<ol>\n<li>减少数据库访问次数</li>\n<li>文件和数据库分离（静态化页面）</li>\n<li>大数据分布式存储（主从配置读写分离）</li>\n<li>服务器集群，负载均衡</li>\n<li>页面缓存的使用</li>\n<li>内存数据库代替关系型数据库</li>\n</ol>\n<p>例子：省市区三级联动、首页部分数据（广告）局部缓存</p>\n<p>分布式案例</p>\n<ol>\n<li>MySQL主从配置读写分离</li>\n</ol>\n<h2 id=\"7-处理抢购高并发\"><a href=\"#7-处理抢购高并发\" class=\"headerlink\" title=\"7  处理抢购高并发\"></a>7  处理抢购高并发</h2><ol>\n<li>将请求尽量拦截在上游</li>\n<li>充分利用缓存</li>\n</ol>\n<p>前端方面：</p>\n<ul>\n<li>把详情页部署到CDN节点上，做页面静态化处理<ul>\n<li>CDN：内容分发网络，将源站内容分发到离用户最近的节点，提高访问速度</li>\n</ul>\n</li>\n<li>禁止重复提交请求、对用户请求限流</li>\n</ul>\n<p>后端方面：</p>\n<ul>\n<li>根据用户id限制访问频率</li>\n<li>缓存的应用</li>\n</ul>\n<h2 id=\"8-如何解决celery队列阻塞问题\"><a href=\"#8-如何解决celery队列阻塞问题\" class=\"headerlink\" title=\"8  如何解决celery队列阻塞问题\"></a>8  如何解决celery队列阻塞问题</h2><ul>\n<li><p>队列阻塞的原因：</p>\n<ol>\n<li>队列中有耗时任务，且任务量大于celery并发数（Celery没有足够的worker去执行耗时任务）</li>\n<li>队列中有耗时任务，且Celery启动了<strong>预取机制</strong><ul>\n<li>任务会有指定的worker去执行，就算其worker是空闲状态，也不会执行其它任务</li>\n</ul>\n</li>\n</ol>\n</li>\n<li><p>解决：</p>\n<ul>\n<li><p><strong>指定进程数</strong></p>\n<p><code>celery -A project worker --concurrency=4</code></p>\n</li>\n<li><p><strong>改变进程池方式为协程方式</strong></p>\n<p><code>pip install eventlet</code></p>\n<p><code>celery -A project worker -P eventlet -c 1000</code></p>\n</li>\n<li><p><strong>增加并发数</strong></p>\n</li>\n</ul>\n<p><code>celery -A project worker -n 进程名字 --concurrencu=并发数 -l info</code></p>\n<ul>\n<li><p><strong>取消预取机制</strong></p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 任务发送完成时是否需要确认，对性能会稍有影响</span></span><br><span class=\"line\">celery_app.conf.CELERY_LATE = <span class=\"literal\">True</span></span><br><span class=\"line\"><span class=\"comment\"># Celery worker每次去队列取任务的数量，默认值为4</span></span><br><span class=\"line\">celery_app.conf.CELERY_PREFETCH_MULTIPLIER = <span class=\"number\">1</span></span><br></pre></td></tr></table></figure>\n\n<p><code>celery -A project worker -n 进程名字 -Ofair -l info</code></p>\n</li>\n<li><p><strong>错误重试机制</strong></p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 重连时间间隔</span></span><br><span class=\"line\"><span class=\"meta\">@celery_app.task(bind=True, retry_backoff=3)</span></span><br><span class=\"line\"><span class=\"keyword\">try</span>:</span><br><span class=\"line\">    ...</span><br><span class=\"line\"><span class=\"keyword\">except</span> Exception <span class=\"keyword\">as</span> e:</span><br><span class=\"line\">    <span class=\"comment\"># 有异常自动重连三次</span></span><br><span class=\"line\">    <span class=\"keyword\">raise</span> self.retry(exc=e, max_retries=<span class=\"number\">3</span>)</span><br></pre></td></tr></table></figure>\n\n</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"9-进程和线程的对比\"><a href=\"#9-进程和线程的对比\" class=\"headerlink\" title=\"9  进程和线程的对比\"></a>9  进程和线程的对比</h2><p><a href=\"https://handout-1300728887.cos.ap-beijing.myqcloud.com/%E8%AE%B2%E4%B9%89/python-web%E5%9F%BA%E7%A1%80(5.1.2%E7%89%88%E6%9C%AC)/multitasking/%E8%BF%9B%E7%A8%8B%E5%92%8C%E7%BA%BF%E7%A8%8B%E5%AF%B9%E6%AF%94.html\" target=\"_blank\" rel=\"noopener\">参考文档</a></p>\n<p>进程：CPU的一种执行单元</p>\n<ul>\n<li>密集CPU任务（大量并行计算）</li>\n</ul>\n<p>线程：进程执行程序的最小调度单位</p>\n<ul>\n<li>密集I/O任务</li>\n</ul>\n<p>协程：微线程，可以在单线程上执行多个任务，用函数切换，开销极小</p>\n<h4 id=\"关系对比\"><a href=\"#关系对比\" class=\"headerlink\" title=\"关系对比\"></a>关系对比</h4><ol>\n<li>线程是依附在进程里面的，没有进程就没有线程</li>\n<li>一个进程默认提供一条线程，进程可以创建多个线程</li>\n</ol>\n<h4 id=\"区别对比\"><a href=\"#区别对比\" class=\"headerlink\" title=\"区别对比\"></a>区别对比</h4><ol>\n<li>进程之间不共享全局变量</li>\n<li>线程之间共享全局变量，但是要注意资源竞争的问题，解决办法: 互斥锁或者线程同步</li>\n<li>创建进程的资源开销要比创建线程的资源开销要大</li>\n<li>进程是操作系统资源分配的基本单位，线程是CPU调度的基本单位</li>\n<li>线程不能够独立执行，必须依存在进程中</li>\n<li>多进程开发比单进程多线程开发稳定性要强</li>\n</ol>\n<h4 id=\"优缺点\"><a href=\"#优缺点\" class=\"headerlink\" title=\"优缺点\"></a>优缺点</h4><ul>\n<li>进程优缺点:<ul>\n<li>优点：可以用多核</li>\n<li>缺点：资源开销大</li>\n</ul>\n</li>\n<li>线程优缺点:<ul>\n<li>优点：资源开销小</li>\n<li>缺点：不能使用多核做到高并行</li>\n</ul>\n</li>\n</ul>\n","site":{"data":{}},"excerpt":"<h1 id=\"一、celery异步\"><a href=\"#一、celery异步\" class=\"headerlink\" title=\"一、celery异步\"></a>一、celery异步</h1><p>celery是异步任务的调度工具，主要解决耗时任务，通过<strong>消息队列</strong>在客户端与消费者间协调</p>\n<ul>\n<li><p>消息中间件（消息队列Broker）：客户端把任务放入队列中，消费者从队列中取出任务执行，第三方队列服务：RabbitMQ\\redis\\kafka\\MetaMQ\\RocketMQ</p>","more":"<ul>\n<li><strong>RabbitMQ：</strong>是一个消息代理。工作是接收和转发消息类似邮局，处理消息<ul>\n<li>异步消息：支持多种传递协议，消息排队，传递确认，到队列的灵活路由，多种交换类型</li>\n<li>分布式部署：部署为集群以实现高可用和吞吐量</li>\n<li>可靠性：可在性能和可靠性之间进行权衡</li>\n<li>灵活的路由：通过交换机进行路由</li>\n<li>多协议：多种消息协议的消息传递</li>\n<li>管理与监控：HTTP-API，命令行工具</li>\n</ul>\n</li>\n<li><strong>基本慨念：</strong><ul>\n<li>Producer：生产者，投递消息的程序：创建消息（消息体和标签），RabbitMQ会根据标签把消息发送给消费者</li>\n<li>Consumer：消费者，接收消息的程序：丢弃标签，消费消息体</li>\n<li>Broker：消息中间件的服务节点：RabbitMQ服务实例</li>\n<li>Queue：队列：内部对象，用于存储信息，生产者投递，消费者取出消费</li>\n<li>Xchange：交换器。指定消息按什么规则，路由到哪个队列，如果路由不到或返回或丢弃</li>\n<li>RoutingKey：路由键关键字，Xchange根据此来进行邮递，需要与交换器类型和绑定键联合使用，决定消息流向哪里</li>\n<li>Binding：绑定，把Xchange和Queue按照路由规则绑定起来，指定绑定键（BindingKey）</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>任务执行单元（消费者worker）：可以有多个并发，实时监控消息队列，获取任务并执行它</p>\n</li>\n<li><p>任务执行结果存储（task result store）：由于是由主任务中解耦出来的，主任务想要知道执行结果，必须通过中间件存储</p>\n</li>\n</ul>\n<h1 id=\"二、Q-amp-F\"><a href=\"#二、Q-amp-F\" class=\"headerlink\" title=\"二、Q&amp;F\"></a>二、Q&amp;F</h1><h2 id=\"1-消息队列的理解\"><a href=\"#1-消息队列的理解\" class=\"headerlink\" title=\"1  消息队列的理解\"></a>1  消息队列的理解</h2><p><strong>消息队列</strong>：保存消息的容器</p>\n<p>消息:传输的数据单位</p>\n<p>消息源与目标间的中间人，主要目的是<strong>提供路由保证消息的传递</strong>，</p>\n<h2 id=\"2-为什么使用消息队列\"><a href=\"#2-为什么使用消息队列\" class=\"headerlink\" title=\"2  为什么使用消息队列\"></a>2  为什么使用消息队列</h2><p>在高并发情况下，来不及同步处理，请求会发生堵塞。通过消息队列，可以异步处理请求，缓解系统压力</p>\n<p>应用场景：</p>\n<ul>\n<li>异步处理、应用解耦、流量削锋和消息通讯等  </li>\n</ul>\n<p><strong>使用消息队列，把不是必须的业务逻辑，异步处理</strong></p>\n<p>消息队列的缺点：</p>\n<ul>\n<li>系统可用性降低</li>\n<li>系统复杂性提高</li>\n<li>一致性问题</li>\n</ul>\n<h2 id=\"3-多线程在web中的使用\"><a href=\"#3-多线程在web中的使用\" class=\"headerlink\" title=\"3  多线程在web中的使用\"></a>3  多线程在web中的使用</h2><p>一般在使用IO操作时</p>\n<p>使用场景：</p>\n<ul>\n<li>需要并行操作几个文件的读写，同步不能异步的情况下</li>\n<li>视图中需要多个第三方接口</li>\n<li>订单提交后，修改库存销量</li>\n</ul>\n<h2 id=\"4-为什么使用celery而不使用线程发送耗时任务\"><a href=\"#4-为什么使用celery而不使用线程发送耗时任务\" class=\"headerlink\" title=\"4  为什么使用celery而不使用线程发送耗时任务\"></a>4  为什么使用celery而不使用线程发送耗时任务</h2><p>因为并发量较大的时候，线程切换会有开销时间，也会降低并发的数量、共享数据维护麻烦</p>\n<p>celery是通过消息队列进行异步任务处理，不用担心并发量高是负载过大，也可以处理复杂系统性能问题，相对灵活</p>\n<h2 id=\"5-什么是乐观锁\"><a href=\"#5-什么是乐观锁\" class=\"headerlink\" title=\"5 什么是乐观锁\"></a>5 什么是乐观锁</h2><p>每次拿数据的时候都认为别人不会修改，所以不会上锁</p>\n<p>在更新的时候判断此时的库存是否是之前查询出的库存，如果相同，表示没人修改，可以更新库存，否则表示别人抢过资源，不再执行库存更新</p>\n<p><strong>实现方式：</strong>利用时间戳、数据版本version字段，数据被修改＋1</p>\n<p>使用场景：高并发，减少数据冲突，保证数据一致性</p>\n<h2 id=\"6-高并发与分布式的应用场景\"><a href=\"#6-高并发与分布式的应用场景\" class=\"headerlink\" title=\"6 高并发与分布式的应用场景\"></a>6 高并发与分布式的应用场景</h2><p>处理网站并发量</p>\n<ol>\n<li>减少数据库访问次数</li>\n<li>文件和数据库分离（静态化页面）</li>\n<li>大数据分布式存储（主从配置读写分离）</li>\n<li>服务器集群，负载均衡</li>\n<li>页面缓存的使用</li>\n<li>内存数据库代替关系型数据库</li>\n</ol>\n<p>例子：省市区三级联动、首页部分数据（广告）局部缓存</p>\n<p>分布式案例</p>\n<ol>\n<li>MySQL主从配置读写分离</li>\n</ol>\n<h2 id=\"7-处理抢购高并发\"><a href=\"#7-处理抢购高并发\" class=\"headerlink\" title=\"7  处理抢购高并发\"></a>7  处理抢购高并发</h2><ol>\n<li>将请求尽量拦截在上游</li>\n<li>充分利用缓存</li>\n</ol>\n<p>前端方面：</p>\n<ul>\n<li>把详情页部署到CDN节点上，做页面静态化处理<ul>\n<li>CDN：内容分发网络，将源站内容分发到离用户最近的节点，提高访问速度</li>\n</ul>\n</li>\n<li>禁止重复提交请求、对用户请求限流</li>\n</ul>\n<p>后端方面：</p>\n<ul>\n<li>根据用户id限制访问频率</li>\n<li>缓存的应用</li>\n</ul>\n<h2 id=\"8-如何解决celery队列阻塞问题\"><a href=\"#8-如何解决celery队列阻塞问题\" class=\"headerlink\" title=\"8  如何解决celery队列阻塞问题\"></a>8  如何解决celery队列阻塞问题</h2><ul>\n<li><p>队列阻塞的原因：</p>\n<ol>\n<li>队列中有耗时任务，且任务量大于celery并发数（Celery没有足够的worker去执行耗时任务）</li>\n<li>队列中有耗时任务，且Celery启动了<strong>预取机制</strong><ul>\n<li>任务会有指定的worker去执行，就算其worker是空闲状态，也不会执行其它任务</li>\n</ul>\n</li>\n</ol>\n</li>\n<li><p>解决：</p>\n<ul>\n<li><p><strong>指定进程数</strong></p>\n<p><code>celery -A project worker --concurrency=4</code></p>\n</li>\n<li><p><strong>改变进程池方式为协程方式</strong></p>\n<p><code>pip install eventlet</code></p>\n<p><code>celery -A project worker -P eventlet -c 1000</code></p>\n</li>\n<li><p><strong>增加并发数</strong></p>\n</li>\n</ul>\n<p><code>celery -A project worker -n 进程名字 --concurrencu=并发数 -l info</code></p>\n<ul>\n<li><p><strong>取消预取机制</strong></p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 任务发送完成时是否需要确认，对性能会稍有影响</span></span><br><span class=\"line\">celery_app.conf.CELERY_LATE = <span class=\"literal\">True</span></span><br><span class=\"line\"><span class=\"comment\"># Celery worker每次去队列取任务的数量，默认值为4</span></span><br><span class=\"line\">celery_app.conf.CELERY_PREFETCH_MULTIPLIER = <span class=\"number\">1</span></span><br></pre></td></tr></table></figure>\n\n<p><code>celery -A project worker -n 进程名字 -Ofair -l info</code></p>\n</li>\n<li><p><strong>错误重试机制</strong></p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 重连时间间隔</span></span><br><span class=\"line\"><span class=\"meta\">@celery_app.task(bind=True, retry_backoff=3)</span></span><br><span class=\"line\"><span class=\"keyword\">try</span>:</span><br><span class=\"line\">    ...</span><br><span class=\"line\"><span class=\"keyword\">except</span> Exception <span class=\"keyword\">as</span> e:</span><br><span class=\"line\">    <span class=\"comment\"># 有异常自动重连三次</span></span><br><span class=\"line\">    <span class=\"keyword\">raise</span> self.retry(exc=e, max_retries=<span class=\"number\">3</span>)</span><br></pre></td></tr></table></figure>\n\n</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"9-进程和线程的对比\"><a href=\"#9-进程和线程的对比\" class=\"headerlink\" title=\"9  进程和线程的对比\"></a>9  进程和线程的对比</h2><p><a href=\"https://handout-1300728887.cos.ap-beijing.myqcloud.com/%E8%AE%B2%E4%B9%89/python-web%E5%9F%BA%E7%A1%80(5.1.2%E7%89%88%E6%9C%AC)/multitasking/%E8%BF%9B%E7%A8%8B%E5%92%8C%E7%BA%BF%E7%A8%8B%E5%AF%B9%E6%AF%94.html\" target=\"_blank\" rel=\"noopener\">参考文档</a></p>\n<p>进程：CPU的一种执行单元</p>\n<ul>\n<li>密集CPU任务（大量并行计算）</li>\n</ul>\n<p>线程：进程执行程序的最小调度单位</p>\n<ul>\n<li>密集I/O任务</li>\n</ul>\n<p>协程：微线程，可以在单线程上执行多个任务，用函数切换，开销极小</p>\n<h4 id=\"关系对比\"><a href=\"#关系对比\" class=\"headerlink\" title=\"关系对比\"></a>关系对比</h4><ol>\n<li>线程是依附在进程里面的，没有进程就没有线程</li>\n<li>一个进程默认提供一条线程，进程可以创建多个线程</li>\n</ol>\n<h4 id=\"区别对比\"><a href=\"#区别对比\" class=\"headerlink\" title=\"区别对比\"></a>区别对比</h4><ol>\n<li>进程之间不共享全局变量</li>\n<li>线程之间共享全局变量，但是要注意资源竞争的问题，解决办法: 互斥锁或者线程同步</li>\n<li>创建进程的资源开销要比创建线程的资源开销要大</li>\n<li>进程是操作系统资源分配的基本单位，线程是CPU调度的基本单位</li>\n<li>线程不能够独立执行，必须依存在进程中</li>\n<li>多进程开发比单进程多线程开发稳定性要强</li>\n</ol>\n<h4 id=\"优缺点\"><a href=\"#优缺点\" class=\"headerlink\" title=\"优缺点\"></a>优缺点</h4><ul>\n<li>进程优缺点:<ul>\n<li>优点：可以用多核</li>\n<li>缺点：资源开销大</li>\n</ul>\n</li>\n<li>线程优缺点:<ul>\n<li>优点：资源开销小</li>\n<li>缺点：不能使用多核做到高并行</li>\n</ul>\n</li>\n</ul>"},{"title":"有趣的小网站","date":"2020-07-11T03:11:03.000Z","top":0,"_content":"\n# 收集的有趣小网站总汇（不定期更新）\n\n## 资源搜索\n\n### 书籍\n\n1. [鸠摩搜书 - 电子书搜索引擎](https://www.jiumodiary.com/)\n2. [书伴 – 为静心阅读而生](https://bookfere.com/)\n3. [Library Genesis](http://gen.lib.rus.ec/)\n\n<!--more-->\n\n###  网盘\n\n1. [去转盘](https://www.quzhuanpan.com/)\n\n### 设计素材\n\n1. [爱给网——视频素材——音效配音](http://www.aigei.com/)\n2. [搞定设计](https://www.gaoding.com/)\n\n### PPT\n\n1. [slidesgo](https://slidesgo.com/)\n\n##  下载相关\n\n1. [MSDN我告诉你 - MSDN原版系统,MSDN官网镜像下载](http://www.imsdn.cn/)\n2. [精品绿色便携软件](https://www.portablesoft.org/)\n3. [win版软件目录](https://mp.weixin.qq.com/s?__biz=MzIzNzcyMTgwMg==&mid=100000238&idx=1&sn=9acce874990a972b14071656d80d0315&chksm=68c5004b5fb2895dc934d464bcc66ac086e006d831fea8025e5381deef936652788a25312085&mpshare=1&scene=1&srcid=0925nq3Gr3C1BXDRBNj7h3wB&sharer_sharetime=1601014647909&sharer_shareid=5318e70eaace126767ff22531de28fe8&version=3.0.31.2998&platform=win&rd2werd=1#wechat_redirect)\n\n## 私单\n\n1. [猪八戒网](https://www.zbj.com/)\n2. [威客_时间财富网](http://www.680.com/)\n3. [一品威客网](http://www.epwk.com/)\n\n##  工具\n\n1. [禾坡运营导航](http://www.hepou.com/)\n2. [PDF文件转换](https://smallpdf.com/)\n3. [稳健工具](https://yuwenjian.cn/html/wjgjx.html)\n4. [孟坤工具](http://tool.mkblog.cn/)\n5. [菜鸟工具](https://c.runoob.com/)\n6. [在线工具](https://tool.lu/)\n7. [扩展迷——Google扩展](https://www.extfans.com/)\n\n##  IT相关\n\n1. [菜鸟教程](https://www.runoob.com/)\n2. [力扣（LeetCode）](https://leetcode-cn.com/)\n3. [JSON在线转换工具](https://www.sojson.com/)\n4. [一译——文档翻译](https://yiyibooks.cn/)\n\n### Docker\n\n1. [docker中文社区](https://www.docker.org.cn/index.html)\n\n###  Redis\n\n1. [Redis命令参考](http://doc.redisfans.com/)\n2. [Redis中文官网](http://redis.cn/)\n\n##  小游戏、小兴致\n\n1. [时光邮局——写给未来的自己](https://www.hi2future.com/)\n2. [IO games](http://iogames.fun/)\n\n##  视频\n\n1. [哔哩哔哩](https://www.bilibili.com/)\n\n## 文档\n\n1. [MySQL](https://boke-1300728887.cos.ap-beijing.myqcloud.com/Mysql(3).pdf)","source":"_posts/有趣的小网站.md","raw":"---\ntitle: 有趣的小网站\ndate: 2020-07-11 11:11:03\ntags: Luck\ntop: 0\n---\n\n# 收集的有趣小网站总汇（不定期更新）\n\n## 资源搜索\n\n### 书籍\n\n1. [鸠摩搜书 - 电子书搜索引擎](https://www.jiumodiary.com/)\n2. [书伴 – 为静心阅读而生](https://bookfere.com/)\n3. [Library Genesis](http://gen.lib.rus.ec/)\n\n<!--more-->\n\n###  网盘\n\n1. [去转盘](https://www.quzhuanpan.com/)\n\n### 设计素材\n\n1. [爱给网——视频素材——音效配音](http://www.aigei.com/)\n2. [搞定设计](https://www.gaoding.com/)\n\n### PPT\n\n1. [slidesgo](https://slidesgo.com/)\n\n##  下载相关\n\n1. [MSDN我告诉你 - MSDN原版系统,MSDN官网镜像下载](http://www.imsdn.cn/)\n2. [精品绿色便携软件](https://www.portablesoft.org/)\n3. [win版软件目录](https://mp.weixin.qq.com/s?__biz=MzIzNzcyMTgwMg==&mid=100000238&idx=1&sn=9acce874990a972b14071656d80d0315&chksm=68c5004b5fb2895dc934d464bcc66ac086e006d831fea8025e5381deef936652788a25312085&mpshare=1&scene=1&srcid=0925nq3Gr3C1BXDRBNj7h3wB&sharer_sharetime=1601014647909&sharer_shareid=5318e70eaace126767ff22531de28fe8&version=3.0.31.2998&platform=win&rd2werd=1#wechat_redirect)\n\n## 私单\n\n1. [猪八戒网](https://www.zbj.com/)\n2. [威客_时间财富网](http://www.680.com/)\n3. [一品威客网](http://www.epwk.com/)\n\n##  工具\n\n1. [禾坡运营导航](http://www.hepou.com/)\n2. [PDF文件转换](https://smallpdf.com/)\n3. [稳健工具](https://yuwenjian.cn/html/wjgjx.html)\n4. [孟坤工具](http://tool.mkblog.cn/)\n5. [菜鸟工具](https://c.runoob.com/)\n6. [在线工具](https://tool.lu/)\n7. [扩展迷——Google扩展](https://www.extfans.com/)\n\n##  IT相关\n\n1. [菜鸟教程](https://www.runoob.com/)\n2. [力扣（LeetCode）](https://leetcode-cn.com/)\n3. [JSON在线转换工具](https://www.sojson.com/)\n4. [一译——文档翻译](https://yiyibooks.cn/)\n\n### Docker\n\n1. [docker中文社区](https://www.docker.org.cn/index.html)\n\n###  Redis\n\n1. [Redis命令参考](http://doc.redisfans.com/)\n2. [Redis中文官网](http://redis.cn/)\n\n##  小游戏、小兴致\n\n1. [时光邮局——写给未来的自己](https://www.hi2future.com/)\n2. [IO games](http://iogames.fun/)\n\n##  视频\n\n1. [哔哩哔哩](https://www.bilibili.com/)\n\n## 文档\n\n1. [MySQL](https://boke-1300728887.cos.ap-beijing.myqcloud.com/Mysql(3).pdf)","slug":"有趣的小网站","published":1,"updated":"2020-09-27T03:45:40.767Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckfp5akfh000mn8jh44c2f4ka","content":"<h1 id=\"收集的有趣小网站总汇（不定期更新）\"><a href=\"#收集的有趣小网站总汇（不定期更新）\" class=\"headerlink\" title=\"收集的有趣小网站总汇（不定期更新）\"></a>收集的有趣小网站总汇（不定期更新）</h1><h2 id=\"资源搜索\"><a href=\"#资源搜索\" class=\"headerlink\" title=\"资源搜索\"></a>资源搜索</h2><h3 id=\"书籍\"><a href=\"#书籍\" class=\"headerlink\" title=\"书籍\"></a>书籍</h3><ol>\n<li><a href=\"https://www.jiumodiary.com/\" target=\"_blank\" rel=\"noopener\">鸠摩搜书 - 电子书搜索引擎</a></li>\n<li><a href=\"https://bookfere.com/\" target=\"_blank\" rel=\"noopener\">书伴 – 为静心阅读而生</a></li>\n<li><a href=\"http://gen.lib.rus.ec/\" target=\"_blank\" rel=\"noopener\">Library Genesis</a></li>\n</ol>\n<a id=\"more\"></a>\n\n<h3 id=\"网盘\"><a href=\"#网盘\" class=\"headerlink\" title=\"网盘\"></a>网盘</h3><ol>\n<li><a href=\"https://www.quzhuanpan.com/\" target=\"_blank\" rel=\"noopener\">去转盘</a></li>\n</ol>\n<h3 id=\"设计素材\"><a href=\"#设计素材\" class=\"headerlink\" title=\"设计素材\"></a>设计素材</h3><ol>\n<li><a href=\"http://www.aigei.com/\" target=\"_blank\" rel=\"noopener\">爱给网——视频素材——音效配音</a></li>\n<li><a href=\"https://www.gaoding.com/\" target=\"_blank\" rel=\"noopener\">搞定设计</a></li>\n</ol>\n<h3 id=\"PPT\"><a href=\"#PPT\" class=\"headerlink\" title=\"PPT\"></a>PPT</h3><ol>\n<li><a href=\"https://slidesgo.com/\" target=\"_blank\" rel=\"noopener\">slidesgo</a></li>\n</ol>\n<h2 id=\"下载相关\"><a href=\"#下载相关\" class=\"headerlink\" title=\"下载相关\"></a>下载相关</h2><ol>\n<li><a href=\"http://www.imsdn.cn/\" target=\"_blank\" rel=\"noopener\">MSDN我告诉你 - MSDN原版系统,MSDN官网镜像下载</a></li>\n<li><a href=\"https://www.portablesoft.org/\" target=\"_blank\" rel=\"noopener\">精品绿色便携软件</a></li>\n<li><a href=\"https://mp.weixin.qq.com/s?__biz=MzIzNzcyMTgwMg==&mid=100000238&idx=1&sn=9acce874990a972b14071656d80d0315&chksm=68c5004b5fb2895dc934d464bcc66ac086e006d831fea8025e5381deef936652788a25312085&mpshare=1&scene=1&srcid=0925nq3Gr3C1BXDRBNj7h3wB&sharer_sharetime=1601014647909&sharer_shareid=5318e70eaace126767ff22531de28fe8&version=3.0.31.2998&platform=win&rd2werd=1#wechat_redirect\" target=\"_blank\" rel=\"noopener\">win版软件目录</a></li>\n</ol>\n<h2 id=\"私单\"><a href=\"#私单\" class=\"headerlink\" title=\"私单\"></a>私单</h2><ol>\n<li><a href=\"https://www.zbj.com/\" target=\"_blank\" rel=\"noopener\">猪八戒网</a></li>\n<li><a href=\"http://www.680.com/\" target=\"_blank\" rel=\"noopener\">威客_时间财富网</a></li>\n<li><a href=\"http://www.epwk.com/\" target=\"_blank\" rel=\"noopener\">一品威客网</a></li>\n</ol>\n<h2 id=\"工具\"><a href=\"#工具\" class=\"headerlink\" title=\"工具\"></a>工具</h2><ol>\n<li><a href=\"http://www.hepou.com/\" target=\"_blank\" rel=\"noopener\">禾坡运营导航</a></li>\n<li><a href=\"https://smallpdf.com/\" target=\"_blank\" rel=\"noopener\">PDF文件转换</a></li>\n<li><a href=\"https://yuwenjian.cn/html/wjgjx.html\" target=\"_blank\" rel=\"noopener\">稳健工具</a></li>\n<li><a href=\"http://tool.mkblog.cn/\" target=\"_blank\" rel=\"noopener\">孟坤工具</a></li>\n<li><a href=\"https://c.runoob.com/\" target=\"_blank\" rel=\"noopener\">菜鸟工具</a></li>\n<li><a href=\"https://tool.lu/\" target=\"_blank\" rel=\"noopener\">在线工具</a></li>\n<li><a href=\"https://www.extfans.com/\" target=\"_blank\" rel=\"noopener\">扩展迷——Google扩展</a></li>\n</ol>\n<h2 id=\"IT相关\"><a href=\"#IT相关\" class=\"headerlink\" title=\"IT相关\"></a>IT相关</h2><ol>\n<li><a href=\"https://www.runoob.com/\" target=\"_blank\" rel=\"noopener\">菜鸟教程</a></li>\n<li><a href=\"https://leetcode-cn.com/\" target=\"_blank\" rel=\"noopener\">力扣（LeetCode）</a></li>\n<li><a href=\"https://www.sojson.com/\" target=\"_blank\" rel=\"noopener\">JSON在线转换工具</a></li>\n<li><a href=\"https://yiyibooks.cn/\" target=\"_blank\" rel=\"noopener\">一译——文档翻译</a></li>\n</ol>\n<h3 id=\"Docker\"><a href=\"#Docker\" class=\"headerlink\" title=\"Docker\"></a>Docker</h3><ol>\n<li><a href=\"https://www.docker.org.cn/index.html\" target=\"_blank\" rel=\"noopener\">docker中文社区</a></li>\n</ol>\n<h3 id=\"Redis\"><a href=\"#Redis\" class=\"headerlink\" title=\"Redis\"></a>Redis</h3><ol>\n<li><a href=\"http://doc.redisfans.com/\" target=\"_blank\" rel=\"noopener\">Redis命令参考</a></li>\n<li><a href=\"http://redis.cn/\" target=\"_blank\" rel=\"noopener\">Redis中文官网</a></li>\n</ol>\n<h2 id=\"小游戏、小兴致\"><a href=\"#小游戏、小兴致\" class=\"headerlink\" title=\"小游戏、小兴致\"></a>小游戏、小兴致</h2><ol>\n<li><a href=\"https://www.hi2future.com/\" target=\"_blank\" rel=\"noopener\">时光邮局——写给未来的自己</a></li>\n<li><a href=\"http://iogames.fun/\" target=\"_blank\" rel=\"noopener\">IO games</a></li>\n</ol>\n<h2 id=\"视频\"><a href=\"#视频\" class=\"headerlink\" title=\"视频\"></a>视频</h2><ol>\n<li><a href=\"https://www.bilibili.com/\" target=\"_blank\" rel=\"noopener\">哔哩哔哩</a></li>\n</ol>\n<h2 id=\"文档\"><a href=\"#文档\" class=\"headerlink\" title=\"文档\"></a>文档</h2><ol>\n<li><a href=\"https://boke-1300728887.cos.ap-beijing.myqcloud.com/Mysql(3).pdf\" target=\"_blank\" rel=\"noopener\">MySQL</a></li>\n</ol>\n","site":{"data":{}},"excerpt":"<h1 id=\"收集的有趣小网站总汇（不定期更新）\"><a href=\"#收集的有趣小网站总汇（不定期更新）\" class=\"headerlink\" title=\"收集的有趣小网站总汇（不定期更新）\"></a>收集的有趣小网站总汇（不定期更新）</h1><h2 id=\"资源搜索\"><a href=\"#资源搜索\" class=\"headerlink\" title=\"资源搜索\"></a>资源搜索</h2><h3 id=\"书籍\"><a href=\"#书籍\" class=\"headerlink\" title=\"书籍\"></a>书籍</h3><ol>\n<li><a href=\"https://www.jiumodiary.com/\" target=\"_blank\" rel=\"noopener\">鸠摩搜书 - 电子书搜索引擎</a></li>\n<li><a href=\"https://bookfere.com/\" target=\"_blank\" rel=\"noopener\">书伴 – 为静心阅读而生</a></li>\n<li><a href=\"http://gen.lib.rus.ec/\" target=\"_blank\" rel=\"noopener\">Library Genesis</a></li>\n</ol>","more":"<h3 id=\"网盘\"><a href=\"#网盘\" class=\"headerlink\" title=\"网盘\"></a>网盘</h3><ol>\n<li><a href=\"https://www.quzhuanpan.com/\" target=\"_blank\" rel=\"noopener\">去转盘</a></li>\n</ol>\n<h3 id=\"设计素材\"><a href=\"#设计素材\" class=\"headerlink\" title=\"设计素材\"></a>设计素材</h3><ol>\n<li><a href=\"http://www.aigei.com/\" target=\"_blank\" rel=\"noopener\">爱给网——视频素材——音效配音</a></li>\n<li><a href=\"https://www.gaoding.com/\" target=\"_blank\" rel=\"noopener\">搞定设计</a></li>\n</ol>\n<h3 id=\"PPT\"><a href=\"#PPT\" class=\"headerlink\" title=\"PPT\"></a>PPT</h3><ol>\n<li><a href=\"https://slidesgo.com/\" target=\"_blank\" rel=\"noopener\">slidesgo</a></li>\n</ol>\n<h2 id=\"下载相关\"><a href=\"#下载相关\" class=\"headerlink\" title=\"下载相关\"></a>下载相关</h2><ol>\n<li><a href=\"http://www.imsdn.cn/\" target=\"_blank\" rel=\"noopener\">MSDN我告诉你 - MSDN原版系统,MSDN官网镜像下载</a></li>\n<li><a href=\"https://www.portablesoft.org/\" target=\"_blank\" rel=\"noopener\">精品绿色便携软件</a></li>\n<li><a href=\"https://mp.weixin.qq.com/s?__biz=MzIzNzcyMTgwMg==&mid=100000238&idx=1&sn=9acce874990a972b14071656d80d0315&chksm=68c5004b5fb2895dc934d464bcc66ac086e006d831fea8025e5381deef936652788a25312085&mpshare=1&scene=1&srcid=0925nq3Gr3C1BXDRBNj7h3wB&sharer_sharetime=1601014647909&sharer_shareid=5318e70eaace126767ff22531de28fe8&version=3.0.31.2998&platform=win&rd2werd=1#wechat_redirect\" target=\"_blank\" rel=\"noopener\">win版软件目录</a></li>\n</ol>\n<h2 id=\"私单\"><a href=\"#私单\" class=\"headerlink\" title=\"私单\"></a>私单</h2><ol>\n<li><a href=\"https://www.zbj.com/\" target=\"_blank\" rel=\"noopener\">猪八戒网</a></li>\n<li><a href=\"http://www.680.com/\" target=\"_blank\" rel=\"noopener\">威客_时间财富网</a></li>\n<li><a href=\"http://www.epwk.com/\" target=\"_blank\" rel=\"noopener\">一品威客网</a></li>\n</ol>\n<h2 id=\"工具\"><a href=\"#工具\" class=\"headerlink\" title=\"工具\"></a>工具</h2><ol>\n<li><a href=\"http://www.hepou.com/\" target=\"_blank\" rel=\"noopener\">禾坡运营导航</a></li>\n<li><a href=\"https://smallpdf.com/\" target=\"_blank\" rel=\"noopener\">PDF文件转换</a></li>\n<li><a href=\"https://yuwenjian.cn/html/wjgjx.html\" target=\"_blank\" rel=\"noopener\">稳健工具</a></li>\n<li><a href=\"http://tool.mkblog.cn/\" target=\"_blank\" rel=\"noopener\">孟坤工具</a></li>\n<li><a href=\"https://c.runoob.com/\" target=\"_blank\" rel=\"noopener\">菜鸟工具</a></li>\n<li><a href=\"https://tool.lu/\" target=\"_blank\" rel=\"noopener\">在线工具</a></li>\n<li><a href=\"https://www.extfans.com/\" target=\"_blank\" rel=\"noopener\">扩展迷——Google扩展</a></li>\n</ol>\n<h2 id=\"IT相关\"><a href=\"#IT相关\" class=\"headerlink\" title=\"IT相关\"></a>IT相关</h2><ol>\n<li><a href=\"https://www.runoob.com/\" target=\"_blank\" rel=\"noopener\">菜鸟教程</a></li>\n<li><a href=\"https://leetcode-cn.com/\" target=\"_blank\" rel=\"noopener\">力扣（LeetCode）</a></li>\n<li><a href=\"https://www.sojson.com/\" target=\"_blank\" rel=\"noopener\">JSON在线转换工具</a></li>\n<li><a href=\"https://yiyibooks.cn/\" target=\"_blank\" rel=\"noopener\">一译——文档翻译</a></li>\n</ol>\n<h3 id=\"Docker\"><a href=\"#Docker\" class=\"headerlink\" title=\"Docker\"></a>Docker</h3><ol>\n<li><a href=\"https://www.docker.org.cn/index.html\" target=\"_blank\" rel=\"noopener\">docker中文社区</a></li>\n</ol>\n<h3 id=\"Redis\"><a href=\"#Redis\" class=\"headerlink\" title=\"Redis\"></a>Redis</h3><ol>\n<li><a href=\"http://doc.redisfans.com/\" target=\"_blank\" rel=\"noopener\">Redis命令参考</a></li>\n<li><a href=\"http://redis.cn/\" target=\"_blank\" rel=\"noopener\">Redis中文官网</a></li>\n</ol>\n<h2 id=\"小游戏、小兴致\"><a href=\"#小游戏、小兴致\" class=\"headerlink\" title=\"小游戏、小兴致\"></a>小游戏、小兴致</h2><ol>\n<li><a href=\"https://www.hi2future.com/\" target=\"_blank\" rel=\"noopener\">时光邮局——写给未来的自己</a></li>\n<li><a href=\"http://iogames.fun/\" target=\"_blank\" rel=\"noopener\">IO games</a></li>\n</ol>\n<h2 id=\"视频\"><a href=\"#视频\" class=\"headerlink\" title=\"视频\"></a>视频</h2><ol>\n<li><a href=\"https://www.bilibili.com/\" target=\"_blank\" rel=\"noopener\">哔哩哔哩</a></li>\n</ol>\n<h2 id=\"文档\"><a href=\"#文档\" class=\"headerlink\" title=\"文档\"></a>文档</h2><ol>\n<li><a href=\"https://boke-1300728887.cos.ap-beijing.myqcloud.com/Mysql(3).pdf\" target=\"_blank\" rel=\"noopener\">MySQL</a></li>\n</ol>"},{"title":"测试","date":"2020-05-03T02:55:13.000Z","top":0,"_content":"\n测试  \n\n- 手工测试\n- web自动化测试\n- 接口测试\n- 移动自动化测试\n- 缺陷工具的使用\n\n软件测试是一种实际输出与预期输出之间的审核或比较的过程\n\n<!--more-->\n\n**目的**\n\n1. 发现错误\n\n2. 证明程序有错\n\n3. 记录软件使用过程中的一些数据\n\n4. 降低开发风险\n\n   以最少的人力物力和时间找出软件潜在的各种错误和缺陷，通过修改更正，提高软件质量，消除隐患风险\n\n**原则**\n\n1. 测试证明软件存在缺陷\n2. 不能执行穷尽测试\n3. 尽早介入\n4. 缺陷存在群集现象\n5. 需要专门的测试环境\n6. 不存在没有缺陷的软件\n\n### 软件开发模型\n\n**软件开发过程模型**是软件开发人员在公司里工作的过程\n\n1. 瀑布模型\n   - 线性\n2. 快速原型模型\n3. 增量模型\n4. 螺旋模型\n\n### 测试模型\n\n- **单元测试（白盒测试）**：模块测试，验证软件的基本组成单位的正确性\n\n- **集成测试（灰盒测试）**：模块间的测试，测试接口（功能＋接口）\n\n- 系统测试\n  - 冒烟测试：主干流程测试，确认软件基本功能\n  - 系统测试（黑盒测试）：检测系统功能、质量性能是否满足系统的要求\n  - 回归测试：修改了旧代码之后重新进行测试\n- **验收测试**：确保软件是否满足用户需求\n\n**V模型：**强调了在整个软件项目开发中需要经历的若干个测试级别，并与每一个开发级别对应；\n\n**W模型：**补充了V模型中忽略的内容，强调了测试计划等工作的先行和对系统需求和系统设计的测试\n\n**H模型：**强调测试是独立的，只要测试准备完成，就可以执行\n\n### 软件测试的分类\n\n![](https://tupian-1300728887.cos.ap-chengdu.myqcloud.com/classify.png)\n\n### 软件测试的流程\n\n需求分析 --> 测试计划 --> 测试设计 --> 测试执行 --> 评估\n\n# 测试用例（TestCase）\n\n为某个特殊目标而编制的一组测试输入、执行条件以及预期结果。以便测试某个程序路径或核实是否满足某个特定需求，为了**高效率地发现软件缺陷而精心设计**的少量测试数据\n\n**测试用例的特性：**\n\n1. 有效性\n2. 可复用性\n3. 易组织性\n4. 可评估性\n5. 可管理性\n\n**测试用例八大要素：**\n\n1. 测试用例编号\n2. 测试用例标题\n3. 测试项目\n4. 前提条件（硬件和软件环境）\n5. 测试输入\n6. 预期输出\n7. 操作步骤\n8. 级别\n\n**测试用例的原则：**\n\n1. 保证测试用例的明确性\n2. 保证测试用例的代表性\n3. 保证测试用例的简洁性\n\n## 测试用例设计方法\n\n常用的测试用例设计方法：**等价类划分法、边界值分析法、判定表法、正交验证法、错误推测法、场景法、因果法**\n\n### 等价类划分法\n\n把所有可能的输入数据，分成若干部分，然后从每部分中选取少数代表性的数据\n\n- 有效等价类：合理的、有意义的\n  - 检验功能和性能\n- 无效等价类：不合理的、无意义的\n  - 对无效数据的处理能力、健壮性\n\n### 边界值法\n\n对输入或输出边界值进行测试，也是一种黑盒测试\n\n和等价类划分法的区别：\n\n- 是等价类划分法的补充\n- 等价类划分法可以挑选等价范围任意一个数据作为代表，边界值分析法要求每个边界值都要作为测试条件\n- 输入输出都考虑\n\n常见的边界值：\n\n**边界点（上点）**：输入范围的边界点\n\n**离店**：两边界点最近的点\n\n**内点**：输入范围内任意一个点\n\n### 判定表法\n\n**判定表也称决策表，是分析和表达多逻辑条件下执行不同操作的工具**\n\n组成：\n\n- 条件桩：列出问题得所有条件\n- 动作桩：列出问题规定可能采取的操作\n- 条件项：列出针对它左列条件的取值\n- 动作项：列出在条件项的各种取值情况下应该采取的动作","source":"_posts/测试.md","raw":"---\ntitle: 测试\ndate: 2020-05-03 10:55:13\ntags: 测试\ntop: 0\n---\n\n测试  \n\n- 手工测试\n- web自动化测试\n- 接口测试\n- 移动自动化测试\n- 缺陷工具的使用\n\n软件测试是一种实际输出与预期输出之间的审核或比较的过程\n\n<!--more-->\n\n**目的**\n\n1. 发现错误\n\n2. 证明程序有错\n\n3. 记录软件使用过程中的一些数据\n\n4. 降低开发风险\n\n   以最少的人力物力和时间找出软件潜在的各种错误和缺陷，通过修改更正，提高软件质量，消除隐患风险\n\n**原则**\n\n1. 测试证明软件存在缺陷\n2. 不能执行穷尽测试\n3. 尽早介入\n4. 缺陷存在群集现象\n5. 需要专门的测试环境\n6. 不存在没有缺陷的软件\n\n### 软件开发模型\n\n**软件开发过程模型**是软件开发人员在公司里工作的过程\n\n1. 瀑布模型\n   - 线性\n2. 快速原型模型\n3. 增量模型\n4. 螺旋模型\n\n### 测试模型\n\n- **单元测试（白盒测试）**：模块测试，验证软件的基本组成单位的正确性\n\n- **集成测试（灰盒测试）**：模块间的测试，测试接口（功能＋接口）\n\n- 系统测试\n  - 冒烟测试：主干流程测试，确认软件基本功能\n  - 系统测试（黑盒测试）：检测系统功能、质量性能是否满足系统的要求\n  - 回归测试：修改了旧代码之后重新进行测试\n- **验收测试**：确保软件是否满足用户需求\n\n**V模型：**强调了在整个软件项目开发中需要经历的若干个测试级别，并与每一个开发级别对应；\n\n**W模型：**补充了V模型中忽略的内容，强调了测试计划等工作的先行和对系统需求和系统设计的测试\n\n**H模型：**强调测试是独立的，只要测试准备完成，就可以执行\n\n### 软件测试的分类\n\n![](https://tupian-1300728887.cos.ap-chengdu.myqcloud.com/classify.png)\n\n### 软件测试的流程\n\n需求分析 --> 测试计划 --> 测试设计 --> 测试执行 --> 评估\n\n# 测试用例（TestCase）\n\n为某个特殊目标而编制的一组测试输入、执行条件以及预期结果。以便测试某个程序路径或核实是否满足某个特定需求，为了**高效率地发现软件缺陷而精心设计**的少量测试数据\n\n**测试用例的特性：**\n\n1. 有效性\n2. 可复用性\n3. 易组织性\n4. 可评估性\n5. 可管理性\n\n**测试用例八大要素：**\n\n1. 测试用例编号\n2. 测试用例标题\n3. 测试项目\n4. 前提条件（硬件和软件环境）\n5. 测试输入\n6. 预期输出\n7. 操作步骤\n8. 级别\n\n**测试用例的原则：**\n\n1. 保证测试用例的明确性\n2. 保证测试用例的代表性\n3. 保证测试用例的简洁性\n\n## 测试用例设计方法\n\n常用的测试用例设计方法：**等价类划分法、边界值分析法、判定表法、正交验证法、错误推测法、场景法、因果法**\n\n### 等价类划分法\n\n把所有可能的输入数据，分成若干部分，然后从每部分中选取少数代表性的数据\n\n- 有效等价类：合理的、有意义的\n  - 检验功能和性能\n- 无效等价类：不合理的、无意义的\n  - 对无效数据的处理能力、健壮性\n\n### 边界值法\n\n对输入或输出边界值进行测试，也是一种黑盒测试\n\n和等价类划分法的区别：\n\n- 是等价类划分法的补充\n- 等价类划分法可以挑选等价范围任意一个数据作为代表，边界值分析法要求每个边界值都要作为测试条件\n- 输入输出都考虑\n\n常见的边界值：\n\n**边界点（上点）**：输入范围的边界点\n\n**离店**：两边界点最近的点\n\n**内点**：输入范围内任意一个点\n\n### 判定表法\n\n**判定表也称决策表，是分析和表达多逻辑条件下执行不同操作的工具**\n\n组成：\n\n- 条件桩：列出问题得所有条件\n- 动作桩：列出问题规定可能采取的操作\n- 条件项：列出针对它左列条件的取值\n- 动作项：列出在条件项的各种取值情况下应该采取的动作","slug":"测试","published":1,"updated":"2020-08-11T07:15:29.651Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckfp5akfk000on8jh12zo70sx","content":"<p>测试  </p>\n<ul>\n<li>手工测试</li>\n<li>web自动化测试</li>\n<li>接口测试</li>\n<li>移动自动化测试</li>\n<li>缺陷工具的使用</li>\n</ul>\n<p>软件测试是一种实际输出与预期输出之间的审核或比较的过程</p>\n<a id=\"more\"></a>\n\n<p><strong>目的</strong></p>\n<ol>\n<li><p>发现错误</p>\n</li>\n<li><p>证明程序有错</p>\n</li>\n<li><p>记录软件使用过程中的一些数据</p>\n</li>\n<li><p>降低开发风险</p>\n<p>以最少的人力物力和时间找出软件潜在的各种错误和缺陷，通过修改更正，提高软件质量，消除隐患风险</p>\n</li>\n</ol>\n<p><strong>原则</strong></p>\n<ol>\n<li>测试证明软件存在缺陷</li>\n<li>不能执行穷尽测试</li>\n<li>尽早介入</li>\n<li>缺陷存在群集现象</li>\n<li>需要专门的测试环境</li>\n<li>不存在没有缺陷的软件</li>\n</ol>\n<h3 id=\"软件开发模型\"><a href=\"#软件开发模型\" class=\"headerlink\" title=\"软件开发模型\"></a>软件开发模型</h3><p><strong>软件开发过程模型</strong>是软件开发人员在公司里工作的过程</p>\n<ol>\n<li>瀑布模型<ul>\n<li>线性</li>\n</ul>\n</li>\n<li>快速原型模型</li>\n<li>增量模型</li>\n<li>螺旋模型</li>\n</ol>\n<h3 id=\"测试模型\"><a href=\"#测试模型\" class=\"headerlink\" title=\"测试模型\"></a>测试模型</h3><ul>\n<li><p><strong>单元测试（白盒测试）</strong>：模块测试，验证软件的基本组成单位的正确性</p>\n</li>\n<li><p><strong>集成测试（灰盒测试）</strong>：模块间的测试，测试接口（功能＋接口）</p>\n</li>\n<li><p>系统测试</p>\n<ul>\n<li>冒烟测试：主干流程测试，确认软件基本功能</li>\n<li>系统测试（黑盒测试）：检测系统功能、质量性能是否满足系统的要求</li>\n<li>回归测试：修改了旧代码之后重新进行测试</li>\n</ul>\n</li>\n<li><p><strong>验收测试</strong>：确保软件是否满足用户需求</p>\n</li>\n</ul>\n<p><strong>V模型：</strong>强调了在整个软件项目开发中需要经历的若干个测试级别，并与每一个开发级别对应；</p>\n<p><strong>W模型：</strong>补充了V模型中忽略的内容，强调了测试计划等工作的先行和对系统需求和系统设计的测试</p>\n<p><strong>H模型：</strong>强调测试是独立的，只要测试准备完成，就可以执行</p>\n<h3 id=\"软件测试的分类\"><a href=\"#软件测试的分类\" class=\"headerlink\" title=\"软件测试的分类\"></a>软件测试的分类</h3><p><img src=\"https://tupian-1300728887.cos.ap-chengdu.myqcloud.com/classify.png\" alt=\"\"></p>\n<h3 id=\"软件测试的流程\"><a href=\"#软件测试的流程\" class=\"headerlink\" title=\"软件测试的流程\"></a>软件测试的流程</h3><p>需求分析 –&gt; 测试计划 –&gt; 测试设计 –&gt; 测试执行 –&gt; 评估</p>\n<h1 id=\"测试用例（TestCase）\"><a href=\"#测试用例（TestCase）\" class=\"headerlink\" title=\"测试用例（TestCase）\"></a>测试用例（TestCase）</h1><p>为某个特殊目标而编制的一组测试输入、执行条件以及预期结果。以便测试某个程序路径或核实是否满足某个特定需求，为了<strong>高效率地发现软件缺陷而精心设计</strong>的少量测试数据</p>\n<p><strong>测试用例的特性：</strong></p>\n<ol>\n<li>有效性</li>\n<li>可复用性</li>\n<li>易组织性</li>\n<li>可评估性</li>\n<li>可管理性</li>\n</ol>\n<p><strong>测试用例八大要素：</strong></p>\n<ol>\n<li>测试用例编号</li>\n<li>测试用例标题</li>\n<li>测试项目</li>\n<li>前提条件（硬件和软件环境）</li>\n<li>测试输入</li>\n<li>预期输出</li>\n<li>操作步骤</li>\n<li>级别</li>\n</ol>\n<p><strong>测试用例的原则：</strong></p>\n<ol>\n<li>保证测试用例的明确性</li>\n<li>保证测试用例的代表性</li>\n<li>保证测试用例的简洁性</li>\n</ol>\n<h2 id=\"测试用例设计方法\"><a href=\"#测试用例设计方法\" class=\"headerlink\" title=\"测试用例设计方法\"></a>测试用例设计方法</h2><p>常用的测试用例设计方法：<strong>等价类划分法、边界值分析法、判定表法、正交验证法、错误推测法、场景法、因果法</strong></p>\n<h3 id=\"等价类划分法\"><a href=\"#等价类划分法\" class=\"headerlink\" title=\"等价类划分法\"></a>等价类划分法</h3><p>把所有可能的输入数据，分成若干部分，然后从每部分中选取少数代表性的数据</p>\n<ul>\n<li>有效等价类：合理的、有意义的<ul>\n<li>检验功能和性能</li>\n</ul>\n</li>\n<li>无效等价类：不合理的、无意义的<ul>\n<li>对无效数据的处理能力、健壮性</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"边界值法\"><a href=\"#边界值法\" class=\"headerlink\" title=\"边界值法\"></a>边界值法</h3><p>对输入或输出边界值进行测试，也是一种黑盒测试</p>\n<p>和等价类划分法的区别：</p>\n<ul>\n<li>是等价类划分法的补充</li>\n<li>等价类划分法可以挑选等价范围任意一个数据作为代表，边界值分析法要求每个边界值都要作为测试条件</li>\n<li>输入输出都考虑</li>\n</ul>\n<p>常见的边界值：</p>\n<p><strong>边界点（上点）</strong>：输入范围的边界点</p>\n<p><strong>离店</strong>：两边界点最近的点</p>\n<p><strong>内点</strong>：输入范围内任意一个点</p>\n<h3 id=\"判定表法\"><a href=\"#判定表法\" class=\"headerlink\" title=\"判定表法\"></a>判定表法</h3><p><strong>判定表也称决策表，是分析和表达多逻辑条件下执行不同操作的工具</strong></p>\n<p>组成：</p>\n<ul>\n<li>条件桩：列出问题得所有条件</li>\n<li>动作桩：列出问题规定可能采取的操作</li>\n<li>条件项：列出针对它左列条件的取值</li>\n<li>动作项：列出在条件项的各种取值情况下应该采取的动作</li>\n</ul>\n","site":{"data":{}},"excerpt":"<p>测试  </p>\n<ul>\n<li>手工测试</li>\n<li>web自动化测试</li>\n<li>接口测试</li>\n<li>移动自动化测试</li>\n<li>缺陷工具的使用</li>\n</ul>\n<p>软件测试是一种实际输出与预期输出之间的审核或比较的过程</p>","more":"<p><strong>目的</strong></p>\n<ol>\n<li><p>发现错误</p>\n</li>\n<li><p>证明程序有错</p>\n</li>\n<li><p>记录软件使用过程中的一些数据</p>\n</li>\n<li><p>降低开发风险</p>\n<p>以最少的人力物力和时间找出软件潜在的各种错误和缺陷，通过修改更正，提高软件质量，消除隐患风险</p>\n</li>\n</ol>\n<p><strong>原则</strong></p>\n<ol>\n<li>测试证明软件存在缺陷</li>\n<li>不能执行穷尽测试</li>\n<li>尽早介入</li>\n<li>缺陷存在群集现象</li>\n<li>需要专门的测试环境</li>\n<li>不存在没有缺陷的软件</li>\n</ol>\n<h3 id=\"软件开发模型\"><a href=\"#软件开发模型\" class=\"headerlink\" title=\"软件开发模型\"></a>软件开发模型</h3><p><strong>软件开发过程模型</strong>是软件开发人员在公司里工作的过程</p>\n<ol>\n<li>瀑布模型<ul>\n<li>线性</li>\n</ul>\n</li>\n<li>快速原型模型</li>\n<li>增量模型</li>\n<li>螺旋模型</li>\n</ol>\n<h3 id=\"测试模型\"><a href=\"#测试模型\" class=\"headerlink\" title=\"测试模型\"></a>测试模型</h3><ul>\n<li><p><strong>单元测试（白盒测试）</strong>：模块测试，验证软件的基本组成单位的正确性</p>\n</li>\n<li><p><strong>集成测试（灰盒测试）</strong>：模块间的测试，测试接口（功能＋接口）</p>\n</li>\n<li><p>系统测试</p>\n<ul>\n<li>冒烟测试：主干流程测试，确认软件基本功能</li>\n<li>系统测试（黑盒测试）：检测系统功能、质量性能是否满足系统的要求</li>\n<li>回归测试：修改了旧代码之后重新进行测试</li>\n</ul>\n</li>\n<li><p><strong>验收测试</strong>：确保软件是否满足用户需求</p>\n</li>\n</ul>\n<p><strong>V模型：</strong>强调了在整个软件项目开发中需要经历的若干个测试级别，并与每一个开发级别对应；</p>\n<p><strong>W模型：</strong>补充了V模型中忽略的内容，强调了测试计划等工作的先行和对系统需求和系统设计的测试</p>\n<p><strong>H模型：</strong>强调测试是独立的，只要测试准备完成，就可以执行</p>\n<h3 id=\"软件测试的分类\"><a href=\"#软件测试的分类\" class=\"headerlink\" title=\"软件测试的分类\"></a>软件测试的分类</h3><p><img src=\"https://tupian-1300728887.cos.ap-chengdu.myqcloud.com/classify.png\" alt=\"\"></p>\n<h3 id=\"软件测试的流程\"><a href=\"#软件测试的流程\" class=\"headerlink\" title=\"软件测试的流程\"></a>软件测试的流程</h3><p>需求分析 –&gt; 测试计划 –&gt; 测试设计 –&gt; 测试执行 –&gt; 评估</p>\n<h1 id=\"测试用例（TestCase）\"><a href=\"#测试用例（TestCase）\" class=\"headerlink\" title=\"测试用例（TestCase）\"></a>测试用例（TestCase）</h1><p>为某个特殊目标而编制的一组测试输入、执行条件以及预期结果。以便测试某个程序路径或核实是否满足某个特定需求，为了<strong>高效率地发现软件缺陷而精心设计</strong>的少量测试数据</p>\n<p><strong>测试用例的特性：</strong></p>\n<ol>\n<li>有效性</li>\n<li>可复用性</li>\n<li>易组织性</li>\n<li>可评估性</li>\n<li>可管理性</li>\n</ol>\n<p><strong>测试用例八大要素：</strong></p>\n<ol>\n<li>测试用例编号</li>\n<li>测试用例标题</li>\n<li>测试项目</li>\n<li>前提条件（硬件和软件环境）</li>\n<li>测试输入</li>\n<li>预期输出</li>\n<li>操作步骤</li>\n<li>级别</li>\n</ol>\n<p><strong>测试用例的原则：</strong></p>\n<ol>\n<li>保证测试用例的明确性</li>\n<li>保证测试用例的代表性</li>\n<li>保证测试用例的简洁性</li>\n</ol>\n<h2 id=\"测试用例设计方法\"><a href=\"#测试用例设计方法\" class=\"headerlink\" title=\"测试用例设计方法\"></a>测试用例设计方法</h2><p>常用的测试用例设计方法：<strong>等价类划分法、边界值分析法、判定表法、正交验证法、错误推测法、场景法、因果法</strong></p>\n<h3 id=\"等价类划分法\"><a href=\"#等价类划分法\" class=\"headerlink\" title=\"等价类划分法\"></a>等价类划分法</h3><p>把所有可能的输入数据，分成若干部分，然后从每部分中选取少数代表性的数据</p>\n<ul>\n<li>有效等价类：合理的、有意义的<ul>\n<li>检验功能和性能</li>\n</ul>\n</li>\n<li>无效等价类：不合理的、无意义的<ul>\n<li>对无效数据的处理能力、健壮性</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"边界值法\"><a href=\"#边界值法\" class=\"headerlink\" title=\"边界值法\"></a>边界值法</h3><p>对输入或输出边界值进行测试，也是一种黑盒测试</p>\n<p>和等价类划分法的区别：</p>\n<ul>\n<li>是等价类划分法的补充</li>\n<li>等价类划分法可以挑选等价范围任意一个数据作为代表，边界值分析法要求每个边界值都要作为测试条件</li>\n<li>输入输出都考虑</li>\n</ul>\n<p>常见的边界值：</p>\n<p><strong>边界点（上点）</strong>：输入范围的边界点</p>\n<p><strong>离店</strong>：两边界点最近的点</p>\n<p><strong>内点</strong>：输入范围内任意一个点</p>\n<h3 id=\"判定表法\"><a href=\"#判定表法\" class=\"headerlink\" title=\"判定表法\"></a>判定表法</h3><p><strong>判定表也称决策表，是分析和表达多逻辑条件下执行不同操作的工具</strong></p>\n<p>组成：</p>\n<ul>\n<li>条件桩：列出问题得所有条件</li>\n<li>动作桩：列出问题规定可能采取的操作</li>\n<li>条件项：列出针对它左列条件的取值</li>\n<li>动作项：列出在条件项的各种取值情况下应该采取的动作</li>\n</ul>"},{"title":"版本控制管理工具使用","date":"2020-09-30T03:26:15.000Z","top":0,"_content":"\n# 一、[GIT](https://learngitbranching.js.org/)\n\n## 常用命令\n\n- 克隆远程库\t`git clone 地址`\n- 添加到暂存    `git add .`\n\n<!--more-->\n\n- 提交暂存区的文件到本地仓库    `git commit -m 'test'`\n- 拉取    `git pull origin <name>`\n- 推送    `git push origin <name>`\n- 查看仓库当前的状态    `git status`\n- 查看远程库信息    `git remote`\n- 查看当前分支    `git branch` \n- 切换分支    `git checkout <name>`\n- 合并分支到当前分支    `git merge <name>`\n\n# 二、SVN\n\n","source":"_posts/版本控制管理工具使用.md","raw":"---\ntitle: 版本控制管理工具使用\ndate: 2020-09-30 11:26:15\ntags: tool\ntop: 0\n---\n\n# 一、[GIT](https://learngitbranching.js.org/)\n\n## 常用命令\n\n- 克隆远程库\t`git clone 地址`\n- 添加到暂存    `git add .`\n\n<!--more-->\n\n- 提交暂存区的文件到本地仓库    `git commit -m 'test'`\n- 拉取    `git pull origin <name>`\n- 推送    `git push origin <name>`\n- 查看仓库当前的状态    `git status`\n- 查看远程库信息    `git remote`\n- 查看当前分支    `git branch` \n- 切换分支    `git checkout <name>`\n- 合并分支到当前分支    `git merge <name>`\n\n# 二、SVN\n\n","slug":"版本控制管理工具使用","published":1,"updated":"2020-09-30T06:49:55.009Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckfp5akg20011n8jhgr3sg5qe","content":"<h1 id=\"一、GIT\"><a href=\"#一、GIT\" class=\"headerlink\" title=\"一、GIT\"></a>一、<a href=\"https://learngitbranching.js.org/\" target=\"_blank\" rel=\"noopener\">GIT</a></h1><h2 id=\"常用命令\"><a href=\"#常用命令\" class=\"headerlink\" title=\"常用命令\"></a>常用命令</h2><ul>\n<li>克隆远程库    <code>git clone 地址</code></li>\n<li>添加到暂存    <code>git add .</code></li>\n</ul>\n<a id=\"more\"></a>\n\n<ul>\n<li>提交暂存区的文件到本地仓库    <code>git commit -m &#39;test&#39;</code></li>\n<li>拉取    <code>git pull origin &lt;name&gt;</code></li>\n<li>推送    <code>git push origin &lt;name&gt;</code></li>\n<li>查看仓库当前的状态    <code>git status</code></li>\n<li>查看远程库信息    <code>git remote</code></li>\n<li>查看当前分支    <code>git branch</code> </li>\n<li>切换分支    <code>git checkout &lt;name&gt;</code></li>\n<li>合并分支到当前分支    <code>git merge &lt;name&gt;</code></li>\n</ul>\n<h1 id=\"二、SVN\"><a href=\"#二、SVN\" class=\"headerlink\" title=\"二、SVN\"></a>二、SVN</h1>","site":{"data":{}},"excerpt":"<h1 id=\"一、GIT\"><a href=\"#一、GIT\" class=\"headerlink\" title=\"一、GIT\"></a>一、<a href=\"https://learngitbranching.js.org/\" target=\"_blank\" rel=\"noopener\">GIT</a></h1><h2 id=\"常用命令\"><a href=\"#常用命令\" class=\"headerlink\" title=\"常用命令\"></a>常用命令</h2><ul>\n<li>克隆远程库    <code>git clone 地址</code></li>\n<li>添加到暂存    <code>git add .</code></li>\n</ul>","more":"<ul>\n<li>提交暂存区的文件到本地仓库    <code>git commit -m &#39;test&#39;</code></li>\n<li>拉取    <code>git pull origin &lt;name&gt;</code></li>\n<li>推送    <code>git push origin &lt;name&gt;</code></li>\n<li>查看仓库当前的状态    <code>git status</code></li>\n<li>查看远程库信息    <code>git remote</code></li>\n<li>查看当前分支    <code>git branch</code> </li>\n<li>切换分支    <code>git checkout &lt;name&gt;</code></li>\n<li>合并分支到当前分支    <code>git merge &lt;name&gt;</code></li>\n</ul>\n<h1 id=\"二、SVN\"><a href=\"#二、SVN\" class=\"headerlink\" title=\"二、SVN\"></a>二、SVN</h1>"},{"title":"部署相关","date":"2020-09-30T03:41:49.000Z","top":0,"_content":"\n# 一、nginx\n\n[参考文档](https://handout-1300728887.cos.ap-beijing.myqcloud.com/%E8%AE%B2%E4%B9%89/%E9%A1%B9%E7%9B%AE%E9%83%A8%E7%BD%B2/nginx/Advanced.html)\n\n**是一个高性能的HTTP和反向代理服务器，主要处理静态资源**\n\n### 1.1  [反向代理](https://handout-1300728887.cos.ap-beijing.myqcloud.com/%E8%AE%B2%E4%B9%89/%E9%A1%B9%E7%9B%AE%E9%83%A8%E7%BD%B2/nginx/nginx-reverse.html)\n\n正向代理： 为局域网**客户端**向外访问Internet服务**（代理用户，隐藏客户端）**\n\n反向代理： 为局域网**服务器**向外提供Internet服务**（代理服务器，隐藏服务器）**\n\n<!--more-->\n\n### 1.2  [负载均衡](https://handout-1300728887.cos.ap-beijing.myqcloud.com/%E8%AE%B2%E4%B9%89/%E9%A1%B9%E7%9B%AE%E9%83%A8%E7%BD%B2/nginx/nginx-load.html)\n\n有一台服务器充当调度者的身份（负载均衡器），请求先到达它，再根据每台服务器的负载情况分配请求\n\n1. 内置策略：nginx自带算法\n   - 雨露均沾型：轮训（默认）、加权轮训、哈希\n     - 轮训：按顺序逐一分配\n     - 加权轮训：权重越大，被分配几率越高，适用于服务器性能不均衡情况\n   - 定向服务型：ip_hash、least_conn、cookie、route、lean\n     - ip_hash：按访问IP的哈希结果分配请求，分配后访客访问固定后端服务器，有效的解决动态网页会话共享问题。\n   - 商业类型：ntlm、least_time、queue、stick\n2. 第三方算法：fair、url_hash\n   - fair：基于后端服务器的响应时间来分配请求，响应时间短的优先分配。\n   - url_hash：按访问的哈希结果分配请求，使同定向到同一台后端服务器，可提高后端缓存服务器的效率。\n\n### 1.3  提供静态文件\n\n静态文件收集命令：`python mange.py collectstatic`\n\n### 1.4  WSGI\n\n- WSGI是一种通信协议， Web 服务器(uWSGI)与 Web 应用程序或应用框架(Django)之间的一种低级别的接口\n- uwsgi是一种线路协议我不是一种通信协议，常用于在uWSGI服务器于其他网络服务器的数据通信\n- uWSGI是实现了uwsgi和WSGI两种协议的Web服务器，**主要处理动态资源**\n\n# 二、gunicorn\n\n[参考文档](https://handout-1300728887.cos.ap-beijing.myqcloud.com/%E8%AE%B2%E4%B9%89/%E9%BB%91%E9%A9%AC%E5%A4%B4%E6%9D%A1%E9%A1%B9%E7%9B%AE%E8%AF%BE%E4%BB%B6/C12-Deployment/Gunicorn.html)\n\n安装：`pip install gunicorn`\n\n查看使用信息：`$gunicorn -h`\n\n直接运行：`gunicorn 运行文件名称：flask程序实例名`\n\n指定进程和端口号：`$gunicorn -w 4 -b 127.0.0.1:5001 运行文件名称:Flask程序实例名","source":"_posts/部署相关.md","raw":"---\ntitle: 部署相关\ndate: 2020-09-30 11:41:49\ntags: Web\ntop: 0\n---\n\n# 一、nginx\n\n[参考文档](https://handout-1300728887.cos.ap-beijing.myqcloud.com/%E8%AE%B2%E4%B9%89/%E9%A1%B9%E7%9B%AE%E9%83%A8%E7%BD%B2/nginx/Advanced.html)\n\n**是一个高性能的HTTP和反向代理服务器，主要处理静态资源**\n\n### 1.1  [反向代理](https://handout-1300728887.cos.ap-beijing.myqcloud.com/%E8%AE%B2%E4%B9%89/%E9%A1%B9%E7%9B%AE%E9%83%A8%E7%BD%B2/nginx/nginx-reverse.html)\n\n正向代理： 为局域网**客户端**向外访问Internet服务**（代理用户，隐藏客户端）**\n\n反向代理： 为局域网**服务器**向外提供Internet服务**（代理服务器，隐藏服务器）**\n\n<!--more-->\n\n### 1.2  [负载均衡](https://handout-1300728887.cos.ap-beijing.myqcloud.com/%E8%AE%B2%E4%B9%89/%E9%A1%B9%E7%9B%AE%E9%83%A8%E7%BD%B2/nginx/nginx-load.html)\n\n有一台服务器充当调度者的身份（负载均衡器），请求先到达它，再根据每台服务器的负载情况分配请求\n\n1. 内置策略：nginx自带算法\n   - 雨露均沾型：轮训（默认）、加权轮训、哈希\n     - 轮训：按顺序逐一分配\n     - 加权轮训：权重越大，被分配几率越高，适用于服务器性能不均衡情况\n   - 定向服务型：ip_hash、least_conn、cookie、route、lean\n     - ip_hash：按访问IP的哈希结果分配请求，分配后访客访问固定后端服务器，有效的解决动态网页会话共享问题。\n   - 商业类型：ntlm、least_time、queue、stick\n2. 第三方算法：fair、url_hash\n   - fair：基于后端服务器的响应时间来分配请求，响应时间短的优先分配。\n   - url_hash：按访问的哈希结果分配请求，使同定向到同一台后端服务器，可提高后端缓存服务器的效率。\n\n### 1.3  提供静态文件\n\n静态文件收集命令：`python mange.py collectstatic`\n\n### 1.4  WSGI\n\n- WSGI是一种通信协议， Web 服务器(uWSGI)与 Web 应用程序或应用框架(Django)之间的一种低级别的接口\n- uwsgi是一种线路协议我不是一种通信协议，常用于在uWSGI服务器于其他网络服务器的数据通信\n- uWSGI是实现了uwsgi和WSGI两种协议的Web服务器，**主要处理动态资源**\n\n# 二、gunicorn\n\n[参考文档](https://handout-1300728887.cos.ap-beijing.myqcloud.com/%E8%AE%B2%E4%B9%89/%E9%BB%91%E9%A9%AC%E5%A4%B4%E6%9D%A1%E9%A1%B9%E7%9B%AE%E8%AF%BE%E4%BB%B6/C12-Deployment/Gunicorn.html)\n\n安装：`pip install gunicorn`\n\n查看使用信息：`$gunicorn -h`\n\n直接运行：`gunicorn 运行文件名称：flask程序实例名`\n\n指定进程和端口号：`$gunicorn -w 4 -b 127.0.0.1:5001 运行文件名称:Flask程序实例名","slug":"部署相关","published":1,"updated":"2020-09-30T08:06:59.477Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckfp5akg50012n8jhciowes1w","content":"<h1 id=\"一、nginx\"><a href=\"#一、nginx\" class=\"headerlink\" title=\"一、nginx\"></a>一、nginx</h1><p><a href=\"https://handout-1300728887.cos.ap-beijing.myqcloud.com/%E8%AE%B2%E4%B9%89/%E9%A1%B9%E7%9B%AE%E9%83%A8%E7%BD%B2/nginx/Advanced.html\" target=\"_blank\" rel=\"noopener\">参考文档</a></p>\n<p><strong>是一个高性能的HTTP和反向代理服务器，主要处理静态资源</strong></p>\n<h3 id=\"1-1-反向代理\"><a href=\"#1-1-反向代理\" class=\"headerlink\" title=\"1.1  反向代理\"></a>1.1  <a href=\"https://handout-1300728887.cos.ap-beijing.myqcloud.com/%E8%AE%B2%E4%B9%89/%E9%A1%B9%E7%9B%AE%E9%83%A8%E7%BD%B2/nginx/nginx-reverse.html\" target=\"_blank\" rel=\"noopener\">反向代理</a></h3><p>正向代理： 为局域网<strong>客户端</strong>向外访问Internet服务<strong>（代理用户，隐藏客户端）</strong></p>\n<p>反向代理： 为局域网<strong>服务器</strong>向外提供Internet服务<strong>（代理服务器，隐藏服务器）</strong></p>\n<a id=\"more\"></a>\n\n<h3 id=\"1-2-负载均衡\"><a href=\"#1-2-负载均衡\" class=\"headerlink\" title=\"1.2  负载均衡\"></a>1.2  <a href=\"https://handout-1300728887.cos.ap-beijing.myqcloud.com/%E8%AE%B2%E4%B9%89/%E9%A1%B9%E7%9B%AE%E9%83%A8%E7%BD%B2/nginx/nginx-load.html\" target=\"_blank\" rel=\"noopener\">负载均衡</a></h3><p>有一台服务器充当调度者的身份（负载均衡器），请求先到达它，再根据每台服务器的负载情况分配请求</p>\n<ol>\n<li>内置策略：nginx自带算法<ul>\n<li>雨露均沾型：轮训（默认）、加权轮训、哈希<ul>\n<li>轮训：按顺序逐一分配</li>\n<li>加权轮训：权重越大，被分配几率越高，适用于服务器性能不均衡情况</li>\n</ul>\n</li>\n<li>定向服务型：ip_hash、least_conn、cookie、route、lean<ul>\n<li>ip_hash：按访问IP的哈希结果分配请求，分配后访客访问固定后端服务器，有效的解决动态网页会话共享问题。</li>\n</ul>\n</li>\n<li>商业类型：ntlm、least_time、queue、stick</li>\n</ul>\n</li>\n<li>第三方算法：fair、url_hash<ul>\n<li>fair：基于后端服务器的响应时间来分配请求，响应时间短的优先分配。</li>\n<li>url_hash：按访问的哈希结果分配请求，使同定向到同一台后端服务器，可提高后端缓存服务器的效率。</li>\n</ul>\n</li>\n</ol>\n<h3 id=\"1-3-提供静态文件\"><a href=\"#1-3-提供静态文件\" class=\"headerlink\" title=\"1.3  提供静态文件\"></a>1.3  提供静态文件</h3><p>静态文件收集命令：<code>python mange.py collectstatic</code></p>\n<h3 id=\"1-4-WSGI\"><a href=\"#1-4-WSGI\" class=\"headerlink\" title=\"1.4  WSGI\"></a>1.4  WSGI</h3><ul>\n<li>WSGI是一种通信协议， Web 服务器(uWSGI)与 Web 应用程序或应用框架(Django)之间的一种低级别的接口</li>\n<li>uwsgi是一种线路协议我不是一种通信协议，常用于在uWSGI服务器于其他网络服务器的数据通信</li>\n<li>uWSGI是实现了uwsgi和WSGI两种协议的Web服务器，<strong>主要处理动态资源</strong></li>\n</ul>\n<h1 id=\"二、gunicorn\"><a href=\"#二、gunicorn\" class=\"headerlink\" title=\"二、gunicorn\"></a>二、gunicorn</h1><p><a href=\"https://handout-1300728887.cos.ap-beijing.myqcloud.com/%E8%AE%B2%E4%B9%89/%E9%BB%91%E9%A9%AC%E5%A4%B4%E6%9D%A1%E9%A1%B9%E7%9B%AE%E8%AF%BE%E4%BB%B6/C12-Deployment/Gunicorn.html\" target=\"_blank\" rel=\"noopener\">参考文档</a></p>\n<p>安装：<code>pip install gunicorn</code></p>\n<p>查看使用信息：<code>$gunicorn -h</code></p>\n<p>直接运行：<code>gunicorn 运行文件名称：flask程序实例名</code></p>\n<p>指定进程和端口号：`$gunicorn -w 4 -b 127.0.0.1:5001 运行文件名称:Flask程序实例名</p>\n","site":{"data":{}},"excerpt":"<h1 id=\"一、nginx\"><a href=\"#一、nginx\" class=\"headerlink\" title=\"一、nginx\"></a>一、nginx</h1><p><a href=\"https://handout-1300728887.cos.ap-beijing.myqcloud.com/%E8%AE%B2%E4%B9%89/%E9%A1%B9%E7%9B%AE%E9%83%A8%E7%BD%B2/nginx/Advanced.html\" target=\"_blank\" rel=\"noopener\">参考文档</a></p>\n<p><strong>是一个高性能的HTTP和反向代理服务器，主要处理静态资源</strong></p>\n<h3 id=\"1-1-反向代理\"><a href=\"#1-1-反向代理\" class=\"headerlink\" title=\"1.1  反向代理\"></a>1.1  <a href=\"https://handout-1300728887.cos.ap-beijing.myqcloud.com/%E8%AE%B2%E4%B9%89/%E9%A1%B9%E7%9B%AE%E9%83%A8%E7%BD%B2/nginx/nginx-reverse.html\" target=\"_blank\" rel=\"noopener\">反向代理</a></h3><p>正向代理： 为局域网<strong>客户端</strong>向外访问Internet服务<strong>（代理用户，隐藏客户端）</strong></p>\n<p>反向代理： 为局域网<strong>服务器</strong>向外提供Internet服务<strong>（代理服务器，隐藏服务器）</strong></p>","more":"<h3 id=\"1-2-负载均衡\"><a href=\"#1-2-负载均衡\" class=\"headerlink\" title=\"1.2  负载均衡\"></a>1.2  <a href=\"https://handout-1300728887.cos.ap-beijing.myqcloud.com/%E8%AE%B2%E4%B9%89/%E9%A1%B9%E7%9B%AE%E9%83%A8%E7%BD%B2/nginx/nginx-load.html\" target=\"_blank\" rel=\"noopener\">负载均衡</a></h3><p>有一台服务器充当调度者的身份（负载均衡器），请求先到达它，再根据每台服务器的负载情况分配请求</p>\n<ol>\n<li>内置策略：nginx自带算法<ul>\n<li>雨露均沾型：轮训（默认）、加权轮训、哈希<ul>\n<li>轮训：按顺序逐一分配</li>\n<li>加权轮训：权重越大，被分配几率越高，适用于服务器性能不均衡情况</li>\n</ul>\n</li>\n<li>定向服务型：ip_hash、least_conn、cookie、route、lean<ul>\n<li>ip_hash：按访问IP的哈希结果分配请求，分配后访客访问固定后端服务器，有效的解决动态网页会话共享问题。</li>\n</ul>\n</li>\n<li>商业类型：ntlm、least_time、queue、stick</li>\n</ul>\n</li>\n<li>第三方算法：fair、url_hash<ul>\n<li>fair：基于后端服务器的响应时间来分配请求，响应时间短的优先分配。</li>\n<li>url_hash：按访问的哈希结果分配请求，使同定向到同一台后端服务器，可提高后端缓存服务器的效率。</li>\n</ul>\n</li>\n</ol>\n<h3 id=\"1-3-提供静态文件\"><a href=\"#1-3-提供静态文件\" class=\"headerlink\" title=\"1.3  提供静态文件\"></a>1.3  提供静态文件</h3><p>静态文件收集命令：<code>python mange.py collectstatic</code></p>\n<h3 id=\"1-4-WSGI\"><a href=\"#1-4-WSGI\" class=\"headerlink\" title=\"1.4  WSGI\"></a>1.4  WSGI</h3><ul>\n<li>WSGI是一种通信协议， Web 服务器(uWSGI)与 Web 应用程序或应用框架(Django)之间的一种低级别的接口</li>\n<li>uwsgi是一种线路协议我不是一种通信协议，常用于在uWSGI服务器于其他网络服务器的数据通信</li>\n<li>uWSGI是实现了uwsgi和WSGI两种协议的Web服务器，<strong>主要处理动态资源</strong></li>\n</ul>\n<h1 id=\"二、gunicorn\"><a href=\"#二、gunicorn\" class=\"headerlink\" title=\"二、gunicorn\"></a>二、gunicorn</h1><p><a href=\"https://handout-1300728887.cos.ap-beijing.myqcloud.com/%E8%AE%B2%E4%B9%89/%E9%BB%91%E9%A9%AC%E5%A4%B4%E6%9D%A1%E9%A1%B9%E7%9B%AE%E8%AF%BE%E4%BB%B6/C12-Deployment/Gunicorn.html\" target=\"_blank\" rel=\"noopener\">参考文档</a></p>\n<p>安装：<code>pip install gunicorn</code></p>\n<p>查看使用信息：<code>$gunicorn -h</code></p>\n<p>直接运行：<code>gunicorn 运行文件名称：flask程序实例名</code></p>\n<p>指定进程和端口号：`$gunicorn -w 4 -b 127.0.0.1:5001 运行文件名称:Flask程序实例名</p>"},{"title":"Python数据结构与算法","date":"2020-09-30T03:37:57.000Z","top":0,"_content":"\n## 一、数据结构和算法\n\n数据：能够被计算机处理的符号或符号集\n\n数据元素（节点、记录）：数据的基本单位。例：学生统计表\n\n数据项（字段、域）：组成数据元素的最小单位。例：编号、姓名、性别等\n\n<!--more-->\n\n### 1  数据结构\n\n**相互之间存在的一种或多种特定的数据元素的集合用于计算机存储、组织数据的方式**\n\n![](https://img2018.cnblogs.com/blog/1672612/201906/1672612-20190607153718002-1151308139.jpg)\n\n#### 1.1  逻辑结构\n\n**数据元素间的抽象关系（如近邻关系、从属关系等），分为线性结构与非线性结构，**抽象出来的，与机器无关\n\n![](https://img2018.cnblogs.com/blog/1672612/201906/1672612-20190607154347579-543280178.png)\n\n| 结构类型 | 数据元素间的相互关系 |\n| :------: | :------------------: |\n|   集合   |          无          |\n|   线性   |        一对一        |\n|   树形   |        一对多        |\n|    图    |        多对多        |\n\n#### 1.2  （存储）物理结构\n\n**数据在计算机中的存放方式，反应数据元素间的逻辑关系**\n\n- 顺序存储（向量存储）：把数据元素存放在一组存储地址连续的存储单元里，逻辑关系和物理关系是一致的\n- 链式存储（动态存储）：通过指针反应数据间的逻辑关系\n- 索引存储：建立一个附加的索引表\n- 散列存储：根据节点的关键字直接计算出该节点的存储地址\n\n> 同一逻辑结构可以对应不同的存储结构，算法的设计取决于数据的逻辑结构，而算法实现依赖于指定的存储结构\n\n### 2  算法\n\n**解决特定问题的一种方法或一种描述**\n\n#### 2.1  数据结构和算法的联系\n\n程序=算法+数据结构\n\n- 算法设计: 取决于选定的逻辑结构\n- 算法实现: 依赖于采用的存储结构\n\n区别：\n\n- 数据结构关注的是**数据的逻辑结构、存储结构的基本操作**\n- 算法关注的是**在数据结构的基础上解决实际问题**\n\n算法的五大特性：\n\n1. 可行性：解决具体问题，完成期望功能\n2. 确定性：每一步在一定条件下只有一条执行路径\n3. 有穷性： 算法执行的步骤（或规则）是有限的\n4. 输入：具有零或多个输入\n5. 输出：至少有一个或多个输出\n\n评价算法好坏的方法：\n\n- 正确性：运行正确是一个算法的前提。\n- 可读性：容易理解、容易编程和调试、容易维护。\n- 健壮性：考虑情况全面，不容以出现运行错误。\n- 时间效率高：算法消耗的时间少。\n- 储存量低：占用较少的存储空间。\n\n#### 2.2  时间复杂度O(n)\n\n计算规则\n\n1. 基本操作，只有**常数项O(1)**\n2. 顺序结构，按**加法计算**\n3. 循环结构，按**乘法计算**\n4. 分支结构，**取最大值**\n\n#### 2.3  空间复杂度S(n)\n\n**一个算法在运行过程中临时占用存储空间大小的度量**\n\n## 二、线性数据结构\n\n特点：在数据元素的非空有限集合中\n\n- 存在唯一的（第一个--最后一个）数据元素\n- 且第一个元素没有直接前驱元素，最后一个元素没有直接后继元素，其他元素都有唯一的前驱和后继元素\n\n### 1  线性表\n\n- 线性表有顺序存储结构和链式存储结构。\n\n#### 1.1  顺序存储结构（顺序表）\n\n**是指将线性表中的各个元素依次存放在一组地址连续的存储单元中，通常将这种方法存储的线性表称为顺序表。**\n顺序表的优缺点：\n\n- 优：无须关心表中元素之间的关系，所以不用增加额外的存储空间；可以快速地取表中任意位置的元素。\n- 缺：插入和删除需要移动大量元素\n\n#### 1.2  线性表的链式存储（链表）\n\n一组任意的连续或非连续存储单元存储线性表的元素，存储元素本身（数据域）和后继元素地址（指针域)\t\n\n- 链表与顺序表的对比\n\n  |        |    存储方式    |           时间性能           |       空间性能       |\n  | :----: | :------------: | :--------------------------: | :------------------: |\n  | 顺序表 | 连续的存储单元 | 查找：O(1)；插入、删除：O(n) |     预先分配空间     |\n  | 单链表 | 任意的存储单元 | 查找：O(n)；插入、删除：O(1) | 不用估计预用空间大小 |\n\n循环单链表：首尾相连的一种单链表，最后一个结点称为：尾指针：rear\n\n双向链表： 链表中的每个结点有两个指针域，一个指向直接前驱结点，另一个指向直接后继结点。 data -- prior -- next \n\n### 2  栈和队列\n\n#### 2.1  栈\n\n**限制在表一端进行插入（入栈）和删除（出栈）操作的线性表**\n\n- 栈顶：允许操作端\n\n- 栈底：固定端\n\n> 先进后出\n\n##### 2.1.1  栈的存储结构\n\n栈是运算受限的线性表，线性表的存储结构对栈也适用\n\n1. 顺序栈\n2. 链栈\n\n#### 2.2  队列\n\n**插入（队尾）在表一段，删除（对头）在表的另一端**\n\n> 先进先出\n\n##### 2.2.1  队列的存储结构\n\n队列也是一种运算受限的线性表\n\n- 顺序队列\n- 链队列\n\n小结：\n\n1. 链式栈的栈顶应在链头，插入与删除操作都在链头进行。\n2. 循环队列要注意对空条件和对满条件；而对于链队列，需要特别注意出队仅对队头指针操作，当只有一个元素时，出队需要修改队尾指针。\n3. 递归实质上是通过栈来实现函数调用，只不过是调用自身而已。\n\n### 3  字符串和数组\n\n#### 3.1  字符串\n\n 串（String）是由零个或多个任意字符串组成的字符序列。 \n\n##### 3.1.1  串的存储结构\n\n- 定长顺序存储结构（顺序串）\n  - 定长是指按预定义的大小为每一个串变量分配固定长度的存储区。 最大不能超过256\n- 堆分配存储结构\n\n#### 3.2 数组\n\n **结构中的元素本身可以是具有某种结构的数据，但属于同一数据类型，一般线性表的扩充**\n\n是一个具有固定格式和数量的数据有续集，一旦被定义就不再改变，两种基本运算：\n\n1. 取值操作：给定一组下标，读其对应的数据元素。\n2. 赋值操作：给定一组下标，存储或修改与其相对应的数据元素。\n\n##### 3.2.1  数组的存储结构\n\n一维：顺序存储结构，直接按其下标顺序分配存储空间\n\n多维：按某种次序将数组中元素排成一个线性序列，再作存储\n\n存二维数组：\n\n1. 先行后列\n2. 先列后行\n\n##### 3.2.2  稀疏矩阵\n\n**矩阵中大多数元素为零元素的矩阵，按常规分配方法浪费内存**\n\n三元组表存储\n\n- 非零元素所在行、列及值构成一个三元组（i,j,v）\n\n## 三、非线性结构\n\n### 1  树和二叉树\n\n前驱唯一而后继不唯一，一对多\n\n定义：树（tree）是n（n>=0）个结点的有限集合。当n=0时，该集合满足以下条件：\n\n- 只有一个特殊节点称为根节点（root）\n\n- 当n>1时，其余n-1个结点被分成m(m>0)个互相不相交的集合，称为根节点的**子树**\n\n  树的定义用了递归概念，其算法也常常使用递归\n\n#### 1.1  二叉树\n\n二叉树是每个节点最多有两个子树的树结构。通常子树被称作“左子树”（left subtree）和“右子树”（right subtree）\n\n满二叉树：除了叶结点外每一个结点都有左右子叶且叶子结点都处在最底层的二叉树。 \n\n##### 1.1.1  存储结构\n\n顺序存储结构：按照二叉树结点从上至下、从左到右的顺序存储。\n\n链式存储结构：每个节点由三个域组成：数据域和左、右指针域。\n\n![](https://img-blog.csdnimg.cn/20181214150636793.jpeg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2NzZG5fYWl5YW5n,size_16,color_FFFFFF,t_70)\n\n##### 1.1.2  二叉树遍历\n\n**深度优先一般用递归，广度优先一般用队列。一般情况下能用递归实现的算法大部分也能用堆栈来实现。**\n\n1. 深度优先遍历\n   1. 先序遍历\t` 根节点->左子树->右子树 `\n   2. 中序遍历    ` 左子树->根节点->右子树 `\n   3. 后序遍历    ` 左子树->右子树->根节点 `\n2. 广度优先遍历（层次遍历）\n   -  从树的root开始，从上到下从从左到右遍历整个树的节点 \n\n### 2  图\n\n任意两个结点之间都可能相关，即结点之间的邻接关系可以是任意的。\n\n## 四、排序和搜索\n\n### 1  冒泡排序\n\n**重复遍历数列，一次比较两个元素**\n\n![冒泡排序](https://tupian-1300728887.cos.ap-chengdu.myqcloud.com/%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F.gif)\n\n### 2  选择排序\n\n**找到最大或最小的元素，把它排在队前或队尾，循而往复， 放到已排序序列的末尾**\n\n![选择排序](https://tupian-1300728887.cos.ap-chengdu.myqcloud.com/%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F.gif)\n\n### 3  插入排序\n\n**通过构建有序序列，对于未排序数据，在已排序序列中从后向前扫描，找到相应位置并插入。**\n\n![插入排序](https://tupian-1300728887.cos.ap-chengdu.myqcloud.com/%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F.gif)\n\n### 4  希尔排序\n\n**希尔排序是插入排序的一种，将数据分成几组，分别使用插入排序**\n\n![希尔排序](https://tupian-1300728887.cos.ap-chengdu.myqcloud.com/%E5%B8%8C%E5%B0%94%E6%8E%92%E5%BA%8F.jpg)\n\n### 5  快速排序\n\n**从序列中挑出一个元素（基准），把小于（大于）基准的元素放在基准前边（后边）**\n\n![快速排序](https://tupian-1300728887.cos.ap-chengdu.myqcloud.com/%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F.gif)\n\n### 6  归并排序\n\n **分治法，先递归分解数据，在合并数组；比较两个数组最前边的数，谁小谁先取**\n\n![归并排序](https://tupian-1300728887.cos.ap-chengdu.myqcloud.com/%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F.gif)\n\n## 五、搜索\n\n### 1  顺序查找\n\n### 2  二分法查找\n\n### 3  二叉树查找\n\n### 4  哈希查找","source":"_posts/Python数据结构与算法.md","raw":"---\ntitle: Python数据结构与算法\ndate: 2020-09-30 11:37:57\ntags: Python\ntop: 0\n---\n\n## 一、数据结构和算法\n\n数据：能够被计算机处理的符号或符号集\n\n数据元素（节点、记录）：数据的基本单位。例：学生统计表\n\n数据项（字段、域）：组成数据元素的最小单位。例：编号、姓名、性别等\n\n<!--more-->\n\n### 1  数据结构\n\n**相互之间存在的一种或多种特定的数据元素的集合用于计算机存储、组织数据的方式**\n\n![](https://img2018.cnblogs.com/blog/1672612/201906/1672612-20190607153718002-1151308139.jpg)\n\n#### 1.1  逻辑结构\n\n**数据元素间的抽象关系（如近邻关系、从属关系等），分为线性结构与非线性结构，**抽象出来的，与机器无关\n\n![](https://img2018.cnblogs.com/blog/1672612/201906/1672612-20190607154347579-543280178.png)\n\n| 结构类型 | 数据元素间的相互关系 |\n| :------: | :------------------: |\n|   集合   |          无          |\n|   线性   |        一对一        |\n|   树形   |        一对多        |\n|    图    |        多对多        |\n\n#### 1.2  （存储）物理结构\n\n**数据在计算机中的存放方式，反应数据元素间的逻辑关系**\n\n- 顺序存储（向量存储）：把数据元素存放在一组存储地址连续的存储单元里，逻辑关系和物理关系是一致的\n- 链式存储（动态存储）：通过指针反应数据间的逻辑关系\n- 索引存储：建立一个附加的索引表\n- 散列存储：根据节点的关键字直接计算出该节点的存储地址\n\n> 同一逻辑结构可以对应不同的存储结构，算法的设计取决于数据的逻辑结构，而算法实现依赖于指定的存储结构\n\n### 2  算法\n\n**解决特定问题的一种方法或一种描述**\n\n#### 2.1  数据结构和算法的联系\n\n程序=算法+数据结构\n\n- 算法设计: 取决于选定的逻辑结构\n- 算法实现: 依赖于采用的存储结构\n\n区别：\n\n- 数据结构关注的是**数据的逻辑结构、存储结构的基本操作**\n- 算法关注的是**在数据结构的基础上解决实际问题**\n\n算法的五大特性：\n\n1. 可行性：解决具体问题，完成期望功能\n2. 确定性：每一步在一定条件下只有一条执行路径\n3. 有穷性： 算法执行的步骤（或规则）是有限的\n4. 输入：具有零或多个输入\n5. 输出：至少有一个或多个输出\n\n评价算法好坏的方法：\n\n- 正确性：运行正确是一个算法的前提。\n- 可读性：容易理解、容易编程和调试、容易维护。\n- 健壮性：考虑情况全面，不容以出现运行错误。\n- 时间效率高：算法消耗的时间少。\n- 储存量低：占用较少的存储空间。\n\n#### 2.2  时间复杂度O(n)\n\n计算规则\n\n1. 基本操作，只有**常数项O(1)**\n2. 顺序结构，按**加法计算**\n3. 循环结构，按**乘法计算**\n4. 分支结构，**取最大值**\n\n#### 2.3  空间复杂度S(n)\n\n**一个算法在运行过程中临时占用存储空间大小的度量**\n\n## 二、线性数据结构\n\n特点：在数据元素的非空有限集合中\n\n- 存在唯一的（第一个--最后一个）数据元素\n- 且第一个元素没有直接前驱元素，最后一个元素没有直接后继元素，其他元素都有唯一的前驱和后继元素\n\n### 1  线性表\n\n- 线性表有顺序存储结构和链式存储结构。\n\n#### 1.1  顺序存储结构（顺序表）\n\n**是指将线性表中的各个元素依次存放在一组地址连续的存储单元中，通常将这种方法存储的线性表称为顺序表。**\n顺序表的优缺点：\n\n- 优：无须关心表中元素之间的关系，所以不用增加额外的存储空间；可以快速地取表中任意位置的元素。\n- 缺：插入和删除需要移动大量元素\n\n#### 1.2  线性表的链式存储（链表）\n\n一组任意的连续或非连续存储单元存储线性表的元素，存储元素本身（数据域）和后继元素地址（指针域)\t\n\n- 链表与顺序表的对比\n\n  |        |    存储方式    |           时间性能           |       空间性能       |\n  | :----: | :------------: | :--------------------------: | :------------------: |\n  | 顺序表 | 连续的存储单元 | 查找：O(1)；插入、删除：O(n) |     预先分配空间     |\n  | 单链表 | 任意的存储单元 | 查找：O(n)；插入、删除：O(1) | 不用估计预用空间大小 |\n\n循环单链表：首尾相连的一种单链表，最后一个结点称为：尾指针：rear\n\n双向链表： 链表中的每个结点有两个指针域，一个指向直接前驱结点，另一个指向直接后继结点。 data -- prior -- next \n\n### 2  栈和队列\n\n#### 2.1  栈\n\n**限制在表一端进行插入（入栈）和删除（出栈）操作的线性表**\n\n- 栈顶：允许操作端\n\n- 栈底：固定端\n\n> 先进后出\n\n##### 2.1.1  栈的存储结构\n\n栈是运算受限的线性表，线性表的存储结构对栈也适用\n\n1. 顺序栈\n2. 链栈\n\n#### 2.2  队列\n\n**插入（队尾）在表一段，删除（对头）在表的另一端**\n\n> 先进先出\n\n##### 2.2.1  队列的存储结构\n\n队列也是一种运算受限的线性表\n\n- 顺序队列\n- 链队列\n\n小结：\n\n1. 链式栈的栈顶应在链头，插入与删除操作都在链头进行。\n2. 循环队列要注意对空条件和对满条件；而对于链队列，需要特别注意出队仅对队头指针操作，当只有一个元素时，出队需要修改队尾指针。\n3. 递归实质上是通过栈来实现函数调用，只不过是调用自身而已。\n\n### 3  字符串和数组\n\n#### 3.1  字符串\n\n 串（String）是由零个或多个任意字符串组成的字符序列。 \n\n##### 3.1.1  串的存储结构\n\n- 定长顺序存储结构（顺序串）\n  - 定长是指按预定义的大小为每一个串变量分配固定长度的存储区。 最大不能超过256\n- 堆分配存储结构\n\n#### 3.2 数组\n\n **结构中的元素本身可以是具有某种结构的数据，但属于同一数据类型，一般线性表的扩充**\n\n是一个具有固定格式和数量的数据有续集，一旦被定义就不再改变，两种基本运算：\n\n1. 取值操作：给定一组下标，读其对应的数据元素。\n2. 赋值操作：给定一组下标，存储或修改与其相对应的数据元素。\n\n##### 3.2.1  数组的存储结构\n\n一维：顺序存储结构，直接按其下标顺序分配存储空间\n\n多维：按某种次序将数组中元素排成一个线性序列，再作存储\n\n存二维数组：\n\n1. 先行后列\n2. 先列后行\n\n##### 3.2.2  稀疏矩阵\n\n**矩阵中大多数元素为零元素的矩阵，按常规分配方法浪费内存**\n\n三元组表存储\n\n- 非零元素所在行、列及值构成一个三元组（i,j,v）\n\n## 三、非线性结构\n\n### 1  树和二叉树\n\n前驱唯一而后继不唯一，一对多\n\n定义：树（tree）是n（n>=0）个结点的有限集合。当n=0时，该集合满足以下条件：\n\n- 只有一个特殊节点称为根节点（root）\n\n- 当n>1时，其余n-1个结点被分成m(m>0)个互相不相交的集合，称为根节点的**子树**\n\n  树的定义用了递归概念，其算法也常常使用递归\n\n#### 1.1  二叉树\n\n二叉树是每个节点最多有两个子树的树结构。通常子树被称作“左子树”（left subtree）和“右子树”（right subtree）\n\n满二叉树：除了叶结点外每一个结点都有左右子叶且叶子结点都处在最底层的二叉树。 \n\n##### 1.1.1  存储结构\n\n顺序存储结构：按照二叉树结点从上至下、从左到右的顺序存储。\n\n链式存储结构：每个节点由三个域组成：数据域和左、右指针域。\n\n![](https://img-blog.csdnimg.cn/20181214150636793.jpeg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2NzZG5fYWl5YW5n,size_16,color_FFFFFF,t_70)\n\n##### 1.1.2  二叉树遍历\n\n**深度优先一般用递归，广度优先一般用队列。一般情况下能用递归实现的算法大部分也能用堆栈来实现。**\n\n1. 深度优先遍历\n   1. 先序遍历\t` 根节点->左子树->右子树 `\n   2. 中序遍历    ` 左子树->根节点->右子树 `\n   3. 后序遍历    ` 左子树->右子树->根节点 `\n2. 广度优先遍历（层次遍历）\n   -  从树的root开始，从上到下从从左到右遍历整个树的节点 \n\n### 2  图\n\n任意两个结点之间都可能相关，即结点之间的邻接关系可以是任意的。\n\n## 四、排序和搜索\n\n### 1  冒泡排序\n\n**重复遍历数列，一次比较两个元素**\n\n![冒泡排序](https://tupian-1300728887.cos.ap-chengdu.myqcloud.com/%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F.gif)\n\n### 2  选择排序\n\n**找到最大或最小的元素，把它排在队前或队尾，循而往复， 放到已排序序列的末尾**\n\n![选择排序](https://tupian-1300728887.cos.ap-chengdu.myqcloud.com/%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F.gif)\n\n### 3  插入排序\n\n**通过构建有序序列，对于未排序数据，在已排序序列中从后向前扫描，找到相应位置并插入。**\n\n![插入排序](https://tupian-1300728887.cos.ap-chengdu.myqcloud.com/%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F.gif)\n\n### 4  希尔排序\n\n**希尔排序是插入排序的一种，将数据分成几组，分别使用插入排序**\n\n![希尔排序](https://tupian-1300728887.cos.ap-chengdu.myqcloud.com/%E5%B8%8C%E5%B0%94%E6%8E%92%E5%BA%8F.jpg)\n\n### 5  快速排序\n\n**从序列中挑出一个元素（基准），把小于（大于）基准的元素放在基准前边（后边）**\n\n![快速排序](https://tupian-1300728887.cos.ap-chengdu.myqcloud.com/%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F.gif)\n\n### 6  归并排序\n\n **分治法，先递归分解数据，在合并数组；比较两个数组最前边的数，谁小谁先取**\n\n![归并排序](https://tupian-1300728887.cos.ap-chengdu.myqcloud.com/%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F.gif)\n\n## 五、搜索\n\n### 1  顺序查找\n\n### 2  二分法查找\n\n### 3  二叉树查找\n\n### 4  哈希查找","slug":"Python数据结构与算法","published":1,"updated":"2020-09-30T08:04:23.425Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckfp5akg70014n8jhe2ktcagp","content":"<h2 id=\"一、数据结构和算法\"><a href=\"#一、数据结构和算法\" class=\"headerlink\" title=\"一、数据结构和算法\"></a>一、数据结构和算法</h2><p>数据：能够被计算机处理的符号或符号集</p>\n<p>数据元素（节点、记录）：数据的基本单位。例：学生统计表</p>\n<p>数据项（字段、域）：组成数据元素的最小单位。例：编号、姓名、性别等</p>\n<a id=\"more\"></a>\n\n<h3 id=\"1-数据结构\"><a href=\"#1-数据结构\" class=\"headerlink\" title=\"1  数据结构\"></a>1  数据结构</h3><p><strong>相互之间存在的一种或多种特定的数据元素的集合用于计算机存储、组织数据的方式</strong></p>\n<p><img src=\"https://img2018.cnblogs.com/blog/1672612/201906/1672612-20190607153718002-1151308139.jpg\" alt=\"\"></p>\n<h4 id=\"1-1-逻辑结构\"><a href=\"#1-1-逻辑结构\" class=\"headerlink\" title=\"1.1  逻辑结构\"></a>1.1  逻辑结构</h4><p><strong>数据元素间的抽象关系（如近邻关系、从属关系等），分为线性结构与非线性结构，</strong>抽象出来的，与机器无关</p>\n<p><img src=\"https://img2018.cnblogs.com/blog/1672612/201906/1672612-20190607154347579-543280178.png\" alt=\"\"></p>\n<table>\n<thead>\n<tr>\n<th align=\"center\">结构类型</th>\n<th align=\"center\">数据元素间的相互关系</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\">集合</td>\n<td align=\"center\">无</td>\n</tr>\n<tr>\n<td align=\"center\">线性</td>\n<td align=\"center\">一对一</td>\n</tr>\n<tr>\n<td align=\"center\">树形</td>\n<td align=\"center\">一对多</td>\n</tr>\n<tr>\n<td align=\"center\">图</td>\n<td align=\"center\">多对多</td>\n</tr>\n</tbody></table>\n<h4 id=\"1-2-（存储）物理结构\"><a href=\"#1-2-（存储）物理结构\" class=\"headerlink\" title=\"1.2  （存储）物理结构\"></a>1.2  （存储）物理结构</h4><p><strong>数据在计算机中的存放方式，反应数据元素间的逻辑关系</strong></p>\n<ul>\n<li>顺序存储（向量存储）：把数据元素存放在一组存储地址连续的存储单元里，逻辑关系和物理关系是一致的</li>\n<li>链式存储（动态存储）：通过指针反应数据间的逻辑关系</li>\n<li>索引存储：建立一个附加的索引表</li>\n<li>散列存储：根据节点的关键字直接计算出该节点的存储地址</li>\n</ul>\n<blockquote>\n<p>同一逻辑结构可以对应不同的存储结构，算法的设计取决于数据的逻辑结构，而算法实现依赖于指定的存储结构</p>\n</blockquote>\n<h3 id=\"2-算法\"><a href=\"#2-算法\" class=\"headerlink\" title=\"2  算法\"></a>2  算法</h3><p><strong>解决特定问题的一种方法或一种描述</strong></p>\n<h4 id=\"2-1-数据结构和算法的联系\"><a href=\"#2-1-数据结构和算法的联系\" class=\"headerlink\" title=\"2.1  数据结构和算法的联系\"></a>2.1  数据结构和算法的联系</h4><p>程序=算法+数据结构</p>\n<ul>\n<li>算法设计: 取决于选定的逻辑结构</li>\n<li>算法实现: 依赖于采用的存储结构</li>\n</ul>\n<p>区别：</p>\n<ul>\n<li>数据结构关注的是<strong>数据的逻辑结构、存储结构的基本操作</strong></li>\n<li>算法关注的是<strong>在数据结构的基础上解决实际问题</strong></li>\n</ul>\n<p>算法的五大特性：</p>\n<ol>\n<li>可行性：解决具体问题，完成期望功能</li>\n<li>确定性：每一步在一定条件下只有一条执行路径</li>\n<li>有穷性： 算法执行的步骤（或规则）是有限的</li>\n<li>输入：具有零或多个输入</li>\n<li>输出：至少有一个或多个输出</li>\n</ol>\n<p>评价算法好坏的方法：</p>\n<ul>\n<li>正确性：运行正确是一个算法的前提。</li>\n<li>可读性：容易理解、容易编程和调试、容易维护。</li>\n<li>健壮性：考虑情况全面，不容以出现运行错误。</li>\n<li>时间效率高：算法消耗的时间少。</li>\n<li>储存量低：占用较少的存储空间。</li>\n</ul>\n<h4 id=\"2-2-时间复杂度O-n\"><a href=\"#2-2-时间复杂度O-n\" class=\"headerlink\" title=\"2.2  时间复杂度O(n)\"></a>2.2  时间复杂度O(n)</h4><p>计算规则</p>\n<ol>\n<li>基本操作，只有<strong>常数项O(1)</strong></li>\n<li>顺序结构，按<strong>加法计算</strong></li>\n<li>循环结构，按<strong>乘法计算</strong></li>\n<li>分支结构，<strong>取最大值</strong></li>\n</ol>\n<h4 id=\"2-3-空间复杂度S-n\"><a href=\"#2-3-空间复杂度S-n\" class=\"headerlink\" title=\"2.3  空间复杂度S(n)\"></a>2.3  空间复杂度S(n)</h4><p><strong>一个算法在运行过程中临时占用存储空间大小的度量</strong></p>\n<h2 id=\"二、线性数据结构\"><a href=\"#二、线性数据结构\" class=\"headerlink\" title=\"二、线性数据结构\"></a>二、线性数据结构</h2><p>特点：在数据元素的非空有限集合中</p>\n<ul>\n<li>存在唯一的（第一个–最后一个）数据元素</li>\n<li>且第一个元素没有直接前驱元素，最后一个元素没有直接后继元素，其他元素都有唯一的前驱和后继元素</li>\n</ul>\n<h3 id=\"1-线性表\"><a href=\"#1-线性表\" class=\"headerlink\" title=\"1  线性表\"></a>1  线性表</h3><ul>\n<li>线性表有顺序存储结构和链式存储结构。</li>\n</ul>\n<h4 id=\"1-1-顺序存储结构（顺序表）\"><a href=\"#1-1-顺序存储结构（顺序表）\" class=\"headerlink\" title=\"1.1  顺序存储结构（顺序表）\"></a>1.1  顺序存储结构（顺序表）</h4><p><strong>是指将线性表中的各个元素依次存放在一组地址连续的存储单元中，通常将这种方法存储的线性表称为顺序表。</strong><br>顺序表的优缺点：</p>\n<ul>\n<li>优：无须关心表中元素之间的关系，所以不用增加额外的存储空间；可以快速地取表中任意位置的元素。</li>\n<li>缺：插入和删除需要移动大量元素</li>\n</ul>\n<h4 id=\"1-2-线性表的链式存储（链表）\"><a href=\"#1-2-线性表的链式存储（链表）\" class=\"headerlink\" title=\"1.2  线性表的链式存储（链表）\"></a>1.2  线性表的链式存储（链表）</h4><p>一组任意的连续或非连续存储单元存储线性表的元素，存储元素本身（数据域）和后继元素地址（指针域)    </p>\n<ul>\n<li><p>链表与顺序表的对比</p>\n<table>\n<thead>\n<tr>\n<th align=\"center\"></th>\n<th align=\"center\">存储方式</th>\n<th align=\"center\">时间性能</th>\n<th align=\"center\">空间性能</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\">顺序表</td>\n<td align=\"center\">连续的存储单元</td>\n<td align=\"center\">查找：O(1)；插入、删除：O(n)</td>\n<td align=\"center\">预先分配空间</td>\n</tr>\n<tr>\n<td align=\"center\">单链表</td>\n<td align=\"center\">任意的存储单元</td>\n<td align=\"center\">查找：O(n)；插入、删除：O(1)</td>\n<td align=\"center\">不用估计预用空间大小</td>\n</tr>\n</tbody></table>\n</li>\n</ul>\n<p>循环单链表：首尾相连的一种单链表，最后一个结点称为：尾指针：rear</p>\n<p>双向链表： 链表中的每个结点有两个指针域，一个指向直接前驱结点，另一个指向直接后继结点。 data – prior – next </p>\n<h3 id=\"2-栈和队列\"><a href=\"#2-栈和队列\" class=\"headerlink\" title=\"2  栈和队列\"></a>2  栈和队列</h3><h4 id=\"2-1-栈\"><a href=\"#2-1-栈\" class=\"headerlink\" title=\"2.1  栈\"></a>2.1  栈</h4><p><strong>限制在表一端进行插入（入栈）和删除（出栈）操作的线性表</strong></p>\n<ul>\n<li><p>栈顶：允许操作端</p>\n</li>\n<li><p>栈底：固定端</p>\n</li>\n</ul>\n<blockquote>\n<p>先进后出</p>\n</blockquote>\n<h5 id=\"2-1-1-栈的存储结构\"><a href=\"#2-1-1-栈的存储结构\" class=\"headerlink\" title=\"2.1.1  栈的存储结构\"></a>2.1.1  栈的存储结构</h5><p>栈是运算受限的线性表，线性表的存储结构对栈也适用</p>\n<ol>\n<li>顺序栈</li>\n<li>链栈</li>\n</ol>\n<h4 id=\"2-2-队列\"><a href=\"#2-2-队列\" class=\"headerlink\" title=\"2.2  队列\"></a>2.2  队列</h4><p><strong>插入（队尾）在表一段，删除（对头）在表的另一端</strong></p>\n<blockquote>\n<p>先进先出</p>\n</blockquote>\n<h5 id=\"2-2-1-队列的存储结构\"><a href=\"#2-2-1-队列的存储结构\" class=\"headerlink\" title=\"2.2.1  队列的存储结构\"></a>2.2.1  队列的存储结构</h5><p>队列也是一种运算受限的线性表</p>\n<ul>\n<li>顺序队列</li>\n<li>链队列</li>\n</ul>\n<p>小结：</p>\n<ol>\n<li>链式栈的栈顶应在链头，插入与删除操作都在链头进行。</li>\n<li>循环队列要注意对空条件和对满条件；而对于链队列，需要特别注意出队仅对队头指针操作，当只有一个元素时，出队需要修改队尾指针。</li>\n<li>递归实质上是通过栈来实现函数调用，只不过是调用自身而已。</li>\n</ol>\n<h3 id=\"3-字符串和数组\"><a href=\"#3-字符串和数组\" class=\"headerlink\" title=\"3  字符串和数组\"></a>3  字符串和数组</h3><h4 id=\"3-1-字符串\"><a href=\"#3-1-字符串\" class=\"headerlink\" title=\"3.1  字符串\"></a>3.1  字符串</h4><p> 串（String）是由零个或多个任意字符串组成的字符序列。 </p>\n<h5 id=\"3-1-1-串的存储结构\"><a href=\"#3-1-1-串的存储结构\" class=\"headerlink\" title=\"3.1.1  串的存储结构\"></a>3.1.1  串的存储结构</h5><ul>\n<li>定长顺序存储结构（顺序串）<ul>\n<li>定长是指按预定义的大小为每一个串变量分配固定长度的存储区。 最大不能超过256</li>\n</ul>\n</li>\n<li>堆分配存储结构</li>\n</ul>\n<h4 id=\"3-2-数组\"><a href=\"#3-2-数组\" class=\"headerlink\" title=\"3.2 数组\"></a>3.2 数组</h4><p> <strong>结构中的元素本身可以是具有某种结构的数据，但属于同一数据类型，一般线性表的扩充</strong></p>\n<p>是一个具有固定格式和数量的数据有续集，一旦被定义就不再改变，两种基本运算：</p>\n<ol>\n<li>取值操作：给定一组下标，读其对应的数据元素。</li>\n<li>赋值操作：给定一组下标，存储或修改与其相对应的数据元素。</li>\n</ol>\n<h5 id=\"3-2-1-数组的存储结构\"><a href=\"#3-2-1-数组的存储结构\" class=\"headerlink\" title=\"3.2.1  数组的存储结构\"></a>3.2.1  数组的存储结构</h5><p>一维：顺序存储结构，直接按其下标顺序分配存储空间</p>\n<p>多维：按某种次序将数组中元素排成一个线性序列，再作存储</p>\n<p>存二维数组：</p>\n<ol>\n<li>先行后列</li>\n<li>先列后行</li>\n</ol>\n<h5 id=\"3-2-2-稀疏矩阵\"><a href=\"#3-2-2-稀疏矩阵\" class=\"headerlink\" title=\"3.2.2  稀疏矩阵\"></a>3.2.2  稀疏矩阵</h5><p><strong>矩阵中大多数元素为零元素的矩阵，按常规分配方法浪费内存</strong></p>\n<p>三元组表存储</p>\n<ul>\n<li>非零元素所在行、列及值构成一个三元组（i,j,v）</li>\n</ul>\n<h2 id=\"三、非线性结构\"><a href=\"#三、非线性结构\" class=\"headerlink\" title=\"三、非线性结构\"></a>三、非线性结构</h2><h3 id=\"1-树和二叉树\"><a href=\"#1-树和二叉树\" class=\"headerlink\" title=\"1  树和二叉树\"></a>1  树和二叉树</h3><p>前驱唯一而后继不唯一，一对多</p>\n<p>定义：树（tree）是n（n&gt;=0）个结点的有限集合。当n=0时，该集合满足以下条件：</p>\n<ul>\n<li><p>只有一个特殊节点称为根节点（root）</p>\n</li>\n<li><p>当n&gt;1时，其余n-1个结点被分成m(m&gt;0)个互相不相交的集合，称为根节点的<strong>子树</strong></p>\n<p>树的定义用了递归概念，其算法也常常使用递归</p>\n</li>\n</ul>\n<h4 id=\"1-1-二叉树\"><a href=\"#1-1-二叉树\" class=\"headerlink\" title=\"1.1  二叉树\"></a>1.1  二叉树</h4><p>二叉树是每个节点最多有两个子树的树结构。通常子树被称作“左子树”（left subtree）和“右子树”（right subtree）</p>\n<p>满二叉树：除了叶结点外每一个结点都有左右子叶且叶子结点都处在最底层的二叉树。 </p>\n<h5 id=\"1-1-1-存储结构\"><a href=\"#1-1-1-存储结构\" class=\"headerlink\" title=\"1.1.1  存储结构\"></a>1.1.1  存储结构</h5><p>顺序存储结构：按照二叉树结点从上至下、从左到右的顺序存储。</p>\n<p>链式存储结构：每个节点由三个域组成：数据域和左、右指针域。</p>\n<p><img src=\"https://img-blog.csdnimg.cn/20181214150636793.jpeg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2NzZG5fYWl5YW5n,size_16,color_FFFFFF,t_70\" alt=\"\"></p>\n<h5 id=\"1-1-2-二叉树遍历\"><a href=\"#1-1-2-二叉树遍历\" class=\"headerlink\" title=\"1.1.2  二叉树遍历\"></a>1.1.2  二叉树遍历</h5><p><strong>深度优先一般用递归，广度优先一般用队列。一般情况下能用递归实现的算法大部分也能用堆栈来实现。</strong></p>\n<ol>\n<li>深度优先遍历<ol>\n<li>先序遍历    <code>根节点-&gt;左子树-&gt;右子树</code></li>\n<li>中序遍历    <code>左子树-&gt;根节点-&gt;右子树</code></li>\n<li>后序遍历    <code>左子树-&gt;右子树-&gt;根节点</code></li>\n</ol>\n</li>\n<li>广度优先遍历（层次遍历）<ul>\n<li>从树的root开始，从上到下从从左到右遍历整个树的节点 </li>\n</ul>\n</li>\n</ol>\n<h3 id=\"2-图\"><a href=\"#2-图\" class=\"headerlink\" title=\"2  图\"></a>2  图</h3><p>任意两个结点之间都可能相关，即结点之间的邻接关系可以是任意的。</p>\n<h2 id=\"四、排序和搜索\"><a href=\"#四、排序和搜索\" class=\"headerlink\" title=\"四、排序和搜索\"></a>四、排序和搜索</h2><h3 id=\"1-冒泡排序\"><a href=\"#1-冒泡排序\" class=\"headerlink\" title=\"1  冒泡排序\"></a>1  冒泡排序</h3><p><strong>重复遍历数列，一次比较两个元素</strong></p>\n<p><img src=\"https://tupian-1300728887.cos.ap-chengdu.myqcloud.com/%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F.gif\" alt=\"冒泡排序\"></p>\n<h3 id=\"2-选择排序\"><a href=\"#2-选择排序\" class=\"headerlink\" title=\"2  选择排序\"></a>2  选择排序</h3><p><strong>找到最大或最小的元素，把它排在队前或队尾，循而往复， 放到已排序序列的末尾</strong></p>\n<p><img src=\"https://tupian-1300728887.cos.ap-chengdu.myqcloud.com/%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F.gif\" alt=\"选择排序\"></p>\n<h3 id=\"3-插入排序\"><a href=\"#3-插入排序\" class=\"headerlink\" title=\"3  插入排序\"></a>3  插入排序</h3><p><strong>通过构建有序序列，对于未排序数据，在已排序序列中从后向前扫描，找到相应位置并插入。</strong></p>\n<p><img src=\"https://tupian-1300728887.cos.ap-chengdu.myqcloud.com/%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F.gif\" alt=\"插入排序\"></p>\n<h3 id=\"4-希尔排序\"><a href=\"#4-希尔排序\" class=\"headerlink\" title=\"4  希尔排序\"></a>4  希尔排序</h3><p><strong>希尔排序是插入排序的一种，将数据分成几组，分别使用插入排序</strong></p>\n<p><img src=\"https://tupian-1300728887.cos.ap-chengdu.myqcloud.com/%E5%B8%8C%E5%B0%94%E6%8E%92%E5%BA%8F.jpg\" alt=\"希尔排序\"></p>\n<h3 id=\"5-快速排序\"><a href=\"#5-快速排序\" class=\"headerlink\" title=\"5  快速排序\"></a>5  快速排序</h3><p><strong>从序列中挑出一个元素（基准），把小于（大于）基准的元素放在基准前边（后边）</strong></p>\n<p><img src=\"https://tupian-1300728887.cos.ap-chengdu.myqcloud.com/%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F.gif\" alt=\"快速排序\"></p>\n<h3 id=\"6-归并排序\"><a href=\"#6-归并排序\" class=\"headerlink\" title=\"6  归并排序\"></a>6  归并排序</h3><p> <strong>分治法，先递归分解数据，在合并数组；比较两个数组最前边的数，谁小谁先取</strong></p>\n<p><img src=\"https://tupian-1300728887.cos.ap-chengdu.myqcloud.com/%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F.gif\" alt=\"归并排序\"></p>\n<h2 id=\"五、搜索\"><a href=\"#五、搜索\" class=\"headerlink\" title=\"五、搜索\"></a>五、搜索</h2><h3 id=\"1-顺序查找\"><a href=\"#1-顺序查找\" class=\"headerlink\" title=\"1  顺序查找\"></a>1  顺序查找</h3><h3 id=\"2-二分法查找\"><a href=\"#2-二分法查找\" class=\"headerlink\" title=\"2  二分法查找\"></a>2  二分法查找</h3><h3 id=\"3-二叉树查找\"><a href=\"#3-二叉树查找\" class=\"headerlink\" title=\"3  二叉树查找\"></a>3  二叉树查找</h3><h3 id=\"4-哈希查找\"><a href=\"#4-哈希查找\" class=\"headerlink\" title=\"4  哈希查找\"></a>4  哈希查找</h3>","site":{"data":{}},"excerpt":"<h2 id=\"一、数据结构和算法\"><a href=\"#一、数据结构和算法\" class=\"headerlink\" title=\"一、数据结构和算法\"></a>一、数据结构和算法</h2><p>数据：能够被计算机处理的符号或符号集</p>\n<p>数据元素（节点、记录）：数据的基本单位。例：学生统计表</p>\n<p>数据项（字段、域）：组成数据元素的最小单位。例：编号、姓名、性别等</p>","more":"<h3 id=\"1-数据结构\"><a href=\"#1-数据结构\" class=\"headerlink\" title=\"1  数据结构\"></a>1  数据结构</h3><p><strong>相互之间存在的一种或多种特定的数据元素的集合用于计算机存储、组织数据的方式</strong></p>\n<p><img src=\"https://img2018.cnblogs.com/blog/1672612/201906/1672612-20190607153718002-1151308139.jpg\" alt=\"\"></p>\n<h4 id=\"1-1-逻辑结构\"><a href=\"#1-1-逻辑结构\" class=\"headerlink\" title=\"1.1  逻辑结构\"></a>1.1  逻辑结构</h4><p><strong>数据元素间的抽象关系（如近邻关系、从属关系等），分为线性结构与非线性结构，</strong>抽象出来的，与机器无关</p>\n<p><img src=\"https://img2018.cnblogs.com/blog/1672612/201906/1672612-20190607154347579-543280178.png\" alt=\"\"></p>\n<table>\n<thead>\n<tr>\n<th align=\"center\">结构类型</th>\n<th align=\"center\">数据元素间的相互关系</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\">集合</td>\n<td align=\"center\">无</td>\n</tr>\n<tr>\n<td align=\"center\">线性</td>\n<td align=\"center\">一对一</td>\n</tr>\n<tr>\n<td align=\"center\">树形</td>\n<td align=\"center\">一对多</td>\n</tr>\n<tr>\n<td align=\"center\">图</td>\n<td align=\"center\">多对多</td>\n</tr>\n</tbody></table>\n<h4 id=\"1-2-（存储）物理结构\"><a href=\"#1-2-（存储）物理结构\" class=\"headerlink\" title=\"1.2  （存储）物理结构\"></a>1.2  （存储）物理结构</h4><p><strong>数据在计算机中的存放方式，反应数据元素间的逻辑关系</strong></p>\n<ul>\n<li>顺序存储（向量存储）：把数据元素存放在一组存储地址连续的存储单元里，逻辑关系和物理关系是一致的</li>\n<li>链式存储（动态存储）：通过指针反应数据间的逻辑关系</li>\n<li>索引存储：建立一个附加的索引表</li>\n<li>散列存储：根据节点的关键字直接计算出该节点的存储地址</li>\n</ul>\n<blockquote>\n<p>同一逻辑结构可以对应不同的存储结构，算法的设计取决于数据的逻辑结构，而算法实现依赖于指定的存储结构</p>\n</blockquote>\n<h3 id=\"2-算法\"><a href=\"#2-算法\" class=\"headerlink\" title=\"2  算法\"></a>2  算法</h3><p><strong>解决特定问题的一种方法或一种描述</strong></p>\n<h4 id=\"2-1-数据结构和算法的联系\"><a href=\"#2-1-数据结构和算法的联系\" class=\"headerlink\" title=\"2.1  数据结构和算法的联系\"></a>2.1  数据结构和算法的联系</h4><p>程序=算法+数据结构</p>\n<ul>\n<li>算法设计: 取决于选定的逻辑结构</li>\n<li>算法实现: 依赖于采用的存储结构</li>\n</ul>\n<p>区别：</p>\n<ul>\n<li>数据结构关注的是<strong>数据的逻辑结构、存储结构的基本操作</strong></li>\n<li>算法关注的是<strong>在数据结构的基础上解决实际问题</strong></li>\n</ul>\n<p>算法的五大特性：</p>\n<ol>\n<li>可行性：解决具体问题，完成期望功能</li>\n<li>确定性：每一步在一定条件下只有一条执行路径</li>\n<li>有穷性： 算法执行的步骤（或规则）是有限的</li>\n<li>输入：具有零或多个输入</li>\n<li>输出：至少有一个或多个输出</li>\n</ol>\n<p>评价算法好坏的方法：</p>\n<ul>\n<li>正确性：运行正确是一个算法的前提。</li>\n<li>可读性：容易理解、容易编程和调试、容易维护。</li>\n<li>健壮性：考虑情况全面，不容以出现运行错误。</li>\n<li>时间效率高：算法消耗的时间少。</li>\n<li>储存量低：占用较少的存储空间。</li>\n</ul>\n<h4 id=\"2-2-时间复杂度O-n\"><a href=\"#2-2-时间复杂度O-n\" class=\"headerlink\" title=\"2.2  时间复杂度O(n)\"></a>2.2  时间复杂度O(n)</h4><p>计算规则</p>\n<ol>\n<li>基本操作，只有<strong>常数项O(1)</strong></li>\n<li>顺序结构，按<strong>加法计算</strong></li>\n<li>循环结构，按<strong>乘法计算</strong></li>\n<li>分支结构，<strong>取最大值</strong></li>\n</ol>\n<h4 id=\"2-3-空间复杂度S-n\"><a href=\"#2-3-空间复杂度S-n\" class=\"headerlink\" title=\"2.3  空间复杂度S(n)\"></a>2.3  空间复杂度S(n)</h4><p><strong>一个算法在运行过程中临时占用存储空间大小的度量</strong></p>\n<h2 id=\"二、线性数据结构\"><a href=\"#二、线性数据结构\" class=\"headerlink\" title=\"二、线性数据结构\"></a>二、线性数据结构</h2><p>特点：在数据元素的非空有限集合中</p>\n<ul>\n<li>存在唯一的（第一个–最后一个）数据元素</li>\n<li>且第一个元素没有直接前驱元素，最后一个元素没有直接后继元素，其他元素都有唯一的前驱和后继元素</li>\n</ul>\n<h3 id=\"1-线性表\"><a href=\"#1-线性表\" class=\"headerlink\" title=\"1  线性表\"></a>1  线性表</h3><ul>\n<li>线性表有顺序存储结构和链式存储结构。</li>\n</ul>\n<h4 id=\"1-1-顺序存储结构（顺序表）\"><a href=\"#1-1-顺序存储结构（顺序表）\" class=\"headerlink\" title=\"1.1  顺序存储结构（顺序表）\"></a>1.1  顺序存储结构（顺序表）</h4><p><strong>是指将线性表中的各个元素依次存放在一组地址连续的存储单元中，通常将这种方法存储的线性表称为顺序表。</strong><br>顺序表的优缺点：</p>\n<ul>\n<li>优：无须关心表中元素之间的关系，所以不用增加额外的存储空间；可以快速地取表中任意位置的元素。</li>\n<li>缺：插入和删除需要移动大量元素</li>\n</ul>\n<h4 id=\"1-2-线性表的链式存储（链表）\"><a href=\"#1-2-线性表的链式存储（链表）\" class=\"headerlink\" title=\"1.2  线性表的链式存储（链表）\"></a>1.2  线性表的链式存储（链表）</h4><p>一组任意的连续或非连续存储单元存储线性表的元素，存储元素本身（数据域）和后继元素地址（指针域)    </p>\n<ul>\n<li><p>链表与顺序表的对比</p>\n<table>\n<thead>\n<tr>\n<th align=\"center\"></th>\n<th align=\"center\">存储方式</th>\n<th align=\"center\">时间性能</th>\n<th align=\"center\">空间性能</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\">顺序表</td>\n<td align=\"center\">连续的存储单元</td>\n<td align=\"center\">查找：O(1)；插入、删除：O(n)</td>\n<td align=\"center\">预先分配空间</td>\n</tr>\n<tr>\n<td align=\"center\">单链表</td>\n<td align=\"center\">任意的存储单元</td>\n<td align=\"center\">查找：O(n)；插入、删除：O(1)</td>\n<td align=\"center\">不用估计预用空间大小</td>\n</tr>\n</tbody></table>\n</li>\n</ul>\n<p>循环单链表：首尾相连的一种单链表，最后一个结点称为：尾指针：rear</p>\n<p>双向链表： 链表中的每个结点有两个指针域，一个指向直接前驱结点，另一个指向直接后继结点。 data – prior – next </p>\n<h3 id=\"2-栈和队列\"><a href=\"#2-栈和队列\" class=\"headerlink\" title=\"2  栈和队列\"></a>2  栈和队列</h3><h4 id=\"2-1-栈\"><a href=\"#2-1-栈\" class=\"headerlink\" title=\"2.1  栈\"></a>2.1  栈</h4><p><strong>限制在表一端进行插入（入栈）和删除（出栈）操作的线性表</strong></p>\n<ul>\n<li><p>栈顶：允许操作端</p>\n</li>\n<li><p>栈底：固定端</p>\n</li>\n</ul>\n<blockquote>\n<p>先进后出</p>\n</blockquote>\n<h5 id=\"2-1-1-栈的存储结构\"><a href=\"#2-1-1-栈的存储结构\" class=\"headerlink\" title=\"2.1.1  栈的存储结构\"></a>2.1.1  栈的存储结构</h5><p>栈是运算受限的线性表，线性表的存储结构对栈也适用</p>\n<ol>\n<li>顺序栈</li>\n<li>链栈</li>\n</ol>\n<h4 id=\"2-2-队列\"><a href=\"#2-2-队列\" class=\"headerlink\" title=\"2.2  队列\"></a>2.2  队列</h4><p><strong>插入（队尾）在表一段，删除（对头）在表的另一端</strong></p>\n<blockquote>\n<p>先进先出</p>\n</blockquote>\n<h5 id=\"2-2-1-队列的存储结构\"><a href=\"#2-2-1-队列的存储结构\" class=\"headerlink\" title=\"2.2.1  队列的存储结构\"></a>2.2.1  队列的存储结构</h5><p>队列也是一种运算受限的线性表</p>\n<ul>\n<li>顺序队列</li>\n<li>链队列</li>\n</ul>\n<p>小结：</p>\n<ol>\n<li>链式栈的栈顶应在链头，插入与删除操作都在链头进行。</li>\n<li>循环队列要注意对空条件和对满条件；而对于链队列，需要特别注意出队仅对队头指针操作，当只有一个元素时，出队需要修改队尾指针。</li>\n<li>递归实质上是通过栈来实现函数调用，只不过是调用自身而已。</li>\n</ol>\n<h3 id=\"3-字符串和数组\"><a href=\"#3-字符串和数组\" class=\"headerlink\" title=\"3  字符串和数组\"></a>3  字符串和数组</h3><h4 id=\"3-1-字符串\"><a href=\"#3-1-字符串\" class=\"headerlink\" title=\"3.1  字符串\"></a>3.1  字符串</h4><p> 串（String）是由零个或多个任意字符串组成的字符序列。 </p>\n<h5 id=\"3-1-1-串的存储结构\"><a href=\"#3-1-1-串的存储结构\" class=\"headerlink\" title=\"3.1.1  串的存储结构\"></a>3.1.1  串的存储结构</h5><ul>\n<li>定长顺序存储结构（顺序串）<ul>\n<li>定长是指按预定义的大小为每一个串变量分配固定长度的存储区。 最大不能超过256</li>\n</ul>\n</li>\n<li>堆分配存储结构</li>\n</ul>\n<h4 id=\"3-2-数组\"><a href=\"#3-2-数组\" class=\"headerlink\" title=\"3.2 数组\"></a>3.2 数组</h4><p> <strong>结构中的元素本身可以是具有某种结构的数据，但属于同一数据类型，一般线性表的扩充</strong></p>\n<p>是一个具有固定格式和数量的数据有续集，一旦被定义就不再改变，两种基本运算：</p>\n<ol>\n<li>取值操作：给定一组下标，读其对应的数据元素。</li>\n<li>赋值操作：给定一组下标，存储或修改与其相对应的数据元素。</li>\n</ol>\n<h5 id=\"3-2-1-数组的存储结构\"><a href=\"#3-2-1-数组的存储结构\" class=\"headerlink\" title=\"3.2.1  数组的存储结构\"></a>3.2.1  数组的存储结构</h5><p>一维：顺序存储结构，直接按其下标顺序分配存储空间</p>\n<p>多维：按某种次序将数组中元素排成一个线性序列，再作存储</p>\n<p>存二维数组：</p>\n<ol>\n<li>先行后列</li>\n<li>先列后行</li>\n</ol>\n<h5 id=\"3-2-2-稀疏矩阵\"><a href=\"#3-2-2-稀疏矩阵\" class=\"headerlink\" title=\"3.2.2  稀疏矩阵\"></a>3.2.2  稀疏矩阵</h5><p><strong>矩阵中大多数元素为零元素的矩阵，按常规分配方法浪费内存</strong></p>\n<p>三元组表存储</p>\n<ul>\n<li>非零元素所在行、列及值构成一个三元组（i,j,v）</li>\n</ul>\n<h2 id=\"三、非线性结构\"><a href=\"#三、非线性结构\" class=\"headerlink\" title=\"三、非线性结构\"></a>三、非线性结构</h2><h3 id=\"1-树和二叉树\"><a href=\"#1-树和二叉树\" class=\"headerlink\" title=\"1  树和二叉树\"></a>1  树和二叉树</h3><p>前驱唯一而后继不唯一，一对多</p>\n<p>定义：树（tree）是n（n&gt;=0）个结点的有限集合。当n=0时，该集合满足以下条件：</p>\n<ul>\n<li><p>只有一个特殊节点称为根节点（root）</p>\n</li>\n<li><p>当n&gt;1时，其余n-1个结点被分成m(m&gt;0)个互相不相交的集合，称为根节点的<strong>子树</strong></p>\n<p>树的定义用了递归概念，其算法也常常使用递归</p>\n</li>\n</ul>\n<h4 id=\"1-1-二叉树\"><a href=\"#1-1-二叉树\" class=\"headerlink\" title=\"1.1  二叉树\"></a>1.1  二叉树</h4><p>二叉树是每个节点最多有两个子树的树结构。通常子树被称作“左子树”（left subtree）和“右子树”（right subtree）</p>\n<p>满二叉树：除了叶结点外每一个结点都有左右子叶且叶子结点都处在最底层的二叉树。 </p>\n<h5 id=\"1-1-1-存储结构\"><a href=\"#1-1-1-存储结构\" class=\"headerlink\" title=\"1.1.1  存储结构\"></a>1.1.1  存储结构</h5><p>顺序存储结构：按照二叉树结点从上至下、从左到右的顺序存储。</p>\n<p>链式存储结构：每个节点由三个域组成：数据域和左、右指针域。</p>\n<p><img src=\"https://img-blog.csdnimg.cn/20181214150636793.jpeg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2NzZG5fYWl5YW5n,size_16,color_FFFFFF,t_70\" alt=\"\"></p>\n<h5 id=\"1-1-2-二叉树遍历\"><a href=\"#1-1-2-二叉树遍历\" class=\"headerlink\" title=\"1.1.2  二叉树遍历\"></a>1.1.2  二叉树遍历</h5><p><strong>深度优先一般用递归，广度优先一般用队列。一般情况下能用递归实现的算法大部分也能用堆栈来实现。</strong></p>\n<ol>\n<li>深度优先遍历<ol>\n<li>先序遍历    <code>根节点-&gt;左子树-&gt;右子树</code></li>\n<li>中序遍历    <code>左子树-&gt;根节点-&gt;右子树</code></li>\n<li>后序遍历    <code>左子树-&gt;右子树-&gt;根节点</code></li>\n</ol>\n</li>\n<li>广度优先遍历（层次遍历）<ul>\n<li>从树的root开始，从上到下从从左到右遍历整个树的节点 </li>\n</ul>\n</li>\n</ol>\n<h3 id=\"2-图\"><a href=\"#2-图\" class=\"headerlink\" title=\"2  图\"></a>2  图</h3><p>任意两个结点之间都可能相关，即结点之间的邻接关系可以是任意的。</p>\n<h2 id=\"四、排序和搜索\"><a href=\"#四、排序和搜索\" class=\"headerlink\" title=\"四、排序和搜索\"></a>四、排序和搜索</h2><h3 id=\"1-冒泡排序\"><a href=\"#1-冒泡排序\" class=\"headerlink\" title=\"1  冒泡排序\"></a>1  冒泡排序</h3><p><strong>重复遍历数列，一次比较两个元素</strong></p>\n<p><img src=\"https://tupian-1300728887.cos.ap-chengdu.myqcloud.com/%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F.gif\" alt=\"冒泡排序\"></p>\n<h3 id=\"2-选择排序\"><a href=\"#2-选择排序\" class=\"headerlink\" title=\"2  选择排序\"></a>2  选择排序</h3><p><strong>找到最大或最小的元素，把它排在队前或队尾，循而往复， 放到已排序序列的末尾</strong></p>\n<p><img src=\"https://tupian-1300728887.cos.ap-chengdu.myqcloud.com/%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F.gif\" alt=\"选择排序\"></p>\n<h3 id=\"3-插入排序\"><a href=\"#3-插入排序\" class=\"headerlink\" title=\"3  插入排序\"></a>3  插入排序</h3><p><strong>通过构建有序序列，对于未排序数据，在已排序序列中从后向前扫描，找到相应位置并插入。</strong></p>\n<p><img src=\"https://tupian-1300728887.cos.ap-chengdu.myqcloud.com/%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F.gif\" alt=\"插入排序\"></p>\n<h3 id=\"4-希尔排序\"><a href=\"#4-希尔排序\" class=\"headerlink\" title=\"4  希尔排序\"></a>4  希尔排序</h3><p><strong>希尔排序是插入排序的一种，将数据分成几组，分别使用插入排序</strong></p>\n<p><img src=\"https://tupian-1300728887.cos.ap-chengdu.myqcloud.com/%E5%B8%8C%E5%B0%94%E6%8E%92%E5%BA%8F.jpg\" alt=\"希尔排序\"></p>\n<h3 id=\"5-快速排序\"><a href=\"#5-快速排序\" class=\"headerlink\" title=\"5  快速排序\"></a>5  快速排序</h3><p><strong>从序列中挑出一个元素（基准），把小于（大于）基准的元素放在基准前边（后边）</strong></p>\n<p><img src=\"https://tupian-1300728887.cos.ap-chengdu.myqcloud.com/%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F.gif\" alt=\"快速排序\"></p>\n<h3 id=\"6-归并排序\"><a href=\"#6-归并排序\" class=\"headerlink\" title=\"6  归并排序\"></a>6  归并排序</h3><p> <strong>分治法，先递归分解数据，在合并数组；比较两个数组最前边的数，谁小谁先取</strong></p>\n<p><img src=\"https://tupian-1300728887.cos.ap-chengdu.myqcloud.com/%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F.gif\" alt=\"归并排序\"></p>\n<h2 id=\"五、搜索\"><a href=\"#五、搜索\" class=\"headerlink\" title=\"五、搜索\"></a>五、搜索</h2><h3 id=\"1-顺序查找\"><a href=\"#1-顺序查找\" class=\"headerlink\" title=\"1  顺序查找\"></a>1  顺序查找</h3><h3 id=\"2-二分法查找\"><a href=\"#2-二分法查找\" class=\"headerlink\" title=\"2  二分法查找\"></a>2  二分法查找</h3><h3 id=\"3-二叉树查找\"><a href=\"#3-二叉树查找\" class=\"headerlink\" title=\"3  二叉树查找\"></a>3  二叉树查找</h3><h3 id=\"4-哈希查找\"><a href=\"#4-哈希查找\" class=\"headerlink\" title=\"4  哈希查找\"></a>4  哈希查找</h3>"},{"title":"网络通信概括","date":"2020-09-30T03:35:15.000Z","top":0,"_content":"\n# 一、通信协议\n\nTDP：用户数据报协议，无连接的\n\n**TCP：传输控制协议，面向连接的、可靠的、基于字节流的传输层通信协议**\n\nHTTP：超文本传输协议，浏览器和web服务器通信需要HTTP协议 \n\nRPC：远程过程调用，向另一台计算机上的程序请求服务，不需要了解底层网络技术的协议。\n\n<!--more-->\n\n## 1. 网络协议分层\n\n[参考文档](https://www.jianshu.com/p/30fb2b0bcfd8)\n\n![](https://tupian-1300728887.cos.ap-chengdu.myqcloud.com/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE%E5%88%86%E5%B1%82.png)\n\n\n\n## 2  长连接与短连接\n\n长连接：连接 -> 传输数据 -> 保持连接 -> 传输数据 -> 直到一方断开\n\n- 操作频繁、点对点的通讯、数据库连接\n  - TCP三握手时间\n  - 不安全\n\n短连接：连接 -> 传输数据-> 断开连接\n\n- http服务\n\n## 3  CSRF攻击\n\n[参考文档](https://handout-1300728887.cos.ap-beijing.myqcloud.com/%E8%AE%B2%E4%B9%89/Django%E6%A1%86%E6%9E%B6/Django%E6%A1%86%E6%9E%B6/C05-Template/csrf.html)\n\n1. 浏览并登录信任网站A\n2. 验证通过，产生A的Cookie\n3. 再没登出的情况下，浏览**攻击网站B**\n4. B要求访问第三方网站A\n5. 根据B的请求，浏览器带着A的Cookie访问A\n6. A不知道请求源，因为浏览器会自动携带用户的Cookie，按需处理请求，达到模拟用户操作csrf攻击\n\n**防止csrf攻击**\n\n1. 在后端响应的cookie写入csrf_token值\n2. 前端from表单中也写入csrf_token值\n3. 获取两个csrf_token，看是否一致\n\nDjango自带的防csrf中间间\n\n**跨站请求伪造**：攻击者盗用你的身份，发送恶意请求\n\n# Q&A\n\n## 1  token和jwt存在什么区别\n\ntoken需要查库验证，JWT直接在服务端进行，不需要查库\n\n## 2  什么是三次握手和四次挥手\n\n[参考文档](https://blog.csdn.net/qq_38950316/article/details/81087809)\n\n三次挥手：\n\n1. 建立连接时，客户端发送syn包（seq=x）到服务器，并进入SYN_SENT（发送）状态，等待服务器确认；\n2. 服务器收到syn包，必须确认客户的SYN（ack=x+1），同时自己也发送一个SYN包（seq=y），即SYN+ACK包，此时服务器进入SYN_RECV（收到）状态；\n3. 客户端收到服务器的SYN+ACK包，向服务器发送确认包ACK(ack=y+1），此包发送完毕，客户端和服务器进入ESTABLISHED（TCP连接成功）状态，完成三次握手。\n\n四次挥手：\n\n待补充\n\n## 3 什么是RESTFul\n\n- 每一个URI代表1种资源；\n\n- 客户端使用GET、POST、PUT、DELETE4个表示操作方式的动词对服务端资源进行操作：GET用来获取资源，POST用来新建资源（也可以用于更新资源），PUT用来更新资源，DELETE用来删除资源；\n\n- 通过操作资源的表现形式来操作资源；\n\n- 资源的表现形式是XML或者HTML；\n\n- 客户端与服务端之间的交互在请求之间是无状态的，从客户端到服务端的每个请求都必须包含理解请求所必需的信息。","source":"_posts/网络通信概括.md","raw":"---\ntitle: 网络通信概括\ndate: 2020-09-30 11:35:15\ntags: Web\ntop: 0\n---\n\n# 一、通信协议\n\nTDP：用户数据报协议，无连接的\n\n**TCP：传输控制协议，面向连接的、可靠的、基于字节流的传输层通信协议**\n\nHTTP：超文本传输协议，浏览器和web服务器通信需要HTTP协议 \n\nRPC：远程过程调用，向另一台计算机上的程序请求服务，不需要了解底层网络技术的协议。\n\n<!--more-->\n\n## 1. 网络协议分层\n\n[参考文档](https://www.jianshu.com/p/30fb2b0bcfd8)\n\n![](https://tupian-1300728887.cos.ap-chengdu.myqcloud.com/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE%E5%88%86%E5%B1%82.png)\n\n\n\n## 2  长连接与短连接\n\n长连接：连接 -> 传输数据 -> 保持连接 -> 传输数据 -> 直到一方断开\n\n- 操作频繁、点对点的通讯、数据库连接\n  - TCP三握手时间\n  - 不安全\n\n短连接：连接 -> 传输数据-> 断开连接\n\n- http服务\n\n## 3  CSRF攻击\n\n[参考文档](https://handout-1300728887.cos.ap-beijing.myqcloud.com/%E8%AE%B2%E4%B9%89/Django%E6%A1%86%E6%9E%B6/Django%E6%A1%86%E6%9E%B6/C05-Template/csrf.html)\n\n1. 浏览并登录信任网站A\n2. 验证通过，产生A的Cookie\n3. 再没登出的情况下，浏览**攻击网站B**\n4. B要求访问第三方网站A\n5. 根据B的请求，浏览器带着A的Cookie访问A\n6. A不知道请求源，因为浏览器会自动携带用户的Cookie，按需处理请求，达到模拟用户操作csrf攻击\n\n**防止csrf攻击**\n\n1. 在后端响应的cookie写入csrf_token值\n2. 前端from表单中也写入csrf_token值\n3. 获取两个csrf_token，看是否一致\n\nDjango自带的防csrf中间间\n\n**跨站请求伪造**：攻击者盗用你的身份，发送恶意请求\n\n# Q&A\n\n## 1  token和jwt存在什么区别\n\ntoken需要查库验证，JWT直接在服务端进行，不需要查库\n\n## 2  什么是三次握手和四次挥手\n\n[参考文档](https://blog.csdn.net/qq_38950316/article/details/81087809)\n\n三次挥手：\n\n1. 建立连接时，客户端发送syn包（seq=x）到服务器，并进入SYN_SENT（发送）状态，等待服务器确认；\n2. 服务器收到syn包，必须确认客户的SYN（ack=x+1），同时自己也发送一个SYN包（seq=y），即SYN+ACK包，此时服务器进入SYN_RECV（收到）状态；\n3. 客户端收到服务器的SYN+ACK包，向服务器发送确认包ACK(ack=y+1），此包发送完毕，客户端和服务器进入ESTABLISHED（TCP连接成功）状态，完成三次握手。\n\n四次挥手：\n\n待补充\n\n## 3 什么是RESTFul\n\n- 每一个URI代表1种资源；\n\n- 客户端使用GET、POST、PUT、DELETE4个表示操作方式的动词对服务端资源进行操作：GET用来获取资源，POST用来新建资源（也可以用于更新资源），PUT用来更新资源，DELETE用来删除资源；\n\n- 通过操作资源的表现形式来操作资源；\n\n- 资源的表现形式是XML或者HTML；\n\n- 客户端与服务端之间的交互在请求之间是无状态的，从客户端到服务端的每个请求都必须包含理解请求所必需的信息。","slug":"网络通信概括","published":1,"updated":"2020-09-30T08:04:10.866Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckfp5akg80016n8jhewdb1kp8","content":"<h1 id=\"一、通信协议\"><a href=\"#一、通信协议\" class=\"headerlink\" title=\"一、通信协议\"></a>一、通信协议</h1><p>TDP：用户数据报协议，无连接的</p>\n<p><strong>TCP：传输控制协议，面向连接的、可靠的、基于字节流的传输层通信协议</strong></p>\n<p>HTTP：超文本传输协议，浏览器和web服务器通信需要HTTP协议 </p>\n<p>RPC：远程过程调用，向另一台计算机上的程序请求服务，不需要了解底层网络技术的协议。</p>\n<a id=\"more\"></a>\n\n<h2 id=\"1-网络协议分层\"><a href=\"#1-网络协议分层\" class=\"headerlink\" title=\"1. 网络协议分层\"></a>1. 网络协议分层</h2><p><a href=\"https://www.jianshu.com/p/30fb2b0bcfd8\" target=\"_blank\" rel=\"noopener\">参考文档</a></p>\n<p><img src=\"https://tupian-1300728887.cos.ap-chengdu.myqcloud.com/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE%E5%88%86%E5%B1%82.png\" alt=\"\"></p>\n<h2 id=\"2-长连接与短连接\"><a href=\"#2-长连接与短连接\" class=\"headerlink\" title=\"2  长连接与短连接\"></a>2  长连接与短连接</h2><p>长连接：连接 -&gt; 传输数据 -&gt; 保持连接 -&gt; 传输数据 -&gt; 直到一方断开</p>\n<ul>\n<li>操作频繁、点对点的通讯、数据库连接<ul>\n<li>TCP三握手时间</li>\n<li>不安全</li>\n</ul>\n</li>\n</ul>\n<p>短连接：连接 -&gt; 传输数据-&gt; 断开连接</p>\n<ul>\n<li>http服务</li>\n</ul>\n<h2 id=\"3-CSRF攻击\"><a href=\"#3-CSRF攻击\" class=\"headerlink\" title=\"3  CSRF攻击\"></a>3  CSRF攻击</h2><p><a href=\"https://handout-1300728887.cos.ap-beijing.myqcloud.com/%E8%AE%B2%E4%B9%89/Django%E6%A1%86%E6%9E%B6/Django%E6%A1%86%E6%9E%B6/C05-Template/csrf.html\" target=\"_blank\" rel=\"noopener\">参考文档</a></p>\n<ol>\n<li>浏览并登录信任网站A</li>\n<li>验证通过，产生A的Cookie</li>\n<li>再没登出的情况下，浏览<strong>攻击网站B</strong></li>\n<li>B要求访问第三方网站A</li>\n<li>根据B的请求，浏览器带着A的Cookie访问A</li>\n<li>A不知道请求源，因为浏览器会自动携带用户的Cookie，按需处理请求，达到模拟用户操作csrf攻击</li>\n</ol>\n<p><strong>防止csrf攻击</strong></p>\n<ol>\n<li>在后端响应的cookie写入csrf_token值</li>\n<li>前端from表单中也写入csrf_token值</li>\n<li>获取两个csrf_token，看是否一致</li>\n</ol>\n<p>Django自带的防csrf中间间</p>\n<p><strong>跨站请求伪造</strong>：攻击者盗用你的身份，发送恶意请求</p>\n<h1 id=\"Q-amp-A\"><a href=\"#Q-amp-A\" class=\"headerlink\" title=\"Q&amp;A\"></a>Q&amp;A</h1><h2 id=\"1-token和jwt存在什么区别\"><a href=\"#1-token和jwt存在什么区别\" class=\"headerlink\" title=\"1  token和jwt存在什么区别\"></a>1  token和jwt存在什么区别</h2><p>token需要查库验证，JWT直接在服务端进行，不需要查库</p>\n<h2 id=\"2-什么是三次握手和四次挥手\"><a href=\"#2-什么是三次握手和四次挥手\" class=\"headerlink\" title=\"2  什么是三次握手和四次挥手\"></a>2  什么是三次握手和四次挥手</h2><p><a href=\"https://blog.csdn.net/qq_38950316/article/details/81087809\" target=\"_blank\" rel=\"noopener\">参考文档</a></p>\n<p>三次挥手：</p>\n<ol>\n<li>建立连接时，客户端发送syn包（seq=x）到服务器，并进入SYN_SENT（发送）状态，等待服务器确认；</li>\n<li>服务器收到syn包，必须确认客户的SYN（ack=x+1），同时自己也发送一个SYN包（seq=y），即SYN+ACK包，此时服务器进入SYN_RECV（收到）状态；</li>\n<li>客户端收到服务器的SYN+ACK包，向服务器发送确认包ACK(ack=y+1），此包发送完毕，客户端和服务器进入ESTABLISHED（TCP连接成功）状态，完成三次握手。</li>\n</ol>\n<p>四次挥手：</p>\n<p>待补充</p>\n<h2 id=\"3-什么是RESTFul\"><a href=\"#3-什么是RESTFul\" class=\"headerlink\" title=\"3 什么是RESTFul\"></a>3 什么是RESTFul</h2><ul>\n<li><p>每一个URI代表1种资源；</p>\n</li>\n<li><p>客户端使用GET、POST、PUT、DELETE4个表示操作方式的动词对服务端资源进行操作：GET用来获取资源，POST用来新建资源（也可以用于更新资源），PUT用来更新资源，DELETE用来删除资源；</p>\n</li>\n<li><p>通过操作资源的表现形式来操作资源；</p>\n</li>\n<li><p>资源的表现形式是XML或者HTML；</p>\n</li>\n<li><p>客户端与服务端之间的交互在请求之间是无状态的，从客户端到服务端的每个请求都必须包含理解请求所必需的信息。</p>\n</li>\n</ul>\n","site":{"data":{}},"excerpt":"<h1 id=\"一、通信协议\"><a href=\"#一、通信协议\" class=\"headerlink\" title=\"一、通信协议\"></a>一、通信协议</h1><p>TDP：用户数据报协议，无连接的</p>\n<p><strong>TCP：传输控制协议，面向连接的、可靠的、基于字节流的传输层通信协议</strong></p>\n<p>HTTP：超文本传输协议，浏览器和web服务器通信需要HTTP协议 </p>\n<p>RPC：远程过程调用，向另一台计算机上的程序请求服务，不需要了解底层网络技术的协议。</p>","more":"<h2 id=\"1-网络协议分层\"><a href=\"#1-网络协议分层\" class=\"headerlink\" title=\"1. 网络协议分层\"></a>1. 网络协议分层</h2><p><a href=\"https://www.jianshu.com/p/30fb2b0bcfd8\" target=\"_blank\" rel=\"noopener\">参考文档</a></p>\n<p><img src=\"https://tupian-1300728887.cos.ap-chengdu.myqcloud.com/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE%E5%88%86%E5%B1%82.png\" alt=\"\"></p>\n<h2 id=\"2-长连接与短连接\"><a href=\"#2-长连接与短连接\" class=\"headerlink\" title=\"2  长连接与短连接\"></a>2  长连接与短连接</h2><p>长连接：连接 -&gt; 传输数据 -&gt; 保持连接 -&gt; 传输数据 -&gt; 直到一方断开</p>\n<ul>\n<li>操作频繁、点对点的通讯、数据库连接<ul>\n<li>TCP三握手时间</li>\n<li>不安全</li>\n</ul>\n</li>\n</ul>\n<p>短连接：连接 -&gt; 传输数据-&gt; 断开连接</p>\n<ul>\n<li>http服务</li>\n</ul>\n<h2 id=\"3-CSRF攻击\"><a href=\"#3-CSRF攻击\" class=\"headerlink\" title=\"3  CSRF攻击\"></a>3  CSRF攻击</h2><p><a href=\"https://handout-1300728887.cos.ap-beijing.myqcloud.com/%E8%AE%B2%E4%B9%89/Django%E6%A1%86%E6%9E%B6/Django%E6%A1%86%E6%9E%B6/C05-Template/csrf.html\" target=\"_blank\" rel=\"noopener\">参考文档</a></p>\n<ol>\n<li>浏览并登录信任网站A</li>\n<li>验证通过，产生A的Cookie</li>\n<li>再没登出的情况下，浏览<strong>攻击网站B</strong></li>\n<li>B要求访问第三方网站A</li>\n<li>根据B的请求，浏览器带着A的Cookie访问A</li>\n<li>A不知道请求源，因为浏览器会自动携带用户的Cookie，按需处理请求，达到模拟用户操作csrf攻击</li>\n</ol>\n<p><strong>防止csrf攻击</strong></p>\n<ol>\n<li>在后端响应的cookie写入csrf_token值</li>\n<li>前端from表单中也写入csrf_token值</li>\n<li>获取两个csrf_token，看是否一致</li>\n</ol>\n<p>Django自带的防csrf中间间</p>\n<p><strong>跨站请求伪造</strong>：攻击者盗用你的身份，发送恶意请求</p>\n<h1 id=\"Q-amp-A\"><a href=\"#Q-amp-A\" class=\"headerlink\" title=\"Q&amp;A\"></a>Q&amp;A</h1><h2 id=\"1-token和jwt存在什么区别\"><a href=\"#1-token和jwt存在什么区别\" class=\"headerlink\" title=\"1  token和jwt存在什么区别\"></a>1  token和jwt存在什么区别</h2><p>token需要查库验证，JWT直接在服务端进行，不需要查库</p>\n<h2 id=\"2-什么是三次握手和四次挥手\"><a href=\"#2-什么是三次握手和四次挥手\" class=\"headerlink\" title=\"2  什么是三次握手和四次挥手\"></a>2  什么是三次握手和四次挥手</h2><p><a href=\"https://blog.csdn.net/qq_38950316/article/details/81087809\" target=\"_blank\" rel=\"noopener\">参考文档</a></p>\n<p>三次挥手：</p>\n<ol>\n<li>建立连接时，客户端发送syn包（seq=x）到服务器，并进入SYN_SENT（发送）状态，等待服务器确认；</li>\n<li>服务器收到syn包，必须确认客户的SYN（ack=x+1），同时自己也发送一个SYN包（seq=y），即SYN+ACK包，此时服务器进入SYN_RECV（收到）状态；</li>\n<li>客户端收到服务器的SYN+ACK包，向服务器发送确认包ACK(ack=y+1），此包发送完毕，客户端和服务器进入ESTABLISHED（TCP连接成功）状态，完成三次握手。</li>\n</ol>\n<p>四次挥手：</p>\n<p>待补充</p>\n<h2 id=\"3-什么是RESTFul\"><a href=\"#3-什么是RESTFul\" class=\"headerlink\" title=\"3 什么是RESTFul\"></a>3 什么是RESTFul</h2><ul>\n<li><p>每一个URI代表1种资源；</p>\n</li>\n<li><p>客户端使用GET、POST、PUT、DELETE4个表示操作方式的动词对服务端资源进行操作：GET用来获取资源，POST用来新建资源（也可以用于更新资源），PUT用来更新资源，DELETE用来删除资源；</p>\n</li>\n<li><p>通过操作资源的表现形式来操作资源；</p>\n</li>\n<li><p>资源的表现形式是XML或者HTML；</p>\n</li>\n<li><p>客户端与服务端之间的交互在请求之间是无状态的，从客户端到服务端的每个请求都必须包含理解请求所必需的信息。</p>\n</li>\n</ul>"},{"title":"总汇","date":"2020-02-28T11:56:28.000Z","top":0,"_content":"\n# （一）Flask与Django\n\n- **轻量、简洁、扩展性强，，原生不支持数据库**\n- 核心：werkzeug和jinja2\n\n<!--more-->\n\n|   房有居   | 用户模块、主页渲染、搜索房源信息功能及数据库的优化 |\n| :--------: | :------------------------------------------------: |\n| **食天下** |              **现菜谱展示、用户模块**              |\n| **书香阁** |         **书刊列表展示、用户历史记录保存**         |\n\n---\n\n### Flask与Django对比\n\n- 与Django对比\n  - 不同点：\n    1. Django：支持 ORM、认证、CSRF/模板、后台管理等。 \n    2. Flask：自带jinja2模板，实现其它功能需要调用扩展包\n  - 相同点：\n    1.  性能都不⾼，都是单进程服务器。 \n\n### MVT设计模式\n\n设计模式：解决一类问题而总结出来的经验和套路\n\n**MVC：**核心思想：分工、解耦，让不同代码之间降低耦合，增强代码的可扩展性和可移植性\n\n**MVT：**\n\n- M：模型 Model\n- V：视图 View\n- T：模板 Template\n\n### 前后端不分离的区别\n\n前后端不分离：\n\n- 页面的控制和渲染是由后端实现的\n  - 优点：页面展示无延迟，因为响应给用户的就是页面；方便实现搜索引擎排名，帮助爬虫服务器更高效率的爬取数据，即SEO\n  - 缺点：对后端程序员要求高\n\n前后端分离：\n\n- 页面的控制和渲染是由前端实现的\n  - 优点：后端程序员只需专注数据和业务即可\n  - 缺点：有延迟，先加载页面 -- 发请求获取数据 -- 渲染\n- 补充：前后端不分离，一般不做页面静态化，因为用户先拿到的就是静态页面\n\n### Django信号\n\n**Django 提供一个“信号分发器”，允许解耦的应用在框架的其它地方发生操作时会被通知到。信号允许特定的sender（发送者）通知一组receiver（接收者）某些操作已经发生。**\n\n信号遵守的设计模式：**观察者设计模式（通知机制、监听机制）**\n\n- [使用](https://handout-1300728887.cos.ap-beijing.myqcloud.com/%E8%AE%B2%E4%B9%89/%E6%80%9D%E7%BB%B4%E5%AF%BC%E5%9B%BE/Django%E4%BF%A1%E5%8F%B7.jpg)\n\n### Django项目中的社会化分享\n\n结合项目中使用：\n\n- MobTech平台创建应用：https://www.mob.com/\n\n  1. 注册登录\n  2. 产品中心 --> 开发者平台\n  3. 创建应用并添加产品和SDK\n  4. 进入到<应用管理>查看App Key和App Secret\n\n- 创建Django项目\n\n- 根据开发文档集成ShareSDK\n\n  - 进入文档中心，打开web集成文档\n\n    https://www.mob.com/wiki/list\n\n  - 根据开发文档集成ShareSDK，实现社会化分享功能\n\n### Django自带的缓存cache和redis的区别\n\ncache是python实现缓存的一种工具\n\nredis是一种存放缓存数据的数据库\n\n可以使用cache这个缓存工具，将缓存数据缓存到redis数据库\n\n### 如何对Django框架进行二次开发，增大并发数\n\n可能造成并发降低的原因：\n\n1. 数据库操作变慢\n2. python语言执行速度变慢\n\nDjango二次开发方向：\n\n- 扩展Django Models使其支持Sharding（一种数据库分片技术）\n- 手动关闭GC（垃圾回收）\n- **把那些稳定且对性能最敏感的组件，使用c或c++来重写**\n\n### 中间件的定义方式、结构\n\n```python\ndef middleware_name(get_response):\n    # 这个节点表示请求初始化：在最开始的时候补充额外逻辑\n    def middleware(request):\n        # 这个节点表示请求被执行前：在请求执行的时候补充额外逻辑\n        response = get_response(request)\n        # z这个节点表示响应之前：在响应之前补充额外逻辑\n        return response\n    return middleware\n```\n\n### [ORM（ **object-relation-mapping** ）](https://handout-1300728887.cos.ap-beijing.myqcloud.com/%E8%AE%B2%E4%B9%89/%E9%BB%91%E9%A9%AC%E5%A4%B4%E6%9D%A1%E9%A1%B9%E7%9B%AE%E8%AF%BE%E4%BB%B6/C02-Database/ORM.html)\n\n- 对象关系映射 本质上就是将数据从一种形式转换到另外一种形式，定义的类相当于数据库中的表，在类中的定义的属性相当于是表中的字段，实例化的每一个对象，相当于的每一条数据。\n  - 类 -> 表\n  - 类属性 -> 字段\n  - 类对象 -> 数据\n\n- 作用：\n\n  1. 省去编写sql语句，提⾼开发效率；\n\n  2. 防注⼊攻击\n\n  3. 适配不同的数据库。\n- 缺点：查询效率较低，需要手动的优化。\n- 操作方式：\n\n  1. 先创建模型类，再迁移到数据库中：不能对数据库表的字段的定义，实现精确控制。 \n  2. 使⽤sql创建数据库的表，定义模型类，通过模型类，实现ORM操作。 \n\n---\n\n#  （二）熟练 MySQL、Redis 等数据库的使用\n\n### 1  [复制集与分布式](https://handout-1300728887.cos.ap-beijing.myqcloud.com/%E8%AE%B2%E4%B9%89/%E9%BB%91%E9%A9%AC%E5%A4%B4%E6%9D%A1%E9%A1%B9%E7%9B%AE%E8%AF%BE%E4%BB%B6/C02-Database/DatabaseTheory.html)\n\n- 复制集：\n  1. 数据库中数据相同，起到备份作用\n  2. 高可用\n\n- 分布式：\n  1. 数据库中数据不同，共同组成完整的数据集合\n  2. 高吞吐\n\n### 2  主从复制\n\n1. 主服务器的数据发生改变时，会将改变的记录写在本地二进制log日志中\n2. 从服务器的一个线程会把更新的数据拷贝中继log日志中\n3. 从服务器读取中继文件并执行，达到主从一致\n\n **利用主从在达到高可用的同时，也可以通过读写分离提供吞吐量。** \n\n### 3  [事务](https://handout-1300728887.cos.ap-beijing.myqcloud.com/%E8%AE%B2%E4%B9%89/python-web%E5%9F%BA%E7%A1%80(5.1.2%E7%89%88%E6%9C%AC)/mysqlhigh/%E4%BA%8B%E5%8A%A1.html)\n\n- 四大特性：\n  - 原子性：强调事务中的多个操作时一个整体\n  - 一致性：强调数据库中不会保存不一致状态\n  - 隔离性：强调数据库中事务之间相互不可见\n  - 持久性：强调数据库能永久保存数据，一旦提交就不可撤销\n- 隔离级别：\n  - 读已提交：一个事务要等另一个事务提交后才能读取数据，可避免脏读的发生。\n  - 读未提交：一个事务可以读取另一个未提交事务的数据，最低级别，任何情况都无法保证。\n  - **可重复读(MySQL默认)**：就是在开始读取数据（事务开启）时，不再允许修改操作，可避免脏读、不可重复读的发生。\n  - 串行化：最高的事务隔离级别，事务串行化顺序执行，可以避免脏读、不可重复读与幻读。效率抵消，耗性能\n\n## 一、Mysql\n\n### 1  [索引](https://handout-1300728887.cos.ap-beijing.myqcloud.com/%E8%AE%B2%E4%B9%89/python-web%E5%9F%BA%E7%A1%80(5.1.2%E7%89%88%E6%9C%AC)/mysqlhigh/%E7%B4%A2%E5%BC%95.html)\n\n也叫“键”，保存数据库中所有记录的位置信息，相比于目录\n\n优点：加快查询速度\n\n缺点：耗费时间空间（不是越多越好）\n\n**优化**\n\n1. 不是越多越好，而是需要自己合理的使用\n\n### 2  [sql语句优化](https://handout-1300728887.cos.ap-beijing.myqcloud.com/%E8%AE%B2%E4%B9%89/%E9%BB%91%E9%A9%AC%E5%A4%B4%E6%9D%A1%E9%A1%B9%E7%9B%AE%E8%AF%BE%E4%BB%B6/C02-Database/DatabaseOptimize.html)\n\n- 1.避免全表扫描 \n- 2.查询时使⽤select明确指明所要查询的字段，避免使⽤ select * 的操作； \n- 3.SQL语句尽量⼤写 \n- 4.尽量避免在 where ⼦句中使⽤!=或<>操作符， \n- 5.遵循最左原则，在where⼦句中写查询条件时把索引字段放在前⾯ \n- 6.能使⽤关联查询解决的，尽量不要使⽤⼦查询 \n- 7.能不使⽤关联查询的尽量不要使⽤关联查询 \n- 8.不需要获取全表数据的时候，不要查询全表数据，使⽤LIMIT来限制数据 \n\n### 3  数据库的优化\n\n- 在进⾏表设计时，可适度增加冗余字段(反范式设计)，减少JOIN操作；\n- 多字段表可以进⾏垂直分表优化，多数据表可以进⾏⽔平分表优化；\n- 选择恰当的数据类型，如整型的选择；\n- 对于强调快速读取的操作，可以考虑使⽤MyISAM数据库引擎；\n- 对较频繁的作为查询条件的字段创建索引；唯⼀性太差的字段不适合单独创建索引，即使频繁作为查询条件；更新⾮常频繁的字段不适合创建索引；\n- 编写SQL时使⽤上⾯的⽅式对SQL语句进⾏优化；\n- 使⽤慢查询⼯具找出效率低下的SQL语句进⾏优化；\n- 构建缓存，减少数据库磁盘操作；\n- 可以考虑结合使⽤内存型数据库，如Redis，进⾏混合存储。\n\n### 4  数据库存储过程与触发器\n\n存储过程：完成特定功能的SOL语句集\n\n触发器：对表进行（插入、删除、更新）触发一系列预定好的SQL语句\n\n### 5  [数据库设计](https://handout-1300728887.cos.ap-beijing.myqcloud.com/%E8%AE%B2%E4%B9%89/%E9%BB%91%E9%A9%AC%E5%A4%B4%E6%9D%A1%E9%A1%B9%E7%9B%AE%E8%AF%BE%E4%BB%B6/C02-Database/DatabaseDesign.html)\n\n库设计：\n\n1. 数据库名要明确\n2. 不同类型的数据分开管理\n\n表设计：\n\n1. 命名，业务表跟基础表区分，驼峰命名法\n2. 词性分析法，**名词体现表或字段，动词体现关系**\n   - 一对一、一对多、多对多\n3. 不要用物理删除，以防后悔\n4. 三范式：\n   - 字段不可分割、原子性\n   - 满足范式一，表有主键依赖\n   - 满足范式二，表非主字段之间没有依赖关系。\n5. 反范式：**利用冗余字段存储数据，节省数据查询的时间，本质是空间换时间。**\n6. 字段类型、是否允许为null、是否有默认值\n   - 整形：int长度并不影响精度，长度只和显示有关\n     - **存储范围相同**\n   - 字符串：char和varchar\n     - char不可变，查询效率高，可能造成存储浪费\n     - varchar可变，查询效率不如char，节省空间\n7. 索引设计\n   - 主键、外键、唯一约束；\n   - key/value，提高查询效率的字段；\n   - **外键：作用是维护数据的完整性。**\n     - 应用：在实际开发项目过程中，用不用外键？\n     - 建议：项目开发初期可以利用外键帮助维护数据的完整性，但是，项目的中后期，建议移除外键。\n8. 数据库引擎（MySQL的核心）的选择：决定数据存储和增删改查方式，争对表\n   - **InnoDB**（事务、安全能力）\n     1. **支持事务，安全性级别较高，查询效率相对较低。**\n     2. 为处理巨大数据量的最大性能设计\n     3. **InnoDB支持外键完整性约束**\n   - **MyISAM**（主要用来插入和查询）\n     1. **不支持事务，插入、查询效率较高，增删改效率较低。**\n     2. 产生三个文件（名字一表名字开始）：\n        1. frm：文件存储表定义\n        2. .MYD：数据文件\n        3. .MYI：索引文件\n   - **MEMORY**（存放临时数据）\n     1. 将表中数据存储到内存中，未查询和引用其他表数据提供快速访问\n\n#### 5.1  分库分表\n\n**垂直拆分**\n\n- 垂直分表：\"大表拆小表\"，基于列字段进行，将不常用，数据较大，长度较长拆分\n- 垂直分库：根据业务切分成不同的库\n\n**水平拆分**\n\n- 水平分表：针对数据量巨大的单张表， 按照某种规则（RANGE,HASH取模等），切分到多张表里面去,有IO瓶颈\n- 水平分库分表：将表数据切分到多个服务器上，分布式，有效解决瓶颈、突破IO\n\n**先垂直分在水平分**\n\n##### 分库分表后面临的问题\n\n- 事务支持\n- 多库结果集合并\n- 跨库join\n\n**分库分表方案产品中间件**：官方MySQL Fabric、阿里TDDL，Cobar、360Atlas\n\n### 6  SQL语句中where和having那个执行更快\n\nSQL语句执行顺序：\n\n`from -> where -> group by -> having -> select -> order by`\n\n两者区别：\n\nwhere：是一个约束声明，结果返回之前起作用，不能使用聚合函数\n\nhaving：是一个过滤声明，过滤分组数据，只能用于group by，可以使用聚合函数\n\n---\n\n## 二、Redis\n\n### 1  [Redis特点](https://handout-1300728887.cos.ap-beijing.myqcloud.com/%E8%AE%B2%E4%B9%89/%E9%BB%91%E9%A9%AC%E5%A4%B4%E6%9D%A1%E9%A1%B9%E7%9B%AE%E8%AF%BE%E4%BB%B6/C02-Database/Redis.html)\n\n1. 速度快：C语言实现，存储在内存中以键值对形式保存\n2. **持久化:**\n   - redis可以将数据写入到磁盘中，在停机后，再次启动redis时，将磁盘中的备份数据加载到redis中\n   - 两种机制：\n     1. RDB快照持久化（默认开启）\n        - 将内存中的数据存入磁盘\n        - 缺点：一旦数据库出现问题，rdb文件数据不是全新的\n     2. AOF追加文件持久化\n        - 文件会变大，自动压缩\n3. 多种数据结构：string  hash  list  set  zset\n4. 支持多种编程语言\n5. 支持事务、流水线、消息队列\n6. [主从复制](https://handout-1300728887.cos.ap-beijing.myqcloud.com/%E8%AE%B2%E4%B9%89/redis%E8%AE%B2%E4%B9%89/redis%E8%AE%B2%E4%B9%89/redis/da-jian-zhu-cong.html)\n7. 高可用、分布式\n\n### 2  redis宕机\n\n- slave从宕机\n\n  - 重启后会自动加入到主从架构中，完成数据同步\n\n- master主宕机（主从都没持久化）\n\n  1. 不要立马重启服务\n  2. slave执行`SLAVEOF ON ONE`断开主从关系并升级为主库\n  3. 重启主，`SLAVEOF`设为从\n\n  可使用简单方法：**哨兵**\n\n### 3  redis高可用\n\n**提供了主从同步＋哨兵机制（ Sentinel ）**\n\n- 哨兵机制：实现故障转移，当检测到主服务器发生故障时，把从服务器升级为主，保证数据正常使用\n  - 原理：心跳机制＋投票裁决＋故障转移\n    - 定时给master/slave发送消息，若指定时间内无响应（主观宕机 SDOWN）\n    - Sentinel群都报告某一master无响应（客观宕机 SDOWN）\n    - 通过一定vote算法，将从升为主\n\n### 4  为什么Redis比MySQL快\n\n|            |     Redis      |          MySQL           |\n| :--------: | :------------: | :----------------------: |\n|  数据格式  |      k-v       |          B+TREE          |\n| 时间复杂度 | 0(1)（常数阶） |    0(logn)（对数阶）     |\n|  存储位置  | 从内存直接取出 | 磁盘表（全局扫或索引查） |\n\nRedis是单线程的多路复用IO，单线程避免线程切换开销；多路复用避免IO等待开销；多核处理器下对数据进行分区，各处理器处理不同的数据（分着干）\n\n## 三、缓存\n\n### 1  有效期TTL（Time to live）\n\n- 作用：\n  - 节省空间\n  - 做到数据有效性，失效后，做到数据一致性\n\n#### 1.1  过期策略\n\n- 定时过期：时间一到立即清除，对内存友好，但会占用大量CPU资源\n- 惰性过期：当访问时才去判断是否过期，节省CPU，占用内存\n- 定期过期：每隔一段时间，随机清除\n\n **Redis中同时使用了惰性过期和定期过期两种过期策略。** \n\n#### 1.2  缓存淘汰 （eviction）\n\n-  LRU（Least recently used，最近最少使用）\n   -  新数据插入到表头部\n   -  缓存命中时，将其移到头部\n   -  缓存满的时候将尾部的数据丢掉\n-  LFU（Least Frequently Used 最近最少使用算法）\n   -  如果数据在一段时间内使用次数很少，那么将来也会很少\n\n### 2  缓存模式\n\n- **先更新数据库，再删除缓存** \n\n#### 2.1  缓存穿透\n\n- 频繁请求缓存中不存在的数据，增大数据库压力\n\n  - 解决方案：\n    1. 返回缓存伪造数据\n    2. 限制请求参数\n    3. 借助第三方过滤器：布隆过滤器...\n\n- 布隆过滤器\n\n  本质上是一种**概率型数据结构， 由一个很长的bit数组和一系列哈希函数组成的 **\n\n  特点：**高效地插入和查询**\n\n  算法的核心： **某样东西一定不存在或者可能存在**\n\n  缺点：**数据只能插入不能删除**\n\n  - 存储原理：经过多次不同维度的hash计算，将数据映射到二进制向量里\n  - 服务流程：\n    1. 当用户访问时，去布隆过滤器中判断key值是否存在，否则直接返回\n    2. 如果key值存在，则访问redis，由于存在误判率，redis中也可能不存在\n    3. 再访问数据库，若也不存在，直接返回空\n\n![](https://img-blog.csdnimg.cn/20190306043938625.?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0lUX3Rvd25sZXQ=,size_16,color_FFFFFF,t_70)\n\n#### 2.2  缓存雪崩\n\n- 同一时间内，大量缓存失效，造成数据库压力剧增\n  - 解决方案：\n    1. 设置不同的有效期值\n    2. 采用多级缓存\n    3. 利用加锁或者队列\n\n---\n\n#  （三）[版本控制管理工具 Git](https://learngitbranching.js.org/)\n\n### 一、常用命令\n\n- 克隆远程库\t`git clone 地址`\n- 添加到暂存    `git add .`\n- 提交暂存区的文件到本地仓库    `git commit -m 'test'`\n- 拉取    `git pull origin <name>`\n- 推送    `git push origin <name>`\n- 查看仓库当前的状态    `git status`\n- 查看远程库信息    `git remote`\n- 查看当前分支    `git branch` \n- 切换分支    `git checkout <name>`\n- 合并分支到当前分支    `git merge <name>`\n\n---\n\n# （四）熟悉 Celery 异步方案，多线程、多进程的使用\n\ncelery是异步任务的调度工具，主要解决耗时任务，通过**消息队列**在客户端与消费者间协调\n\n- 消息中间件（消息队列Broker）：客户端把任务放入队列中，消费者从队列中取出任务执行，第三方队列服务：RabbitMQ\\redis\\kafka\\MetaMQ\\RocketMQ\n  - **RabbitMQ：**是一个消息代理。工作是接收和转发消息类似邮局，处理消息\n    - 异步消息：支持多种传递协议，消息排队，传递确认，到队列的灵活路由，多种交换类型\n    - 分布式部署：部署为集群以实现高可用和吞吐量\n    - 可靠性：可在性能和可靠性之间进行权衡\n    - 灵活的路由：通过交换机进行路由\n    - 多协议：多种消息协议的消息传递\n    - 管理与监控：HTTP-API，命令行工具\n  - **基本慨念：**\n    - Producer：生产者，投递消息的程序：创建消息（消息体和标签），RabbitMQ会根据标签把消息发送给消费者\n    - Consumer：消费者，接收消息的程序：丢弃标签，消费消息体\n    - Broker：消息中间件的服务节点：RabbitMQ服务实例\n    - Queue：队列：内部对象，用于存储信息，生产者投递，消费者取出消费\n    - Xchange：交换器。指定消息按什么规则，路由到哪个队列，如果路由不到或返回或丢弃\n    - RoutingKey：路由键关键字，Xchange根据此来进行邮递，需要与交换器类型和绑定键联合使用，决定消息流向哪里\n    - Binding：绑定，把Xchange和Queue按照路由规则绑定起来，指定绑定键（BindingKey）\n- 任务执行单元（消费者worker）：可以有多个并发，实时监控消息队列，获取任务并执行它\n- 任务执行结果存储（task result store）：由于是由主任务中解耦出来的，主任务想要知道执行结果，必须通过中间件存储\n\n### 1  消息队列的理解\n\n**消息队列**：保存消息的容器\n\n消息:传输的数据单位\n\n消息源与目标间的中间人，主要目的是**提供路由保证消息的传递**，\n\n### 2  为什么使用消息队列\n\n在高并发情况下，来不及同步处理，请求会发生堵塞。通过消息队列，可以异步处理请求，缓解系统压力\n\n应用场景：\n\n- 异步处理、应用解耦、流量削锋和消息通讯等  \n\n**使用消息队列，把不是必须的业务逻辑，异步处理**\n\n消息队列的缺点：\n\n- 系统可用性降低\n- 系统复杂性提高\n- 一致性问题\n\n### 3  多线程在web中的使用\n\n一般在使用IO操作时\n\n使用场景：\n\n- 需要并行操作几个文件的读写，同步不能异步的情况下\n- 视图中需要多个第三方接口\n- 订单提交后，修改库存销量\n\n### 4  为什么使用celery而不使用线程发送耗时任务\n\n因为并发量较大的时候，线程切换会有开销时间，也会降低并发的数量、共享数据维护麻烦\n\ncelery是通过消息队列进行异步任务处理，不用担心并发量高是负载过大，也可以处理复杂系统性能问题，相对灵活\n\n### 5  处理抢购高并发\n\n1. 将请求尽量拦截在上游\n2. 充分利用缓存\n\n前端方面：\n\n- 把详情页部署到CDN节点上，做页面静态化处理\n  - CDN：内容分发网络，将源站内容分发到离用户最近的节点，提高访问速度\n- 禁止重复提交请求、对用户请求限流\n\n后端方面：\n\n- 根据用户id限制访问频率\n- 缓存的应用\n\n### 6  如何解决celery队列阻塞问题\n\n- 队列阻塞的原因：\n\n  1. 队列中有耗时任务，且任务量大于celery并发数（Celery没有足够的worker去执行耗时任务）\n  2. 队列中有耗时任务，且Celery启动了**预取机制**\n     - 任务会有指定的worker去执行，就算其worker是空闲状态，也不会执行其它任务\n\n- 解决：\n\n  - **指定进程数**\n\n    `celery -A project worker --concurrency=4`\n\n  - **改变进程池方式为协程方式**\n\n    `pip install eventlet `\n  \n    `celery -A project worker -P eventlet -c 1000`\n  \n  - **增加并发数**\n  \n  `celery -A project worker -n 进程名字 --concurrencu=并发数 -l info`\n  \n  - **取消预取机制**\n  \n    ```python\n    # 任务发送完成时是否需要确认，对性能会稍有影响\n    celery_app.conf.CELERY_LATE = True\n    # Celery worker每次去队列取任务的数量，默认值为4\n    celery_app.conf.CELERY_PREFETCH_MULTIPLIER = 1\n    ```\n  \n    `celery -A project worker -n 进程名字 -Ofair -l info`\n  \n  - **错误重试机制**\n  \n    ```python\n    # 重连时间间隔\n    @celery_app.task(bind=True, retry_backoff=3)\n    try:\n        ...\n    except Exception as e:\n        # 有异常自动重连三次\n        raise self.retry(exc=e, max_retries=3)\n    ```\n\n### 7  [进程和线程的对比](https://handout-1300728887.cos.ap-beijing.myqcloud.com/%E8%AE%B2%E4%B9%89/python-web%E5%9F%BA%E7%A1%80(5.1.2%E7%89%88%E6%9C%AC)/multitasking/%E8%BF%9B%E7%A8%8B%E5%92%8C%E7%BA%BF%E7%A8%8B%E5%AF%B9%E6%AF%94.html)\n\n进程：CPU的一种执行单元\n\n- 密集CPU任务（大量并行计算）\n\n线程：进程执行程序的最小调度单位\n\n- 密集I/O任务\n\n协程：微线程，可以在单线程上执行多个任务，用函数切换，开销极小\n\n#### 关系对比\n\n1. 线程是依附在进程里面的，没有进程就没有线程\n2. 一个进程默认提供一条线程，进程可以创建多个线程\n\n#### 区别对比\n\n1. 进程之间不共享全局变量\n2. 线程之间共享全局变量，但是要注意资源竞争的问题，解决办法: 互斥锁或者线程同步\n3. 创建进程的资源开销要比创建线程的资源开销要大\n4. 进程是操作系统资源分配的基本单位，线程是CPU调度的基本单位\n5. 线程不能够独立执行，必须依存在进程中\n6. 多进程开发比单进程多线程开发稳定性要强\n\n#### 优缺点\n\n- 进程优缺点:\n  - 优点：可以用多核\n  - 缺点：资源开销大\n- 线程优缺点:\n  - 优点：资源开销小\n  - 缺点：不能使用多核做到高并行\n\n---\n\n#  （五）熟悉 TCP/[HTTP](https://handout-1300728887.cos.ap-beijing.myqcloud.com/%E8%AE%B2%E4%B9%89/python-web%E5%9F%BA%E7%A1%80(5.1.2%E7%89%88%E6%9C%AC)/http/HTTP%E5%8D%8F%E8%AE%AE.html) 协议等网络知识\n\nTDP：用户数据报协议，无连接的\n\n**TCP：传输控制协议，面向连接的、可靠的、基于字节流的传输层通信协议**\n\nHTTP：超文本传输协议，浏览器和web服务器通信需要HTTP协议 \n\nRPC：远程过程调用，向另一台计算机上的程序请求服务，不需要了解底层网络技术的协议。\n\n## 一、[网络协议分层](https://www.jianshu.com/p/30fb2b0bcfd8)\n\n![](https://tupian-1300728887.cos.ap-chengdu.myqcloud.com/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE%E5%88%86%E5%B1%82.png)\n\n### 1  乐观锁\n\n每次拿数据的时候都认为别人不会修改，所以不会上锁\n\n在更新的时候判断此时的库存是否是之前查询出的库存，如果相同，表示没人修改，可以更新库存，否则表示别人抢过资源，不再执行库存更新\n\n**实现方式：**利用时间戳、数据版本version字段，数据被修改＋1\n\n使用场景：高并发，减少数据冲突，保证数据一致性\n\n### 2  高并发，分布式\n\n处理网站并发量\n\n1. 减少数据库访问次数\n2. 文件和数据库分离（静态化页面）\n3. 大数据分布式存储（主从配置读写分离）\n4. 服务器集群，负载均衡\n5. 页面缓存的使用\n6. 内存数据库代替关系型数据库\n\n例子：省市区三级联动、首页部分数据（广告）局部缓存\n\n分布式案例\n\n1. MySQL主从配置读写分离\n\n### 3  长连接与短连接\n\n长连接：连接 -> 传输数据 -> 保持连接 -> 传输数据 -> 直到一方断开\n\n- 操作频繁、点对点的通讯、数据库连接\n  - TCP三握手时间\n  - 不安全\n\n短连接：连接 -> 传输数据-> 断开连接\n\n- http服务\n\n### 4  token和jwt存在什么区别\n\ntoken需要查库验证，JWT直接在服务端进行，不需要查库\n\n### 5  [三次握手和四次挥手](https://blog.csdn.net/qq_38950316/article/details/81087809)\n\n三次挥手：\n\n1. 建立连接时，客户端发送syn包（seq=x）到服务器，并进入SYN_SENT（发送）状态，等待服务器确认；\n2. 服务器收到syn包，必须确认客户的SYN（ack=x+1），同时自己也发送一个SYN包（seq=y），即SYN+ACK包，此时服务器进入SYN_RECV（收到）状态；\n3. 客户端收到服务器的SYN+ACK包，向服务器发送确认包ACK(ack=y+1），此包发送完毕，客户端和服务器进入ESTABLISHED（TCP连接成功）状态，完成三次握手。\n\n四次挥手：\n\n### 6  [CSRF攻击](https://handout-1300728887.cos.ap-beijing.myqcloud.com/%E8%AE%B2%E4%B9%89/Django%E6%A1%86%E6%9E%B6/Django%E6%A1%86%E6%9E%B6/C05-Template/csrf.html)\n\n1. 浏览并登录信任网站A\n2. 验证通过，产生A的Cookie\n3. 再没登出的情况下，浏览**攻击网站B**\n4. B要求访问第三方网站A\n5. 根据B的请求，浏览器带着A的Cookie访问A\n6. A不知道请求源，因为浏览器会自动携带用户的Cookie，按需处理请求，达到模拟用户操作csrf攻击\n\n**防止csrf攻击**\n\n1. 在后端响应的cookie写入csrf_token值\n2. 前端from表单中也写入csrf_token值\n3. 获取两个csrf_token，看是否一致\n\nDjango自带的防csrf中间间\n\n**跨站请求伪造**：攻击者盗用你的身份，发送恶意请求\n\n### 7  RESTFul思想\n\n- 每一个URI代表1种资源；\n\n- 客户端使用GET、POST、PUT、DELETE4个表示操作方式的动词对服务端资源进行操作：GET用来获取资源，POST用来新建资源（也可以用于更新资源），PUT用来更新资源，DELETE用来删除资源；\n\n- 通过操作资源的表现形式来操作资源；\n\n- 资源的表现形式是XML或者HTML；\n\n- 客户端与服务端之间的交互在请求之间是无状态的，从客户端到服务端的每个请求都必须包含理解请求所必需的信息。\n\n---\n\n# （六）[使用腾讯云存储方案](https://cloud.tencent.com/document/product/436)\n\n腾讯对象存储服务（COS）通过网络随时存储和调用各种数据文件\n\n1. 创建一个或多个存储同，上传文件\n2. 根据地址可上传和下载\n3. 可设置相应属性及访问权限\n4. 下载SDK包，执行相应操作\n\n# （七）[熟悉 Linux 系统](https://handout-1300728887.cos.ap-beijing.myqcloud.com/%E8%AE%B2%E4%B9%89/%E7%AC%94%E8%AE%B0/Linux%E5%9F%BA%E7%A1%80%E5%91%BD%E4%BB%A4.html)，了解 Docker、Elasticsearch\n\n### 1  [Docker](http://www.docker.org.cn/index.html)\n\n**开源的软件部署解决方案、轻量级的应用容器框架，采用C/S架构，其可以轻松的为任何应用创建一个轻量级的、可移植的、自给自足的容器。**\n\n> 是一种快速解决生产问题的一种技术手段。\n\n优缺点：\n\n- 优：\n  - 多： 适用场景多\n  - 快： 环境部署快、更新快\n  - 好： 好多人在用，东西好\n  - 省： 省钱省力省人工(123原则)\n- 缺：\n  - 太腻歪人： 依赖操作系统\n  - 不善于沟通：依赖网络\n  - 不善理财： 银行U盾等场景不能用\n\n**镜像**\n\n- 类似虚拟机的镜像，可以创建新的容器\n\n```dockerfile\n# 镜像\ndocker search [image_name]\t\t\t# 搜索镜像\ndocker pull [image_name]\t\t\t# 获取镜像\ndocker images\t\t\t\t\t\t# 查看镜像\ndocker history [image_name]\t\t\t# 查看镜像历史\ndocker tag [old_image]:[old_version]\t# 重命名\ndocker rm [image_name]\t\t\t\t# 删除\ndocker save -o [包文件] [镜像]\t\t# 导出镜像\ndocker load -i [image.tar_name]\t\t# 导入镜像\n```\n\n**容器**\n\n- 由镜像创建的运行实例，类似虚拟机\n\n```dockerfile\n# 容器\ndocker ps\t\t\t\t\t\t\t\t# 查看容器\ndocker start [container_id]\t\t\t\t# 启动已终止的容器\ndocker stop [container_id]\t\t\t\t# 关闭\ndocker rm [container_id]\t\t\t\t# 删除\n\t\t-f\t\t# 强制删除\ndocker run [docker_image] /bin/bash\n\t\t--name\t# 给容器定义一个名称\n\t\t-i \t\t# 让容器的标准输入保持打开。\n\t\t-t\t\t# 分配一个伪终端,并绑定到容器的标准输入上\n\t\t-d \t\t# 守护进程开启\n\t\t-v\t\t# 本地:容器 --映射\n\t\t-p  \t# 端口映射\ndocker exec -it 容器id /bin/bash\t\t\t# 进入后台运行容器\ndocker commit [container_id] [new_image:tag]\t# 基于容器创建镜像\n\t\t-m \t\t# '改动信息' \n\t\t-a \t\t# \"作者信息\"\ndocker logs [容器id]\t\t\t\t\t# 查看运行日志\ndocker inspect  [容器id]\t\t\t\t# 查看详细信息\n```\n\n**仓库（公有、私有、本地）**\n\n- 托管镜像\n\n#### 1.1 dockerflie\n\n Dockerfile类似于我们学习过的脚本，将我们在上面学到的镜像，使用自动化的方式实现出来。\n\n```dockerfile\n# 基础指令\nFROM <image>\t\t\t\t\t# 第一条指令（除首行注释外）\nMAINTAINER <name>\t\t\t\t# 作者信息\nRUN <command>\t\t\t\t\t# 镜像构建时候运行的命令\nEXPOSE <port>\t\t\t\t\t# 对外开发端口\nENTRYPOINT python3 manage.py runserver 0.0.0.0:8000\n\t\t\t\t\t\t\t\t# 运行Django项目，只能有一个\n\n# 文件编辑指令\nADD <src>... <dest>\t\t# 将指定的 <src> 文件复制到容器文件系统中的 <dest>\nCOPY <src>... <dest>\t\t\t# 复制文件\n\n# 环境指令\nENV <key> <value>\t\t\t\t# 设置环境变量\nWORKDIR /path/to/workdir\t\t# 切换目录\n```\n\n### 2  es的存储底层原理\n\n**集群：**es可以作为独立的单个搜索引擎，为了处理大型数据集，实现容错和高可用性，es可以运行在许多合作的服务器上，这些服务器的集合称为集群\n\n**节点：**形成集群的每个服务器\n\n**分片：**数据可以分为较小的分片，放到不同的服务器上，分布式处理。而应用程序并不知道分片的存在\n\n**副本：**复制集原理，其中之一被选择更改索引操作（主分片），主废副升，不能在同一个节点上\n\n**es扩容：**\n\n- 垂直：采购更强大的服务器\n- 水平：采购更多的不同服务器\n\n### 3  [使用 Haystack 调用 Elasticsearch](https://handout-1300728887.cos.ap-beijing.myqcloud.com/%E8%AE%B2%E4%B9%89/%E7%BE%8E%E5%A4%9A%E5%95%86%E5%9F%8E%E8%AE%B2%E4%B9%89/goods/goods-search/haystack-create-index.html)\n\n**Elasticsearch是基于Lucene库实时的分布式搜索分析引擎，全文检索、结构化搜索、分析这三功能的组合**\n\n**全文检索引擎：对数据库里的数据先进行一遍预处理，从而生成索引结构数据（类似于字典那样的结构数据），再使用关键字在索引数据中检索数据**\n\n属于面向文档的数据库\n\nElasticsearch是远端服务器开启的服务\n\n需要用Haystack调用搜索引擎\n\n1. 安装：\n\n   `pip install django-haystack`\n\n   `pip install elasticsearch==2.4.1`\n\n2. 注册到应用\n\n```python\nINSTALLED_APPS = [\n    'haystack', # 全文检索\n]\nurl(r'^search/', include('haystack.urls')),\n```\n\n3.  配置\n\n```python\n# Haystack\nHAYSTACK_CONNECTIONS = {\n    'default': {\n        'ENGINE': 'haystack.backends.elasticsearch_backend.ElasticsearchSearchEngine',\n        'URL': 'http://192.168.103.158:9200/', # Elasticsearch服务器ip地址，端口号固定为9200\n        'INDEX_NAME': 'meiduo_mall', # Elasticsearch建立的索引库的名称\n    },\n}\n\n# 当添加、修改、删除数据时，自动生成索引\nHAYSTACK_SIGNAL_PROCESSOR = 'haystack.signals.RealtimeSignalProcessor'\n```\n\n4. 创建索引类：search_indexes.py\n\n5. 创建txt字段索引值模板文件\n\n6. 手动生成索引（仅第一次）\n\n   `python manage.py rebuild_index`\n\n- 常见问题：\n\n  1. 如何实现分页功能\n     - HAYSTACK_SEARCH_RESULTS_PER_PAGE = 5\n\n  2. No module named haystack\n     - 是否安装/注册了haystack模板\n\n  3. 在html页面出现No serults found\n     - 是否创建了search_indexes.py文件\n     - 数据库中是否有数据\n\n### 3  es是怎么跟数据库关联起来的\n\nLogstash是一个开源数据收集引擎，具有实时管道功能。可以动态得将来自不同数据源的数据统一起来，并将数据标准化到你所选择的目的地\n\n### 4  es倒排索引和常用API\n\n倒排索引：也称反向索引，根据单词查找文档\n\n正向索引：存储每个文档单词的列表\n\n- es常用的api\n  - [查询](https://handout-1300728887.cos.ap-beijing.myqcloud.com/%E8%AE%B2%E4%B9%89/%E9%BB%91%E9%A9%AC%E5%A4%B4%E6%9D%A1%E9%A1%B9%E7%9B%AE%E8%AF%BE%E4%BB%B6/C10-Elasticsearch/Query.html)\n\n# （八）首页静态化、定时任务\n\n**静态化与缓存的主要区别**\n\n- 静态化：将数据静态化到页面，客户端访问时不查询数据库，存储与硬盘\n\n- 缓存：将数据存储于服务器内存\n\n**定时任务的原理**\n\n- 由**crond守护进程**和**crontab文件（任务表）**组成\n\n- 守护进程在系统启动时由init进程启动，受init监视，如果它挂了，init会重启它守护进程每分钟唤醒一次，通过检查crontab文件判断需要做什么\n\n  ```bash\n  # 添加定时任务到系统中\n  $ python manage.py crontab add\n  \n  # 显示已激活的定时任务\n  $ python manage.py crontab show\n  \n  # 移除定时任务\n  $ python manage.py crontab remove\n  ```\n\n**支付宝接入：** \n\n- Python支付宝SDK：https://github.com/fzlee/alipay/blob/master/README.zh-hans.md \n\n# （九）部署相关\n\n## 1  [nginx](https://handout-1300728887.cos.ap-beijing.myqcloud.com/%E8%AE%B2%E4%B9%89/%E9%A1%B9%E7%9B%AE%E9%83%A8%E7%BD%B2/nginx/Advanced.html)\n\n**是一个高性能的HTTP和反向代理服务器，主要处理静态资源**\n\n### 1.1  [反向代理](https://handout-1300728887.cos.ap-beijing.myqcloud.com/%E8%AE%B2%E4%B9%89/%E9%A1%B9%E7%9B%AE%E9%83%A8%E7%BD%B2/nginx/nginx-reverse.html)\n\n正向代理： 为局域网**客户端**向外访问Internet服务**（代理用户，隐藏客户端）**\n\n反向代理： 为局域网**服务器**向外提供Internet服务**（代理服务器，隐藏服务器）**\n\n### 1.2  [负载均衡](https://handout-1300728887.cos.ap-beijing.myqcloud.com/%E8%AE%B2%E4%B9%89/%E9%A1%B9%E7%9B%AE%E9%83%A8%E7%BD%B2/nginx/nginx-load.html)\n\n有一台服务器充当调度者的身份（负载均衡器），请求先到达它，再根据每台服务器的负载情况分配请求\n\n1. 内置策略：nginx自带算法\n   - 雨露均沾型：轮训（默认）、加权轮训、哈希\n     - 轮训：按顺序逐一分配\n     - 加权轮训：权重越大，被分配几率越高，适用于服务器性能不均衡情况\n   - 定向服务型：ip_hash、least_conn、cookie、route、lean\n     - ip_hash：按访问IP的哈希结果分配请求，分配后访客访问固定后端服务器，有效的解决动态网页会话共享问题。\n   - 商业类型：ntlm、least_time、queue、stick\n3. 第三方算法：fair、url_hash\n   - fair：基于后端服务器的响应时间来分配请求，响应时间短的优先分配。\n   - url_hash：按访问的哈希结果分配请求，使同定向到同一台后端服务器，可提高后端缓存服务器的效率。\n\n### 1.3  提供静态文件\n\n静态文件收集命令：`python mange.py collectstatic`\n\n### 1.4  WSGI\n\n- WSGI是一种通信协议， Web 服务器(uWSGI)与 Web 应用程序或应用框架(Django)之间的一种低级别的接口\n- uwsgi是一种线路协议我不是一种通信协议，常用于在uWSGI服务器于其他网络服务器的数据通信\n- uWSGI是实现了uwsgi和WSGI两种协议的Web服务器，**主要处理动态资源**\n\n## 2  [gunicorn](https://handout-1300728887.cos.ap-beijing.myqcloud.com/%E8%AE%B2%E4%B9%89/%E9%BB%91%E9%A9%AC%E5%A4%B4%E6%9D%A1%E9%A1%B9%E7%9B%AE%E8%AF%BE%E4%BB%B6/C12-Deployment/Gunicorn.html)\n\n安装：`pip install gunicorn`\n\n查看使用信息：`$gunicorn -h`\n\n直接运行：`gunicorn 运行文件名称：flask程序实例名`\n\n指定进程和端口号：`$gunicorn -w 4 -b 127.0.0.1:5001 运行文件名称:Flask程序实例名`\n\n# 支付流程\n\n![](https://tupian-1300728887.cos.ap-chengdu.myqcloud.com/%E5%85%AC%E7%A7%81%E9%92%A5.png)\n\n- 生成密钥\n\n```bash\nopenssl\t\t# 进入环境\ngenrsa -out app_private_key.pem 2048\t# 私钥\nrsa -in app_private_key.pem -pubout -out app_pubout_key.pem\t\t# 公钥\n```\n\n# 极睿科技总结\n\n## 一、装饰器\n\n作用：在不改变已有函数源代码及调用方式的前提下，对已有函数进行功能的扩展\n\n```python\n# 不改变原有函数__name__\\备注信息\nfrom functools import wraps\ndef check(fu):  # fu:目标函数\n    \n    @wraps(fu)\n    def inner():\n        '''执行函数之前'''\n        fu()\n        '''执行函数之后'''\n    return inner\n\n# 语法糖写法\n@check\ndef comment():\n    print('发表评论')\n    \ncomment()\n# check等价与  comment = check(comment)\n```\n\n## 二、数据结构与算法\n\n数据：能够被计算机处理的符号或符号集\n\n数据元素（节点、记录）：数据的基本单位。例：学生统计表\n\n数据项（字段、域）：组成数据元素的最小单位。例：编号、姓名、性别等\n\n### 1  数据结构\n\n**相互之间存在的一种或多种特定的数据元素的集合用于计算机存储、组织数据的方式**\n\n![](https://img2018.cnblogs.com/blog/1672612/201906/1672612-20190607153718002-1151308139.jpg)\n\n#### 1.1  逻辑结构\n\n**数据元素间的抽象关系（如近邻关系、从属关系等），分为线性结构与非线性结构，**抽象出来的，与机器无关\n\n![](https://img2018.cnblogs.com/blog/1672612/201906/1672612-20190607154347579-543280178.png)\n\n| 结构类型 | 数据元素间的相互关系 |\n| :------: | :------------------: |\n|   集合   |          无          |\n|   线性   |        一对一        |\n|   树形   |        一对多        |\n|    图    |        多对多        |\n\n#### 1.2  （存储）物理结构\n\n**数据在计算机中的存放方式，反应数据元素间的逻辑关系**\n\n- 顺序存储（向量存储）：把数据元素存放在一组存储地址连续的存储单元里，逻辑关系和物理关系是一致的\n- 链式存储（动态存储）：通过指针反应数据间的逻辑关系\n- 索引存储：建立一个附加的索引表\n- 散列存储：根据节点的关键字直接计算出该节点的存储地址\n\n> 同一逻辑结构可以对应不同的存储结构，算法的设计取决于数据的逻辑结构，而算法实现依赖于指定的存储结构\n\n### 2  算法\n\n**解决特定问题的一种方法或一种描述**\n\n#### 2.1  数据结构和算法的联系\n\n程序=算法+数据结构\n\n- 算法设计: 取决于选定的逻辑结构\n- 算法实现: 依赖于采用的存储结构\n\n区别：\n\n- 数据结构关注的是**数据的逻辑结构、存储结构的基本操作**\n- 算法关注的是**在数据结构的基础上解决实际问题**\n\n算法的五大特性：\n\n1. 可行性：解决具体问题，完成期望功能\n2. 确定性：每一步在一定条件下只有一条执行路径\n3. 有穷性： 算法执行的步骤（或规则）是有限的\n4. 输入：具有零或多个输入\n5. 输出：至少有一个或多个输出\n\n评价算法好坏的方法：\n\n- 正确性：运行正确是一个算法的前提。\n- 可读性：容易理解、容易编程和调试、容易维护。\n- 健壮性：考虑情况全面，不容以出现运行错误。\n- 时间效率高：算法消耗的时间少。\n- 储存量低：占用较少的存储空间。\n\n#### 2.2  时间复杂度O(n)\n\n计算规则\n\n1. 基本操作，只有**常数项O(1)**\n2. 顺序结构，按**加法计算**\n3. 循环结构，按**乘法计算**\n4. 分支结构，**取最大值**\n\n#### 2.3  空间复杂度S(n)\n\n**一个算法在运行过程中临时占用存储空间大小的度量**\n\n## 三、线性数据结构\n\n特点：在数据元素的非空有限集合中\n\n- 存在唯一的（第一个--最后一个）数据元素\n- 且第一个元素没有直接前驱元素，最后一个元素没有直接后继元素，其他元素都有唯一的前驱和后继元素\n\n### 1  线性表\n\n- 线性表有顺序存储结构和链式存储结构。\n\n#### 1.1  顺序存储结构（顺序表）\n\n**是指将线性表中的各个元素依次存放在一组地址连续的存储单元中，通常将这种方法存储的线性表称为顺序表。**\n顺序表的优缺点：\n\n- 优：无须关心表中元素之间的关系，所以不用增加额外的存储空间；可以快速地取表中任意位置的元素。\n- 缺：插入和删除需要移动大量元素\n\n#### 1.2  线性表的链式存储（链表）\n\n一组任意的连续或非连续存储单元存储线性表的元素，存储元素本身（数据域）和后继元素地址（指针域)\t\n\n- 链表与顺序表的对比\n\n  |        |    存储方式    |           时间性能           |       空间性能       |\n  | :----: | :------------: | :--------------------------: | :------------------: |\n  | 顺序表 | 连续的存储单元 | 查找：O(1)；插入、删除：O(n) |     预先分配空间     |\n  | 单链表 | 任意的存储单元 | 查找：O(n)；插入、删除：O(1) | 不用估计预用空间大小 |\n\n循环单链表：首尾相连的一种单链表，最后一个结点称为：尾指针：rear\n\n双向链表： 链表中的每个结点有两个指针域，一个指向直接前驱结点，另一个指向直接后继结点。 data -- prior -- next \n\n### 2  栈和队列\n\n#### 2.1  栈\n\n**限制在表一端进行插入（入栈）和删除（出栈）操作的线性表**\n\n- 栈顶：允许操作端\n\n- 栈底：固定端\n\n> 先进后出\n\n##### 2.1.1  栈的存储结构\n\n栈是运算受限的线性表，线性表的存储结构对栈也适用\n\n1. 顺序栈\n2. 链栈\n\n#### 2.2  队列\n\n**插入（队尾）在表一段，删除（对头）在表的另一端**\n\n> 先进先出\n\n##### 2.2.1  队列的存储结构\n\n队列也是一种运算受限的线性表\n\n- 顺序队列\n- 链队列\n\n小结：\n\n1. 链式栈的栈顶应在链头，插入与删除操作都在链头进行。\n2. 循环队列要注意对空条件和对满条件；而对于链队列，需要特别注意出队仅对队头指针操作，当只有一个元素时，出队需要修改队尾指针。\n3. 递归实质上是通过栈来实现函数调用，只不过是调用自身而已。\n\n### 3  字符串和数组\n\n#### 3.1  字符串\n\n 串（String）是由零个或多个任意字符串组成的字符序列。 \n\n##### 3.1.1  串的存储结构\n\n- 定长顺序存储结构（顺序串）\n  - 定长是指按预定义的大小为每一个串变量分配固定长度的存储区。 最大不能超过256\n- 堆分配存储结构\n\n#### 3.2 数组\n\n **结构中的元素本身可以是具有某种结构的数据，但属于同一数据类型，一般线性表的扩充**\n\n是一个具有固定格式和数量的数据有续集，一旦被定义就不再改变，两种基本运算：\n\n1. 取值操作：给定一组下标，读其对应的数据元素。\n2. 赋值操作：给定一组下标，存储或修改与其相对应的数据元素。\n\n##### 3.2.1  数组的存储结构\n\n一维：顺序存储结构，直接按其下标顺序分配存储空间\n\n多维：按某种次序将数组中元素排成一个线性序列，再作存储\n\n存二维数组：\n\n1. 先行后列\n2. 先列后行\n\n##### 3.2.2  稀疏矩阵\n\n**矩阵中大多数元素为零元素的矩阵，按常规分配方法浪费内存**\n\n三元组表存储\n\n- 非零元素所在行、列及值构成一个三元组（i,j,v）\n\n## 四、非线性结构\n\n### 1  树和二叉树\n\n前驱唯一而后继不唯一，一对多\n\n定义：树（tree）是n（n>=0）个结点的有限集合。当n=0时，该集合满足以下条件：\n\n- 只有一个特殊节点称为根节点（root）\n\n- 当n>1时，其余n-1个结点被分成m(m>0)个互相不相交的集合，称为根节点的**子树**\n\n  树的定义用了递归概念，其算法也常常使用递归\n\n#### 1.1  二叉树\n\n二叉树是每个节点最多有两个子树的树结构。通常子树被称作“左子树”（left subtree）和“右子树”（right subtree）\n\n满二叉树：除了叶结点外每一个结点都有左右子叶且叶子结点都处在最底层的二叉树。 \n\n##### 1.1.1  存储结构\n\n顺序存储结构：按照二叉树结点从上至下、从左到右的顺序存储。\n\n链式存储结构：每个节点由三个域组成：数据域和左、右指针域。\n\n![](https://img-blog.csdnimg.cn/20181214150636793.jpeg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2NzZG5fYWl5YW5n,size_16,color_FFFFFF,t_70)\n\n##### 1.1.2  二叉树遍历\n\n**深度优先一般用递归，广度优先一般用队列。一般情况下能用递归实现的算法大部分也能用堆栈来实现。**\n\n1. 深度优先遍历\n   1. 先序遍历\t` 根节点->左子树->右子树 `\n   2. 中序遍历    ` 左子树->根节点->右子树 `\n   3. 后序遍历    ` 左子树->右子树->根节点 `\n2. 广度优先遍历（层次遍历）\n   -  从树的root开始，从上到下从从左到右遍历整个树的节点 \n\n### 2  图\n\n任意两个结点之间都可能相关，即结点之间的邻接关系可以是任意的。\n\n## 五、排序和搜索\n\n### 1  冒泡排序\n\n**重复遍历数列，一次比较两个元素**\n\n![冒泡排序](https://tupian-1300728887.cos.ap-chengdu.myqcloud.com/%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F.gif)\n\n### 2  选择排序\n\n**找到最大或最小的元素，把它排在队前或队尾，循而往复， 放到已排序序列的末尾**\n\n![选择排序](https://tupian-1300728887.cos.ap-chengdu.myqcloud.com/%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F.gif)\n\n### 3  插入排序\n\n**通过构建有序序列，对于未排序数据，在已排序序列中从后向前扫描，找到相应位置并插入。**\n\n![插入排序](https://tupian-1300728887.cos.ap-chengdu.myqcloud.com/%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F.gif)\n\n### 4  希尔排序\n\n**希尔排序是插入排序的一种，将数据分成几组，分别使用插入排序**\n\n![希尔排序](https://tupian-1300728887.cos.ap-chengdu.myqcloud.com/%E5%B8%8C%E5%B0%94%E6%8E%92%E5%BA%8F.jpg)\n\n### 5  快速排序\n\n**从序列中挑出一个元素（基准），把小于（大于）基准的元素放在基准前边（后边）**\n\n![快速排序](https://tupian-1300728887.cos.ap-chengdu.myqcloud.com/%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F.gif)\n\n### 6  归并排序\n\n **分治法，先递归分解数据，在合并数组；比较两个数组最前边的数，谁小谁先取**\n\n![归并排序](https://tupian-1300728887.cos.ap-chengdu.myqcloud.com/%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F.gif)\n\n### 7  搜索\n\n#### 7.1  顺序查找\n\n#### 7.2  二分法查找\n\n#### 7.3  二叉树查找\n\n#### 7.4  哈希查找\n\n# （十）大数据\n\n# 奇点控股\n\n面试题\n\n一、python的语言特性\n\n- 简单、易学、免费、开源、高级语言、可移植性、解释型语言、面向对象、可扩展性、丰富的库、规范的代码\n  - 高级语言：不用考虑内存一类的底层细节\n  - 可移植性：无需修改，可在多平台上运行\n  - 解释型语言： 在运行程序的时候才翻译，专门有一个解释器去进行翻译，每个语句都是执行的时候才翻译。效率比较低，依赖解释器，跨 平台性好 \n  - 编译型语言： 程序在执行之前需要一个专门的编译过程，把程序编译成 为机器语言的文件，运行时不需要重新翻译，直接使用编译的结果就行了。程序执行效率高，依赖编译器，跨平台性差些\n  - 可扩展性： 如果你需要你的一段关键代码运行得更快或者希望某些算法不公开，你可以把你的部分程序用C或C++编写，然后在你的Python程序中使用它们 \n\n二、*args和**kwargs的区别\n\n- 都是不定长参数\n\n  - *args：将参数打包成元组进行传参\n\n  - **kwargs：将参数打包成字典进行传参\n\n三、\n\n```python\ndef main():    \n\ta = 'hello'    \n\tb = a    \n\ta = b + 'world'    \n\tprint(a)    \n\tprint(b)\nmain()\n# helloworld\n# hello\n```\n\n四、TCP/IP协议分几层，TCP、UDP、HTTP分别在哪一层\n\n- 四层：网络接口层、网络层、传输层（TCP、UDP）、应用层（HTTP）\n\n五、\n\n```python\ndef main():    \n    try:        \n        a = 'str'        \n        b = 123        \n        print(a + b)    \n    except:        \n        print('except')    \n    else:        \n        print('else')    \n    finally:        \n        print('finally')\nmain()\n# except\n# finally\n```\n\n## 总结\n\n- **python中的魔法方法**\n\n  ```python\n  __init__(self)\t# 在创建一个对象是默认被调用，不需要手动调用\n  __str__(self)\t# 用来显示信息，需要return一个数据\n  __del__(self)\t# 当删除对象时，默认被调用\n  __new__(self)\t# 才是实例化对象调用的第一个方法，它只取下 cls 参数，并把 其他参数传给 __init__\n  __call__(self)\t# 允许一个类的实例像函数一样被调用 。\n  __getitem__(self)\t\t# 定义获取容器中指定元素的行为，相当于 self[key] 。\n  __getattr__(self) \t# 定义当用户试图访问一个不存在属性的时候的行为 。\n  __setattr__(self) \t# 定义当一个属性被设置的时候的行为 。\n  __getattribute__(self) \t# 定义当一个属性被访问的时候的行为 。\n  ```\n\n- **可变与不可变类型**\n\n  - **指内存中的那块内容（value）是否可以发生改变**\n  - 可变类型：不需要申请新内存，在原有基础上改变\n  - 不可变类型：必须在内存中新申请一块区域\n\n- **冒泡排序**\n\n```python\ndef bubble_sort(alist):\n    for j in range(len(alist)-1, 0, -1):\n        for i in range(j):\n            if alist[i] > alist[i+1]:\n                alist[i], alist[i+1] = alist[i+1], alist[i]\n```\n\n- **is和==的区别**\n\n  -  都是对对象进行比较判断作用的\n  -  ==（比较运算法），用来判断两个对象的value值\n  -  is（同一性运算符），用来判断两个对象的唯一身份标识，id地址\n\n  只有**数值型（-5~256）和字符串**型的情况下，a is b才为True，当a和b是**tuple，list，dict**或**set**型时，a is b为False。 \n\n- **python默认递归限制1000or998**\n\n  - 修改限制\n\n    ```python\n    import sys\n    sys.setrecursionlimit(1500)\n    ```\n\n- **数据量大情况下Paginator的缺点**\n\n  - 查询效率慢的问题\n  - **PageHelper的分页功能是通过Limit拼接SQL实现的** \n\n# 中科软总结\n\n- 项目用了几台服务器\n\n  |             用途             | 服务器 |\n  | :--------------------------: | :----: |\n  |   Nginx反向代理和静态文件    |   1    |\n  |         主业务服务器         |   1    |\n  | celery异步任务broker和worker |   2    |\n  |        MySQL读写分离         |   2    |\n  |            redis             |   1    |\n  |          **共计**：          | **7**  |\n","source":"_posts/总汇.md","raw":"---\ntitle: 总汇\ndate: 2020-2-28 19:56:28\ntags: web\ntop: 0\n---\n\n# （一）Flask与Django\n\n- **轻量、简洁、扩展性强，，原生不支持数据库**\n- 核心：werkzeug和jinja2\n\n<!--more-->\n\n|   房有居   | 用户模块、主页渲染、搜索房源信息功能及数据库的优化 |\n| :--------: | :------------------------------------------------: |\n| **食天下** |              **现菜谱展示、用户模块**              |\n| **书香阁** |         **书刊列表展示、用户历史记录保存**         |\n\n---\n\n### Flask与Django对比\n\n- 与Django对比\n  - 不同点：\n    1. Django：支持 ORM、认证、CSRF/模板、后台管理等。 \n    2. Flask：自带jinja2模板，实现其它功能需要调用扩展包\n  - 相同点：\n    1.  性能都不⾼，都是单进程服务器。 \n\n### MVT设计模式\n\n设计模式：解决一类问题而总结出来的经验和套路\n\n**MVC：**核心思想：分工、解耦，让不同代码之间降低耦合，增强代码的可扩展性和可移植性\n\n**MVT：**\n\n- M：模型 Model\n- V：视图 View\n- T：模板 Template\n\n### 前后端不分离的区别\n\n前后端不分离：\n\n- 页面的控制和渲染是由后端实现的\n  - 优点：页面展示无延迟，因为响应给用户的就是页面；方便实现搜索引擎排名，帮助爬虫服务器更高效率的爬取数据，即SEO\n  - 缺点：对后端程序员要求高\n\n前后端分离：\n\n- 页面的控制和渲染是由前端实现的\n  - 优点：后端程序员只需专注数据和业务即可\n  - 缺点：有延迟，先加载页面 -- 发请求获取数据 -- 渲染\n- 补充：前后端不分离，一般不做页面静态化，因为用户先拿到的就是静态页面\n\n### Django信号\n\n**Django 提供一个“信号分发器”，允许解耦的应用在框架的其它地方发生操作时会被通知到。信号允许特定的sender（发送者）通知一组receiver（接收者）某些操作已经发生。**\n\n信号遵守的设计模式：**观察者设计模式（通知机制、监听机制）**\n\n- [使用](https://handout-1300728887.cos.ap-beijing.myqcloud.com/%E8%AE%B2%E4%B9%89/%E6%80%9D%E7%BB%B4%E5%AF%BC%E5%9B%BE/Django%E4%BF%A1%E5%8F%B7.jpg)\n\n### Django项目中的社会化分享\n\n结合项目中使用：\n\n- MobTech平台创建应用：https://www.mob.com/\n\n  1. 注册登录\n  2. 产品中心 --> 开发者平台\n  3. 创建应用并添加产品和SDK\n  4. 进入到<应用管理>查看App Key和App Secret\n\n- 创建Django项目\n\n- 根据开发文档集成ShareSDK\n\n  - 进入文档中心，打开web集成文档\n\n    https://www.mob.com/wiki/list\n\n  - 根据开发文档集成ShareSDK，实现社会化分享功能\n\n### Django自带的缓存cache和redis的区别\n\ncache是python实现缓存的一种工具\n\nredis是一种存放缓存数据的数据库\n\n可以使用cache这个缓存工具，将缓存数据缓存到redis数据库\n\n### 如何对Django框架进行二次开发，增大并发数\n\n可能造成并发降低的原因：\n\n1. 数据库操作变慢\n2. python语言执行速度变慢\n\nDjango二次开发方向：\n\n- 扩展Django Models使其支持Sharding（一种数据库分片技术）\n- 手动关闭GC（垃圾回收）\n- **把那些稳定且对性能最敏感的组件，使用c或c++来重写**\n\n### 中间件的定义方式、结构\n\n```python\ndef middleware_name(get_response):\n    # 这个节点表示请求初始化：在最开始的时候补充额外逻辑\n    def middleware(request):\n        # 这个节点表示请求被执行前：在请求执行的时候补充额外逻辑\n        response = get_response(request)\n        # z这个节点表示响应之前：在响应之前补充额外逻辑\n        return response\n    return middleware\n```\n\n### [ORM（ **object-relation-mapping** ）](https://handout-1300728887.cos.ap-beijing.myqcloud.com/%E8%AE%B2%E4%B9%89/%E9%BB%91%E9%A9%AC%E5%A4%B4%E6%9D%A1%E9%A1%B9%E7%9B%AE%E8%AF%BE%E4%BB%B6/C02-Database/ORM.html)\n\n- 对象关系映射 本质上就是将数据从一种形式转换到另外一种形式，定义的类相当于数据库中的表，在类中的定义的属性相当于是表中的字段，实例化的每一个对象，相当于的每一条数据。\n  - 类 -> 表\n  - 类属性 -> 字段\n  - 类对象 -> 数据\n\n- 作用：\n\n  1. 省去编写sql语句，提⾼开发效率；\n\n  2. 防注⼊攻击\n\n  3. 适配不同的数据库。\n- 缺点：查询效率较低，需要手动的优化。\n- 操作方式：\n\n  1. 先创建模型类，再迁移到数据库中：不能对数据库表的字段的定义，实现精确控制。 \n  2. 使⽤sql创建数据库的表，定义模型类，通过模型类，实现ORM操作。 \n\n---\n\n#  （二）熟练 MySQL、Redis 等数据库的使用\n\n### 1  [复制集与分布式](https://handout-1300728887.cos.ap-beijing.myqcloud.com/%E8%AE%B2%E4%B9%89/%E9%BB%91%E9%A9%AC%E5%A4%B4%E6%9D%A1%E9%A1%B9%E7%9B%AE%E8%AF%BE%E4%BB%B6/C02-Database/DatabaseTheory.html)\n\n- 复制集：\n  1. 数据库中数据相同，起到备份作用\n  2. 高可用\n\n- 分布式：\n  1. 数据库中数据不同，共同组成完整的数据集合\n  2. 高吞吐\n\n### 2  主从复制\n\n1. 主服务器的数据发生改变时，会将改变的记录写在本地二进制log日志中\n2. 从服务器的一个线程会把更新的数据拷贝中继log日志中\n3. 从服务器读取中继文件并执行，达到主从一致\n\n **利用主从在达到高可用的同时，也可以通过读写分离提供吞吐量。** \n\n### 3  [事务](https://handout-1300728887.cos.ap-beijing.myqcloud.com/%E8%AE%B2%E4%B9%89/python-web%E5%9F%BA%E7%A1%80(5.1.2%E7%89%88%E6%9C%AC)/mysqlhigh/%E4%BA%8B%E5%8A%A1.html)\n\n- 四大特性：\n  - 原子性：强调事务中的多个操作时一个整体\n  - 一致性：强调数据库中不会保存不一致状态\n  - 隔离性：强调数据库中事务之间相互不可见\n  - 持久性：强调数据库能永久保存数据，一旦提交就不可撤销\n- 隔离级别：\n  - 读已提交：一个事务要等另一个事务提交后才能读取数据，可避免脏读的发生。\n  - 读未提交：一个事务可以读取另一个未提交事务的数据，最低级别，任何情况都无法保证。\n  - **可重复读(MySQL默认)**：就是在开始读取数据（事务开启）时，不再允许修改操作，可避免脏读、不可重复读的发生。\n  - 串行化：最高的事务隔离级别，事务串行化顺序执行，可以避免脏读、不可重复读与幻读。效率抵消，耗性能\n\n## 一、Mysql\n\n### 1  [索引](https://handout-1300728887.cos.ap-beijing.myqcloud.com/%E8%AE%B2%E4%B9%89/python-web%E5%9F%BA%E7%A1%80(5.1.2%E7%89%88%E6%9C%AC)/mysqlhigh/%E7%B4%A2%E5%BC%95.html)\n\n也叫“键”，保存数据库中所有记录的位置信息，相比于目录\n\n优点：加快查询速度\n\n缺点：耗费时间空间（不是越多越好）\n\n**优化**\n\n1. 不是越多越好，而是需要自己合理的使用\n\n### 2  [sql语句优化](https://handout-1300728887.cos.ap-beijing.myqcloud.com/%E8%AE%B2%E4%B9%89/%E9%BB%91%E9%A9%AC%E5%A4%B4%E6%9D%A1%E9%A1%B9%E7%9B%AE%E8%AF%BE%E4%BB%B6/C02-Database/DatabaseOptimize.html)\n\n- 1.避免全表扫描 \n- 2.查询时使⽤select明确指明所要查询的字段，避免使⽤ select * 的操作； \n- 3.SQL语句尽量⼤写 \n- 4.尽量避免在 where ⼦句中使⽤!=或<>操作符， \n- 5.遵循最左原则，在where⼦句中写查询条件时把索引字段放在前⾯ \n- 6.能使⽤关联查询解决的，尽量不要使⽤⼦查询 \n- 7.能不使⽤关联查询的尽量不要使⽤关联查询 \n- 8.不需要获取全表数据的时候，不要查询全表数据，使⽤LIMIT来限制数据 \n\n### 3  数据库的优化\n\n- 在进⾏表设计时，可适度增加冗余字段(反范式设计)，减少JOIN操作；\n- 多字段表可以进⾏垂直分表优化，多数据表可以进⾏⽔平分表优化；\n- 选择恰当的数据类型，如整型的选择；\n- 对于强调快速读取的操作，可以考虑使⽤MyISAM数据库引擎；\n- 对较频繁的作为查询条件的字段创建索引；唯⼀性太差的字段不适合单独创建索引，即使频繁作为查询条件；更新⾮常频繁的字段不适合创建索引；\n- 编写SQL时使⽤上⾯的⽅式对SQL语句进⾏优化；\n- 使⽤慢查询⼯具找出效率低下的SQL语句进⾏优化；\n- 构建缓存，减少数据库磁盘操作；\n- 可以考虑结合使⽤内存型数据库，如Redis，进⾏混合存储。\n\n### 4  数据库存储过程与触发器\n\n存储过程：完成特定功能的SOL语句集\n\n触发器：对表进行（插入、删除、更新）触发一系列预定好的SQL语句\n\n### 5  [数据库设计](https://handout-1300728887.cos.ap-beijing.myqcloud.com/%E8%AE%B2%E4%B9%89/%E9%BB%91%E9%A9%AC%E5%A4%B4%E6%9D%A1%E9%A1%B9%E7%9B%AE%E8%AF%BE%E4%BB%B6/C02-Database/DatabaseDesign.html)\n\n库设计：\n\n1. 数据库名要明确\n2. 不同类型的数据分开管理\n\n表设计：\n\n1. 命名，业务表跟基础表区分，驼峰命名法\n2. 词性分析法，**名词体现表或字段，动词体现关系**\n   - 一对一、一对多、多对多\n3. 不要用物理删除，以防后悔\n4. 三范式：\n   - 字段不可分割、原子性\n   - 满足范式一，表有主键依赖\n   - 满足范式二，表非主字段之间没有依赖关系。\n5. 反范式：**利用冗余字段存储数据，节省数据查询的时间，本质是空间换时间。**\n6. 字段类型、是否允许为null、是否有默认值\n   - 整形：int长度并不影响精度，长度只和显示有关\n     - **存储范围相同**\n   - 字符串：char和varchar\n     - char不可变，查询效率高，可能造成存储浪费\n     - varchar可变，查询效率不如char，节省空间\n7. 索引设计\n   - 主键、外键、唯一约束；\n   - key/value，提高查询效率的字段；\n   - **外键：作用是维护数据的完整性。**\n     - 应用：在实际开发项目过程中，用不用外键？\n     - 建议：项目开发初期可以利用外键帮助维护数据的完整性，但是，项目的中后期，建议移除外键。\n8. 数据库引擎（MySQL的核心）的选择：决定数据存储和增删改查方式，争对表\n   - **InnoDB**（事务、安全能力）\n     1. **支持事务，安全性级别较高，查询效率相对较低。**\n     2. 为处理巨大数据量的最大性能设计\n     3. **InnoDB支持外键完整性约束**\n   - **MyISAM**（主要用来插入和查询）\n     1. **不支持事务，插入、查询效率较高，增删改效率较低。**\n     2. 产生三个文件（名字一表名字开始）：\n        1. frm：文件存储表定义\n        2. .MYD：数据文件\n        3. .MYI：索引文件\n   - **MEMORY**（存放临时数据）\n     1. 将表中数据存储到内存中，未查询和引用其他表数据提供快速访问\n\n#### 5.1  分库分表\n\n**垂直拆分**\n\n- 垂直分表：\"大表拆小表\"，基于列字段进行，将不常用，数据较大，长度较长拆分\n- 垂直分库：根据业务切分成不同的库\n\n**水平拆分**\n\n- 水平分表：针对数据量巨大的单张表， 按照某种规则（RANGE,HASH取模等），切分到多张表里面去,有IO瓶颈\n- 水平分库分表：将表数据切分到多个服务器上，分布式，有效解决瓶颈、突破IO\n\n**先垂直分在水平分**\n\n##### 分库分表后面临的问题\n\n- 事务支持\n- 多库结果集合并\n- 跨库join\n\n**分库分表方案产品中间件**：官方MySQL Fabric、阿里TDDL，Cobar、360Atlas\n\n### 6  SQL语句中where和having那个执行更快\n\nSQL语句执行顺序：\n\n`from -> where -> group by -> having -> select -> order by`\n\n两者区别：\n\nwhere：是一个约束声明，结果返回之前起作用，不能使用聚合函数\n\nhaving：是一个过滤声明，过滤分组数据，只能用于group by，可以使用聚合函数\n\n---\n\n## 二、Redis\n\n### 1  [Redis特点](https://handout-1300728887.cos.ap-beijing.myqcloud.com/%E8%AE%B2%E4%B9%89/%E9%BB%91%E9%A9%AC%E5%A4%B4%E6%9D%A1%E9%A1%B9%E7%9B%AE%E8%AF%BE%E4%BB%B6/C02-Database/Redis.html)\n\n1. 速度快：C语言实现，存储在内存中以键值对形式保存\n2. **持久化:**\n   - redis可以将数据写入到磁盘中，在停机后，再次启动redis时，将磁盘中的备份数据加载到redis中\n   - 两种机制：\n     1. RDB快照持久化（默认开启）\n        - 将内存中的数据存入磁盘\n        - 缺点：一旦数据库出现问题，rdb文件数据不是全新的\n     2. AOF追加文件持久化\n        - 文件会变大，自动压缩\n3. 多种数据结构：string  hash  list  set  zset\n4. 支持多种编程语言\n5. 支持事务、流水线、消息队列\n6. [主从复制](https://handout-1300728887.cos.ap-beijing.myqcloud.com/%E8%AE%B2%E4%B9%89/redis%E8%AE%B2%E4%B9%89/redis%E8%AE%B2%E4%B9%89/redis/da-jian-zhu-cong.html)\n7. 高可用、分布式\n\n### 2  redis宕机\n\n- slave从宕机\n\n  - 重启后会自动加入到主从架构中，完成数据同步\n\n- master主宕机（主从都没持久化）\n\n  1. 不要立马重启服务\n  2. slave执行`SLAVEOF ON ONE`断开主从关系并升级为主库\n  3. 重启主，`SLAVEOF`设为从\n\n  可使用简单方法：**哨兵**\n\n### 3  redis高可用\n\n**提供了主从同步＋哨兵机制（ Sentinel ）**\n\n- 哨兵机制：实现故障转移，当检测到主服务器发生故障时，把从服务器升级为主，保证数据正常使用\n  - 原理：心跳机制＋投票裁决＋故障转移\n    - 定时给master/slave发送消息，若指定时间内无响应（主观宕机 SDOWN）\n    - Sentinel群都报告某一master无响应（客观宕机 SDOWN）\n    - 通过一定vote算法，将从升为主\n\n### 4  为什么Redis比MySQL快\n\n|            |     Redis      |          MySQL           |\n| :--------: | :------------: | :----------------------: |\n|  数据格式  |      k-v       |          B+TREE          |\n| 时间复杂度 | 0(1)（常数阶） |    0(logn)（对数阶）     |\n|  存储位置  | 从内存直接取出 | 磁盘表（全局扫或索引查） |\n\nRedis是单线程的多路复用IO，单线程避免线程切换开销；多路复用避免IO等待开销；多核处理器下对数据进行分区，各处理器处理不同的数据（分着干）\n\n## 三、缓存\n\n### 1  有效期TTL（Time to live）\n\n- 作用：\n  - 节省空间\n  - 做到数据有效性，失效后，做到数据一致性\n\n#### 1.1  过期策略\n\n- 定时过期：时间一到立即清除，对内存友好，但会占用大量CPU资源\n- 惰性过期：当访问时才去判断是否过期，节省CPU，占用内存\n- 定期过期：每隔一段时间，随机清除\n\n **Redis中同时使用了惰性过期和定期过期两种过期策略。** \n\n#### 1.2  缓存淘汰 （eviction）\n\n-  LRU（Least recently used，最近最少使用）\n   -  新数据插入到表头部\n   -  缓存命中时，将其移到头部\n   -  缓存满的时候将尾部的数据丢掉\n-  LFU（Least Frequently Used 最近最少使用算法）\n   -  如果数据在一段时间内使用次数很少，那么将来也会很少\n\n### 2  缓存模式\n\n- **先更新数据库，再删除缓存** \n\n#### 2.1  缓存穿透\n\n- 频繁请求缓存中不存在的数据，增大数据库压力\n\n  - 解决方案：\n    1. 返回缓存伪造数据\n    2. 限制请求参数\n    3. 借助第三方过滤器：布隆过滤器...\n\n- 布隆过滤器\n\n  本质上是一种**概率型数据结构， 由一个很长的bit数组和一系列哈希函数组成的 **\n\n  特点：**高效地插入和查询**\n\n  算法的核心： **某样东西一定不存在或者可能存在**\n\n  缺点：**数据只能插入不能删除**\n\n  - 存储原理：经过多次不同维度的hash计算，将数据映射到二进制向量里\n  - 服务流程：\n    1. 当用户访问时，去布隆过滤器中判断key值是否存在，否则直接返回\n    2. 如果key值存在，则访问redis，由于存在误判率，redis中也可能不存在\n    3. 再访问数据库，若也不存在，直接返回空\n\n![](https://img-blog.csdnimg.cn/20190306043938625.?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0lUX3Rvd25sZXQ=,size_16,color_FFFFFF,t_70)\n\n#### 2.2  缓存雪崩\n\n- 同一时间内，大量缓存失效，造成数据库压力剧增\n  - 解决方案：\n    1. 设置不同的有效期值\n    2. 采用多级缓存\n    3. 利用加锁或者队列\n\n---\n\n#  （三）[版本控制管理工具 Git](https://learngitbranching.js.org/)\n\n### 一、常用命令\n\n- 克隆远程库\t`git clone 地址`\n- 添加到暂存    `git add .`\n- 提交暂存区的文件到本地仓库    `git commit -m 'test'`\n- 拉取    `git pull origin <name>`\n- 推送    `git push origin <name>`\n- 查看仓库当前的状态    `git status`\n- 查看远程库信息    `git remote`\n- 查看当前分支    `git branch` \n- 切换分支    `git checkout <name>`\n- 合并分支到当前分支    `git merge <name>`\n\n---\n\n# （四）熟悉 Celery 异步方案，多线程、多进程的使用\n\ncelery是异步任务的调度工具，主要解决耗时任务，通过**消息队列**在客户端与消费者间协调\n\n- 消息中间件（消息队列Broker）：客户端把任务放入队列中，消费者从队列中取出任务执行，第三方队列服务：RabbitMQ\\redis\\kafka\\MetaMQ\\RocketMQ\n  - **RabbitMQ：**是一个消息代理。工作是接收和转发消息类似邮局，处理消息\n    - 异步消息：支持多种传递协议，消息排队，传递确认，到队列的灵活路由，多种交换类型\n    - 分布式部署：部署为集群以实现高可用和吞吐量\n    - 可靠性：可在性能和可靠性之间进行权衡\n    - 灵活的路由：通过交换机进行路由\n    - 多协议：多种消息协议的消息传递\n    - 管理与监控：HTTP-API，命令行工具\n  - **基本慨念：**\n    - Producer：生产者，投递消息的程序：创建消息（消息体和标签），RabbitMQ会根据标签把消息发送给消费者\n    - Consumer：消费者，接收消息的程序：丢弃标签，消费消息体\n    - Broker：消息中间件的服务节点：RabbitMQ服务实例\n    - Queue：队列：内部对象，用于存储信息，生产者投递，消费者取出消费\n    - Xchange：交换器。指定消息按什么规则，路由到哪个队列，如果路由不到或返回或丢弃\n    - RoutingKey：路由键关键字，Xchange根据此来进行邮递，需要与交换器类型和绑定键联合使用，决定消息流向哪里\n    - Binding：绑定，把Xchange和Queue按照路由规则绑定起来，指定绑定键（BindingKey）\n- 任务执行单元（消费者worker）：可以有多个并发，实时监控消息队列，获取任务并执行它\n- 任务执行结果存储（task result store）：由于是由主任务中解耦出来的，主任务想要知道执行结果，必须通过中间件存储\n\n### 1  消息队列的理解\n\n**消息队列**：保存消息的容器\n\n消息:传输的数据单位\n\n消息源与目标间的中间人，主要目的是**提供路由保证消息的传递**，\n\n### 2  为什么使用消息队列\n\n在高并发情况下，来不及同步处理，请求会发生堵塞。通过消息队列，可以异步处理请求，缓解系统压力\n\n应用场景：\n\n- 异步处理、应用解耦、流量削锋和消息通讯等  \n\n**使用消息队列，把不是必须的业务逻辑，异步处理**\n\n消息队列的缺点：\n\n- 系统可用性降低\n- 系统复杂性提高\n- 一致性问题\n\n### 3  多线程在web中的使用\n\n一般在使用IO操作时\n\n使用场景：\n\n- 需要并行操作几个文件的读写，同步不能异步的情况下\n- 视图中需要多个第三方接口\n- 订单提交后，修改库存销量\n\n### 4  为什么使用celery而不使用线程发送耗时任务\n\n因为并发量较大的时候，线程切换会有开销时间，也会降低并发的数量、共享数据维护麻烦\n\ncelery是通过消息队列进行异步任务处理，不用担心并发量高是负载过大，也可以处理复杂系统性能问题，相对灵活\n\n### 5  处理抢购高并发\n\n1. 将请求尽量拦截在上游\n2. 充分利用缓存\n\n前端方面：\n\n- 把详情页部署到CDN节点上，做页面静态化处理\n  - CDN：内容分发网络，将源站内容分发到离用户最近的节点，提高访问速度\n- 禁止重复提交请求、对用户请求限流\n\n后端方面：\n\n- 根据用户id限制访问频率\n- 缓存的应用\n\n### 6  如何解决celery队列阻塞问题\n\n- 队列阻塞的原因：\n\n  1. 队列中有耗时任务，且任务量大于celery并发数（Celery没有足够的worker去执行耗时任务）\n  2. 队列中有耗时任务，且Celery启动了**预取机制**\n     - 任务会有指定的worker去执行，就算其worker是空闲状态，也不会执行其它任务\n\n- 解决：\n\n  - **指定进程数**\n\n    `celery -A project worker --concurrency=4`\n\n  - **改变进程池方式为协程方式**\n\n    `pip install eventlet `\n  \n    `celery -A project worker -P eventlet -c 1000`\n  \n  - **增加并发数**\n  \n  `celery -A project worker -n 进程名字 --concurrencu=并发数 -l info`\n  \n  - **取消预取机制**\n  \n    ```python\n    # 任务发送完成时是否需要确认，对性能会稍有影响\n    celery_app.conf.CELERY_LATE = True\n    # Celery worker每次去队列取任务的数量，默认值为4\n    celery_app.conf.CELERY_PREFETCH_MULTIPLIER = 1\n    ```\n  \n    `celery -A project worker -n 进程名字 -Ofair -l info`\n  \n  - **错误重试机制**\n  \n    ```python\n    # 重连时间间隔\n    @celery_app.task(bind=True, retry_backoff=3)\n    try:\n        ...\n    except Exception as e:\n        # 有异常自动重连三次\n        raise self.retry(exc=e, max_retries=3)\n    ```\n\n### 7  [进程和线程的对比](https://handout-1300728887.cos.ap-beijing.myqcloud.com/%E8%AE%B2%E4%B9%89/python-web%E5%9F%BA%E7%A1%80(5.1.2%E7%89%88%E6%9C%AC)/multitasking/%E8%BF%9B%E7%A8%8B%E5%92%8C%E7%BA%BF%E7%A8%8B%E5%AF%B9%E6%AF%94.html)\n\n进程：CPU的一种执行单元\n\n- 密集CPU任务（大量并行计算）\n\n线程：进程执行程序的最小调度单位\n\n- 密集I/O任务\n\n协程：微线程，可以在单线程上执行多个任务，用函数切换，开销极小\n\n#### 关系对比\n\n1. 线程是依附在进程里面的，没有进程就没有线程\n2. 一个进程默认提供一条线程，进程可以创建多个线程\n\n#### 区别对比\n\n1. 进程之间不共享全局变量\n2. 线程之间共享全局变量，但是要注意资源竞争的问题，解决办法: 互斥锁或者线程同步\n3. 创建进程的资源开销要比创建线程的资源开销要大\n4. 进程是操作系统资源分配的基本单位，线程是CPU调度的基本单位\n5. 线程不能够独立执行，必须依存在进程中\n6. 多进程开发比单进程多线程开发稳定性要强\n\n#### 优缺点\n\n- 进程优缺点:\n  - 优点：可以用多核\n  - 缺点：资源开销大\n- 线程优缺点:\n  - 优点：资源开销小\n  - 缺点：不能使用多核做到高并行\n\n---\n\n#  （五）熟悉 TCP/[HTTP](https://handout-1300728887.cos.ap-beijing.myqcloud.com/%E8%AE%B2%E4%B9%89/python-web%E5%9F%BA%E7%A1%80(5.1.2%E7%89%88%E6%9C%AC)/http/HTTP%E5%8D%8F%E8%AE%AE.html) 协议等网络知识\n\nTDP：用户数据报协议，无连接的\n\n**TCP：传输控制协议，面向连接的、可靠的、基于字节流的传输层通信协议**\n\nHTTP：超文本传输协议，浏览器和web服务器通信需要HTTP协议 \n\nRPC：远程过程调用，向另一台计算机上的程序请求服务，不需要了解底层网络技术的协议。\n\n## 一、[网络协议分层](https://www.jianshu.com/p/30fb2b0bcfd8)\n\n![](https://tupian-1300728887.cos.ap-chengdu.myqcloud.com/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE%E5%88%86%E5%B1%82.png)\n\n### 1  乐观锁\n\n每次拿数据的时候都认为别人不会修改，所以不会上锁\n\n在更新的时候判断此时的库存是否是之前查询出的库存，如果相同，表示没人修改，可以更新库存，否则表示别人抢过资源，不再执行库存更新\n\n**实现方式：**利用时间戳、数据版本version字段，数据被修改＋1\n\n使用场景：高并发，减少数据冲突，保证数据一致性\n\n### 2  高并发，分布式\n\n处理网站并发量\n\n1. 减少数据库访问次数\n2. 文件和数据库分离（静态化页面）\n3. 大数据分布式存储（主从配置读写分离）\n4. 服务器集群，负载均衡\n5. 页面缓存的使用\n6. 内存数据库代替关系型数据库\n\n例子：省市区三级联动、首页部分数据（广告）局部缓存\n\n分布式案例\n\n1. MySQL主从配置读写分离\n\n### 3  长连接与短连接\n\n长连接：连接 -> 传输数据 -> 保持连接 -> 传输数据 -> 直到一方断开\n\n- 操作频繁、点对点的通讯、数据库连接\n  - TCP三握手时间\n  - 不安全\n\n短连接：连接 -> 传输数据-> 断开连接\n\n- http服务\n\n### 4  token和jwt存在什么区别\n\ntoken需要查库验证，JWT直接在服务端进行，不需要查库\n\n### 5  [三次握手和四次挥手](https://blog.csdn.net/qq_38950316/article/details/81087809)\n\n三次挥手：\n\n1. 建立连接时，客户端发送syn包（seq=x）到服务器，并进入SYN_SENT（发送）状态，等待服务器确认；\n2. 服务器收到syn包，必须确认客户的SYN（ack=x+1），同时自己也发送一个SYN包（seq=y），即SYN+ACK包，此时服务器进入SYN_RECV（收到）状态；\n3. 客户端收到服务器的SYN+ACK包，向服务器发送确认包ACK(ack=y+1），此包发送完毕，客户端和服务器进入ESTABLISHED（TCP连接成功）状态，完成三次握手。\n\n四次挥手：\n\n### 6  [CSRF攻击](https://handout-1300728887.cos.ap-beijing.myqcloud.com/%E8%AE%B2%E4%B9%89/Django%E6%A1%86%E6%9E%B6/Django%E6%A1%86%E6%9E%B6/C05-Template/csrf.html)\n\n1. 浏览并登录信任网站A\n2. 验证通过，产生A的Cookie\n3. 再没登出的情况下，浏览**攻击网站B**\n4. B要求访问第三方网站A\n5. 根据B的请求，浏览器带着A的Cookie访问A\n6. A不知道请求源，因为浏览器会自动携带用户的Cookie，按需处理请求，达到模拟用户操作csrf攻击\n\n**防止csrf攻击**\n\n1. 在后端响应的cookie写入csrf_token值\n2. 前端from表单中也写入csrf_token值\n3. 获取两个csrf_token，看是否一致\n\nDjango自带的防csrf中间间\n\n**跨站请求伪造**：攻击者盗用你的身份，发送恶意请求\n\n### 7  RESTFul思想\n\n- 每一个URI代表1种资源；\n\n- 客户端使用GET、POST、PUT、DELETE4个表示操作方式的动词对服务端资源进行操作：GET用来获取资源，POST用来新建资源（也可以用于更新资源），PUT用来更新资源，DELETE用来删除资源；\n\n- 通过操作资源的表现形式来操作资源；\n\n- 资源的表现形式是XML或者HTML；\n\n- 客户端与服务端之间的交互在请求之间是无状态的，从客户端到服务端的每个请求都必须包含理解请求所必需的信息。\n\n---\n\n# （六）[使用腾讯云存储方案](https://cloud.tencent.com/document/product/436)\n\n腾讯对象存储服务（COS）通过网络随时存储和调用各种数据文件\n\n1. 创建一个或多个存储同，上传文件\n2. 根据地址可上传和下载\n3. 可设置相应属性及访问权限\n4. 下载SDK包，执行相应操作\n\n# （七）[熟悉 Linux 系统](https://handout-1300728887.cos.ap-beijing.myqcloud.com/%E8%AE%B2%E4%B9%89/%E7%AC%94%E8%AE%B0/Linux%E5%9F%BA%E7%A1%80%E5%91%BD%E4%BB%A4.html)，了解 Docker、Elasticsearch\n\n### 1  [Docker](http://www.docker.org.cn/index.html)\n\n**开源的软件部署解决方案、轻量级的应用容器框架，采用C/S架构，其可以轻松的为任何应用创建一个轻量级的、可移植的、自给自足的容器。**\n\n> 是一种快速解决生产问题的一种技术手段。\n\n优缺点：\n\n- 优：\n  - 多： 适用场景多\n  - 快： 环境部署快、更新快\n  - 好： 好多人在用，东西好\n  - 省： 省钱省力省人工(123原则)\n- 缺：\n  - 太腻歪人： 依赖操作系统\n  - 不善于沟通：依赖网络\n  - 不善理财： 银行U盾等场景不能用\n\n**镜像**\n\n- 类似虚拟机的镜像，可以创建新的容器\n\n```dockerfile\n# 镜像\ndocker search [image_name]\t\t\t# 搜索镜像\ndocker pull [image_name]\t\t\t# 获取镜像\ndocker images\t\t\t\t\t\t# 查看镜像\ndocker history [image_name]\t\t\t# 查看镜像历史\ndocker tag [old_image]:[old_version]\t# 重命名\ndocker rm [image_name]\t\t\t\t# 删除\ndocker save -o [包文件] [镜像]\t\t# 导出镜像\ndocker load -i [image.tar_name]\t\t# 导入镜像\n```\n\n**容器**\n\n- 由镜像创建的运行实例，类似虚拟机\n\n```dockerfile\n# 容器\ndocker ps\t\t\t\t\t\t\t\t# 查看容器\ndocker start [container_id]\t\t\t\t# 启动已终止的容器\ndocker stop [container_id]\t\t\t\t# 关闭\ndocker rm [container_id]\t\t\t\t# 删除\n\t\t-f\t\t# 强制删除\ndocker run [docker_image] /bin/bash\n\t\t--name\t# 给容器定义一个名称\n\t\t-i \t\t# 让容器的标准输入保持打开。\n\t\t-t\t\t# 分配一个伪终端,并绑定到容器的标准输入上\n\t\t-d \t\t# 守护进程开启\n\t\t-v\t\t# 本地:容器 --映射\n\t\t-p  \t# 端口映射\ndocker exec -it 容器id /bin/bash\t\t\t# 进入后台运行容器\ndocker commit [container_id] [new_image:tag]\t# 基于容器创建镜像\n\t\t-m \t\t# '改动信息' \n\t\t-a \t\t# \"作者信息\"\ndocker logs [容器id]\t\t\t\t\t# 查看运行日志\ndocker inspect  [容器id]\t\t\t\t# 查看详细信息\n```\n\n**仓库（公有、私有、本地）**\n\n- 托管镜像\n\n#### 1.1 dockerflie\n\n Dockerfile类似于我们学习过的脚本，将我们在上面学到的镜像，使用自动化的方式实现出来。\n\n```dockerfile\n# 基础指令\nFROM <image>\t\t\t\t\t# 第一条指令（除首行注释外）\nMAINTAINER <name>\t\t\t\t# 作者信息\nRUN <command>\t\t\t\t\t# 镜像构建时候运行的命令\nEXPOSE <port>\t\t\t\t\t# 对外开发端口\nENTRYPOINT python3 manage.py runserver 0.0.0.0:8000\n\t\t\t\t\t\t\t\t# 运行Django项目，只能有一个\n\n# 文件编辑指令\nADD <src>... <dest>\t\t# 将指定的 <src> 文件复制到容器文件系统中的 <dest>\nCOPY <src>... <dest>\t\t\t# 复制文件\n\n# 环境指令\nENV <key> <value>\t\t\t\t# 设置环境变量\nWORKDIR /path/to/workdir\t\t# 切换目录\n```\n\n### 2  es的存储底层原理\n\n**集群：**es可以作为独立的单个搜索引擎，为了处理大型数据集，实现容错和高可用性，es可以运行在许多合作的服务器上，这些服务器的集合称为集群\n\n**节点：**形成集群的每个服务器\n\n**分片：**数据可以分为较小的分片，放到不同的服务器上，分布式处理。而应用程序并不知道分片的存在\n\n**副本：**复制集原理，其中之一被选择更改索引操作（主分片），主废副升，不能在同一个节点上\n\n**es扩容：**\n\n- 垂直：采购更强大的服务器\n- 水平：采购更多的不同服务器\n\n### 3  [使用 Haystack 调用 Elasticsearch](https://handout-1300728887.cos.ap-beijing.myqcloud.com/%E8%AE%B2%E4%B9%89/%E7%BE%8E%E5%A4%9A%E5%95%86%E5%9F%8E%E8%AE%B2%E4%B9%89/goods/goods-search/haystack-create-index.html)\n\n**Elasticsearch是基于Lucene库实时的分布式搜索分析引擎，全文检索、结构化搜索、分析这三功能的组合**\n\n**全文检索引擎：对数据库里的数据先进行一遍预处理，从而生成索引结构数据（类似于字典那样的结构数据），再使用关键字在索引数据中检索数据**\n\n属于面向文档的数据库\n\nElasticsearch是远端服务器开启的服务\n\n需要用Haystack调用搜索引擎\n\n1. 安装：\n\n   `pip install django-haystack`\n\n   `pip install elasticsearch==2.4.1`\n\n2. 注册到应用\n\n```python\nINSTALLED_APPS = [\n    'haystack', # 全文检索\n]\nurl(r'^search/', include('haystack.urls')),\n```\n\n3.  配置\n\n```python\n# Haystack\nHAYSTACK_CONNECTIONS = {\n    'default': {\n        'ENGINE': 'haystack.backends.elasticsearch_backend.ElasticsearchSearchEngine',\n        'URL': 'http://192.168.103.158:9200/', # Elasticsearch服务器ip地址，端口号固定为9200\n        'INDEX_NAME': 'meiduo_mall', # Elasticsearch建立的索引库的名称\n    },\n}\n\n# 当添加、修改、删除数据时，自动生成索引\nHAYSTACK_SIGNAL_PROCESSOR = 'haystack.signals.RealtimeSignalProcessor'\n```\n\n4. 创建索引类：search_indexes.py\n\n5. 创建txt字段索引值模板文件\n\n6. 手动生成索引（仅第一次）\n\n   `python manage.py rebuild_index`\n\n- 常见问题：\n\n  1. 如何实现分页功能\n     - HAYSTACK_SEARCH_RESULTS_PER_PAGE = 5\n\n  2. No module named haystack\n     - 是否安装/注册了haystack模板\n\n  3. 在html页面出现No serults found\n     - 是否创建了search_indexes.py文件\n     - 数据库中是否有数据\n\n### 3  es是怎么跟数据库关联起来的\n\nLogstash是一个开源数据收集引擎，具有实时管道功能。可以动态得将来自不同数据源的数据统一起来，并将数据标准化到你所选择的目的地\n\n### 4  es倒排索引和常用API\n\n倒排索引：也称反向索引，根据单词查找文档\n\n正向索引：存储每个文档单词的列表\n\n- es常用的api\n  - [查询](https://handout-1300728887.cos.ap-beijing.myqcloud.com/%E8%AE%B2%E4%B9%89/%E9%BB%91%E9%A9%AC%E5%A4%B4%E6%9D%A1%E9%A1%B9%E7%9B%AE%E8%AF%BE%E4%BB%B6/C10-Elasticsearch/Query.html)\n\n# （八）首页静态化、定时任务\n\n**静态化与缓存的主要区别**\n\n- 静态化：将数据静态化到页面，客户端访问时不查询数据库，存储与硬盘\n\n- 缓存：将数据存储于服务器内存\n\n**定时任务的原理**\n\n- 由**crond守护进程**和**crontab文件（任务表）**组成\n\n- 守护进程在系统启动时由init进程启动，受init监视，如果它挂了，init会重启它守护进程每分钟唤醒一次，通过检查crontab文件判断需要做什么\n\n  ```bash\n  # 添加定时任务到系统中\n  $ python manage.py crontab add\n  \n  # 显示已激活的定时任务\n  $ python manage.py crontab show\n  \n  # 移除定时任务\n  $ python manage.py crontab remove\n  ```\n\n**支付宝接入：** \n\n- Python支付宝SDK：https://github.com/fzlee/alipay/blob/master/README.zh-hans.md \n\n# （九）部署相关\n\n## 1  [nginx](https://handout-1300728887.cos.ap-beijing.myqcloud.com/%E8%AE%B2%E4%B9%89/%E9%A1%B9%E7%9B%AE%E9%83%A8%E7%BD%B2/nginx/Advanced.html)\n\n**是一个高性能的HTTP和反向代理服务器，主要处理静态资源**\n\n### 1.1  [反向代理](https://handout-1300728887.cos.ap-beijing.myqcloud.com/%E8%AE%B2%E4%B9%89/%E9%A1%B9%E7%9B%AE%E9%83%A8%E7%BD%B2/nginx/nginx-reverse.html)\n\n正向代理： 为局域网**客户端**向外访问Internet服务**（代理用户，隐藏客户端）**\n\n反向代理： 为局域网**服务器**向外提供Internet服务**（代理服务器，隐藏服务器）**\n\n### 1.2  [负载均衡](https://handout-1300728887.cos.ap-beijing.myqcloud.com/%E8%AE%B2%E4%B9%89/%E9%A1%B9%E7%9B%AE%E9%83%A8%E7%BD%B2/nginx/nginx-load.html)\n\n有一台服务器充当调度者的身份（负载均衡器），请求先到达它，再根据每台服务器的负载情况分配请求\n\n1. 内置策略：nginx自带算法\n   - 雨露均沾型：轮训（默认）、加权轮训、哈希\n     - 轮训：按顺序逐一分配\n     - 加权轮训：权重越大，被分配几率越高，适用于服务器性能不均衡情况\n   - 定向服务型：ip_hash、least_conn、cookie、route、lean\n     - ip_hash：按访问IP的哈希结果分配请求，分配后访客访问固定后端服务器，有效的解决动态网页会话共享问题。\n   - 商业类型：ntlm、least_time、queue、stick\n3. 第三方算法：fair、url_hash\n   - fair：基于后端服务器的响应时间来分配请求，响应时间短的优先分配。\n   - url_hash：按访问的哈希结果分配请求，使同定向到同一台后端服务器，可提高后端缓存服务器的效率。\n\n### 1.3  提供静态文件\n\n静态文件收集命令：`python mange.py collectstatic`\n\n### 1.4  WSGI\n\n- WSGI是一种通信协议， Web 服务器(uWSGI)与 Web 应用程序或应用框架(Django)之间的一种低级别的接口\n- uwsgi是一种线路协议我不是一种通信协议，常用于在uWSGI服务器于其他网络服务器的数据通信\n- uWSGI是实现了uwsgi和WSGI两种协议的Web服务器，**主要处理动态资源**\n\n## 2  [gunicorn](https://handout-1300728887.cos.ap-beijing.myqcloud.com/%E8%AE%B2%E4%B9%89/%E9%BB%91%E9%A9%AC%E5%A4%B4%E6%9D%A1%E9%A1%B9%E7%9B%AE%E8%AF%BE%E4%BB%B6/C12-Deployment/Gunicorn.html)\n\n安装：`pip install gunicorn`\n\n查看使用信息：`$gunicorn -h`\n\n直接运行：`gunicorn 运行文件名称：flask程序实例名`\n\n指定进程和端口号：`$gunicorn -w 4 -b 127.0.0.1:5001 运行文件名称:Flask程序实例名`\n\n# 支付流程\n\n![](https://tupian-1300728887.cos.ap-chengdu.myqcloud.com/%E5%85%AC%E7%A7%81%E9%92%A5.png)\n\n- 生成密钥\n\n```bash\nopenssl\t\t# 进入环境\ngenrsa -out app_private_key.pem 2048\t# 私钥\nrsa -in app_private_key.pem -pubout -out app_pubout_key.pem\t\t# 公钥\n```\n\n# 极睿科技总结\n\n## 一、装饰器\n\n作用：在不改变已有函数源代码及调用方式的前提下，对已有函数进行功能的扩展\n\n```python\n# 不改变原有函数__name__\\备注信息\nfrom functools import wraps\ndef check(fu):  # fu:目标函数\n    \n    @wraps(fu)\n    def inner():\n        '''执行函数之前'''\n        fu()\n        '''执行函数之后'''\n    return inner\n\n# 语法糖写法\n@check\ndef comment():\n    print('发表评论')\n    \ncomment()\n# check等价与  comment = check(comment)\n```\n\n## 二、数据结构与算法\n\n数据：能够被计算机处理的符号或符号集\n\n数据元素（节点、记录）：数据的基本单位。例：学生统计表\n\n数据项（字段、域）：组成数据元素的最小单位。例：编号、姓名、性别等\n\n### 1  数据结构\n\n**相互之间存在的一种或多种特定的数据元素的集合用于计算机存储、组织数据的方式**\n\n![](https://img2018.cnblogs.com/blog/1672612/201906/1672612-20190607153718002-1151308139.jpg)\n\n#### 1.1  逻辑结构\n\n**数据元素间的抽象关系（如近邻关系、从属关系等），分为线性结构与非线性结构，**抽象出来的，与机器无关\n\n![](https://img2018.cnblogs.com/blog/1672612/201906/1672612-20190607154347579-543280178.png)\n\n| 结构类型 | 数据元素间的相互关系 |\n| :------: | :------------------: |\n|   集合   |          无          |\n|   线性   |        一对一        |\n|   树形   |        一对多        |\n|    图    |        多对多        |\n\n#### 1.2  （存储）物理结构\n\n**数据在计算机中的存放方式，反应数据元素间的逻辑关系**\n\n- 顺序存储（向量存储）：把数据元素存放在一组存储地址连续的存储单元里，逻辑关系和物理关系是一致的\n- 链式存储（动态存储）：通过指针反应数据间的逻辑关系\n- 索引存储：建立一个附加的索引表\n- 散列存储：根据节点的关键字直接计算出该节点的存储地址\n\n> 同一逻辑结构可以对应不同的存储结构，算法的设计取决于数据的逻辑结构，而算法实现依赖于指定的存储结构\n\n### 2  算法\n\n**解决特定问题的一种方法或一种描述**\n\n#### 2.1  数据结构和算法的联系\n\n程序=算法+数据结构\n\n- 算法设计: 取决于选定的逻辑结构\n- 算法实现: 依赖于采用的存储结构\n\n区别：\n\n- 数据结构关注的是**数据的逻辑结构、存储结构的基本操作**\n- 算法关注的是**在数据结构的基础上解决实际问题**\n\n算法的五大特性：\n\n1. 可行性：解决具体问题，完成期望功能\n2. 确定性：每一步在一定条件下只有一条执行路径\n3. 有穷性： 算法执行的步骤（或规则）是有限的\n4. 输入：具有零或多个输入\n5. 输出：至少有一个或多个输出\n\n评价算法好坏的方法：\n\n- 正确性：运行正确是一个算法的前提。\n- 可读性：容易理解、容易编程和调试、容易维护。\n- 健壮性：考虑情况全面，不容以出现运行错误。\n- 时间效率高：算法消耗的时间少。\n- 储存量低：占用较少的存储空间。\n\n#### 2.2  时间复杂度O(n)\n\n计算规则\n\n1. 基本操作，只有**常数项O(1)**\n2. 顺序结构，按**加法计算**\n3. 循环结构，按**乘法计算**\n4. 分支结构，**取最大值**\n\n#### 2.3  空间复杂度S(n)\n\n**一个算法在运行过程中临时占用存储空间大小的度量**\n\n## 三、线性数据结构\n\n特点：在数据元素的非空有限集合中\n\n- 存在唯一的（第一个--最后一个）数据元素\n- 且第一个元素没有直接前驱元素，最后一个元素没有直接后继元素，其他元素都有唯一的前驱和后继元素\n\n### 1  线性表\n\n- 线性表有顺序存储结构和链式存储结构。\n\n#### 1.1  顺序存储结构（顺序表）\n\n**是指将线性表中的各个元素依次存放在一组地址连续的存储单元中，通常将这种方法存储的线性表称为顺序表。**\n顺序表的优缺点：\n\n- 优：无须关心表中元素之间的关系，所以不用增加额外的存储空间；可以快速地取表中任意位置的元素。\n- 缺：插入和删除需要移动大量元素\n\n#### 1.2  线性表的链式存储（链表）\n\n一组任意的连续或非连续存储单元存储线性表的元素，存储元素本身（数据域）和后继元素地址（指针域)\t\n\n- 链表与顺序表的对比\n\n  |        |    存储方式    |           时间性能           |       空间性能       |\n  | :----: | :------------: | :--------------------------: | :------------------: |\n  | 顺序表 | 连续的存储单元 | 查找：O(1)；插入、删除：O(n) |     预先分配空间     |\n  | 单链表 | 任意的存储单元 | 查找：O(n)；插入、删除：O(1) | 不用估计预用空间大小 |\n\n循环单链表：首尾相连的一种单链表，最后一个结点称为：尾指针：rear\n\n双向链表： 链表中的每个结点有两个指针域，一个指向直接前驱结点，另一个指向直接后继结点。 data -- prior -- next \n\n### 2  栈和队列\n\n#### 2.1  栈\n\n**限制在表一端进行插入（入栈）和删除（出栈）操作的线性表**\n\n- 栈顶：允许操作端\n\n- 栈底：固定端\n\n> 先进后出\n\n##### 2.1.1  栈的存储结构\n\n栈是运算受限的线性表，线性表的存储结构对栈也适用\n\n1. 顺序栈\n2. 链栈\n\n#### 2.2  队列\n\n**插入（队尾）在表一段，删除（对头）在表的另一端**\n\n> 先进先出\n\n##### 2.2.1  队列的存储结构\n\n队列也是一种运算受限的线性表\n\n- 顺序队列\n- 链队列\n\n小结：\n\n1. 链式栈的栈顶应在链头，插入与删除操作都在链头进行。\n2. 循环队列要注意对空条件和对满条件；而对于链队列，需要特别注意出队仅对队头指针操作，当只有一个元素时，出队需要修改队尾指针。\n3. 递归实质上是通过栈来实现函数调用，只不过是调用自身而已。\n\n### 3  字符串和数组\n\n#### 3.1  字符串\n\n 串（String）是由零个或多个任意字符串组成的字符序列。 \n\n##### 3.1.1  串的存储结构\n\n- 定长顺序存储结构（顺序串）\n  - 定长是指按预定义的大小为每一个串变量分配固定长度的存储区。 最大不能超过256\n- 堆分配存储结构\n\n#### 3.2 数组\n\n **结构中的元素本身可以是具有某种结构的数据，但属于同一数据类型，一般线性表的扩充**\n\n是一个具有固定格式和数量的数据有续集，一旦被定义就不再改变，两种基本运算：\n\n1. 取值操作：给定一组下标，读其对应的数据元素。\n2. 赋值操作：给定一组下标，存储或修改与其相对应的数据元素。\n\n##### 3.2.1  数组的存储结构\n\n一维：顺序存储结构，直接按其下标顺序分配存储空间\n\n多维：按某种次序将数组中元素排成一个线性序列，再作存储\n\n存二维数组：\n\n1. 先行后列\n2. 先列后行\n\n##### 3.2.2  稀疏矩阵\n\n**矩阵中大多数元素为零元素的矩阵，按常规分配方法浪费内存**\n\n三元组表存储\n\n- 非零元素所在行、列及值构成一个三元组（i,j,v）\n\n## 四、非线性结构\n\n### 1  树和二叉树\n\n前驱唯一而后继不唯一，一对多\n\n定义：树（tree）是n（n>=0）个结点的有限集合。当n=0时，该集合满足以下条件：\n\n- 只有一个特殊节点称为根节点（root）\n\n- 当n>1时，其余n-1个结点被分成m(m>0)个互相不相交的集合，称为根节点的**子树**\n\n  树的定义用了递归概念，其算法也常常使用递归\n\n#### 1.1  二叉树\n\n二叉树是每个节点最多有两个子树的树结构。通常子树被称作“左子树”（left subtree）和“右子树”（right subtree）\n\n满二叉树：除了叶结点外每一个结点都有左右子叶且叶子结点都处在最底层的二叉树。 \n\n##### 1.1.1  存储结构\n\n顺序存储结构：按照二叉树结点从上至下、从左到右的顺序存储。\n\n链式存储结构：每个节点由三个域组成：数据域和左、右指针域。\n\n![](https://img-blog.csdnimg.cn/20181214150636793.jpeg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2NzZG5fYWl5YW5n,size_16,color_FFFFFF,t_70)\n\n##### 1.1.2  二叉树遍历\n\n**深度优先一般用递归，广度优先一般用队列。一般情况下能用递归实现的算法大部分也能用堆栈来实现。**\n\n1. 深度优先遍历\n   1. 先序遍历\t` 根节点->左子树->右子树 `\n   2. 中序遍历    ` 左子树->根节点->右子树 `\n   3. 后序遍历    ` 左子树->右子树->根节点 `\n2. 广度优先遍历（层次遍历）\n   -  从树的root开始，从上到下从从左到右遍历整个树的节点 \n\n### 2  图\n\n任意两个结点之间都可能相关，即结点之间的邻接关系可以是任意的。\n\n## 五、排序和搜索\n\n### 1  冒泡排序\n\n**重复遍历数列，一次比较两个元素**\n\n![冒泡排序](https://tupian-1300728887.cos.ap-chengdu.myqcloud.com/%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F.gif)\n\n### 2  选择排序\n\n**找到最大或最小的元素，把它排在队前或队尾，循而往复， 放到已排序序列的末尾**\n\n![选择排序](https://tupian-1300728887.cos.ap-chengdu.myqcloud.com/%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F.gif)\n\n### 3  插入排序\n\n**通过构建有序序列，对于未排序数据，在已排序序列中从后向前扫描，找到相应位置并插入。**\n\n![插入排序](https://tupian-1300728887.cos.ap-chengdu.myqcloud.com/%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F.gif)\n\n### 4  希尔排序\n\n**希尔排序是插入排序的一种，将数据分成几组，分别使用插入排序**\n\n![希尔排序](https://tupian-1300728887.cos.ap-chengdu.myqcloud.com/%E5%B8%8C%E5%B0%94%E6%8E%92%E5%BA%8F.jpg)\n\n### 5  快速排序\n\n**从序列中挑出一个元素（基准），把小于（大于）基准的元素放在基准前边（后边）**\n\n![快速排序](https://tupian-1300728887.cos.ap-chengdu.myqcloud.com/%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F.gif)\n\n### 6  归并排序\n\n **分治法，先递归分解数据，在合并数组；比较两个数组最前边的数，谁小谁先取**\n\n![归并排序](https://tupian-1300728887.cos.ap-chengdu.myqcloud.com/%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F.gif)\n\n### 7  搜索\n\n#### 7.1  顺序查找\n\n#### 7.2  二分法查找\n\n#### 7.3  二叉树查找\n\n#### 7.4  哈希查找\n\n# （十）大数据\n\n# 奇点控股\n\n面试题\n\n一、python的语言特性\n\n- 简单、易学、免费、开源、高级语言、可移植性、解释型语言、面向对象、可扩展性、丰富的库、规范的代码\n  - 高级语言：不用考虑内存一类的底层细节\n  - 可移植性：无需修改，可在多平台上运行\n  - 解释型语言： 在运行程序的时候才翻译，专门有一个解释器去进行翻译，每个语句都是执行的时候才翻译。效率比较低，依赖解释器，跨 平台性好 \n  - 编译型语言： 程序在执行之前需要一个专门的编译过程，把程序编译成 为机器语言的文件，运行时不需要重新翻译，直接使用编译的结果就行了。程序执行效率高，依赖编译器，跨平台性差些\n  - 可扩展性： 如果你需要你的一段关键代码运行得更快或者希望某些算法不公开，你可以把你的部分程序用C或C++编写，然后在你的Python程序中使用它们 \n\n二、*args和**kwargs的区别\n\n- 都是不定长参数\n\n  - *args：将参数打包成元组进行传参\n\n  - **kwargs：将参数打包成字典进行传参\n\n三、\n\n```python\ndef main():    \n\ta = 'hello'    \n\tb = a    \n\ta = b + 'world'    \n\tprint(a)    \n\tprint(b)\nmain()\n# helloworld\n# hello\n```\n\n四、TCP/IP协议分几层，TCP、UDP、HTTP分别在哪一层\n\n- 四层：网络接口层、网络层、传输层（TCP、UDP）、应用层（HTTP）\n\n五、\n\n```python\ndef main():    \n    try:        \n        a = 'str'        \n        b = 123        \n        print(a + b)    \n    except:        \n        print('except')    \n    else:        \n        print('else')    \n    finally:        \n        print('finally')\nmain()\n# except\n# finally\n```\n\n## 总结\n\n- **python中的魔法方法**\n\n  ```python\n  __init__(self)\t# 在创建一个对象是默认被调用，不需要手动调用\n  __str__(self)\t# 用来显示信息，需要return一个数据\n  __del__(self)\t# 当删除对象时，默认被调用\n  __new__(self)\t# 才是实例化对象调用的第一个方法，它只取下 cls 参数，并把 其他参数传给 __init__\n  __call__(self)\t# 允许一个类的实例像函数一样被调用 。\n  __getitem__(self)\t\t# 定义获取容器中指定元素的行为，相当于 self[key] 。\n  __getattr__(self) \t# 定义当用户试图访问一个不存在属性的时候的行为 。\n  __setattr__(self) \t# 定义当一个属性被设置的时候的行为 。\n  __getattribute__(self) \t# 定义当一个属性被访问的时候的行为 。\n  ```\n\n- **可变与不可变类型**\n\n  - **指内存中的那块内容（value）是否可以发生改变**\n  - 可变类型：不需要申请新内存，在原有基础上改变\n  - 不可变类型：必须在内存中新申请一块区域\n\n- **冒泡排序**\n\n```python\ndef bubble_sort(alist):\n    for j in range(len(alist)-1, 0, -1):\n        for i in range(j):\n            if alist[i] > alist[i+1]:\n                alist[i], alist[i+1] = alist[i+1], alist[i]\n```\n\n- **is和==的区别**\n\n  -  都是对对象进行比较判断作用的\n  -  ==（比较运算法），用来判断两个对象的value值\n  -  is（同一性运算符），用来判断两个对象的唯一身份标识，id地址\n\n  只有**数值型（-5~256）和字符串**型的情况下，a is b才为True，当a和b是**tuple，list，dict**或**set**型时，a is b为False。 \n\n- **python默认递归限制1000or998**\n\n  - 修改限制\n\n    ```python\n    import sys\n    sys.setrecursionlimit(1500)\n    ```\n\n- **数据量大情况下Paginator的缺点**\n\n  - 查询效率慢的问题\n  - **PageHelper的分页功能是通过Limit拼接SQL实现的** \n\n# 中科软总结\n\n- 项目用了几台服务器\n\n  |             用途             | 服务器 |\n  | :--------------------------: | :----: |\n  |   Nginx反向代理和静态文件    |   1    |\n  |         主业务服务器         |   1    |\n  | celery异步任务broker和worker |   2    |\n  |        MySQL读写分离         |   2    |\n  |            redis             |   1    |\n  |          **共计**：          | **7**  |\n","slug":"总汇","published":1,"updated":"2020-09-30T08:10:48.879Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckfp5akga0018n8jhakiz12b6","content":"<h1 id=\"（一）Flask与Django\"><a href=\"#（一）Flask与Django\" class=\"headerlink\" title=\"（一）Flask与Django\"></a>（一）Flask与Django</h1><ul>\n<li><strong>轻量、简洁、扩展性强，，原生不支持数据库</strong></li>\n<li>核心：werkzeug和jinja2</li>\n</ul>\n<a id=\"more\"></a>\n\n<table>\n<thead>\n<tr>\n<th align=\"center\">房有居</th>\n<th align=\"center\">用户模块、主页渲染、搜索房源信息功能及数据库的优化</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\"><strong>食天下</strong></td>\n<td align=\"center\"><strong>现菜谱展示、用户模块</strong></td>\n</tr>\n<tr>\n<td align=\"center\"><strong>书香阁</strong></td>\n<td align=\"center\"><strong>书刊列表展示、用户历史记录保存</strong></td>\n</tr>\n</tbody></table>\n<hr>\n<h3 id=\"Flask与Django对比\"><a href=\"#Flask与Django对比\" class=\"headerlink\" title=\"Flask与Django对比\"></a>Flask与Django对比</h3><ul>\n<li>与Django对比<ul>\n<li>不同点：<ol>\n<li>Django：支持 ORM、认证、CSRF/模板、后台管理等。 </li>\n<li>Flask：自带jinja2模板，实现其它功能需要调用扩展包</li>\n</ol>\n</li>\n<li>相同点：<ol>\n<li>性能都不⾼，都是单进程服务器。 </li>\n</ol>\n</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"MVT设计模式\"><a href=\"#MVT设计模式\" class=\"headerlink\" title=\"MVT设计模式\"></a>MVT设计模式</h3><p>设计模式：解决一类问题而总结出来的经验和套路</p>\n<p><strong>MVC：</strong>核心思想：分工、解耦，让不同代码之间降低耦合，增强代码的可扩展性和可移植性</p>\n<p><strong>MVT：</strong></p>\n<ul>\n<li>M：模型 Model</li>\n<li>V：视图 View</li>\n<li>T：模板 Template</li>\n</ul>\n<h3 id=\"前后端不分离的区别\"><a href=\"#前后端不分离的区别\" class=\"headerlink\" title=\"前后端不分离的区别\"></a>前后端不分离的区别</h3><p>前后端不分离：</p>\n<ul>\n<li>页面的控制和渲染是由后端实现的<ul>\n<li>优点：页面展示无延迟，因为响应给用户的就是页面；方便实现搜索引擎排名，帮助爬虫服务器更高效率的爬取数据，即SEO</li>\n<li>缺点：对后端程序员要求高</li>\n</ul>\n</li>\n</ul>\n<p>前后端分离：</p>\n<ul>\n<li>页面的控制和渲染是由前端实现的<ul>\n<li>优点：后端程序员只需专注数据和业务即可</li>\n<li>缺点：有延迟，先加载页面 – 发请求获取数据 – 渲染</li>\n</ul>\n</li>\n<li>补充：前后端不分离，一般不做页面静态化，因为用户先拿到的就是静态页面</li>\n</ul>\n<h3 id=\"Django信号\"><a href=\"#Django信号\" class=\"headerlink\" title=\"Django信号\"></a>Django信号</h3><p><strong>Django 提供一个“信号分发器”，允许解耦的应用在框架的其它地方发生操作时会被通知到。信号允许特定的sender（发送者）通知一组receiver（接收者）某些操作已经发生。</strong></p>\n<p>信号遵守的设计模式：<strong>观察者设计模式（通知机制、监听机制）</strong></p>\n<ul>\n<li><a href=\"https://handout-1300728887.cos.ap-beijing.myqcloud.com/%E8%AE%B2%E4%B9%89/%E6%80%9D%E7%BB%B4%E5%AF%BC%E5%9B%BE/Django%E4%BF%A1%E5%8F%B7.jpg\" target=\"_blank\" rel=\"noopener\">使用</a></li>\n</ul>\n<h3 id=\"Django项目中的社会化分享\"><a href=\"#Django项目中的社会化分享\" class=\"headerlink\" title=\"Django项目中的社会化分享\"></a>Django项目中的社会化分享</h3><p>结合项目中使用：</p>\n<ul>\n<li><p>MobTech平台创建应用：<a href=\"https://www.mob.com/\" target=\"_blank\" rel=\"noopener\">https://www.mob.com/</a></p>\n<ol>\n<li>注册登录</li>\n<li>产品中心 –&gt; 开发者平台</li>\n<li>创建应用并添加产品和SDK</li>\n<li>进入到&lt;应用管理&gt;查看App Key和App Secret</li>\n</ol>\n</li>\n<li><p>创建Django项目</p>\n</li>\n<li><p>根据开发文档集成ShareSDK</p>\n<ul>\n<li><p>进入文档中心，打开web集成文档</p>\n<p><a href=\"https://www.mob.com/wiki/list\" target=\"_blank\" rel=\"noopener\">https://www.mob.com/wiki/list</a></p>\n</li>\n<li><p>根据开发文档集成ShareSDK，实现社会化分享功能</p>\n</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"Django自带的缓存cache和redis的区别\"><a href=\"#Django自带的缓存cache和redis的区别\" class=\"headerlink\" title=\"Django自带的缓存cache和redis的区别\"></a>Django自带的缓存cache和redis的区别</h3><p>cache是python实现缓存的一种工具</p>\n<p>redis是一种存放缓存数据的数据库</p>\n<p>可以使用cache这个缓存工具，将缓存数据缓存到redis数据库</p>\n<h3 id=\"如何对Django框架进行二次开发，增大并发数\"><a href=\"#如何对Django框架进行二次开发，增大并发数\" class=\"headerlink\" title=\"如何对Django框架进行二次开发，增大并发数\"></a>如何对Django框架进行二次开发，增大并发数</h3><p>可能造成并发降低的原因：</p>\n<ol>\n<li>数据库操作变慢</li>\n<li>python语言执行速度变慢</li>\n</ol>\n<p>Django二次开发方向：</p>\n<ul>\n<li>扩展Django Models使其支持Sharding（一种数据库分片技术）</li>\n<li>手动关闭GC（垃圾回收）</li>\n<li><strong>把那些稳定且对性能最敏感的组件，使用c或c++来重写</strong></li>\n</ul>\n<h3 id=\"中间件的定义方式、结构\"><a href=\"#中间件的定义方式、结构\" class=\"headerlink\" title=\"中间件的定义方式、结构\"></a>中间件的定义方式、结构</h3><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">middleware_name</span><span class=\"params\">(get_response)</span>:</span></span><br><span class=\"line\">    <span class=\"comment\"># 这个节点表示请求初始化：在最开始的时候补充额外逻辑</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">middleware</span><span class=\"params\">(request)</span>:</span></span><br><span class=\"line\">        <span class=\"comment\"># 这个节点表示请求被执行前：在请求执行的时候补充额外逻辑</span></span><br><span class=\"line\">        response = get_response(request)</span><br><span class=\"line\">        <span class=\"comment\"># z这个节点表示响应之前：在响应之前补充额外逻辑</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> response</span><br><span class=\"line\">    <span class=\"keyword\">return</span> middleware</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"ORM（-object-relation-mapping-）\"><a href=\"#ORM（-object-relation-mapping-）\" class=\"headerlink\" title=\"ORM（ object-relation-mapping ）\"></a><a href=\"https://handout-1300728887.cos.ap-beijing.myqcloud.com/%E8%AE%B2%E4%B9%89/%E9%BB%91%E9%A9%AC%E5%A4%B4%E6%9D%A1%E9%A1%B9%E7%9B%AE%E8%AF%BE%E4%BB%B6/C02-Database/ORM.html\" target=\"_blank\" rel=\"noopener\">ORM（ <strong>object-relation-mapping</strong> ）</a></h3><ul>\n<li><p>对象关系映射 本质上就是将数据从一种形式转换到另外一种形式，定义的类相当于数据库中的表，在类中的定义的属性相当于是表中的字段，实例化的每一个对象，相当于的每一条数据。</p>\n<ul>\n<li>类 -&gt; 表</li>\n<li>类属性 -&gt; 字段</li>\n<li>类对象 -&gt; 数据</li>\n</ul>\n</li>\n<li><p>作用：</p>\n<ol>\n<li><p>省去编写sql语句，提⾼开发效率；</p>\n</li>\n<li><p>防注⼊攻击</p>\n</li>\n<li><p>适配不同的数据库。</p>\n</li>\n</ol>\n</li>\n<li><p>缺点：查询效率较低，需要手动的优化。</p>\n</li>\n<li><p>操作方式：</p>\n<ol>\n<li>先创建模型类，再迁移到数据库中：不能对数据库表的字段的定义，实现精确控制。 </li>\n<li>使⽤sql创建数据库的表，定义模型类，通过模型类，实现ORM操作。 </li>\n</ol>\n</li>\n</ul>\n<hr>\n<h1 id=\"（二）熟练-MySQL、Redis-等数据库的使用\"><a href=\"#（二）熟练-MySQL、Redis-等数据库的使用\" class=\"headerlink\" title=\"（二）熟练 MySQL、Redis 等数据库的使用\"></a>（二）熟练 MySQL、Redis 等数据库的使用</h1><h3 id=\"1-复制集与分布式\"><a href=\"#1-复制集与分布式\" class=\"headerlink\" title=\"1  复制集与分布式\"></a>1  <a href=\"https://handout-1300728887.cos.ap-beijing.myqcloud.com/%E8%AE%B2%E4%B9%89/%E9%BB%91%E9%A9%AC%E5%A4%B4%E6%9D%A1%E9%A1%B9%E7%9B%AE%E8%AF%BE%E4%BB%B6/C02-Database/DatabaseTheory.html\" target=\"_blank\" rel=\"noopener\">复制集与分布式</a></h3><ul>\n<li><p>复制集：</p>\n<ol>\n<li>数据库中数据相同，起到备份作用</li>\n<li>高可用</li>\n</ol>\n</li>\n<li><p>分布式：</p>\n<ol>\n<li>数据库中数据不同，共同组成完整的数据集合</li>\n<li>高吞吐</li>\n</ol>\n</li>\n</ul>\n<h3 id=\"2-主从复制\"><a href=\"#2-主从复制\" class=\"headerlink\" title=\"2  主从复制\"></a>2  主从复制</h3><ol>\n<li><p>主服务器的数据发生改变时，会将改变的记录写在本地二进制log日志中</p>\n</li>\n<li><p>从服务器的一个线程会把更新的数据拷贝中继log日志中</p>\n</li>\n<li><p>从服务器读取中继文件并执行，达到主从一致</p>\n<p><strong>利用主从在达到高可用的同时，也可以通过读写分离提供吞吐量。</strong> </p>\n</li>\n</ol>\n<h3 id=\"3-事务\"><a href=\"#3-事务\" class=\"headerlink\" title=\"3  事务\"></a>3  <a href=\"https://handout-1300728887.cos.ap-beijing.myqcloud.com/%E8%AE%B2%E4%B9%89/python-web%E5%9F%BA%E7%A1%80(5.1.2%E7%89%88%E6%9C%AC)/mysqlhigh/%E4%BA%8B%E5%8A%A1.html\" target=\"_blank\" rel=\"noopener\">事务</a></h3><ul>\n<li>四大特性：<ul>\n<li>原子性：强调事务中的多个操作时一个整体</li>\n<li>一致性：强调数据库中不会保存不一致状态</li>\n<li>隔离性：强调数据库中事务之间相互不可见</li>\n<li>持久性：强调数据库能永久保存数据，一旦提交就不可撤销</li>\n</ul>\n</li>\n<li>隔离级别：<ul>\n<li>读已提交：一个事务要等另一个事务提交后才能读取数据，可避免脏读的发生。</li>\n<li>读未提交：一个事务可以读取另一个未提交事务的数据，最低级别，任何情况都无法保证。</li>\n<li><strong>可重复读(MySQL默认)</strong>：就是在开始读取数据（事务开启）时，不再允许修改操作，可避免脏读、不可重复读的发生。</li>\n<li>串行化：最高的事务隔离级别，事务串行化顺序执行，可以避免脏读、不可重复读与幻读。效率抵消，耗性能</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"一、Mysql\"><a href=\"#一、Mysql\" class=\"headerlink\" title=\"一、Mysql\"></a>一、Mysql</h2><h3 id=\"1-索引\"><a href=\"#1-索引\" class=\"headerlink\" title=\"1  索引\"></a>1  <a href=\"https://handout-1300728887.cos.ap-beijing.myqcloud.com/%E8%AE%B2%E4%B9%89/python-web%E5%9F%BA%E7%A1%80(5.1.2%E7%89%88%E6%9C%AC)/mysqlhigh/%E7%B4%A2%E5%BC%95.html\" target=\"_blank\" rel=\"noopener\">索引</a></h3><p>也叫“键”，保存数据库中所有记录的位置信息，相比于目录</p>\n<p>优点：加快查询速度</p>\n<p>缺点：耗费时间空间（不是越多越好）</p>\n<p><strong>优化</strong></p>\n<ol>\n<li>不是越多越好，而是需要自己合理的使用</li>\n</ol>\n<h3 id=\"2-sql语句优化\"><a href=\"#2-sql语句优化\" class=\"headerlink\" title=\"2  sql语句优化\"></a>2  <a href=\"https://handout-1300728887.cos.ap-beijing.myqcloud.com/%E8%AE%B2%E4%B9%89/%E9%BB%91%E9%A9%AC%E5%A4%B4%E6%9D%A1%E9%A1%B9%E7%9B%AE%E8%AF%BE%E4%BB%B6/C02-Database/DatabaseOptimize.html\" target=\"_blank\" rel=\"noopener\">sql语句优化</a></h3><ul>\n<li>1.避免全表扫描 </li>\n<li>2.查询时使⽤select明确指明所要查询的字段，避免使⽤ select * 的操作； </li>\n<li>3.SQL语句尽量⼤写 </li>\n<li>4.尽量避免在 where ⼦句中使⽤!=或&lt;&gt;操作符， </li>\n<li>5.遵循最左原则，在where⼦句中写查询条件时把索引字段放在前⾯ </li>\n<li>6.能使⽤关联查询解决的，尽量不要使⽤⼦查询 </li>\n<li>7.能不使⽤关联查询的尽量不要使⽤关联查询 </li>\n<li>8.不需要获取全表数据的时候，不要查询全表数据，使⽤LIMIT来限制数据 </li>\n</ul>\n<h3 id=\"3-数据库的优化\"><a href=\"#3-数据库的优化\" class=\"headerlink\" title=\"3  数据库的优化\"></a>3  数据库的优化</h3><ul>\n<li>在进⾏表设计时，可适度增加冗余字段(反范式设计)，减少JOIN操作；</li>\n<li>多字段表可以进⾏垂直分表优化，多数据表可以进⾏⽔平分表优化；</li>\n<li>选择恰当的数据类型，如整型的选择；</li>\n<li>对于强调快速读取的操作，可以考虑使⽤MyISAM数据库引擎；</li>\n<li>对较频繁的作为查询条件的字段创建索引；唯⼀性太差的字段不适合单独创建索引，即使频繁作为查询条件；更新⾮常频繁的字段不适合创建索引；</li>\n<li>编写SQL时使⽤上⾯的⽅式对SQL语句进⾏优化；</li>\n<li>使⽤慢查询⼯具找出效率低下的SQL语句进⾏优化；</li>\n<li>构建缓存，减少数据库磁盘操作；</li>\n<li>可以考虑结合使⽤内存型数据库，如Redis，进⾏混合存储。</li>\n</ul>\n<h3 id=\"4-数据库存储过程与触发器\"><a href=\"#4-数据库存储过程与触发器\" class=\"headerlink\" title=\"4  数据库存储过程与触发器\"></a>4  数据库存储过程与触发器</h3><p>存储过程：完成特定功能的SOL语句集</p>\n<p>触发器：对表进行（插入、删除、更新）触发一系列预定好的SQL语句</p>\n<h3 id=\"5-数据库设计\"><a href=\"#5-数据库设计\" class=\"headerlink\" title=\"5  数据库设计\"></a>5  <a href=\"https://handout-1300728887.cos.ap-beijing.myqcloud.com/%E8%AE%B2%E4%B9%89/%E9%BB%91%E9%A9%AC%E5%A4%B4%E6%9D%A1%E9%A1%B9%E7%9B%AE%E8%AF%BE%E4%BB%B6/C02-Database/DatabaseDesign.html\" target=\"_blank\" rel=\"noopener\">数据库设计</a></h3><p>库设计：</p>\n<ol>\n<li>数据库名要明确</li>\n<li>不同类型的数据分开管理</li>\n</ol>\n<p>表设计：</p>\n<ol>\n<li>命名，业务表跟基础表区分，驼峰命名法</li>\n<li>词性分析法，<strong>名词体现表或字段，动词体现关系</strong><ul>\n<li>一对一、一对多、多对多</li>\n</ul>\n</li>\n<li>不要用物理删除，以防后悔</li>\n<li>三范式：<ul>\n<li>字段不可分割、原子性</li>\n<li>满足范式一，表有主键依赖</li>\n<li>满足范式二，表非主字段之间没有依赖关系。</li>\n</ul>\n</li>\n<li>反范式：<strong>利用冗余字段存储数据，节省数据查询的时间，本质是空间换时间。</strong></li>\n<li>字段类型、是否允许为null、是否有默认值<ul>\n<li>整形：int长度并不影响精度，长度只和显示有关<ul>\n<li><strong>存储范围相同</strong></li>\n</ul>\n</li>\n<li>字符串：char和varchar<ul>\n<li>char不可变，查询效率高，可能造成存储浪费</li>\n<li>varchar可变，查询效率不如char，节省空间</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>索引设计<ul>\n<li>主键、外键、唯一约束；</li>\n<li>key/value，提高查询效率的字段；</li>\n<li><strong>外键：作用是维护数据的完整性。</strong><ul>\n<li>应用：在实际开发项目过程中，用不用外键？</li>\n<li>建议：项目开发初期可以利用外键帮助维护数据的完整性，但是，项目的中后期，建议移除外键。</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>数据库引擎（MySQL的核心）的选择：决定数据存储和增删改查方式，争对表<ul>\n<li><strong>InnoDB</strong>（事务、安全能力）<ol>\n<li><strong>支持事务，安全性级别较高，查询效率相对较低。</strong></li>\n<li>为处理巨大数据量的最大性能设计</li>\n<li><strong>InnoDB支持外键完整性约束</strong></li>\n</ol>\n</li>\n<li><strong>MyISAM</strong>（主要用来插入和查询）<ol>\n<li><strong>不支持事务，插入、查询效率较高，增删改效率较低。</strong></li>\n<li>产生三个文件（名字一表名字开始）：<ol>\n<li>frm：文件存储表定义</li>\n<li>.MYD：数据文件</li>\n<li>.MYI：索引文件</li>\n</ol>\n</li>\n</ol>\n</li>\n<li><strong>MEMORY</strong>（存放临时数据）<ol>\n<li>将表中数据存储到内存中，未查询和引用其他表数据提供快速访问</li>\n</ol>\n</li>\n</ul>\n</li>\n</ol>\n<h4 id=\"5-1-分库分表\"><a href=\"#5-1-分库分表\" class=\"headerlink\" title=\"5.1  分库分表\"></a>5.1  分库分表</h4><p><strong>垂直拆分</strong></p>\n<ul>\n<li>垂直分表：”大表拆小表”，基于列字段进行，将不常用，数据较大，长度较长拆分</li>\n<li>垂直分库：根据业务切分成不同的库</li>\n</ul>\n<p><strong>水平拆分</strong></p>\n<ul>\n<li>水平分表：针对数据量巨大的单张表， 按照某种规则（RANGE,HASH取模等），切分到多张表里面去,有IO瓶颈</li>\n<li>水平分库分表：将表数据切分到多个服务器上，分布式，有效解决瓶颈、突破IO</li>\n</ul>\n<p><strong>先垂直分在水平分</strong></p>\n<h5 id=\"分库分表后面临的问题\"><a href=\"#分库分表后面临的问题\" class=\"headerlink\" title=\"分库分表后面临的问题\"></a>分库分表后面临的问题</h5><ul>\n<li>事务支持</li>\n<li>多库结果集合并</li>\n<li>跨库join</li>\n</ul>\n<p><strong>分库分表方案产品中间件</strong>：官方MySQL Fabric、阿里TDDL，Cobar、360Atlas</p>\n<h3 id=\"6-SQL语句中where和having那个执行更快\"><a href=\"#6-SQL语句中where和having那个执行更快\" class=\"headerlink\" title=\"6  SQL语句中where和having那个执行更快\"></a>6  SQL语句中where和having那个执行更快</h3><p>SQL语句执行顺序：</p>\n<p><code>from -&gt; where -&gt; group by -&gt; having -&gt; select -&gt; order by</code></p>\n<p>两者区别：</p>\n<p>where：是一个约束声明，结果返回之前起作用，不能使用聚合函数</p>\n<p>having：是一个过滤声明，过滤分组数据，只能用于group by，可以使用聚合函数</p>\n<hr>\n<h2 id=\"二、Redis\"><a href=\"#二、Redis\" class=\"headerlink\" title=\"二、Redis\"></a>二、Redis</h2><h3 id=\"1-Redis特点\"><a href=\"#1-Redis特点\" class=\"headerlink\" title=\"1  Redis特点\"></a>1  <a href=\"https://handout-1300728887.cos.ap-beijing.myqcloud.com/%E8%AE%B2%E4%B9%89/%E9%BB%91%E9%A9%AC%E5%A4%B4%E6%9D%A1%E9%A1%B9%E7%9B%AE%E8%AF%BE%E4%BB%B6/C02-Database/Redis.html\" target=\"_blank\" rel=\"noopener\">Redis特点</a></h3><ol>\n<li>速度快：C语言实现，存储在内存中以键值对形式保存</li>\n<li><strong>持久化:</strong><ul>\n<li>redis可以将数据写入到磁盘中，在停机后，再次启动redis时，将磁盘中的备份数据加载到redis中</li>\n<li>两种机制：<ol>\n<li>RDB快照持久化（默认开启）<ul>\n<li>将内存中的数据存入磁盘</li>\n<li>缺点：一旦数据库出现问题，rdb文件数据不是全新的</li>\n</ul>\n</li>\n<li>AOF追加文件持久化<ul>\n<li>文件会变大，自动压缩</li>\n</ul>\n</li>\n</ol>\n</li>\n</ul>\n</li>\n<li>多种数据结构：string  hash  list  set  zset</li>\n<li>支持多种编程语言</li>\n<li>支持事务、流水线、消息队列</li>\n<li><a href=\"https://handout-1300728887.cos.ap-beijing.myqcloud.com/%E8%AE%B2%E4%B9%89/redis%E8%AE%B2%E4%B9%89/redis%E8%AE%B2%E4%B9%89/redis/da-jian-zhu-cong.html\" target=\"_blank\" rel=\"noopener\">主从复制</a></li>\n<li>高可用、分布式</li>\n</ol>\n<h3 id=\"2-redis宕机\"><a href=\"#2-redis宕机\" class=\"headerlink\" title=\"2  redis宕机\"></a>2  redis宕机</h3><ul>\n<li><p>slave从宕机</p>\n<ul>\n<li>重启后会自动加入到主从架构中，完成数据同步</li>\n</ul>\n</li>\n<li><p>master主宕机（主从都没持久化）</p>\n<ol>\n<li>不要立马重启服务</li>\n<li>slave执行<code>SLAVEOF ON ONE</code>断开主从关系并升级为主库</li>\n<li>重启主，<code>SLAVEOF</code>设为从</li>\n</ol>\n<p>可使用简单方法：<strong>哨兵</strong></p>\n</li>\n</ul>\n<h3 id=\"3-redis高可用\"><a href=\"#3-redis高可用\" class=\"headerlink\" title=\"3  redis高可用\"></a>3  redis高可用</h3><p><strong>提供了主从同步＋哨兵机制（ Sentinel ）</strong></p>\n<ul>\n<li>哨兵机制：实现故障转移，当检测到主服务器发生故障时，把从服务器升级为主，保证数据正常使用<ul>\n<li>原理：心跳机制＋投票裁决＋故障转移<ul>\n<li>定时给master/slave发送消息，若指定时间内无响应（主观宕机 SDOWN）</li>\n<li>Sentinel群都报告某一master无响应（客观宕机 SDOWN）</li>\n<li>通过一定vote算法，将从升为主</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"4-为什么Redis比MySQL快\"><a href=\"#4-为什么Redis比MySQL快\" class=\"headerlink\" title=\"4  为什么Redis比MySQL快\"></a>4  为什么Redis比MySQL快</h3><table>\n<thead>\n<tr>\n<th align=\"center\"></th>\n<th align=\"center\">Redis</th>\n<th align=\"center\">MySQL</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\">数据格式</td>\n<td align=\"center\">k-v</td>\n<td align=\"center\">B+TREE</td>\n</tr>\n<tr>\n<td align=\"center\">时间复杂度</td>\n<td align=\"center\">0(1)（常数阶）</td>\n<td align=\"center\">0(logn)（对数阶）</td>\n</tr>\n<tr>\n<td align=\"center\">存储位置</td>\n<td align=\"center\">从内存直接取出</td>\n<td align=\"center\">磁盘表（全局扫或索引查）</td>\n</tr>\n</tbody></table>\n<p>Redis是单线程的多路复用IO，单线程避免线程切换开销；多路复用避免IO等待开销；多核处理器下对数据进行分区，各处理器处理不同的数据（分着干）</p>\n<h2 id=\"三、缓存\"><a href=\"#三、缓存\" class=\"headerlink\" title=\"三、缓存\"></a>三、缓存</h2><h3 id=\"1-有效期TTL（Time-to-live）\"><a href=\"#1-有效期TTL（Time-to-live）\" class=\"headerlink\" title=\"1  有效期TTL（Time to live）\"></a>1  有效期TTL（Time to live）</h3><ul>\n<li>作用：<ul>\n<li>节省空间</li>\n<li>做到数据有效性，失效后，做到数据一致性</li>\n</ul>\n</li>\n</ul>\n<h4 id=\"1-1-过期策略\"><a href=\"#1-1-过期策略\" class=\"headerlink\" title=\"1.1  过期策略\"></a>1.1  过期策略</h4><ul>\n<li><p>定时过期：时间一到立即清除，对内存友好，但会占用大量CPU资源</p>\n</li>\n<li><p>惰性过期：当访问时才去判断是否过期，节省CPU，占用内存</p>\n</li>\n<li><p>定期过期：每隔一段时间，随机清除</p>\n<p><strong>Redis中同时使用了惰性过期和定期过期两种过期策略。</strong> </p>\n</li>\n</ul>\n<h4 id=\"1-2-缓存淘汰-（eviction）\"><a href=\"#1-2-缓存淘汰-（eviction）\" class=\"headerlink\" title=\"1.2  缓存淘汰 （eviction）\"></a>1.2  缓存淘汰 （eviction）</h4><ul>\n<li>LRU（Least recently used，最近最少使用）<ul>\n<li>新数据插入到表头部</li>\n<li>缓存命中时，将其移到头部</li>\n<li>缓存满的时候将尾部的数据丢掉</li>\n</ul>\n</li>\n<li>LFU（Least Frequently Used 最近最少使用算法）<ul>\n<li>如果数据在一段时间内使用次数很少，那么将来也会很少</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"2-缓存模式\"><a href=\"#2-缓存模式\" class=\"headerlink\" title=\"2  缓存模式\"></a>2  缓存模式</h3><ul>\n<li><strong>先更新数据库，再删除缓存</strong> </li>\n</ul>\n<h4 id=\"2-1-缓存穿透\"><a href=\"#2-1-缓存穿透\" class=\"headerlink\" title=\"2.1  缓存穿透\"></a>2.1  缓存穿透</h4><ul>\n<li><p>频繁请求缓存中不存在的数据，增大数据库压力</p>\n<ul>\n<li>解决方案：<ol>\n<li>返回缓存伪造数据</li>\n<li>限制请求参数</li>\n<li>借助第三方过滤器：布隆过滤器…</li>\n</ol>\n</li>\n</ul>\n</li>\n<li><p>布隆过滤器</p>\n<p>本质上是一种*<em>概率型数据结构， 由一个很长的bit数组和一系列哈希函数组成的 *</em></p>\n<p>特点：<strong>高效地插入和查询</strong></p>\n<p>算法的核心： <strong>某样东西一定不存在或者可能存在</strong></p>\n<p>缺点：<strong>数据只能插入不能删除</strong></p>\n<ul>\n<li>存储原理：经过多次不同维度的hash计算，将数据映射到二进制向量里</li>\n<li>服务流程：<ol>\n<li>当用户访问时，去布隆过滤器中判断key值是否存在，否则直接返回</li>\n<li>如果key值存在，则访问redis，由于存在误判率，redis中也可能不存在</li>\n<li>再访问数据库，若也不存在，直接返回空</li>\n</ol>\n</li>\n</ul>\n</li>\n</ul>\n<p><img src=\"https://img-blog.csdnimg.cn/20190306043938625.?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0lUX3Rvd25sZXQ=,size_16,color_FFFFFF,t_70\" alt=\"\"></p>\n<h4 id=\"2-2-缓存雪崩\"><a href=\"#2-2-缓存雪崩\" class=\"headerlink\" title=\"2.2  缓存雪崩\"></a>2.2  缓存雪崩</h4><ul>\n<li>同一时间内，大量缓存失效，造成数据库压力剧增<ul>\n<li>解决方案：<ol>\n<li>设置不同的有效期值</li>\n<li>采用多级缓存</li>\n<li>利用加锁或者队列</li>\n</ol>\n</li>\n</ul>\n</li>\n</ul>\n<hr>\n<h1 id=\"（三）版本控制管理工具-Git\"><a href=\"#（三）版本控制管理工具-Git\" class=\"headerlink\" title=\"（三）版本控制管理工具 Git\"></a>（三）<a href=\"https://learngitbranching.js.org/\" target=\"_blank\" rel=\"noopener\">版本控制管理工具 Git</a></h1><h3 id=\"一、常用命令\"><a href=\"#一、常用命令\" class=\"headerlink\" title=\"一、常用命令\"></a>一、常用命令</h3><ul>\n<li>克隆远程库    <code>git clone 地址</code></li>\n<li>添加到暂存    <code>git add .</code></li>\n<li>提交暂存区的文件到本地仓库    <code>git commit -m &#39;test&#39;</code></li>\n<li>拉取    <code>git pull origin &lt;name&gt;</code></li>\n<li>推送    <code>git push origin &lt;name&gt;</code></li>\n<li>查看仓库当前的状态    <code>git status</code></li>\n<li>查看远程库信息    <code>git remote</code></li>\n<li>查看当前分支    <code>git branch</code> </li>\n<li>切换分支    <code>git checkout &lt;name&gt;</code></li>\n<li>合并分支到当前分支    <code>git merge &lt;name&gt;</code></li>\n</ul>\n<hr>\n<h1 id=\"（四）熟悉-Celery-异步方案，多线程、多进程的使用\"><a href=\"#（四）熟悉-Celery-异步方案，多线程、多进程的使用\" class=\"headerlink\" title=\"（四）熟悉 Celery 异步方案，多线程、多进程的使用\"></a>（四）熟悉 Celery 异步方案，多线程、多进程的使用</h1><p>celery是异步任务的调度工具，主要解决耗时任务，通过<strong>消息队列</strong>在客户端与消费者间协调</p>\n<ul>\n<li>消息中间件（消息队列Broker）：客户端把任务放入队列中，消费者从队列中取出任务执行，第三方队列服务：RabbitMQ\\redis\\kafka\\MetaMQ\\RocketMQ<ul>\n<li><strong>RabbitMQ：</strong>是一个消息代理。工作是接收和转发消息类似邮局，处理消息<ul>\n<li>异步消息：支持多种传递协议，消息排队，传递确认，到队列的灵活路由，多种交换类型</li>\n<li>分布式部署：部署为集群以实现高可用和吞吐量</li>\n<li>可靠性：可在性能和可靠性之间进行权衡</li>\n<li>灵活的路由：通过交换机进行路由</li>\n<li>多协议：多种消息协议的消息传递</li>\n<li>管理与监控：HTTP-API，命令行工具</li>\n</ul>\n</li>\n<li><strong>基本慨念：</strong><ul>\n<li>Producer：生产者，投递消息的程序：创建消息（消息体和标签），RabbitMQ会根据标签把消息发送给消费者</li>\n<li>Consumer：消费者，接收消息的程序：丢弃标签，消费消息体</li>\n<li>Broker：消息中间件的服务节点：RabbitMQ服务实例</li>\n<li>Queue：队列：内部对象，用于存储信息，生产者投递，消费者取出消费</li>\n<li>Xchange：交换器。指定消息按什么规则，路由到哪个队列，如果路由不到或返回或丢弃</li>\n<li>RoutingKey：路由键关键字，Xchange根据此来进行邮递，需要与交换器类型和绑定键联合使用，决定消息流向哪里</li>\n<li>Binding：绑定，把Xchange和Queue按照路由规则绑定起来，指定绑定键（BindingKey）</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>任务执行单元（消费者worker）：可以有多个并发，实时监控消息队列，获取任务并执行它</li>\n<li>任务执行结果存储（task result store）：由于是由主任务中解耦出来的，主任务想要知道执行结果，必须通过中间件存储</li>\n</ul>\n<h3 id=\"1-消息队列的理解\"><a href=\"#1-消息队列的理解\" class=\"headerlink\" title=\"1  消息队列的理解\"></a>1  消息队列的理解</h3><p><strong>消息队列</strong>：保存消息的容器</p>\n<p>消息:传输的数据单位</p>\n<p>消息源与目标间的中间人，主要目的是<strong>提供路由保证消息的传递</strong>，</p>\n<h3 id=\"2-为什么使用消息队列\"><a href=\"#2-为什么使用消息队列\" class=\"headerlink\" title=\"2  为什么使用消息队列\"></a>2  为什么使用消息队列</h3><p>在高并发情况下，来不及同步处理，请求会发生堵塞。通过消息队列，可以异步处理请求，缓解系统压力</p>\n<p>应用场景：</p>\n<ul>\n<li>异步处理、应用解耦、流量削锋和消息通讯等  </li>\n</ul>\n<p><strong>使用消息队列，把不是必须的业务逻辑，异步处理</strong></p>\n<p>消息队列的缺点：</p>\n<ul>\n<li>系统可用性降低</li>\n<li>系统复杂性提高</li>\n<li>一致性问题</li>\n</ul>\n<h3 id=\"3-多线程在web中的使用\"><a href=\"#3-多线程在web中的使用\" class=\"headerlink\" title=\"3  多线程在web中的使用\"></a>3  多线程在web中的使用</h3><p>一般在使用IO操作时</p>\n<p>使用场景：</p>\n<ul>\n<li>需要并行操作几个文件的读写，同步不能异步的情况下</li>\n<li>视图中需要多个第三方接口</li>\n<li>订单提交后，修改库存销量</li>\n</ul>\n<h3 id=\"4-为什么使用celery而不使用线程发送耗时任务\"><a href=\"#4-为什么使用celery而不使用线程发送耗时任务\" class=\"headerlink\" title=\"4  为什么使用celery而不使用线程发送耗时任务\"></a>4  为什么使用celery而不使用线程发送耗时任务</h3><p>因为并发量较大的时候，线程切换会有开销时间，也会降低并发的数量、共享数据维护麻烦</p>\n<p>celery是通过消息队列进行异步任务处理，不用担心并发量高是负载过大，也可以处理复杂系统性能问题，相对灵活</p>\n<h3 id=\"5-处理抢购高并发\"><a href=\"#5-处理抢购高并发\" class=\"headerlink\" title=\"5  处理抢购高并发\"></a>5  处理抢购高并发</h3><ol>\n<li>将请求尽量拦截在上游</li>\n<li>充分利用缓存</li>\n</ol>\n<p>前端方面：</p>\n<ul>\n<li>把详情页部署到CDN节点上，做页面静态化处理<ul>\n<li>CDN：内容分发网络，将源站内容分发到离用户最近的节点，提高访问速度</li>\n</ul>\n</li>\n<li>禁止重复提交请求、对用户请求限流</li>\n</ul>\n<p>后端方面：</p>\n<ul>\n<li>根据用户id限制访问频率</li>\n<li>缓存的应用</li>\n</ul>\n<h3 id=\"6-如何解决celery队列阻塞问题\"><a href=\"#6-如何解决celery队列阻塞问题\" class=\"headerlink\" title=\"6  如何解决celery队列阻塞问题\"></a>6  如何解决celery队列阻塞问题</h3><ul>\n<li><p>队列阻塞的原因：</p>\n<ol>\n<li>队列中有耗时任务，且任务量大于celery并发数（Celery没有足够的worker去执行耗时任务）</li>\n<li>队列中有耗时任务，且Celery启动了<strong>预取机制</strong><ul>\n<li>任务会有指定的worker去执行，就算其worker是空闲状态，也不会执行其它任务</li>\n</ul>\n</li>\n</ol>\n</li>\n<li><p>解决：</p>\n<ul>\n<li><p><strong>指定进程数</strong></p>\n<p><code>celery -A project worker --concurrency=4</code></p>\n</li>\n<li><p><strong>改变进程池方式为协程方式</strong></p>\n<p><code>pip install eventlet</code></p>\n<p><code>celery -A project worker -P eventlet -c 1000</code></p>\n</li>\n<li><p><strong>增加并发数</strong></p>\n</li>\n</ul>\n<p><code>celery -A project worker -n 进程名字 --concurrencu=并发数 -l info</code></p>\n<ul>\n<li><p><strong>取消预取机制</strong></p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 任务发送完成时是否需要确认，对性能会稍有影响</span></span><br><span class=\"line\">celery_app.conf.CELERY_LATE = <span class=\"literal\">True</span></span><br><span class=\"line\"><span class=\"comment\"># Celery worker每次去队列取任务的数量，默认值为4</span></span><br><span class=\"line\">celery_app.conf.CELERY_PREFETCH_MULTIPLIER = <span class=\"number\">1</span></span><br></pre></td></tr></table></figure>\n\n<p><code>celery -A project worker -n 进程名字 -Ofair -l info</code></p>\n</li>\n<li><p><strong>错误重试机制</strong></p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 重连时间间隔</span></span><br><span class=\"line\"><span class=\"meta\">@celery_app.task(bind=True, retry_backoff=3)</span></span><br><span class=\"line\"><span class=\"keyword\">try</span>:</span><br><span class=\"line\">    ...</span><br><span class=\"line\"><span class=\"keyword\">except</span> Exception <span class=\"keyword\">as</span> e:</span><br><span class=\"line\">    <span class=\"comment\"># 有异常自动重连三次</span></span><br><span class=\"line\">    <span class=\"keyword\">raise</span> self.retry(exc=e, max_retries=<span class=\"number\">3</span>)</span><br></pre></td></tr></table></figure>\n\n</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"7-进程和线程的对比\"><a href=\"#7-进程和线程的对比\" class=\"headerlink\" title=\"7  进程和线程的对比\"></a>7  <a href=\"https://handout-1300728887.cos.ap-beijing.myqcloud.com/%E8%AE%B2%E4%B9%89/python-web%E5%9F%BA%E7%A1%80(5.1.2%E7%89%88%E6%9C%AC)/multitasking/%E8%BF%9B%E7%A8%8B%E5%92%8C%E7%BA%BF%E7%A8%8B%E5%AF%B9%E6%AF%94.html\" target=\"_blank\" rel=\"noopener\">进程和线程的对比</a></h3><p>进程：CPU的一种执行单元</p>\n<ul>\n<li>密集CPU任务（大量并行计算）</li>\n</ul>\n<p>线程：进程执行程序的最小调度单位</p>\n<ul>\n<li>密集I/O任务</li>\n</ul>\n<p>协程：微线程，可以在单线程上执行多个任务，用函数切换，开销极小</p>\n<h4 id=\"关系对比\"><a href=\"#关系对比\" class=\"headerlink\" title=\"关系对比\"></a>关系对比</h4><ol>\n<li>线程是依附在进程里面的，没有进程就没有线程</li>\n<li>一个进程默认提供一条线程，进程可以创建多个线程</li>\n</ol>\n<h4 id=\"区别对比\"><a href=\"#区别对比\" class=\"headerlink\" title=\"区别对比\"></a>区别对比</h4><ol>\n<li>进程之间不共享全局变量</li>\n<li>线程之间共享全局变量，但是要注意资源竞争的问题，解决办法: 互斥锁或者线程同步</li>\n<li>创建进程的资源开销要比创建线程的资源开销要大</li>\n<li>进程是操作系统资源分配的基本单位，线程是CPU调度的基本单位</li>\n<li>线程不能够独立执行，必须依存在进程中</li>\n<li>多进程开发比单进程多线程开发稳定性要强</li>\n</ol>\n<h4 id=\"优缺点\"><a href=\"#优缺点\" class=\"headerlink\" title=\"优缺点\"></a>优缺点</h4><ul>\n<li>进程优缺点:<ul>\n<li>优点：可以用多核</li>\n<li>缺点：资源开销大</li>\n</ul>\n</li>\n<li>线程优缺点:<ul>\n<li>优点：资源开销小</li>\n<li>缺点：不能使用多核做到高并行</li>\n</ul>\n</li>\n</ul>\n<hr>\n<h1 id=\"（五）熟悉-TCP-HTTP-协议等网络知识\"><a href=\"#（五）熟悉-TCP-HTTP-协议等网络知识\" class=\"headerlink\" title=\"（五）熟悉 TCP/HTTP 协议等网络知识\"></a>（五）熟悉 TCP/<a href=\"https://handout-1300728887.cos.ap-beijing.myqcloud.com/%E8%AE%B2%E4%B9%89/python-web%E5%9F%BA%E7%A1%80(5.1.2%E7%89%88%E6%9C%AC)/http/HTTP%E5%8D%8F%E8%AE%AE.html\" target=\"_blank\" rel=\"noopener\">HTTP</a> 协议等网络知识</h1><p>TDP：用户数据报协议，无连接的</p>\n<p><strong>TCP：传输控制协议，面向连接的、可靠的、基于字节流的传输层通信协议</strong></p>\n<p>HTTP：超文本传输协议，浏览器和web服务器通信需要HTTP协议 </p>\n<p>RPC：远程过程调用，向另一台计算机上的程序请求服务，不需要了解底层网络技术的协议。</p>\n<h2 id=\"一、网络协议分层\"><a href=\"#一、网络协议分层\" class=\"headerlink\" title=\"一、网络协议分层\"></a>一、<a href=\"https://www.jianshu.com/p/30fb2b0bcfd8\" target=\"_blank\" rel=\"noopener\">网络协议分层</a></h2><p><img src=\"https://tupian-1300728887.cos.ap-chengdu.myqcloud.com/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE%E5%88%86%E5%B1%82.png\" alt=\"\"></p>\n<h3 id=\"1-乐观锁\"><a href=\"#1-乐观锁\" class=\"headerlink\" title=\"1  乐观锁\"></a>1  乐观锁</h3><p>每次拿数据的时候都认为别人不会修改，所以不会上锁</p>\n<p>在更新的时候判断此时的库存是否是之前查询出的库存，如果相同，表示没人修改，可以更新库存，否则表示别人抢过资源，不再执行库存更新</p>\n<p><strong>实现方式：</strong>利用时间戳、数据版本version字段，数据被修改＋1</p>\n<p>使用场景：高并发，减少数据冲突，保证数据一致性</p>\n<h3 id=\"2-高并发，分布式\"><a href=\"#2-高并发，分布式\" class=\"headerlink\" title=\"2  高并发，分布式\"></a>2  高并发，分布式</h3><p>处理网站并发量</p>\n<ol>\n<li>减少数据库访问次数</li>\n<li>文件和数据库分离（静态化页面）</li>\n<li>大数据分布式存储（主从配置读写分离）</li>\n<li>服务器集群，负载均衡</li>\n<li>页面缓存的使用</li>\n<li>内存数据库代替关系型数据库</li>\n</ol>\n<p>例子：省市区三级联动、首页部分数据（广告）局部缓存</p>\n<p>分布式案例</p>\n<ol>\n<li>MySQL主从配置读写分离</li>\n</ol>\n<h3 id=\"3-长连接与短连接\"><a href=\"#3-长连接与短连接\" class=\"headerlink\" title=\"3  长连接与短连接\"></a>3  长连接与短连接</h3><p>长连接：连接 -&gt; 传输数据 -&gt; 保持连接 -&gt; 传输数据 -&gt; 直到一方断开</p>\n<ul>\n<li>操作频繁、点对点的通讯、数据库连接<ul>\n<li>TCP三握手时间</li>\n<li>不安全</li>\n</ul>\n</li>\n</ul>\n<p>短连接：连接 -&gt; 传输数据-&gt; 断开连接</p>\n<ul>\n<li>http服务</li>\n</ul>\n<h3 id=\"4-token和jwt存在什么区别\"><a href=\"#4-token和jwt存在什么区别\" class=\"headerlink\" title=\"4  token和jwt存在什么区别\"></a>4  token和jwt存在什么区别</h3><p>token需要查库验证，JWT直接在服务端进行，不需要查库</p>\n<h3 id=\"5-三次握手和四次挥手\"><a href=\"#5-三次握手和四次挥手\" class=\"headerlink\" title=\"5  三次握手和四次挥手\"></a>5  <a href=\"https://blog.csdn.net/qq_38950316/article/details/81087809\" target=\"_blank\" rel=\"noopener\">三次握手和四次挥手</a></h3><p>三次挥手：</p>\n<ol>\n<li>建立连接时，客户端发送syn包（seq=x）到服务器，并进入SYN_SENT（发送）状态，等待服务器确认；</li>\n<li>服务器收到syn包，必须确认客户的SYN（ack=x+1），同时自己也发送一个SYN包（seq=y），即SYN+ACK包，此时服务器进入SYN_RECV（收到）状态；</li>\n<li>客户端收到服务器的SYN+ACK包，向服务器发送确认包ACK(ack=y+1），此包发送完毕，客户端和服务器进入ESTABLISHED（TCP连接成功）状态，完成三次握手。</li>\n</ol>\n<p>四次挥手：</p>\n<h3 id=\"6-CSRF攻击\"><a href=\"#6-CSRF攻击\" class=\"headerlink\" title=\"6  CSRF攻击\"></a>6  <a href=\"https://handout-1300728887.cos.ap-beijing.myqcloud.com/%E8%AE%B2%E4%B9%89/Django%E6%A1%86%E6%9E%B6/Django%E6%A1%86%E6%9E%B6/C05-Template/csrf.html\" target=\"_blank\" rel=\"noopener\">CSRF攻击</a></h3><ol>\n<li>浏览并登录信任网站A</li>\n<li>验证通过，产生A的Cookie</li>\n<li>再没登出的情况下，浏览<strong>攻击网站B</strong></li>\n<li>B要求访问第三方网站A</li>\n<li>根据B的请求，浏览器带着A的Cookie访问A</li>\n<li>A不知道请求源，因为浏览器会自动携带用户的Cookie，按需处理请求，达到模拟用户操作csrf攻击</li>\n</ol>\n<p><strong>防止csrf攻击</strong></p>\n<ol>\n<li>在后端响应的cookie写入csrf_token值</li>\n<li>前端from表单中也写入csrf_token值</li>\n<li>获取两个csrf_token，看是否一致</li>\n</ol>\n<p>Django自带的防csrf中间间</p>\n<p><strong>跨站请求伪造</strong>：攻击者盗用你的身份，发送恶意请求</p>\n<h3 id=\"7-RESTFul思想\"><a href=\"#7-RESTFul思想\" class=\"headerlink\" title=\"7  RESTFul思想\"></a>7  RESTFul思想</h3><ul>\n<li><p>每一个URI代表1种资源；</p>\n</li>\n<li><p>客户端使用GET、POST、PUT、DELETE4个表示操作方式的动词对服务端资源进行操作：GET用来获取资源，POST用来新建资源（也可以用于更新资源），PUT用来更新资源，DELETE用来删除资源；</p>\n</li>\n<li><p>通过操作资源的表现形式来操作资源；</p>\n</li>\n<li><p>资源的表现形式是XML或者HTML；</p>\n</li>\n<li><p>客户端与服务端之间的交互在请求之间是无状态的，从客户端到服务端的每个请求都必须包含理解请求所必需的信息。</p>\n</li>\n</ul>\n<hr>\n<h1 id=\"（六）使用腾讯云存储方案\"><a href=\"#（六）使用腾讯云存储方案\" class=\"headerlink\" title=\"（六）使用腾讯云存储方案\"></a>（六）<a href=\"https://cloud.tencent.com/document/product/436\" target=\"_blank\" rel=\"noopener\">使用腾讯云存储方案</a></h1><p>腾讯对象存储服务（COS）通过网络随时存储和调用各种数据文件</p>\n<ol>\n<li>创建一个或多个存储同，上传文件</li>\n<li>根据地址可上传和下载</li>\n<li>可设置相应属性及访问权限</li>\n<li>下载SDK包，执行相应操作</li>\n</ol>\n<h1 id=\"（七）熟悉-Linux-系统，了解-Docker、Elasticsearch\"><a href=\"#（七）熟悉-Linux-系统，了解-Docker、Elasticsearch\" class=\"headerlink\" title=\"（七）熟悉 Linux 系统，了解 Docker、Elasticsearch\"></a>（七）<a href=\"https://handout-1300728887.cos.ap-beijing.myqcloud.com/%E8%AE%B2%E4%B9%89/%E7%AC%94%E8%AE%B0/Linux%E5%9F%BA%E7%A1%80%E5%91%BD%E4%BB%A4.html\" target=\"_blank\" rel=\"noopener\">熟悉 Linux 系统</a>，了解 Docker、Elasticsearch</h1><h3 id=\"1-Docker\"><a href=\"#1-Docker\" class=\"headerlink\" title=\"1  Docker\"></a>1  <a href=\"http://www.docker.org.cn/index.html\" target=\"_blank\" rel=\"noopener\">Docker</a></h3><p><strong>开源的软件部署解决方案、轻量级的应用容器框架，采用C/S架构，其可以轻松的为任何应用创建一个轻量级的、可移植的、自给自足的容器。</strong></p>\n<blockquote>\n<p>是一种快速解决生产问题的一种技术手段。</p>\n</blockquote>\n<p>优缺点：</p>\n<ul>\n<li>优：<ul>\n<li>多： 适用场景多</li>\n<li>快： 环境部署快、更新快</li>\n<li>好： 好多人在用，东西好</li>\n<li>省： 省钱省力省人工(123原则)</li>\n</ul>\n</li>\n<li>缺：<ul>\n<li>太腻歪人： 依赖操作系统</li>\n<li>不善于沟通：依赖网络</li>\n<li>不善理财： 银行U盾等场景不能用</li>\n</ul>\n</li>\n</ul>\n<p><strong>镜像</strong></p>\n<ul>\n<li>类似虚拟机的镜像，可以创建新的容器</li>\n</ul>\n<figure class=\"highlight dockerfile\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 镜像</span></span><br><span class=\"line\">docker search [image_name]\t\t\t<span class=\"comment\"># 搜索镜像</span></span><br><span class=\"line\">docker pull [image_name]\t\t\t<span class=\"comment\"># 获取镜像</span></span><br><span class=\"line\">docker images\t\t\t\t\t\t<span class=\"comment\"># 查看镜像</span></span><br><span class=\"line\">docker history [image_name]\t\t\t<span class=\"comment\"># 查看镜像历史</span></span><br><span class=\"line\">docker tag [old_image]:[old_version]\t<span class=\"comment\"># 重命名</span></span><br><span class=\"line\">docker rm [image_name]\t\t\t\t<span class=\"comment\"># 删除</span></span><br><span class=\"line\">docker save -o [包文件] [镜像]\t\t<span class=\"comment\"># 导出镜像</span></span><br><span class=\"line\">docker load -i [image.tar_name]\t\t<span class=\"comment\"># 导入镜像</span></span><br></pre></td></tr></table></figure>\n\n<p><strong>容器</strong></p>\n<ul>\n<li>由镜像创建的运行实例，类似虚拟机</li>\n</ul>\n<figure class=\"highlight dockerfile\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 容器</span></span><br><span class=\"line\">docker ps\t\t\t\t\t\t\t\t<span class=\"comment\"># 查看容器</span></span><br><span class=\"line\">docker start [container_id]\t\t\t\t<span class=\"comment\"># 启动已终止的容器</span></span><br><span class=\"line\">docker stop [container_id]\t\t\t\t<span class=\"comment\"># 关闭</span></span><br><span class=\"line\">docker rm [container_id]\t\t\t\t<span class=\"comment\"># 删除</span></span><br><span class=\"line\">\t\t-f\t\t<span class=\"comment\"># 强制删除</span></span><br><span class=\"line\">docker <span class=\"keyword\">run</span><span class=\"bash\"> [docker_image] /bin/bash</span></span><br><span class=\"line\">\t\t--name\t<span class=\"comment\"># 给容器定义一个名称</span></span><br><span class=\"line\">\t\t-i \t\t<span class=\"comment\"># 让容器的标准输入保持打开。</span></span><br><span class=\"line\">\t\t-t\t\t<span class=\"comment\"># 分配一个伪终端,并绑定到容器的标准输入上</span></span><br><span class=\"line\">\t\t-d \t\t<span class=\"comment\"># 守护进程开启</span></span><br><span class=\"line\">\t\t-v\t\t<span class=\"comment\"># 本地:容器 --映射</span></span><br><span class=\"line\">\t\t-p  \t<span class=\"comment\"># 端口映射</span></span><br><span class=\"line\">docker exec -it 容器id /bin/bash\t\t\t<span class=\"comment\"># 进入后台运行容器</span></span><br><span class=\"line\">docker commit [container_id] [new_image:tag]\t<span class=\"comment\"># 基于容器创建镜像</span></span><br><span class=\"line\">\t\t-m \t\t<span class=\"comment\"># '改动信息' </span></span><br><span class=\"line\">\t\t-a \t\t<span class=\"comment\"># \"作者信息\"</span></span><br><span class=\"line\">docker logs [容器id]\t\t\t\t\t<span class=\"comment\"># 查看运行日志</span></span><br><span class=\"line\">docker inspect  [容器id]\t\t\t\t<span class=\"comment\"># 查看详细信息</span></span><br></pre></td></tr></table></figure>\n\n<p><strong>仓库（公有、私有、本地）</strong></p>\n<ul>\n<li>托管镜像</li>\n</ul>\n<h4 id=\"1-1-dockerflie\"><a href=\"#1-1-dockerflie\" class=\"headerlink\" title=\"1.1 dockerflie\"></a>1.1 dockerflie</h4><p> Dockerfile类似于我们学习过的脚本，将我们在上面学到的镜像，使用自动化的方式实现出来。</p>\n<figure class=\"highlight dockerfile\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 基础指令</span></span><br><span class=\"line\"><span class=\"keyword\">FROM</span> &lt;image&gt;\t\t\t\t\t<span class=\"comment\"># 第一条指令（除首行注释外）</span></span><br><span class=\"line\"><span class=\"keyword\">MAINTAINER</span> &lt;name&gt;\t\t\t\t<span class=\"comment\"># 作者信息</span></span><br><span class=\"line\"><span class=\"keyword\">RUN</span><span class=\"bash\"> &lt;<span class=\"built_in\">command</span>&gt;\t\t\t\t\t<span class=\"comment\"># 镜像构建时候运行的命令</span></span></span><br><span class=\"line\"><span class=\"keyword\">EXPOSE</span> &lt;port&gt;\t\t\t\t\t<span class=\"comment\"># 对外开发端口</span></span><br><span class=\"line\"><span class=\"keyword\">ENTRYPOINT</span><span class=\"bash\"> python3 manage.py runserver 0.0.0.0:8000</span></span><br><span class=\"line\">\t\t\t\t\t\t\t\t<span class=\"comment\"># 运行Django项目，只能有一个</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 文件编辑指令</span></span><br><span class=\"line\"><span class=\"keyword\">ADD</span><span class=\"bash\"> &lt;src&gt;... &lt;dest&gt;\t\t<span class=\"comment\"># 将指定的 &lt;src&gt; 文件复制到容器文件系统中的 &lt;dest&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">COPY</span><span class=\"bash\"> &lt;src&gt;... &lt;dest&gt;\t\t\t<span class=\"comment\"># 复制文件</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 环境指令</span></span><br><span class=\"line\"><span class=\"keyword\">ENV</span> &lt;key&gt; &lt;value&gt;\t\t\t\t<span class=\"comment\"># 设置环境变量</span></span><br><span class=\"line\"><span class=\"keyword\">WORKDIR</span><span class=\"bash\"> /path/to/workdir\t\t<span class=\"comment\"># 切换目录</span></span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"2-es的存储底层原理\"><a href=\"#2-es的存储底层原理\" class=\"headerlink\" title=\"2  es的存储底层原理\"></a>2  es的存储底层原理</h3><p><strong>集群：</strong>es可以作为独立的单个搜索引擎，为了处理大型数据集，实现容错和高可用性，es可以运行在许多合作的服务器上，这些服务器的集合称为集群</p>\n<p><strong>节点：</strong>形成集群的每个服务器</p>\n<p><strong>分片：</strong>数据可以分为较小的分片，放到不同的服务器上，分布式处理。而应用程序并不知道分片的存在</p>\n<p><strong>副本：</strong>复制集原理，其中之一被选择更改索引操作（主分片），主废副升，不能在同一个节点上</p>\n<p><strong>es扩容：</strong></p>\n<ul>\n<li>垂直：采购更强大的服务器</li>\n<li>水平：采购更多的不同服务器</li>\n</ul>\n<h3 id=\"3-使用-Haystack-调用-Elasticsearch\"><a href=\"#3-使用-Haystack-调用-Elasticsearch\" class=\"headerlink\" title=\"3  使用 Haystack 调用 Elasticsearch\"></a>3  <a href=\"https://handout-1300728887.cos.ap-beijing.myqcloud.com/%E8%AE%B2%E4%B9%89/%E7%BE%8E%E5%A4%9A%E5%95%86%E5%9F%8E%E8%AE%B2%E4%B9%89/goods/goods-search/haystack-create-index.html\" target=\"_blank\" rel=\"noopener\">使用 Haystack 调用 Elasticsearch</a></h3><p><strong>Elasticsearch是基于Lucene库实时的分布式搜索分析引擎，全文检索、结构化搜索、分析这三功能的组合</strong></p>\n<p><strong>全文检索引擎：对数据库里的数据先进行一遍预处理，从而生成索引结构数据（类似于字典那样的结构数据），再使用关键字在索引数据中检索数据</strong></p>\n<p>属于面向文档的数据库</p>\n<p>Elasticsearch是远端服务器开启的服务</p>\n<p>需要用Haystack调用搜索引擎</p>\n<ol>\n<li><p>安装：</p>\n<p><code>pip install django-haystack</code></p>\n<p><code>pip install elasticsearch==2.4.1</code></p>\n</li>\n<li><p>注册到应用</p>\n</li>\n</ol>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">INSTALLED_APPS = [</span><br><span class=\"line\">    <span class=\"string\">'haystack'</span>, <span class=\"comment\"># 全文检索</span></span><br><span class=\"line\">]</span><br><span class=\"line\">url(<span class=\"string\">r'^search/'</span>, include(<span class=\"string\">'haystack.urls'</span>)),</span><br></pre></td></tr></table></figure>\n\n<ol start=\"3\">\n<li>配置</li>\n</ol>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># Haystack</span></span><br><span class=\"line\">HAYSTACK_CONNECTIONS = &#123;</span><br><span class=\"line\">    <span class=\"string\">'default'</span>: &#123;</span><br><span class=\"line\">        <span class=\"string\">'ENGINE'</span>: <span class=\"string\">'haystack.backends.elasticsearch_backend.ElasticsearchSearchEngine'</span>,</span><br><span class=\"line\">        <span class=\"string\">'URL'</span>: <span class=\"string\">'http://192.168.103.158:9200/'</span>, <span class=\"comment\"># Elasticsearch服务器ip地址，端口号固定为9200</span></span><br><span class=\"line\">        <span class=\"string\">'INDEX_NAME'</span>: <span class=\"string\">'meiduo_mall'</span>, <span class=\"comment\"># Elasticsearch建立的索引库的名称</span></span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 当添加、修改、删除数据时，自动生成索引</span></span><br><span class=\"line\">HAYSTACK_SIGNAL_PROCESSOR = <span class=\"string\">'haystack.signals.RealtimeSignalProcessor'</span></span><br></pre></td></tr></table></figure>\n\n<ol start=\"4\">\n<li><p>创建索引类：search_indexes.py</p>\n</li>\n<li><p>创建txt字段索引值模板文件</p>\n</li>\n<li><p>手动生成索引（仅第一次）</p>\n<p><code>python manage.py rebuild_index</code></p>\n</li>\n</ol>\n<ul>\n<li><p>常见问题：</p>\n<ol>\n<li><p>如何实现分页功能</p>\n<ul>\n<li>HAYSTACK_SEARCH_RESULTS_PER_PAGE = 5</li>\n</ul>\n</li>\n<li><p>No module named haystack</p>\n<ul>\n<li>是否安装/注册了haystack模板</li>\n</ul>\n</li>\n<li><p>在html页面出现No serults found</p>\n<ul>\n<li>是否创建了search_indexes.py文件</li>\n<li>数据库中是否有数据</li>\n</ul>\n</li>\n</ol>\n</li>\n</ul>\n<h3 id=\"3-es是怎么跟数据库关联起来的\"><a href=\"#3-es是怎么跟数据库关联起来的\" class=\"headerlink\" title=\"3  es是怎么跟数据库关联起来的\"></a>3  es是怎么跟数据库关联起来的</h3><p>Logstash是一个开源数据收集引擎，具有实时管道功能。可以动态得将来自不同数据源的数据统一起来，并将数据标准化到你所选择的目的地</p>\n<h3 id=\"4-es倒排索引和常用API\"><a href=\"#4-es倒排索引和常用API\" class=\"headerlink\" title=\"4  es倒排索引和常用API\"></a>4  es倒排索引和常用API</h3><p>倒排索引：也称反向索引，根据单词查找文档</p>\n<p>正向索引：存储每个文档单词的列表</p>\n<ul>\n<li>es常用的api<ul>\n<li><a href=\"https://handout-1300728887.cos.ap-beijing.myqcloud.com/%E8%AE%B2%E4%B9%89/%E9%BB%91%E9%A9%AC%E5%A4%B4%E6%9D%A1%E9%A1%B9%E7%9B%AE%E8%AF%BE%E4%BB%B6/C10-Elasticsearch/Query.html\" target=\"_blank\" rel=\"noopener\">查询</a></li>\n</ul>\n</li>\n</ul>\n<h1 id=\"（八）首页静态化、定时任务\"><a href=\"#（八）首页静态化、定时任务\" class=\"headerlink\" title=\"（八）首页静态化、定时任务\"></a>（八）首页静态化、定时任务</h1><p><strong>静态化与缓存的主要区别</strong></p>\n<ul>\n<li><p>静态化：将数据静态化到页面，客户端访问时不查询数据库，存储与硬盘</p>\n</li>\n<li><p>缓存：将数据存储于服务器内存</p>\n</li>\n</ul>\n<p><strong>定时任务的原理</strong></p>\n<ul>\n<li><p>由<strong>crond守护进程</strong>和<strong>crontab文件（任务表）</strong>组成</p>\n</li>\n<li><p>守护进程在系统启动时由init进程启动，受init监视，如果它挂了，init会重启它守护进程每分钟唤醒一次，通过检查crontab文件判断需要做什么</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 添加定时任务到系统中</span></span><br><span class=\"line\">$ python manage.py crontab add</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 显示已激活的定时任务</span></span><br><span class=\"line\">$ python manage.py crontab show</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 移除定时任务</span></span><br><span class=\"line\">$ python manage.py crontab remove</span><br></pre></td></tr></table></figure>\n\n</li>\n</ul>\n<p><strong>支付宝接入：</strong> </p>\n<ul>\n<li>Python支付宝SDK：<a href=\"https://github.com/fzlee/alipay/blob/master/README.zh-hans.md\" target=\"_blank\" rel=\"noopener\">https://github.com/fzlee/alipay/blob/master/README.zh-hans.md</a> </li>\n</ul>\n<h1 id=\"（九）部署相关\"><a href=\"#（九）部署相关\" class=\"headerlink\" title=\"（九）部署相关\"></a>（九）部署相关</h1><h2 id=\"1-nginx\"><a href=\"#1-nginx\" class=\"headerlink\" title=\"1  nginx\"></a>1  <a href=\"https://handout-1300728887.cos.ap-beijing.myqcloud.com/%E8%AE%B2%E4%B9%89/%E9%A1%B9%E7%9B%AE%E9%83%A8%E7%BD%B2/nginx/Advanced.html\" target=\"_blank\" rel=\"noopener\">nginx</a></h2><p><strong>是一个高性能的HTTP和反向代理服务器，主要处理静态资源</strong></p>\n<h3 id=\"1-1-反向代理\"><a href=\"#1-1-反向代理\" class=\"headerlink\" title=\"1.1  反向代理\"></a>1.1  <a href=\"https://handout-1300728887.cos.ap-beijing.myqcloud.com/%E8%AE%B2%E4%B9%89/%E9%A1%B9%E7%9B%AE%E9%83%A8%E7%BD%B2/nginx/nginx-reverse.html\" target=\"_blank\" rel=\"noopener\">反向代理</a></h3><p>正向代理： 为局域网<strong>客户端</strong>向外访问Internet服务<strong>（代理用户，隐藏客户端）</strong></p>\n<p>反向代理： 为局域网<strong>服务器</strong>向外提供Internet服务<strong>（代理服务器，隐藏服务器）</strong></p>\n<h3 id=\"1-2-负载均衡\"><a href=\"#1-2-负载均衡\" class=\"headerlink\" title=\"1.2  负载均衡\"></a>1.2  <a href=\"https://handout-1300728887.cos.ap-beijing.myqcloud.com/%E8%AE%B2%E4%B9%89/%E9%A1%B9%E7%9B%AE%E9%83%A8%E7%BD%B2/nginx/nginx-load.html\" target=\"_blank\" rel=\"noopener\">负载均衡</a></h3><p>有一台服务器充当调度者的身份（负载均衡器），请求先到达它，再根据每台服务器的负载情况分配请求</p>\n<ol>\n<li>内置策略：nginx自带算法<ul>\n<li>雨露均沾型：轮训（默认）、加权轮训、哈希<ul>\n<li>轮训：按顺序逐一分配</li>\n<li>加权轮训：权重越大，被分配几率越高，适用于服务器性能不均衡情况</li>\n</ul>\n</li>\n<li>定向服务型：ip_hash、least_conn、cookie、route、lean<ul>\n<li>ip_hash：按访问IP的哈希结果分配请求，分配后访客访问固定后端服务器，有效的解决动态网页会话共享问题。</li>\n</ul>\n</li>\n<li>商业类型：ntlm、least_time、queue、stick</li>\n</ul>\n</li>\n<li>第三方算法：fair、url_hash<ul>\n<li>fair：基于后端服务器的响应时间来分配请求，响应时间短的优先分配。</li>\n<li>url_hash：按访问的哈希结果分配请求，使同定向到同一台后端服务器，可提高后端缓存服务器的效率。</li>\n</ul>\n</li>\n</ol>\n<h3 id=\"1-3-提供静态文件\"><a href=\"#1-3-提供静态文件\" class=\"headerlink\" title=\"1.3  提供静态文件\"></a>1.3  提供静态文件</h3><p>静态文件收集命令：<code>python mange.py collectstatic</code></p>\n<h3 id=\"1-4-WSGI\"><a href=\"#1-4-WSGI\" class=\"headerlink\" title=\"1.4  WSGI\"></a>1.4  WSGI</h3><ul>\n<li>WSGI是一种通信协议， Web 服务器(uWSGI)与 Web 应用程序或应用框架(Django)之间的一种低级别的接口</li>\n<li>uwsgi是一种线路协议我不是一种通信协议，常用于在uWSGI服务器于其他网络服务器的数据通信</li>\n<li>uWSGI是实现了uwsgi和WSGI两种协议的Web服务器，<strong>主要处理动态资源</strong></li>\n</ul>\n<h2 id=\"2-gunicorn\"><a href=\"#2-gunicorn\" class=\"headerlink\" title=\"2  gunicorn\"></a>2  <a href=\"https://handout-1300728887.cos.ap-beijing.myqcloud.com/%E8%AE%B2%E4%B9%89/%E9%BB%91%E9%A9%AC%E5%A4%B4%E6%9D%A1%E9%A1%B9%E7%9B%AE%E8%AF%BE%E4%BB%B6/C12-Deployment/Gunicorn.html\" target=\"_blank\" rel=\"noopener\">gunicorn</a></h2><p>安装：<code>pip install gunicorn</code></p>\n<p>查看使用信息：<code>$gunicorn -h</code></p>\n<p>直接运行：<code>gunicorn 运行文件名称：flask程序实例名</code></p>\n<p>指定进程和端口号：<code>$gunicorn -w 4 -b 127.0.0.1:5001 运行文件名称:Flask程序实例名</code></p>\n<h1 id=\"支付流程\"><a href=\"#支付流程\" class=\"headerlink\" title=\"支付流程\"></a>支付流程</h1><p><img src=\"https://tupian-1300728887.cos.ap-chengdu.myqcloud.com/%E5%85%AC%E7%A7%81%E9%92%A5.png\" alt=\"\"></p>\n<ul>\n<li>生成密钥</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">openssl\t\t<span class=\"comment\"># 进入环境</span></span><br><span class=\"line\">genrsa -out app_private_key.pem 2048\t<span class=\"comment\"># 私钥</span></span><br><span class=\"line\">rsa -<span class=\"keyword\">in</span> app_private_key.pem -pubout -out app_pubout_key.pem\t\t<span class=\"comment\"># 公钥</span></span><br></pre></td></tr></table></figure>\n\n<h1 id=\"极睿科技总结\"><a href=\"#极睿科技总结\" class=\"headerlink\" title=\"极睿科技总结\"></a>极睿科技总结</h1><h2 id=\"一、装饰器\"><a href=\"#一、装饰器\" class=\"headerlink\" title=\"一、装饰器\"></a>一、装饰器</h2><p>作用：在不改变已有函数源代码及调用方式的前提下，对已有函数进行功能的扩展</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 不改变原有函数__name__\\备注信息</span></span><br><span class=\"line\"><span class=\"keyword\">from</span> functools <span class=\"keyword\">import</span> wraps</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">check</span><span class=\"params\">(fu)</span>:</span>  <span class=\"comment\"># fu:目标函数</span></span><br><span class=\"line\">    </span><br><span class=\"line\"><span class=\"meta\">    @wraps(fu)</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">inner</span><span class=\"params\">()</span>:</span></span><br><span class=\"line\">        <span class=\"string\">'''执行函数之前'''</span></span><br><span class=\"line\">        fu()</span><br><span class=\"line\">        <span class=\"string\">'''执行函数之后'''</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> inner</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 语法糖写法</span></span><br><span class=\"line\"><span class=\"meta\">@check</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">comment</span><span class=\"params\">()</span>:</span></span><br><span class=\"line\">    print(<span class=\"string\">'发表评论'</span>)</span><br><span class=\"line\">    </span><br><span class=\"line\">comment()</span><br><span class=\"line\"><span class=\"comment\"># check等价与  comment = check(comment)</span></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"二、数据结构与算法\"><a href=\"#二、数据结构与算法\" class=\"headerlink\" title=\"二、数据结构与算法\"></a>二、数据结构与算法</h2><p>数据：能够被计算机处理的符号或符号集</p>\n<p>数据元素（节点、记录）：数据的基本单位。例：学生统计表</p>\n<p>数据项（字段、域）：组成数据元素的最小单位。例：编号、姓名、性别等</p>\n<h3 id=\"1-数据结构\"><a href=\"#1-数据结构\" class=\"headerlink\" title=\"1  数据结构\"></a>1  数据结构</h3><p><strong>相互之间存在的一种或多种特定的数据元素的集合用于计算机存储、组织数据的方式</strong></p>\n<p><img src=\"https://img2018.cnblogs.com/blog/1672612/201906/1672612-20190607153718002-1151308139.jpg\" alt=\"\"></p>\n<h4 id=\"1-1-逻辑结构\"><a href=\"#1-1-逻辑结构\" class=\"headerlink\" title=\"1.1  逻辑结构\"></a>1.1  逻辑结构</h4><p><strong>数据元素间的抽象关系（如近邻关系、从属关系等），分为线性结构与非线性结构，</strong>抽象出来的，与机器无关</p>\n<p><img src=\"https://img2018.cnblogs.com/blog/1672612/201906/1672612-20190607154347579-543280178.png\" alt=\"\"></p>\n<table>\n<thead>\n<tr>\n<th align=\"center\">结构类型</th>\n<th align=\"center\">数据元素间的相互关系</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\">集合</td>\n<td align=\"center\">无</td>\n</tr>\n<tr>\n<td align=\"center\">线性</td>\n<td align=\"center\">一对一</td>\n</tr>\n<tr>\n<td align=\"center\">树形</td>\n<td align=\"center\">一对多</td>\n</tr>\n<tr>\n<td align=\"center\">图</td>\n<td align=\"center\">多对多</td>\n</tr>\n</tbody></table>\n<h4 id=\"1-2-（存储）物理结构\"><a href=\"#1-2-（存储）物理结构\" class=\"headerlink\" title=\"1.2  （存储）物理结构\"></a>1.2  （存储）物理结构</h4><p><strong>数据在计算机中的存放方式，反应数据元素间的逻辑关系</strong></p>\n<ul>\n<li>顺序存储（向量存储）：把数据元素存放在一组存储地址连续的存储单元里，逻辑关系和物理关系是一致的</li>\n<li>链式存储（动态存储）：通过指针反应数据间的逻辑关系</li>\n<li>索引存储：建立一个附加的索引表</li>\n<li>散列存储：根据节点的关键字直接计算出该节点的存储地址</li>\n</ul>\n<blockquote>\n<p>同一逻辑结构可以对应不同的存储结构，算法的设计取决于数据的逻辑结构，而算法实现依赖于指定的存储结构</p>\n</blockquote>\n<h3 id=\"2-算法\"><a href=\"#2-算法\" class=\"headerlink\" title=\"2  算法\"></a>2  算法</h3><p><strong>解决特定问题的一种方法或一种描述</strong></p>\n<h4 id=\"2-1-数据结构和算法的联系\"><a href=\"#2-1-数据结构和算法的联系\" class=\"headerlink\" title=\"2.1  数据结构和算法的联系\"></a>2.1  数据结构和算法的联系</h4><p>程序=算法+数据结构</p>\n<ul>\n<li>算法设计: 取决于选定的逻辑结构</li>\n<li>算法实现: 依赖于采用的存储结构</li>\n</ul>\n<p>区别：</p>\n<ul>\n<li>数据结构关注的是<strong>数据的逻辑结构、存储结构的基本操作</strong></li>\n<li>算法关注的是<strong>在数据结构的基础上解决实际问题</strong></li>\n</ul>\n<p>算法的五大特性：</p>\n<ol>\n<li>可行性：解决具体问题，完成期望功能</li>\n<li>确定性：每一步在一定条件下只有一条执行路径</li>\n<li>有穷性： 算法执行的步骤（或规则）是有限的</li>\n<li>输入：具有零或多个输入</li>\n<li>输出：至少有一个或多个输出</li>\n</ol>\n<p>评价算法好坏的方法：</p>\n<ul>\n<li>正确性：运行正确是一个算法的前提。</li>\n<li>可读性：容易理解、容易编程和调试、容易维护。</li>\n<li>健壮性：考虑情况全面，不容以出现运行错误。</li>\n<li>时间效率高：算法消耗的时间少。</li>\n<li>储存量低：占用较少的存储空间。</li>\n</ul>\n<h4 id=\"2-2-时间复杂度O-n\"><a href=\"#2-2-时间复杂度O-n\" class=\"headerlink\" title=\"2.2  时间复杂度O(n)\"></a>2.2  时间复杂度O(n)</h4><p>计算规则</p>\n<ol>\n<li>基本操作，只有<strong>常数项O(1)</strong></li>\n<li>顺序结构，按<strong>加法计算</strong></li>\n<li>循环结构，按<strong>乘法计算</strong></li>\n<li>分支结构，<strong>取最大值</strong></li>\n</ol>\n<h4 id=\"2-3-空间复杂度S-n\"><a href=\"#2-3-空间复杂度S-n\" class=\"headerlink\" title=\"2.3  空间复杂度S(n)\"></a>2.3  空间复杂度S(n)</h4><p><strong>一个算法在运行过程中临时占用存储空间大小的度量</strong></p>\n<h2 id=\"三、线性数据结构\"><a href=\"#三、线性数据结构\" class=\"headerlink\" title=\"三、线性数据结构\"></a>三、线性数据结构</h2><p>特点：在数据元素的非空有限集合中</p>\n<ul>\n<li>存在唯一的（第一个–最后一个）数据元素</li>\n<li>且第一个元素没有直接前驱元素，最后一个元素没有直接后继元素，其他元素都有唯一的前驱和后继元素</li>\n</ul>\n<h3 id=\"1-线性表\"><a href=\"#1-线性表\" class=\"headerlink\" title=\"1  线性表\"></a>1  线性表</h3><ul>\n<li>线性表有顺序存储结构和链式存储结构。</li>\n</ul>\n<h4 id=\"1-1-顺序存储结构（顺序表）\"><a href=\"#1-1-顺序存储结构（顺序表）\" class=\"headerlink\" title=\"1.1  顺序存储结构（顺序表）\"></a>1.1  顺序存储结构（顺序表）</h4><p><strong>是指将线性表中的各个元素依次存放在一组地址连续的存储单元中，通常将这种方法存储的线性表称为顺序表。</strong><br>顺序表的优缺点：</p>\n<ul>\n<li>优：无须关心表中元素之间的关系，所以不用增加额外的存储空间；可以快速地取表中任意位置的元素。</li>\n<li>缺：插入和删除需要移动大量元素</li>\n</ul>\n<h4 id=\"1-2-线性表的链式存储（链表）\"><a href=\"#1-2-线性表的链式存储（链表）\" class=\"headerlink\" title=\"1.2  线性表的链式存储（链表）\"></a>1.2  线性表的链式存储（链表）</h4><p>一组任意的连续或非连续存储单元存储线性表的元素，存储元素本身（数据域）和后继元素地址（指针域)    </p>\n<ul>\n<li><p>链表与顺序表的对比</p>\n<table>\n<thead>\n<tr>\n<th align=\"center\"></th>\n<th align=\"center\">存储方式</th>\n<th align=\"center\">时间性能</th>\n<th align=\"center\">空间性能</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\">顺序表</td>\n<td align=\"center\">连续的存储单元</td>\n<td align=\"center\">查找：O(1)；插入、删除：O(n)</td>\n<td align=\"center\">预先分配空间</td>\n</tr>\n<tr>\n<td align=\"center\">单链表</td>\n<td align=\"center\">任意的存储单元</td>\n<td align=\"center\">查找：O(n)；插入、删除：O(1)</td>\n<td align=\"center\">不用估计预用空间大小</td>\n</tr>\n</tbody></table>\n</li>\n</ul>\n<p>循环单链表：首尾相连的一种单链表，最后一个结点称为：尾指针：rear</p>\n<p>双向链表： 链表中的每个结点有两个指针域，一个指向直接前驱结点，另一个指向直接后继结点。 data – prior – next </p>\n<h3 id=\"2-栈和队列\"><a href=\"#2-栈和队列\" class=\"headerlink\" title=\"2  栈和队列\"></a>2  栈和队列</h3><h4 id=\"2-1-栈\"><a href=\"#2-1-栈\" class=\"headerlink\" title=\"2.1  栈\"></a>2.1  栈</h4><p><strong>限制在表一端进行插入（入栈）和删除（出栈）操作的线性表</strong></p>\n<ul>\n<li><p>栈顶：允许操作端</p>\n</li>\n<li><p>栈底：固定端</p>\n</li>\n</ul>\n<blockquote>\n<p>先进后出</p>\n</blockquote>\n<h5 id=\"2-1-1-栈的存储结构\"><a href=\"#2-1-1-栈的存储结构\" class=\"headerlink\" title=\"2.1.1  栈的存储结构\"></a>2.1.1  栈的存储结构</h5><p>栈是运算受限的线性表，线性表的存储结构对栈也适用</p>\n<ol>\n<li>顺序栈</li>\n<li>链栈</li>\n</ol>\n<h4 id=\"2-2-队列\"><a href=\"#2-2-队列\" class=\"headerlink\" title=\"2.2  队列\"></a>2.2  队列</h4><p><strong>插入（队尾）在表一段，删除（对头）在表的另一端</strong></p>\n<blockquote>\n<p>先进先出</p>\n</blockquote>\n<h5 id=\"2-2-1-队列的存储结构\"><a href=\"#2-2-1-队列的存储结构\" class=\"headerlink\" title=\"2.2.1  队列的存储结构\"></a>2.2.1  队列的存储结构</h5><p>队列也是一种运算受限的线性表</p>\n<ul>\n<li>顺序队列</li>\n<li>链队列</li>\n</ul>\n<p>小结：</p>\n<ol>\n<li>链式栈的栈顶应在链头，插入与删除操作都在链头进行。</li>\n<li>循环队列要注意对空条件和对满条件；而对于链队列，需要特别注意出队仅对队头指针操作，当只有一个元素时，出队需要修改队尾指针。</li>\n<li>递归实质上是通过栈来实现函数调用，只不过是调用自身而已。</li>\n</ol>\n<h3 id=\"3-字符串和数组\"><a href=\"#3-字符串和数组\" class=\"headerlink\" title=\"3  字符串和数组\"></a>3  字符串和数组</h3><h4 id=\"3-1-字符串\"><a href=\"#3-1-字符串\" class=\"headerlink\" title=\"3.1  字符串\"></a>3.1  字符串</h4><p> 串（String）是由零个或多个任意字符串组成的字符序列。 </p>\n<h5 id=\"3-1-1-串的存储结构\"><a href=\"#3-1-1-串的存储结构\" class=\"headerlink\" title=\"3.1.1  串的存储结构\"></a>3.1.1  串的存储结构</h5><ul>\n<li>定长顺序存储结构（顺序串）<ul>\n<li>定长是指按预定义的大小为每一个串变量分配固定长度的存储区。 最大不能超过256</li>\n</ul>\n</li>\n<li>堆分配存储结构</li>\n</ul>\n<h4 id=\"3-2-数组\"><a href=\"#3-2-数组\" class=\"headerlink\" title=\"3.2 数组\"></a>3.2 数组</h4><p> <strong>结构中的元素本身可以是具有某种结构的数据，但属于同一数据类型，一般线性表的扩充</strong></p>\n<p>是一个具有固定格式和数量的数据有续集，一旦被定义就不再改变，两种基本运算：</p>\n<ol>\n<li>取值操作：给定一组下标，读其对应的数据元素。</li>\n<li>赋值操作：给定一组下标，存储或修改与其相对应的数据元素。</li>\n</ol>\n<h5 id=\"3-2-1-数组的存储结构\"><a href=\"#3-2-1-数组的存储结构\" class=\"headerlink\" title=\"3.2.1  数组的存储结构\"></a>3.2.1  数组的存储结构</h5><p>一维：顺序存储结构，直接按其下标顺序分配存储空间</p>\n<p>多维：按某种次序将数组中元素排成一个线性序列，再作存储</p>\n<p>存二维数组：</p>\n<ol>\n<li>先行后列</li>\n<li>先列后行</li>\n</ol>\n<h5 id=\"3-2-2-稀疏矩阵\"><a href=\"#3-2-2-稀疏矩阵\" class=\"headerlink\" title=\"3.2.2  稀疏矩阵\"></a>3.2.2  稀疏矩阵</h5><p><strong>矩阵中大多数元素为零元素的矩阵，按常规分配方法浪费内存</strong></p>\n<p>三元组表存储</p>\n<ul>\n<li>非零元素所在行、列及值构成一个三元组（i,j,v）</li>\n</ul>\n<h2 id=\"四、非线性结构\"><a href=\"#四、非线性结构\" class=\"headerlink\" title=\"四、非线性结构\"></a>四、非线性结构</h2><h3 id=\"1-树和二叉树\"><a href=\"#1-树和二叉树\" class=\"headerlink\" title=\"1  树和二叉树\"></a>1  树和二叉树</h3><p>前驱唯一而后继不唯一，一对多</p>\n<p>定义：树（tree）是n（n&gt;=0）个结点的有限集合。当n=0时，该集合满足以下条件：</p>\n<ul>\n<li><p>只有一个特殊节点称为根节点（root）</p>\n</li>\n<li><p>当n&gt;1时，其余n-1个结点被分成m(m&gt;0)个互相不相交的集合，称为根节点的<strong>子树</strong></p>\n<p>树的定义用了递归概念，其算法也常常使用递归</p>\n</li>\n</ul>\n<h4 id=\"1-1-二叉树\"><a href=\"#1-1-二叉树\" class=\"headerlink\" title=\"1.1  二叉树\"></a>1.1  二叉树</h4><p>二叉树是每个节点最多有两个子树的树结构。通常子树被称作“左子树”（left subtree）和“右子树”（right subtree）</p>\n<p>满二叉树：除了叶结点外每一个结点都有左右子叶且叶子结点都处在最底层的二叉树。 </p>\n<h5 id=\"1-1-1-存储结构\"><a href=\"#1-1-1-存储结构\" class=\"headerlink\" title=\"1.1.1  存储结构\"></a>1.1.1  存储结构</h5><p>顺序存储结构：按照二叉树结点从上至下、从左到右的顺序存储。</p>\n<p>链式存储结构：每个节点由三个域组成：数据域和左、右指针域。</p>\n<p><img src=\"https://img-blog.csdnimg.cn/20181214150636793.jpeg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2NzZG5fYWl5YW5n,size_16,color_FFFFFF,t_70\" alt=\"\"></p>\n<h5 id=\"1-1-2-二叉树遍历\"><a href=\"#1-1-2-二叉树遍历\" class=\"headerlink\" title=\"1.1.2  二叉树遍历\"></a>1.1.2  二叉树遍历</h5><p><strong>深度优先一般用递归，广度优先一般用队列。一般情况下能用递归实现的算法大部分也能用堆栈来实现。</strong></p>\n<ol>\n<li>深度优先遍历<ol>\n<li>先序遍历    <code>根节点-&gt;左子树-&gt;右子树</code></li>\n<li>中序遍历    <code>左子树-&gt;根节点-&gt;右子树</code></li>\n<li>后序遍历    <code>左子树-&gt;右子树-&gt;根节点</code></li>\n</ol>\n</li>\n<li>广度优先遍历（层次遍历）<ul>\n<li>从树的root开始，从上到下从从左到右遍历整个树的节点 </li>\n</ul>\n</li>\n</ol>\n<h3 id=\"2-图\"><a href=\"#2-图\" class=\"headerlink\" title=\"2  图\"></a>2  图</h3><p>任意两个结点之间都可能相关，即结点之间的邻接关系可以是任意的。</p>\n<h2 id=\"五、排序和搜索\"><a href=\"#五、排序和搜索\" class=\"headerlink\" title=\"五、排序和搜索\"></a>五、排序和搜索</h2><h3 id=\"1-冒泡排序\"><a href=\"#1-冒泡排序\" class=\"headerlink\" title=\"1  冒泡排序\"></a>1  冒泡排序</h3><p><strong>重复遍历数列，一次比较两个元素</strong></p>\n<p><img src=\"https://tupian-1300728887.cos.ap-chengdu.myqcloud.com/%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F.gif\" alt=\"冒泡排序\"></p>\n<h3 id=\"2-选择排序\"><a href=\"#2-选择排序\" class=\"headerlink\" title=\"2  选择排序\"></a>2  选择排序</h3><p><strong>找到最大或最小的元素，把它排在队前或队尾，循而往复， 放到已排序序列的末尾</strong></p>\n<p><img src=\"https://tupian-1300728887.cos.ap-chengdu.myqcloud.com/%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F.gif\" alt=\"选择排序\"></p>\n<h3 id=\"3-插入排序\"><a href=\"#3-插入排序\" class=\"headerlink\" title=\"3  插入排序\"></a>3  插入排序</h3><p><strong>通过构建有序序列，对于未排序数据，在已排序序列中从后向前扫描，找到相应位置并插入。</strong></p>\n<p><img src=\"https://tupian-1300728887.cos.ap-chengdu.myqcloud.com/%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F.gif\" alt=\"插入排序\"></p>\n<h3 id=\"4-希尔排序\"><a href=\"#4-希尔排序\" class=\"headerlink\" title=\"4  希尔排序\"></a>4  希尔排序</h3><p><strong>希尔排序是插入排序的一种，将数据分成几组，分别使用插入排序</strong></p>\n<p><img src=\"https://tupian-1300728887.cos.ap-chengdu.myqcloud.com/%E5%B8%8C%E5%B0%94%E6%8E%92%E5%BA%8F.jpg\" alt=\"希尔排序\"></p>\n<h3 id=\"5-快速排序\"><a href=\"#5-快速排序\" class=\"headerlink\" title=\"5  快速排序\"></a>5  快速排序</h3><p><strong>从序列中挑出一个元素（基准），把小于（大于）基准的元素放在基准前边（后边）</strong></p>\n<p><img src=\"https://tupian-1300728887.cos.ap-chengdu.myqcloud.com/%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F.gif\" alt=\"快速排序\"></p>\n<h3 id=\"6-归并排序\"><a href=\"#6-归并排序\" class=\"headerlink\" title=\"6  归并排序\"></a>6  归并排序</h3><p> <strong>分治法，先递归分解数据，在合并数组；比较两个数组最前边的数，谁小谁先取</strong></p>\n<p><img src=\"https://tupian-1300728887.cos.ap-chengdu.myqcloud.com/%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F.gif\" alt=\"归并排序\"></p>\n<h3 id=\"7-搜索\"><a href=\"#7-搜索\" class=\"headerlink\" title=\"7  搜索\"></a>7  搜索</h3><h4 id=\"7-1-顺序查找\"><a href=\"#7-1-顺序查找\" class=\"headerlink\" title=\"7.1  顺序查找\"></a>7.1  顺序查找</h4><h4 id=\"7-2-二分法查找\"><a href=\"#7-2-二分法查找\" class=\"headerlink\" title=\"7.2  二分法查找\"></a>7.2  二分法查找</h4><h4 id=\"7-3-二叉树查找\"><a href=\"#7-3-二叉树查找\" class=\"headerlink\" title=\"7.3  二叉树查找\"></a>7.3  二叉树查找</h4><h4 id=\"7-4-哈希查找\"><a href=\"#7-4-哈希查找\" class=\"headerlink\" title=\"7.4  哈希查找\"></a>7.4  哈希查找</h4><h1 id=\"（十）大数据\"><a href=\"#（十）大数据\" class=\"headerlink\" title=\"（十）大数据\"></a>（十）大数据</h1><h1 id=\"奇点控股\"><a href=\"#奇点控股\" class=\"headerlink\" title=\"奇点控股\"></a>奇点控股</h1><p>面试题</p>\n<p>一、python的语言特性</p>\n<ul>\n<li>简单、易学、免费、开源、高级语言、可移植性、解释型语言、面向对象、可扩展性、丰富的库、规范的代码<ul>\n<li>高级语言：不用考虑内存一类的底层细节</li>\n<li>可移植性：无需修改，可在多平台上运行</li>\n<li>解释型语言： 在运行程序的时候才翻译，专门有一个解释器去进行翻译，每个语句都是执行的时候才翻译。效率比较低，依赖解释器，跨 平台性好 </li>\n<li>编译型语言： 程序在执行之前需要一个专门的编译过程，把程序编译成 为机器语言的文件，运行时不需要重新翻译，直接使用编译的结果就行了。程序执行效率高，依赖编译器，跨平台性差些</li>\n<li>可扩展性： 如果你需要你的一段关键代码运行得更快或者希望某些算法不公开，你可以把你的部分程序用C或C++编写，然后在你的Python程序中使用它们 </li>\n</ul>\n</li>\n</ul>\n<p>二、<em>args和*</em>kwargs的区别</p>\n<ul>\n<li><p>都是不定长参数</p>\n<ul>\n<li><p>*args：将参数打包成元组进行传参</p>\n</li>\n<li><p>**kwargs：将参数打包成字典进行传参</p>\n</li>\n</ul>\n</li>\n</ul>\n<p>三、</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">main</span><span class=\"params\">()</span>:</span>    </span><br><span class=\"line\">\ta = <span class=\"string\">'hello'</span>    </span><br><span class=\"line\">\tb = a    </span><br><span class=\"line\">\ta = b + <span class=\"string\">'world'</span>    </span><br><span class=\"line\">\tprint(a)    </span><br><span class=\"line\">\tprint(b)</span><br><span class=\"line\">main()</span><br><span class=\"line\"><span class=\"comment\"># helloworld</span></span><br><span class=\"line\"><span class=\"comment\"># hello</span></span><br></pre></td></tr></table></figure>\n\n<p>四、TCP/IP协议分几层，TCP、UDP、HTTP分别在哪一层</p>\n<ul>\n<li>四层：网络接口层、网络层、传输层（TCP、UDP）、应用层（HTTP）</li>\n</ul>\n<p>五、</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">main</span><span class=\"params\">()</span>:</span>    </span><br><span class=\"line\">    <span class=\"keyword\">try</span>:        </span><br><span class=\"line\">        a = <span class=\"string\">'str'</span>        </span><br><span class=\"line\">        b = <span class=\"number\">123</span>        </span><br><span class=\"line\">        print(a + b)    </span><br><span class=\"line\">    <span class=\"keyword\">except</span>:        </span><br><span class=\"line\">        print(<span class=\"string\">'except'</span>)    </span><br><span class=\"line\">    <span class=\"keyword\">else</span>:        </span><br><span class=\"line\">        print(<span class=\"string\">'else'</span>)    </span><br><span class=\"line\">    <span class=\"keyword\">finally</span>:        </span><br><span class=\"line\">        print(<span class=\"string\">'finally'</span>)</span><br><span class=\"line\">main()</span><br><span class=\"line\"><span class=\"comment\"># except</span></span><br><span class=\"line\"><span class=\"comment\"># finally</span></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><ul>\n<li><p><strong>python中的魔法方法</strong></p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">__init__(self)\t<span class=\"comment\"># 在创建一个对象是默认被调用，不需要手动调用</span></span><br><span class=\"line\">__str__(self)\t<span class=\"comment\"># 用来显示信息，需要return一个数据</span></span><br><span class=\"line\">__del__(self)\t<span class=\"comment\"># 当删除对象时，默认被调用</span></span><br><span class=\"line\">__new__(self)\t<span class=\"comment\"># 才是实例化对象调用的第一个方法，它只取下 cls 参数，并把 其他参数传给 __init__</span></span><br><span class=\"line\">__call__(self)\t<span class=\"comment\"># 允许一个类的实例像函数一样被调用 。</span></span><br><span class=\"line\">__getitem__(self)\t\t<span class=\"comment\"># 定义获取容器中指定元素的行为，相当于 self[key] 。</span></span><br><span class=\"line\">__getattr__(self) \t<span class=\"comment\"># 定义当用户试图访问一个不存在属性的时候的行为 。</span></span><br><span class=\"line\">__setattr__(self) \t<span class=\"comment\"># 定义当一个属性被设置的时候的行为 。</span></span><br><span class=\"line\">__getattribute__(self) \t<span class=\"comment\"># 定义当一个属性被访问的时候的行为 。</span></span><br></pre></td></tr></table></figure>\n</li>\n<li><p><strong>可变与不可变类型</strong></p>\n<ul>\n<li><strong>指内存中的那块内容（value）是否可以发生改变</strong></li>\n<li>可变类型：不需要申请新内存，在原有基础上改变</li>\n<li>不可变类型：必须在内存中新申请一块区域</li>\n</ul>\n</li>\n<li><p><strong>冒泡排序</strong></p>\n</li>\n</ul>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">bubble_sort</span><span class=\"params\">(alist)</span>:</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> j <span class=\"keyword\">in</span> range(len(alist)<span class=\"number\">-1</span>, <span class=\"number\">0</span>, <span class=\"number\">-1</span>):</span><br><span class=\"line\">        <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> range(j):</span><br><span class=\"line\">            <span class=\"keyword\">if</span> alist[i] &gt; alist[i+<span class=\"number\">1</span>]:</span><br><span class=\"line\">                alist[i], alist[i+<span class=\"number\">1</span>] = alist[i+<span class=\"number\">1</span>], alist[i]</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li><p><strong>is和==的区别</strong></p>\n<ul>\n<li>都是对对象进行比较判断作用的</li>\n<li>==（比较运算法），用来判断两个对象的value值</li>\n<li>is（同一性运算符），用来判断两个对象的唯一身份标识，id地址</li>\n</ul>\n<p>只有<strong>数值型（-5~256）和字符串</strong>型的情况下，a is b才为True，当a和b是<strong>tuple，list，dict</strong>或<strong>set</strong>型时，a is b为False。 </p>\n</li>\n<li><p><strong>python默认递归限制1000or998</strong></p>\n<ul>\n<li><p>修改限制</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> sys</span><br><span class=\"line\">sys.setrecursionlimit(<span class=\"number\">1500</span>)</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n</li>\n<li><p><strong>数据量大情况下Paginator的缺点</strong></p>\n<ul>\n<li>查询效率慢的问题</li>\n<li><strong>PageHelper的分页功能是通过Limit拼接SQL实现的</strong> </li>\n</ul>\n</li>\n</ul>\n<h1 id=\"中科软总结\"><a href=\"#中科软总结\" class=\"headerlink\" title=\"中科软总结\"></a>中科软总结</h1><ul>\n<li><p>项目用了几台服务器</p>\n<table>\n<thead>\n<tr>\n<th align=\"center\">用途</th>\n<th align=\"center\">服务器</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\">Nginx反向代理和静态文件</td>\n<td align=\"center\">1</td>\n</tr>\n<tr>\n<td align=\"center\">主业务服务器</td>\n<td align=\"center\">1</td>\n</tr>\n<tr>\n<td align=\"center\">celery异步任务broker和worker</td>\n<td align=\"center\">2</td>\n</tr>\n<tr>\n<td align=\"center\">MySQL读写分离</td>\n<td align=\"center\">2</td>\n</tr>\n<tr>\n<td align=\"center\">redis</td>\n<td align=\"center\">1</td>\n</tr>\n<tr>\n<td align=\"center\"><strong>共计</strong>：</td>\n<td align=\"center\"><strong>7</strong></td>\n</tr>\n</tbody></table>\n</li>\n</ul>\n","site":{"data":{}},"excerpt":"<h1 id=\"（一）Flask与Django\"><a href=\"#（一）Flask与Django\" class=\"headerlink\" title=\"（一）Flask与Django\"></a>（一）Flask与Django</h1><ul>\n<li><strong>轻量、简洁、扩展性强，，原生不支持数据库</strong></li>\n<li>核心：werkzeug和jinja2</li>\n</ul>","more":"<table>\n<thead>\n<tr>\n<th align=\"center\">房有居</th>\n<th align=\"center\">用户模块、主页渲染、搜索房源信息功能及数据库的优化</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\"><strong>食天下</strong></td>\n<td align=\"center\"><strong>现菜谱展示、用户模块</strong></td>\n</tr>\n<tr>\n<td align=\"center\"><strong>书香阁</strong></td>\n<td align=\"center\"><strong>书刊列表展示、用户历史记录保存</strong></td>\n</tr>\n</tbody></table>\n<hr>\n<h3 id=\"Flask与Django对比\"><a href=\"#Flask与Django对比\" class=\"headerlink\" title=\"Flask与Django对比\"></a>Flask与Django对比</h3><ul>\n<li>与Django对比<ul>\n<li>不同点：<ol>\n<li>Django：支持 ORM、认证、CSRF/模板、后台管理等。 </li>\n<li>Flask：自带jinja2模板，实现其它功能需要调用扩展包</li>\n</ol>\n</li>\n<li>相同点：<ol>\n<li>性能都不⾼，都是单进程服务器。 </li>\n</ol>\n</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"MVT设计模式\"><a href=\"#MVT设计模式\" class=\"headerlink\" title=\"MVT设计模式\"></a>MVT设计模式</h3><p>设计模式：解决一类问题而总结出来的经验和套路</p>\n<p><strong>MVC：</strong>核心思想：分工、解耦，让不同代码之间降低耦合，增强代码的可扩展性和可移植性</p>\n<p><strong>MVT：</strong></p>\n<ul>\n<li>M：模型 Model</li>\n<li>V：视图 View</li>\n<li>T：模板 Template</li>\n</ul>\n<h3 id=\"前后端不分离的区别\"><a href=\"#前后端不分离的区别\" class=\"headerlink\" title=\"前后端不分离的区别\"></a>前后端不分离的区别</h3><p>前后端不分离：</p>\n<ul>\n<li>页面的控制和渲染是由后端实现的<ul>\n<li>优点：页面展示无延迟，因为响应给用户的就是页面；方便实现搜索引擎排名，帮助爬虫服务器更高效率的爬取数据，即SEO</li>\n<li>缺点：对后端程序员要求高</li>\n</ul>\n</li>\n</ul>\n<p>前后端分离：</p>\n<ul>\n<li>页面的控制和渲染是由前端实现的<ul>\n<li>优点：后端程序员只需专注数据和业务即可</li>\n<li>缺点：有延迟，先加载页面 – 发请求获取数据 – 渲染</li>\n</ul>\n</li>\n<li>补充：前后端不分离，一般不做页面静态化，因为用户先拿到的就是静态页面</li>\n</ul>\n<h3 id=\"Django信号\"><a href=\"#Django信号\" class=\"headerlink\" title=\"Django信号\"></a>Django信号</h3><p><strong>Django 提供一个“信号分发器”，允许解耦的应用在框架的其它地方发生操作时会被通知到。信号允许特定的sender（发送者）通知一组receiver（接收者）某些操作已经发生。</strong></p>\n<p>信号遵守的设计模式：<strong>观察者设计模式（通知机制、监听机制）</strong></p>\n<ul>\n<li><a href=\"https://handout-1300728887.cos.ap-beijing.myqcloud.com/%E8%AE%B2%E4%B9%89/%E6%80%9D%E7%BB%B4%E5%AF%BC%E5%9B%BE/Django%E4%BF%A1%E5%8F%B7.jpg\" target=\"_blank\" rel=\"noopener\">使用</a></li>\n</ul>\n<h3 id=\"Django项目中的社会化分享\"><a href=\"#Django项目中的社会化分享\" class=\"headerlink\" title=\"Django项目中的社会化分享\"></a>Django项目中的社会化分享</h3><p>结合项目中使用：</p>\n<ul>\n<li><p>MobTech平台创建应用：<a href=\"https://www.mob.com/\" target=\"_blank\" rel=\"noopener\">https://www.mob.com/</a></p>\n<ol>\n<li>注册登录</li>\n<li>产品中心 –&gt; 开发者平台</li>\n<li>创建应用并添加产品和SDK</li>\n<li>进入到&lt;应用管理&gt;查看App Key和App Secret</li>\n</ol>\n</li>\n<li><p>创建Django项目</p>\n</li>\n<li><p>根据开发文档集成ShareSDK</p>\n<ul>\n<li><p>进入文档中心，打开web集成文档</p>\n<p><a href=\"https://www.mob.com/wiki/list\" target=\"_blank\" rel=\"noopener\">https://www.mob.com/wiki/list</a></p>\n</li>\n<li><p>根据开发文档集成ShareSDK，实现社会化分享功能</p>\n</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"Django自带的缓存cache和redis的区别\"><a href=\"#Django自带的缓存cache和redis的区别\" class=\"headerlink\" title=\"Django自带的缓存cache和redis的区别\"></a>Django自带的缓存cache和redis的区别</h3><p>cache是python实现缓存的一种工具</p>\n<p>redis是一种存放缓存数据的数据库</p>\n<p>可以使用cache这个缓存工具，将缓存数据缓存到redis数据库</p>\n<h3 id=\"如何对Django框架进行二次开发，增大并发数\"><a href=\"#如何对Django框架进行二次开发，增大并发数\" class=\"headerlink\" title=\"如何对Django框架进行二次开发，增大并发数\"></a>如何对Django框架进行二次开发，增大并发数</h3><p>可能造成并发降低的原因：</p>\n<ol>\n<li>数据库操作变慢</li>\n<li>python语言执行速度变慢</li>\n</ol>\n<p>Django二次开发方向：</p>\n<ul>\n<li>扩展Django Models使其支持Sharding（一种数据库分片技术）</li>\n<li>手动关闭GC（垃圾回收）</li>\n<li><strong>把那些稳定且对性能最敏感的组件，使用c或c++来重写</strong></li>\n</ul>\n<h3 id=\"中间件的定义方式、结构\"><a href=\"#中间件的定义方式、结构\" class=\"headerlink\" title=\"中间件的定义方式、结构\"></a>中间件的定义方式、结构</h3><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">middleware_name</span><span class=\"params\">(get_response)</span>:</span></span><br><span class=\"line\">    <span class=\"comment\"># 这个节点表示请求初始化：在最开始的时候补充额外逻辑</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">middleware</span><span class=\"params\">(request)</span>:</span></span><br><span class=\"line\">        <span class=\"comment\"># 这个节点表示请求被执行前：在请求执行的时候补充额外逻辑</span></span><br><span class=\"line\">        response = get_response(request)</span><br><span class=\"line\">        <span class=\"comment\"># z这个节点表示响应之前：在响应之前补充额外逻辑</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> response</span><br><span class=\"line\">    <span class=\"keyword\">return</span> middleware</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"ORM（-object-relation-mapping-）\"><a href=\"#ORM（-object-relation-mapping-）\" class=\"headerlink\" title=\"ORM（ object-relation-mapping ）\"></a><a href=\"https://handout-1300728887.cos.ap-beijing.myqcloud.com/%E8%AE%B2%E4%B9%89/%E9%BB%91%E9%A9%AC%E5%A4%B4%E6%9D%A1%E9%A1%B9%E7%9B%AE%E8%AF%BE%E4%BB%B6/C02-Database/ORM.html\" target=\"_blank\" rel=\"noopener\">ORM（ <strong>object-relation-mapping</strong> ）</a></h3><ul>\n<li><p>对象关系映射 本质上就是将数据从一种形式转换到另外一种形式，定义的类相当于数据库中的表，在类中的定义的属性相当于是表中的字段，实例化的每一个对象，相当于的每一条数据。</p>\n<ul>\n<li>类 -&gt; 表</li>\n<li>类属性 -&gt; 字段</li>\n<li>类对象 -&gt; 数据</li>\n</ul>\n</li>\n<li><p>作用：</p>\n<ol>\n<li><p>省去编写sql语句，提⾼开发效率；</p>\n</li>\n<li><p>防注⼊攻击</p>\n</li>\n<li><p>适配不同的数据库。</p>\n</li>\n</ol>\n</li>\n<li><p>缺点：查询效率较低，需要手动的优化。</p>\n</li>\n<li><p>操作方式：</p>\n<ol>\n<li>先创建模型类，再迁移到数据库中：不能对数据库表的字段的定义，实现精确控制。 </li>\n<li>使⽤sql创建数据库的表，定义模型类，通过模型类，实现ORM操作。 </li>\n</ol>\n</li>\n</ul>\n<hr>\n<h1 id=\"（二）熟练-MySQL、Redis-等数据库的使用\"><a href=\"#（二）熟练-MySQL、Redis-等数据库的使用\" class=\"headerlink\" title=\"（二）熟练 MySQL、Redis 等数据库的使用\"></a>（二）熟练 MySQL、Redis 等数据库的使用</h1><h3 id=\"1-复制集与分布式\"><a href=\"#1-复制集与分布式\" class=\"headerlink\" title=\"1  复制集与分布式\"></a>1  <a href=\"https://handout-1300728887.cos.ap-beijing.myqcloud.com/%E8%AE%B2%E4%B9%89/%E9%BB%91%E9%A9%AC%E5%A4%B4%E6%9D%A1%E9%A1%B9%E7%9B%AE%E8%AF%BE%E4%BB%B6/C02-Database/DatabaseTheory.html\" target=\"_blank\" rel=\"noopener\">复制集与分布式</a></h3><ul>\n<li><p>复制集：</p>\n<ol>\n<li>数据库中数据相同，起到备份作用</li>\n<li>高可用</li>\n</ol>\n</li>\n<li><p>分布式：</p>\n<ol>\n<li>数据库中数据不同，共同组成完整的数据集合</li>\n<li>高吞吐</li>\n</ol>\n</li>\n</ul>\n<h3 id=\"2-主从复制\"><a href=\"#2-主从复制\" class=\"headerlink\" title=\"2  主从复制\"></a>2  主从复制</h3><ol>\n<li><p>主服务器的数据发生改变时，会将改变的记录写在本地二进制log日志中</p>\n</li>\n<li><p>从服务器的一个线程会把更新的数据拷贝中继log日志中</p>\n</li>\n<li><p>从服务器读取中继文件并执行，达到主从一致</p>\n<p><strong>利用主从在达到高可用的同时，也可以通过读写分离提供吞吐量。</strong> </p>\n</li>\n</ol>\n<h3 id=\"3-事务\"><a href=\"#3-事务\" class=\"headerlink\" title=\"3  事务\"></a>3  <a href=\"https://handout-1300728887.cos.ap-beijing.myqcloud.com/%E8%AE%B2%E4%B9%89/python-web%E5%9F%BA%E7%A1%80(5.1.2%E7%89%88%E6%9C%AC)/mysqlhigh/%E4%BA%8B%E5%8A%A1.html\" target=\"_blank\" rel=\"noopener\">事务</a></h3><ul>\n<li>四大特性：<ul>\n<li>原子性：强调事务中的多个操作时一个整体</li>\n<li>一致性：强调数据库中不会保存不一致状态</li>\n<li>隔离性：强调数据库中事务之间相互不可见</li>\n<li>持久性：强调数据库能永久保存数据，一旦提交就不可撤销</li>\n</ul>\n</li>\n<li>隔离级别：<ul>\n<li>读已提交：一个事务要等另一个事务提交后才能读取数据，可避免脏读的发生。</li>\n<li>读未提交：一个事务可以读取另一个未提交事务的数据，最低级别，任何情况都无法保证。</li>\n<li><strong>可重复读(MySQL默认)</strong>：就是在开始读取数据（事务开启）时，不再允许修改操作，可避免脏读、不可重复读的发生。</li>\n<li>串行化：最高的事务隔离级别，事务串行化顺序执行，可以避免脏读、不可重复读与幻读。效率抵消，耗性能</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"一、Mysql\"><a href=\"#一、Mysql\" class=\"headerlink\" title=\"一、Mysql\"></a>一、Mysql</h2><h3 id=\"1-索引\"><a href=\"#1-索引\" class=\"headerlink\" title=\"1  索引\"></a>1  <a href=\"https://handout-1300728887.cos.ap-beijing.myqcloud.com/%E8%AE%B2%E4%B9%89/python-web%E5%9F%BA%E7%A1%80(5.1.2%E7%89%88%E6%9C%AC)/mysqlhigh/%E7%B4%A2%E5%BC%95.html\" target=\"_blank\" rel=\"noopener\">索引</a></h3><p>也叫“键”，保存数据库中所有记录的位置信息，相比于目录</p>\n<p>优点：加快查询速度</p>\n<p>缺点：耗费时间空间（不是越多越好）</p>\n<p><strong>优化</strong></p>\n<ol>\n<li>不是越多越好，而是需要自己合理的使用</li>\n</ol>\n<h3 id=\"2-sql语句优化\"><a href=\"#2-sql语句优化\" class=\"headerlink\" title=\"2  sql语句优化\"></a>2  <a href=\"https://handout-1300728887.cos.ap-beijing.myqcloud.com/%E8%AE%B2%E4%B9%89/%E9%BB%91%E9%A9%AC%E5%A4%B4%E6%9D%A1%E9%A1%B9%E7%9B%AE%E8%AF%BE%E4%BB%B6/C02-Database/DatabaseOptimize.html\" target=\"_blank\" rel=\"noopener\">sql语句优化</a></h3><ul>\n<li>1.避免全表扫描 </li>\n<li>2.查询时使⽤select明确指明所要查询的字段，避免使⽤ select * 的操作； </li>\n<li>3.SQL语句尽量⼤写 </li>\n<li>4.尽量避免在 where ⼦句中使⽤!=或&lt;&gt;操作符， </li>\n<li>5.遵循最左原则，在where⼦句中写查询条件时把索引字段放在前⾯ </li>\n<li>6.能使⽤关联查询解决的，尽量不要使⽤⼦查询 </li>\n<li>7.能不使⽤关联查询的尽量不要使⽤关联查询 </li>\n<li>8.不需要获取全表数据的时候，不要查询全表数据，使⽤LIMIT来限制数据 </li>\n</ul>\n<h3 id=\"3-数据库的优化\"><a href=\"#3-数据库的优化\" class=\"headerlink\" title=\"3  数据库的优化\"></a>3  数据库的优化</h3><ul>\n<li>在进⾏表设计时，可适度增加冗余字段(反范式设计)，减少JOIN操作；</li>\n<li>多字段表可以进⾏垂直分表优化，多数据表可以进⾏⽔平分表优化；</li>\n<li>选择恰当的数据类型，如整型的选择；</li>\n<li>对于强调快速读取的操作，可以考虑使⽤MyISAM数据库引擎；</li>\n<li>对较频繁的作为查询条件的字段创建索引；唯⼀性太差的字段不适合单独创建索引，即使频繁作为查询条件；更新⾮常频繁的字段不适合创建索引；</li>\n<li>编写SQL时使⽤上⾯的⽅式对SQL语句进⾏优化；</li>\n<li>使⽤慢查询⼯具找出效率低下的SQL语句进⾏优化；</li>\n<li>构建缓存，减少数据库磁盘操作；</li>\n<li>可以考虑结合使⽤内存型数据库，如Redis，进⾏混合存储。</li>\n</ul>\n<h3 id=\"4-数据库存储过程与触发器\"><a href=\"#4-数据库存储过程与触发器\" class=\"headerlink\" title=\"4  数据库存储过程与触发器\"></a>4  数据库存储过程与触发器</h3><p>存储过程：完成特定功能的SOL语句集</p>\n<p>触发器：对表进行（插入、删除、更新）触发一系列预定好的SQL语句</p>\n<h3 id=\"5-数据库设计\"><a href=\"#5-数据库设计\" class=\"headerlink\" title=\"5  数据库设计\"></a>5  <a href=\"https://handout-1300728887.cos.ap-beijing.myqcloud.com/%E8%AE%B2%E4%B9%89/%E9%BB%91%E9%A9%AC%E5%A4%B4%E6%9D%A1%E9%A1%B9%E7%9B%AE%E8%AF%BE%E4%BB%B6/C02-Database/DatabaseDesign.html\" target=\"_blank\" rel=\"noopener\">数据库设计</a></h3><p>库设计：</p>\n<ol>\n<li>数据库名要明确</li>\n<li>不同类型的数据分开管理</li>\n</ol>\n<p>表设计：</p>\n<ol>\n<li>命名，业务表跟基础表区分，驼峰命名法</li>\n<li>词性分析法，<strong>名词体现表或字段，动词体现关系</strong><ul>\n<li>一对一、一对多、多对多</li>\n</ul>\n</li>\n<li>不要用物理删除，以防后悔</li>\n<li>三范式：<ul>\n<li>字段不可分割、原子性</li>\n<li>满足范式一，表有主键依赖</li>\n<li>满足范式二，表非主字段之间没有依赖关系。</li>\n</ul>\n</li>\n<li>反范式：<strong>利用冗余字段存储数据，节省数据查询的时间，本质是空间换时间。</strong></li>\n<li>字段类型、是否允许为null、是否有默认值<ul>\n<li>整形：int长度并不影响精度，长度只和显示有关<ul>\n<li><strong>存储范围相同</strong></li>\n</ul>\n</li>\n<li>字符串：char和varchar<ul>\n<li>char不可变，查询效率高，可能造成存储浪费</li>\n<li>varchar可变，查询效率不如char，节省空间</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>索引设计<ul>\n<li>主键、外键、唯一约束；</li>\n<li>key/value，提高查询效率的字段；</li>\n<li><strong>外键：作用是维护数据的完整性。</strong><ul>\n<li>应用：在实际开发项目过程中，用不用外键？</li>\n<li>建议：项目开发初期可以利用外键帮助维护数据的完整性，但是，项目的中后期，建议移除外键。</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>数据库引擎（MySQL的核心）的选择：决定数据存储和增删改查方式，争对表<ul>\n<li><strong>InnoDB</strong>（事务、安全能力）<ol>\n<li><strong>支持事务，安全性级别较高，查询效率相对较低。</strong></li>\n<li>为处理巨大数据量的最大性能设计</li>\n<li><strong>InnoDB支持外键完整性约束</strong></li>\n</ol>\n</li>\n<li><strong>MyISAM</strong>（主要用来插入和查询）<ol>\n<li><strong>不支持事务，插入、查询效率较高，增删改效率较低。</strong></li>\n<li>产生三个文件（名字一表名字开始）：<ol>\n<li>frm：文件存储表定义</li>\n<li>.MYD：数据文件</li>\n<li>.MYI：索引文件</li>\n</ol>\n</li>\n</ol>\n</li>\n<li><strong>MEMORY</strong>（存放临时数据）<ol>\n<li>将表中数据存储到内存中，未查询和引用其他表数据提供快速访问</li>\n</ol>\n</li>\n</ul>\n</li>\n</ol>\n<h4 id=\"5-1-分库分表\"><a href=\"#5-1-分库分表\" class=\"headerlink\" title=\"5.1  分库分表\"></a>5.1  分库分表</h4><p><strong>垂直拆分</strong></p>\n<ul>\n<li>垂直分表：”大表拆小表”，基于列字段进行，将不常用，数据较大，长度较长拆分</li>\n<li>垂直分库：根据业务切分成不同的库</li>\n</ul>\n<p><strong>水平拆分</strong></p>\n<ul>\n<li>水平分表：针对数据量巨大的单张表， 按照某种规则（RANGE,HASH取模等），切分到多张表里面去,有IO瓶颈</li>\n<li>水平分库分表：将表数据切分到多个服务器上，分布式，有效解决瓶颈、突破IO</li>\n</ul>\n<p><strong>先垂直分在水平分</strong></p>\n<h5 id=\"分库分表后面临的问题\"><a href=\"#分库分表后面临的问题\" class=\"headerlink\" title=\"分库分表后面临的问题\"></a>分库分表后面临的问题</h5><ul>\n<li>事务支持</li>\n<li>多库结果集合并</li>\n<li>跨库join</li>\n</ul>\n<p><strong>分库分表方案产品中间件</strong>：官方MySQL Fabric、阿里TDDL，Cobar、360Atlas</p>\n<h3 id=\"6-SQL语句中where和having那个执行更快\"><a href=\"#6-SQL语句中where和having那个执行更快\" class=\"headerlink\" title=\"6  SQL语句中where和having那个执行更快\"></a>6  SQL语句中where和having那个执行更快</h3><p>SQL语句执行顺序：</p>\n<p><code>from -&gt; where -&gt; group by -&gt; having -&gt; select -&gt; order by</code></p>\n<p>两者区别：</p>\n<p>where：是一个约束声明，结果返回之前起作用，不能使用聚合函数</p>\n<p>having：是一个过滤声明，过滤分组数据，只能用于group by，可以使用聚合函数</p>\n<hr>\n<h2 id=\"二、Redis\"><a href=\"#二、Redis\" class=\"headerlink\" title=\"二、Redis\"></a>二、Redis</h2><h3 id=\"1-Redis特点\"><a href=\"#1-Redis特点\" class=\"headerlink\" title=\"1  Redis特点\"></a>1  <a href=\"https://handout-1300728887.cos.ap-beijing.myqcloud.com/%E8%AE%B2%E4%B9%89/%E9%BB%91%E9%A9%AC%E5%A4%B4%E6%9D%A1%E9%A1%B9%E7%9B%AE%E8%AF%BE%E4%BB%B6/C02-Database/Redis.html\" target=\"_blank\" rel=\"noopener\">Redis特点</a></h3><ol>\n<li>速度快：C语言实现，存储在内存中以键值对形式保存</li>\n<li><strong>持久化:</strong><ul>\n<li>redis可以将数据写入到磁盘中，在停机后，再次启动redis时，将磁盘中的备份数据加载到redis中</li>\n<li>两种机制：<ol>\n<li>RDB快照持久化（默认开启）<ul>\n<li>将内存中的数据存入磁盘</li>\n<li>缺点：一旦数据库出现问题，rdb文件数据不是全新的</li>\n</ul>\n</li>\n<li>AOF追加文件持久化<ul>\n<li>文件会变大，自动压缩</li>\n</ul>\n</li>\n</ol>\n</li>\n</ul>\n</li>\n<li>多种数据结构：string  hash  list  set  zset</li>\n<li>支持多种编程语言</li>\n<li>支持事务、流水线、消息队列</li>\n<li><a href=\"https://handout-1300728887.cos.ap-beijing.myqcloud.com/%E8%AE%B2%E4%B9%89/redis%E8%AE%B2%E4%B9%89/redis%E8%AE%B2%E4%B9%89/redis/da-jian-zhu-cong.html\" target=\"_blank\" rel=\"noopener\">主从复制</a></li>\n<li>高可用、分布式</li>\n</ol>\n<h3 id=\"2-redis宕机\"><a href=\"#2-redis宕机\" class=\"headerlink\" title=\"2  redis宕机\"></a>2  redis宕机</h3><ul>\n<li><p>slave从宕机</p>\n<ul>\n<li>重启后会自动加入到主从架构中，完成数据同步</li>\n</ul>\n</li>\n<li><p>master主宕机（主从都没持久化）</p>\n<ol>\n<li>不要立马重启服务</li>\n<li>slave执行<code>SLAVEOF ON ONE</code>断开主从关系并升级为主库</li>\n<li>重启主，<code>SLAVEOF</code>设为从</li>\n</ol>\n<p>可使用简单方法：<strong>哨兵</strong></p>\n</li>\n</ul>\n<h3 id=\"3-redis高可用\"><a href=\"#3-redis高可用\" class=\"headerlink\" title=\"3  redis高可用\"></a>3  redis高可用</h3><p><strong>提供了主从同步＋哨兵机制（ Sentinel ）</strong></p>\n<ul>\n<li>哨兵机制：实现故障转移，当检测到主服务器发生故障时，把从服务器升级为主，保证数据正常使用<ul>\n<li>原理：心跳机制＋投票裁决＋故障转移<ul>\n<li>定时给master/slave发送消息，若指定时间内无响应（主观宕机 SDOWN）</li>\n<li>Sentinel群都报告某一master无响应（客观宕机 SDOWN）</li>\n<li>通过一定vote算法，将从升为主</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"4-为什么Redis比MySQL快\"><a href=\"#4-为什么Redis比MySQL快\" class=\"headerlink\" title=\"4  为什么Redis比MySQL快\"></a>4  为什么Redis比MySQL快</h3><table>\n<thead>\n<tr>\n<th align=\"center\"></th>\n<th align=\"center\">Redis</th>\n<th align=\"center\">MySQL</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\">数据格式</td>\n<td align=\"center\">k-v</td>\n<td align=\"center\">B+TREE</td>\n</tr>\n<tr>\n<td align=\"center\">时间复杂度</td>\n<td align=\"center\">0(1)（常数阶）</td>\n<td align=\"center\">0(logn)（对数阶）</td>\n</tr>\n<tr>\n<td align=\"center\">存储位置</td>\n<td align=\"center\">从内存直接取出</td>\n<td align=\"center\">磁盘表（全局扫或索引查）</td>\n</tr>\n</tbody></table>\n<p>Redis是单线程的多路复用IO，单线程避免线程切换开销；多路复用避免IO等待开销；多核处理器下对数据进行分区，各处理器处理不同的数据（分着干）</p>\n<h2 id=\"三、缓存\"><a href=\"#三、缓存\" class=\"headerlink\" title=\"三、缓存\"></a>三、缓存</h2><h3 id=\"1-有效期TTL（Time-to-live）\"><a href=\"#1-有效期TTL（Time-to-live）\" class=\"headerlink\" title=\"1  有效期TTL（Time to live）\"></a>1  有效期TTL（Time to live）</h3><ul>\n<li>作用：<ul>\n<li>节省空间</li>\n<li>做到数据有效性，失效后，做到数据一致性</li>\n</ul>\n</li>\n</ul>\n<h4 id=\"1-1-过期策略\"><a href=\"#1-1-过期策略\" class=\"headerlink\" title=\"1.1  过期策略\"></a>1.1  过期策略</h4><ul>\n<li><p>定时过期：时间一到立即清除，对内存友好，但会占用大量CPU资源</p>\n</li>\n<li><p>惰性过期：当访问时才去判断是否过期，节省CPU，占用内存</p>\n</li>\n<li><p>定期过期：每隔一段时间，随机清除</p>\n<p><strong>Redis中同时使用了惰性过期和定期过期两种过期策略。</strong> </p>\n</li>\n</ul>\n<h4 id=\"1-2-缓存淘汰-（eviction）\"><a href=\"#1-2-缓存淘汰-（eviction）\" class=\"headerlink\" title=\"1.2  缓存淘汰 （eviction）\"></a>1.2  缓存淘汰 （eviction）</h4><ul>\n<li>LRU（Least recently used，最近最少使用）<ul>\n<li>新数据插入到表头部</li>\n<li>缓存命中时，将其移到头部</li>\n<li>缓存满的时候将尾部的数据丢掉</li>\n</ul>\n</li>\n<li>LFU（Least Frequently Used 最近最少使用算法）<ul>\n<li>如果数据在一段时间内使用次数很少，那么将来也会很少</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"2-缓存模式\"><a href=\"#2-缓存模式\" class=\"headerlink\" title=\"2  缓存模式\"></a>2  缓存模式</h3><ul>\n<li><strong>先更新数据库，再删除缓存</strong> </li>\n</ul>\n<h4 id=\"2-1-缓存穿透\"><a href=\"#2-1-缓存穿透\" class=\"headerlink\" title=\"2.1  缓存穿透\"></a>2.1  缓存穿透</h4><ul>\n<li><p>频繁请求缓存中不存在的数据，增大数据库压力</p>\n<ul>\n<li>解决方案：<ol>\n<li>返回缓存伪造数据</li>\n<li>限制请求参数</li>\n<li>借助第三方过滤器：布隆过滤器…</li>\n</ol>\n</li>\n</ul>\n</li>\n<li><p>布隆过滤器</p>\n<p>本质上是一种*<em>概率型数据结构， 由一个很长的bit数组和一系列哈希函数组成的 *</em></p>\n<p>特点：<strong>高效地插入和查询</strong></p>\n<p>算法的核心： <strong>某样东西一定不存在或者可能存在</strong></p>\n<p>缺点：<strong>数据只能插入不能删除</strong></p>\n<ul>\n<li>存储原理：经过多次不同维度的hash计算，将数据映射到二进制向量里</li>\n<li>服务流程：<ol>\n<li>当用户访问时，去布隆过滤器中判断key值是否存在，否则直接返回</li>\n<li>如果key值存在，则访问redis，由于存在误判率，redis中也可能不存在</li>\n<li>再访问数据库，若也不存在，直接返回空</li>\n</ol>\n</li>\n</ul>\n</li>\n</ul>\n<p><img src=\"https://img-blog.csdnimg.cn/20190306043938625.?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0lUX3Rvd25sZXQ=,size_16,color_FFFFFF,t_70\" alt=\"\"></p>\n<h4 id=\"2-2-缓存雪崩\"><a href=\"#2-2-缓存雪崩\" class=\"headerlink\" title=\"2.2  缓存雪崩\"></a>2.2  缓存雪崩</h4><ul>\n<li>同一时间内，大量缓存失效，造成数据库压力剧增<ul>\n<li>解决方案：<ol>\n<li>设置不同的有效期值</li>\n<li>采用多级缓存</li>\n<li>利用加锁或者队列</li>\n</ol>\n</li>\n</ul>\n</li>\n</ul>\n<hr>\n<h1 id=\"（三）版本控制管理工具-Git\"><a href=\"#（三）版本控制管理工具-Git\" class=\"headerlink\" title=\"（三）版本控制管理工具 Git\"></a>（三）<a href=\"https://learngitbranching.js.org/\" target=\"_blank\" rel=\"noopener\">版本控制管理工具 Git</a></h1><h3 id=\"一、常用命令\"><a href=\"#一、常用命令\" class=\"headerlink\" title=\"一、常用命令\"></a>一、常用命令</h3><ul>\n<li>克隆远程库    <code>git clone 地址</code></li>\n<li>添加到暂存    <code>git add .</code></li>\n<li>提交暂存区的文件到本地仓库    <code>git commit -m &#39;test&#39;</code></li>\n<li>拉取    <code>git pull origin &lt;name&gt;</code></li>\n<li>推送    <code>git push origin &lt;name&gt;</code></li>\n<li>查看仓库当前的状态    <code>git status</code></li>\n<li>查看远程库信息    <code>git remote</code></li>\n<li>查看当前分支    <code>git branch</code> </li>\n<li>切换分支    <code>git checkout &lt;name&gt;</code></li>\n<li>合并分支到当前分支    <code>git merge &lt;name&gt;</code></li>\n</ul>\n<hr>\n<h1 id=\"（四）熟悉-Celery-异步方案，多线程、多进程的使用\"><a href=\"#（四）熟悉-Celery-异步方案，多线程、多进程的使用\" class=\"headerlink\" title=\"（四）熟悉 Celery 异步方案，多线程、多进程的使用\"></a>（四）熟悉 Celery 异步方案，多线程、多进程的使用</h1><p>celery是异步任务的调度工具，主要解决耗时任务，通过<strong>消息队列</strong>在客户端与消费者间协调</p>\n<ul>\n<li>消息中间件（消息队列Broker）：客户端把任务放入队列中，消费者从队列中取出任务执行，第三方队列服务：RabbitMQ\\redis\\kafka\\MetaMQ\\RocketMQ<ul>\n<li><strong>RabbitMQ：</strong>是一个消息代理。工作是接收和转发消息类似邮局，处理消息<ul>\n<li>异步消息：支持多种传递协议，消息排队，传递确认，到队列的灵活路由，多种交换类型</li>\n<li>分布式部署：部署为集群以实现高可用和吞吐量</li>\n<li>可靠性：可在性能和可靠性之间进行权衡</li>\n<li>灵活的路由：通过交换机进行路由</li>\n<li>多协议：多种消息协议的消息传递</li>\n<li>管理与监控：HTTP-API，命令行工具</li>\n</ul>\n</li>\n<li><strong>基本慨念：</strong><ul>\n<li>Producer：生产者，投递消息的程序：创建消息（消息体和标签），RabbitMQ会根据标签把消息发送给消费者</li>\n<li>Consumer：消费者，接收消息的程序：丢弃标签，消费消息体</li>\n<li>Broker：消息中间件的服务节点：RabbitMQ服务实例</li>\n<li>Queue：队列：内部对象，用于存储信息，生产者投递，消费者取出消费</li>\n<li>Xchange：交换器。指定消息按什么规则，路由到哪个队列，如果路由不到或返回或丢弃</li>\n<li>RoutingKey：路由键关键字，Xchange根据此来进行邮递，需要与交换器类型和绑定键联合使用，决定消息流向哪里</li>\n<li>Binding：绑定，把Xchange和Queue按照路由规则绑定起来，指定绑定键（BindingKey）</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>任务执行单元（消费者worker）：可以有多个并发，实时监控消息队列，获取任务并执行它</li>\n<li>任务执行结果存储（task result store）：由于是由主任务中解耦出来的，主任务想要知道执行结果，必须通过中间件存储</li>\n</ul>\n<h3 id=\"1-消息队列的理解\"><a href=\"#1-消息队列的理解\" class=\"headerlink\" title=\"1  消息队列的理解\"></a>1  消息队列的理解</h3><p><strong>消息队列</strong>：保存消息的容器</p>\n<p>消息:传输的数据单位</p>\n<p>消息源与目标间的中间人，主要目的是<strong>提供路由保证消息的传递</strong>，</p>\n<h3 id=\"2-为什么使用消息队列\"><a href=\"#2-为什么使用消息队列\" class=\"headerlink\" title=\"2  为什么使用消息队列\"></a>2  为什么使用消息队列</h3><p>在高并发情况下，来不及同步处理，请求会发生堵塞。通过消息队列，可以异步处理请求，缓解系统压力</p>\n<p>应用场景：</p>\n<ul>\n<li>异步处理、应用解耦、流量削锋和消息通讯等  </li>\n</ul>\n<p><strong>使用消息队列，把不是必须的业务逻辑，异步处理</strong></p>\n<p>消息队列的缺点：</p>\n<ul>\n<li>系统可用性降低</li>\n<li>系统复杂性提高</li>\n<li>一致性问题</li>\n</ul>\n<h3 id=\"3-多线程在web中的使用\"><a href=\"#3-多线程在web中的使用\" class=\"headerlink\" title=\"3  多线程在web中的使用\"></a>3  多线程在web中的使用</h3><p>一般在使用IO操作时</p>\n<p>使用场景：</p>\n<ul>\n<li>需要并行操作几个文件的读写，同步不能异步的情况下</li>\n<li>视图中需要多个第三方接口</li>\n<li>订单提交后，修改库存销量</li>\n</ul>\n<h3 id=\"4-为什么使用celery而不使用线程发送耗时任务\"><a href=\"#4-为什么使用celery而不使用线程发送耗时任务\" class=\"headerlink\" title=\"4  为什么使用celery而不使用线程发送耗时任务\"></a>4  为什么使用celery而不使用线程发送耗时任务</h3><p>因为并发量较大的时候，线程切换会有开销时间，也会降低并发的数量、共享数据维护麻烦</p>\n<p>celery是通过消息队列进行异步任务处理，不用担心并发量高是负载过大，也可以处理复杂系统性能问题，相对灵活</p>\n<h3 id=\"5-处理抢购高并发\"><a href=\"#5-处理抢购高并发\" class=\"headerlink\" title=\"5  处理抢购高并发\"></a>5  处理抢购高并发</h3><ol>\n<li>将请求尽量拦截在上游</li>\n<li>充分利用缓存</li>\n</ol>\n<p>前端方面：</p>\n<ul>\n<li>把详情页部署到CDN节点上，做页面静态化处理<ul>\n<li>CDN：内容分发网络，将源站内容分发到离用户最近的节点，提高访问速度</li>\n</ul>\n</li>\n<li>禁止重复提交请求、对用户请求限流</li>\n</ul>\n<p>后端方面：</p>\n<ul>\n<li>根据用户id限制访问频率</li>\n<li>缓存的应用</li>\n</ul>\n<h3 id=\"6-如何解决celery队列阻塞问题\"><a href=\"#6-如何解决celery队列阻塞问题\" class=\"headerlink\" title=\"6  如何解决celery队列阻塞问题\"></a>6  如何解决celery队列阻塞问题</h3><ul>\n<li><p>队列阻塞的原因：</p>\n<ol>\n<li>队列中有耗时任务，且任务量大于celery并发数（Celery没有足够的worker去执行耗时任务）</li>\n<li>队列中有耗时任务，且Celery启动了<strong>预取机制</strong><ul>\n<li>任务会有指定的worker去执行，就算其worker是空闲状态，也不会执行其它任务</li>\n</ul>\n</li>\n</ol>\n</li>\n<li><p>解决：</p>\n<ul>\n<li><p><strong>指定进程数</strong></p>\n<p><code>celery -A project worker --concurrency=4</code></p>\n</li>\n<li><p><strong>改变进程池方式为协程方式</strong></p>\n<p><code>pip install eventlet</code></p>\n<p><code>celery -A project worker -P eventlet -c 1000</code></p>\n</li>\n<li><p><strong>增加并发数</strong></p>\n</li>\n</ul>\n<p><code>celery -A project worker -n 进程名字 --concurrencu=并发数 -l info</code></p>\n<ul>\n<li><p><strong>取消预取机制</strong></p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 任务发送完成时是否需要确认，对性能会稍有影响</span></span><br><span class=\"line\">celery_app.conf.CELERY_LATE = <span class=\"literal\">True</span></span><br><span class=\"line\"><span class=\"comment\"># Celery worker每次去队列取任务的数量，默认值为4</span></span><br><span class=\"line\">celery_app.conf.CELERY_PREFETCH_MULTIPLIER = <span class=\"number\">1</span></span><br></pre></td></tr></table></figure>\n\n<p><code>celery -A project worker -n 进程名字 -Ofair -l info</code></p>\n</li>\n<li><p><strong>错误重试机制</strong></p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 重连时间间隔</span></span><br><span class=\"line\"><span class=\"meta\">@celery_app.task(bind=True, retry_backoff=3)</span></span><br><span class=\"line\"><span class=\"keyword\">try</span>:</span><br><span class=\"line\">    ...</span><br><span class=\"line\"><span class=\"keyword\">except</span> Exception <span class=\"keyword\">as</span> e:</span><br><span class=\"line\">    <span class=\"comment\"># 有异常自动重连三次</span></span><br><span class=\"line\">    <span class=\"keyword\">raise</span> self.retry(exc=e, max_retries=<span class=\"number\">3</span>)</span><br></pre></td></tr></table></figure>\n\n</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"7-进程和线程的对比\"><a href=\"#7-进程和线程的对比\" class=\"headerlink\" title=\"7  进程和线程的对比\"></a>7  <a href=\"https://handout-1300728887.cos.ap-beijing.myqcloud.com/%E8%AE%B2%E4%B9%89/python-web%E5%9F%BA%E7%A1%80(5.1.2%E7%89%88%E6%9C%AC)/multitasking/%E8%BF%9B%E7%A8%8B%E5%92%8C%E7%BA%BF%E7%A8%8B%E5%AF%B9%E6%AF%94.html\" target=\"_blank\" rel=\"noopener\">进程和线程的对比</a></h3><p>进程：CPU的一种执行单元</p>\n<ul>\n<li>密集CPU任务（大量并行计算）</li>\n</ul>\n<p>线程：进程执行程序的最小调度单位</p>\n<ul>\n<li>密集I/O任务</li>\n</ul>\n<p>协程：微线程，可以在单线程上执行多个任务，用函数切换，开销极小</p>\n<h4 id=\"关系对比\"><a href=\"#关系对比\" class=\"headerlink\" title=\"关系对比\"></a>关系对比</h4><ol>\n<li>线程是依附在进程里面的，没有进程就没有线程</li>\n<li>一个进程默认提供一条线程，进程可以创建多个线程</li>\n</ol>\n<h4 id=\"区别对比\"><a href=\"#区别对比\" class=\"headerlink\" title=\"区别对比\"></a>区别对比</h4><ol>\n<li>进程之间不共享全局变量</li>\n<li>线程之间共享全局变量，但是要注意资源竞争的问题，解决办法: 互斥锁或者线程同步</li>\n<li>创建进程的资源开销要比创建线程的资源开销要大</li>\n<li>进程是操作系统资源分配的基本单位，线程是CPU调度的基本单位</li>\n<li>线程不能够独立执行，必须依存在进程中</li>\n<li>多进程开发比单进程多线程开发稳定性要强</li>\n</ol>\n<h4 id=\"优缺点\"><a href=\"#优缺点\" class=\"headerlink\" title=\"优缺点\"></a>优缺点</h4><ul>\n<li>进程优缺点:<ul>\n<li>优点：可以用多核</li>\n<li>缺点：资源开销大</li>\n</ul>\n</li>\n<li>线程优缺点:<ul>\n<li>优点：资源开销小</li>\n<li>缺点：不能使用多核做到高并行</li>\n</ul>\n</li>\n</ul>\n<hr>\n<h1 id=\"（五）熟悉-TCP-HTTP-协议等网络知识\"><a href=\"#（五）熟悉-TCP-HTTP-协议等网络知识\" class=\"headerlink\" title=\"（五）熟悉 TCP/HTTP 协议等网络知识\"></a>（五）熟悉 TCP/<a href=\"https://handout-1300728887.cos.ap-beijing.myqcloud.com/%E8%AE%B2%E4%B9%89/python-web%E5%9F%BA%E7%A1%80(5.1.2%E7%89%88%E6%9C%AC)/http/HTTP%E5%8D%8F%E8%AE%AE.html\" target=\"_blank\" rel=\"noopener\">HTTP</a> 协议等网络知识</h1><p>TDP：用户数据报协议，无连接的</p>\n<p><strong>TCP：传输控制协议，面向连接的、可靠的、基于字节流的传输层通信协议</strong></p>\n<p>HTTP：超文本传输协议，浏览器和web服务器通信需要HTTP协议 </p>\n<p>RPC：远程过程调用，向另一台计算机上的程序请求服务，不需要了解底层网络技术的协议。</p>\n<h2 id=\"一、网络协议分层\"><a href=\"#一、网络协议分层\" class=\"headerlink\" title=\"一、网络协议分层\"></a>一、<a href=\"https://www.jianshu.com/p/30fb2b0bcfd8\" target=\"_blank\" rel=\"noopener\">网络协议分层</a></h2><p><img src=\"https://tupian-1300728887.cos.ap-chengdu.myqcloud.com/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE%E5%88%86%E5%B1%82.png\" alt=\"\"></p>\n<h3 id=\"1-乐观锁\"><a href=\"#1-乐观锁\" class=\"headerlink\" title=\"1  乐观锁\"></a>1  乐观锁</h3><p>每次拿数据的时候都认为别人不会修改，所以不会上锁</p>\n<p>在更新的时候判断此时的库存是否是之前查询出的库存，如果相同，表示没人修改，可以更新库存，否则表示别人抢过资源，不再执行库存更新</p>\n<p><strong>实现方式：</strong>利用时间戳、数据版本version字段，数据被修改＋1</p>\n<p>使用场景：高并发，减少数据冲突，保证数据一致性</p>\n<h3 id=\"2-高并发，分布式\"><a href=\"#2-高并发，分布式\" class=\"headerlink\" title=\"2  高并发，分布式\"></a>2  高并发，分布式</h3><p>处理网站并发量</p>\n<ol>\n<li>减少数据库访问次数</li>\n<li>文件和数据库分离（静态化页面）</li>\n<li>大数据分布式存储（主从配置读写分离）</li>\n<li>服务器集群，负载均衡</li>\n<li>页面缓存的使用</li>\n<li>内存数据库代替关系型数据库</li>\n</ol>\n<p>例子：省市区三级联动、首页部分数据（广告）局部缓存</p>\n<p>分布式案例</p>\n<ol>\n<li>MySQL主从配置读写分离</li>\n</ol>\n<h3 id=\"3-长连接与短连接\"><a href=\"#3-长连接与短连接\" class=\"headerlink\" title=\"3  长连接与短连接\"></a>3  长连接与短连接</h3><p>长连接：连接 -&gt; 传输数据 -&gt; 保持连接 -&gt; 传输数据 -&gt; 直到一方断开</p>\n<ul>\n<li>操作频繁、点对点的通讯、数据库连接<ul>\n<li>TCP三握手时间</li>\n<li>不安全</li>\n</ul>\n</li>\n</ul>\n<p>短连接：连接 -&gt; 传输数据-&gt; 断开连接</p>\n<ul>\n<li>http服务</li>\n</ul>\n<h3 id=\"4-token和jwt存在什么区别\"><a href=\"#4-token和jwt存在什么区别\" class=\"headerlink\" title=\"4  token和jwt存在什么区别\"></a>4  token和jwt存在什么区别</h3><p>token需要查库验证，JWT直接在服务端进行，不需要查库</p>\n<h3 id=\"5-三次握手和四次挥手\"><a href=\"#5-三次握手和四次挥手\" class=\"headerlink\" title=\"5  三次握手和四次挥手\"></a>5  <a href=\"https://blog.csdn.net/qq_38950316/article/details/81087809\" target=\"_blank\" rel=\"noopener\">三次握手和四次挥手</a></h3><p>三次挥手：</p>\n<ol>\n<li>建立连接时，客户端发送syn包（seq=x）到服务器，并进入SYN_SENT（发送）状态，等待服务器确认；</li>\n<li>服务器收到syn包，必须确认客户的SYN（ack=x+1），同时自己也发送一个SYN包（seq=y），即SYN+ACK包，此时服务器进入SYN_RECV（收到）状态；</li>\n<li>客户端收到服务器的SYN+ACK包，向服务器发送确认包ACK(ack=y+1），此包发送完毕，客户端和服务器进入ESTABLISHED（TCP连接成功）状态，完成三次握手。</li>\n</ol>\n<p>四次挥手：</p>\n<h3 id=\"6-CSRF攻击\"><a href=\"#6-CSRF攻击\" class=\"headerlink\" title=\"6  CSRF攻击\"></a>6  <a href=\"https://handout-1300728887.cos.ap-beijing.myqcloud.com/%E8%AE%B2%E4%B9%89/Django%E6%A1%86%E6%9E%B6/Django%E6%A1%86%E6%9E%B6/C05-Template/csrf.html\" target=\"_blank\" rel=\"noopener\">CSRF攻击</a></h3><ol>\n<li>浏览并登录信任网站A</li>\n<li>验证通过，产生A的Cookie</li>\n<li>再没登出的情况下，浏览<strong>攻击网站B</strong></li>\n<li>B要求访问第三方网站A</li>\n<li>根据B的请求，浏览器带着A的Cookie访问A</li>\n<li>A不知道请求源，因为浏览器会自动携带用户的Cookie，按需处理请求，达到模拟用户操作csrf攻击</li>\n</ol>\n<p><strong>防止csrf攻击</strong></p>\n<ol>\n<li>在后端响应的cookie写入csrf_token值</li>\n<li>前端from表单中也写入csrf_token值</li>\n<li>获取两个csrf_token，看是否一致</li>\n</ol>\n<p>Django自带的防csrf中间间</p>\n<p><strong>跨站请求伪造</strong>：攻击者盗用你的身份，发送恶意请求</p>\n<h3 id=\"7-RESTFul思想\"><a href=\"#7-RESTFul思想\" class=\"headerlink\" title=\"7  RESTFul思想\"></a>7  RESTFul思想</h3><ul>\n<li><p>每一个URI代表1种资源；</p>\n</li>\n<li><p>客户端使用GET、POST、PUT、DELETE4个表示操作方式的动词对服务端资源进行操作：GET用来获取资源，POST用来新建资源（也可以用于更新资源），PUT用来更新资源，DELETE用来删除资源；</p>\n</li>\n<li><p>通过操作资源的表现形式来操作资源；</p>\n</li>\n<li><p>资源的表现形式是XML或者HTML；</p>\n</li>\n<li><p>客户端与服务端之间的交互在请求之间是无状态的，从客户端到服务端的每个请求都必须包含理解请求所必需的信息。</p>\n</li>\n</ul>\n<hr>\n<h1 id=\"（六）使用腾讯云存储方案\"><a href=\"#（六）使用腾讯云存储方案\" class=\"headerlink\" title=\"（六）使用腾讯云存储方案\"></a>（六）<a href=\"https://cloud.tencent.com/document/product/436\" target=\"_blank\" rel=\"noopener\">使用腾讯云存储方案</a></h1><p>腾讯对象存储服务（COS）通过网络随时存储和调用各种数据文件</p>\n<ol>\n<li>创建一个或多个存储同，上传文件</li>\n<li>根据地址可上传和下载</li>\n<li>可设置相应属性及访问权限</li>\n<li>下载SDK包，执行相应操作</li>\n</ol>\n<h1 id=\"（七）熟悉-Linux-系统，了解-Docker、Elasticsearch\"><a href=\"#（七）熟悉-Linux-系统，了解-Docker、Elasticsearch\" class=\"headerlink\" title=\"（七）熟悉 Linux 系统，了解 Docker、Elasticsearch\"></a>（七）<a href=\"https://handout-1300728887.cos.ap-beijing.myqcloud.com/%E8%AE%B2%E4%B9%89/%E7%AC%94%E8%AE%B0/Linux%E5%9F%BA%E7%A1%80%E5%91%BD%E4%BB%A4.html\" target=\"_blank\" rel=\"noopener\">熟悉 Linux 系统</a>，了解 Docker、Elasticsearch</h1><h3 id=\"1-Docker\"><a href=\"#1-Docker\" class=\"headerlink\" title=\"1  Docker\"></a>1  <a href=\"http://www.docker.org.cn/index.html\" target=\"_blank\" rel=\"noopener\">Docker</a></h3><p><strong>开源的软件部署解决方案、轻量级的应用容器框架，采用C/S架构，其可以轻松的为任何应用创建一个轻量级的、可移植的、自给自足的容器。</strong></p>\n<blockquote>\n<p>是一种快速解决生产问题的一种技术手段。</p>\n</blockquote>\n<p>优缺点：</p>\n<ul>\n<li>优：<ul>\n<li>多： 适用场景多</li>\n<li>快： 环境部署快、更新快</li>\n<li>好： 好多人在用，东西好</li>\n<li>省： 省钱省力省人工(123原则)</li>\n</ul>\n</li>\n<li>缺：<ul>\n<li>太腻歪人： 依赖操作系统</li>\n<li>不善于沟通：依赖网络</li>\n<li>不善理财： 银行U盾等场景不能用</li>\n</ul>\n</li>\n</ul>\n<p><strong>镜像</strong></p>\n<ul>\n<li>类似虚拟机的镜像，可以创建新的容器</li>\n</ul>\n<figure class=\"highlight dockerfile\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 镜像</span></span><br><span class=\"line\">docker search [image_name]\t\t\t<span class=\"comment\"># 搜索镜像</span></span><br><span class=\"line\">docker pull [image_name]\t\t\t<span class=\"comment\"># 获取镜像</span></span><br><span class=\"line\">docker images\t\t\t\t\t\t<span class=\"comment\"># 查看镜像</span></span><br><span class=\"line\">docker history [image_name]\t\t\t<span class=\"comment\"># 查看镜像历史</span></span><br><span class=\"line\">docker tag [old_image]:[old_version]\t<span class=\"comment\"># 重命名</span></span><br><span class=\"line\">docker rm [image_name]\t\t\t\t<span class=\"comment\"># 删除</span></span><br><span class=\"line\">docker save -o [包文件] [镜像]\t\t<span class=\"comment\"># 导出镜像</span></span><br><span class=\"line\">docker load -i [image.tar_name]\t\t<span class=\"comment\"># 导入镜像</span></span><br></pre></td></tr></table></figure>\n\n<p><strong>容器</strong></p>\n<ul>\n<li>由镜像创建的运行实例，类似虚拟机</li>\n</ul>\n<figure class=\"highlight dockerfile\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 容器</span></span><br><span class=\"line\">docker ps\t\t\t\t\t\t\t\t<span class=\"comment\"># 查看容器</span></span><br><span class=\"line\">docker start [container_id]\t\t\t\t<span class=\"comment\"># 启动已终止的容器</span></span><br><span class=\"line\">docker stop [container_id]\t\t\t\t<span class=\"comment\"># 关闭</span></span><br><span class=\"line\">docker rm [container_id]\t\t\t\t<span class=\"comment\"># 删除</span></span><br><span class=\"line\">\t\t-f\t\t<span class=\"comment\"># 强制删除</span></span><br><span class=\"line\">docker <span class=\"keyword\">run</span><span class=\"bash\"> [docker_image] /bin/bash</span></span><br><span class=\"line\">\t\t--name\t<span class=\"comment\"># 给容器定义一个名称</span></span><br><span class=\"line\">\t\t-i \t\t<span class=\"comment\"># 让容器的标准输入保持打开。</span></span><br><span class=\"line\">\t\t-t\t\t<span class=\"comment\"># 分配一个伪终端,并绑定到容器的标准输入上</span></span><br><span class=\"line\">\t\t-d \t\t<span class=\"comment\"># 守护进程开启</span></span><br><span class=\"line\">\t\t-v\t\t<span class=\"comment\"># 本地:容器 --映射</span></span><br><span class=\"line\">\t\t-p  \t<span class=\"comment\"># 端口映射</span></span><br><span class=\"line\">docker exec -it 容器id /bin/bash\t\t\t<span class=\"comment\"># 进入后台运行容器</span></span><br><span class=\"line\">docker commit [container_id] [new_image:tag]\t<span class=\"comment\"># 基于容器创建镜像</span></span><br><span class=\"line\">\t\t-m \t\t<span class=\"comment\"># '改动信息' </span></span><br><span class=\"line\">\t\t-a \t\t<span class=\"comment\"># \"作者信息\"</span></span><br><span class=\"line\">docker logs [容器id]\t\t\t\t\t<span class=\"comment\"># 查看运行日志</span></span><br><span class=\"line\">docker inspect  [容器id]\t\t\t\t<span class=\"comment\"># 查看详细信息</span></span><br></pre></td></tr></table></figure>\n\n<p><strong>仓库（公有、私有、本地）</strong></p>\n<ul>\n<li>托管镜像</li>\n</ul>\n<h4 id=\"1-1-dockerflie\"><a href=\"#1-1-dockerflie\" class=\"headerlink\" title=\"1.1 dockerflie\"></a>1.1 dockerflie</h4><p> Dockerfile类似于我们学习过的脚本，将我们在上面学到的镜像，使用自动化的方式实现出来。</p>\n<figure class=\"highlight dockerfile\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 基础指令</span></span><br><span class=\"line\"><span class=\"keyword\">FROM</span> &lt;image&gt;\t\t\t\t\t<span class=\"comment\"># 第一条指令（除首行注释外）</span></span><br><span class=\"line\"><span class=\"keyword\">MAINTAINER</span> &lt;name&gt;\t\t\t\t<span class=\"comment\"># 作者信息</span></span><br><span class=\"line\"><span class=\"keyword\">RUN</span><span class=\"bash\"> &lt;<span class=\"built_in\">command</span>&gt;\t\t\t\t\t<span class=\"comment\"># 镜像构建时候运行的命令</span></span></span><br><span class=\"line\"><span class=\"keyword\">EXPOSE</span> &lt;port&gt;\t\t\t\t\t<span class=\"comment\"># 对外开发端口</span></span><br><span class=\"line\"><span class=\"keyword\">ENTRYPOINT</span><span class=\"bash\"> python3 manage.py runserver 0.0.0.0:8000</span></span><br><span class=\"line\">\t\t\t\t\t\t\t\t<span class=\"comment\"># 运行Django项目，只能有一个</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 文件编辑指令</span></span><br><span class=\"line\"><span class=\"keyword\">ADD</span><span class=\"bash\"> &lt;src&gt;... &lt;dest&gt;\t\t<span class=\"comment\"># 将指定的 &lt;src&gt; 文件复制到容器文件系统中的 &lt;dest&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">COPY</span><span class=\"bash\"> &lt;src&gt;... &lt;dest&gt;\t\t\t<span class=\"comment\"># 复制文件</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 环境指令</span></span><br><span class=\"line\"><span class=\"keyword\">ENV</span> &lt;key&gt; &lt;value&gt;\t\t\t\t<span class=\"comment\"># 设置环境变量</span></span><br><span class=\"line\"><span class=\"keyword\">WORKDIR</span><span class=\"bash\"> /path/to/workdir\t\t<span class=\"comment\"># 切换目录</span></span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"2-es的存储底层原理\"><a href=\"#2-es的存储底层原理\" class=\"headerlink\" title=\"2  es的存储底层原理\"></a>2  es的存储底层原理</h3><p><strong>集群：</strong>es可以作为独立的单个搜索引擎，为了处理大型数据集，实现容错和高可用性，es可以运行在许多合作的服务器上，这些服务器的集合称为集群</p>\n<p><strong>节点：</strong>形成集群的每个服务器</p>\n<p><strong>分片：</strong>数据可以分为较小的分片，放到不同的服务器上，分布式处理。而应用程序并不知道分片的存在</p>\n<p><strong>副本：</strong>复制集原理，其中之一被选择更改索引操作（主分片），主废副升，不能在同一个节点上</p>\n<p><strong>es扩容：</strong></p>\n<ul>\n<li>垂直：采购更强大的服务器</li>\n<li>水平：采购更多的不同服务器</li>\n</ul>\n<h3 id=\"3-使用-Haystack-调用-Elasticsearch\"><a href=\"#3-使用-Haystack-调用-Elasticsearch\" class=\"headerlink\" title=\"3  使用 Haystack 调用 Elasticsearch\"></a>3  <a href=\"https://handout-1300728887.cos.ap-beijing.myqcloud.com/%E8%AE%B2%E4%B9%89/%E7%BE%8E%E5%A4%9A%E5%95%86%E5%9F%8E%E8%AE%B2%E4%B9%89/goods/goods-search/haystack-create-index.html\" target=\"_blank\" rel=\"noopener\">使用 Haystack 调用 Elasticsearch</a></h3><p><strong>Elasticsearch是基于Lucene库实时的分布式搜索分析引擎，全文检索、结构化搜索、分析这三功能的组合</strong></p>\n<p><strong>全文检索引擎：对数据库里的数据先进行一遍预处理，从而生成索引结构数据（类似于字典那样的结构数据），再使用关键字在索引数据中检索数据</strong></p>\n<p>属于面向文档的数据库</p>\n<p>Elasticsearch是远端服务器开启的服务</p>\n<p>需要用Haystack调用搜索引擎</p>\n<ol>\n<li><p>安装：</p>\n<p><code>pip install django-haystack</code></p>\n<p><code>pip install elasticsearch==2.4.1</code></p>\n</li>\n<li><p>注册到应用</p>\n</li>\n</ol>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">INSTALLED_APPS = [</span><br><span class=\"line\">    <span class=\"string\">'haystack'</span>, <span class=\"comment\"># 全文检索</span></span><br><span class=\"line\">]</span><br><span class=\"line\">url(<span class=\"string\">r'^search/'</span>, include(<span class=\"string\">'haystack.urls'</span>)),</span><br></pre></td></tr></table></figure>\n\n<ol start=\"3\">\n<li>配置</li>\n</ol>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># Haystack</span></span><br><span class=\"line\">HAYSTACK_CONNECTIONS = &#123;</span><br><span class=\"line\">    <span class=\"string\">'default'</span>: &#123;</span><br><span class=\"line\">        <span class=\"string\">'ENGINE'</span>: <span class=\"string\">'haystack.backends.elasticsearch_backend.ElasticsearchSearchEngine'</span>,</span><br><span class=\"line\">        <span class=\"string\">'URL'</span>: <span class=\"string\">'http://192.168.103.158:9200/'</span>, <span class=\"comment\"># Elasticsearch服务器ip地址，端口号固定为9200</span></span><br><span class=\"line\">        <span class=\"string\">'INDEX_NAME'</span>: <span class=\"string\">'meiduo_mall'</span>, <span class=\"comment\"># Elasticsearch建立的索引库的名称</span></span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 当添加、修改、删除数据时，自动生成索引</span></span><br><span class=\"line\">HAYSTACK_SIGNAL_PROCESSOR = <span class=\"string\">'haystack.signals.RealtimeSignalProcessor'</span></span><br></pre></td></tr></table></figure>\n\n<ol start=\"4\">\n<li><p>创建索引类：search_indexes.py</p>\n</li>\n<li><p>创建txt字段索引值模板文件</p>\n</li>\n<li><p>手动生成索引（仅第一次）</p>\n<p><code>python manage.py rebuild_index</code></p>\n</li>\n</ol>\n<ul>\n<li><p>常见问题：</p>\n<ol>\n<li><p>如何实现分页功能</p>\n<ul>\n<li>HAYSTACK_SEARCH_RESULTS_PER_PAGE = 5</li>\n</ul>\n</li>\n<li><p>No module named haystack</p>\n<ul>\n<li>是否安装/注册了haystack模板</li>\n</ul>\n</li>\n<li><p>在html页面出现No serults found</p>\n<ul>\n<li>是否创建了search_indexes.py文件</li>\n<li>数据库中是否有数据</li>\n</ul>\n</li>\n</ol>\n</li>\n</ul>\n<h3 id=\"3-es是怎么跟数据库关联起来的\"><a href=\"#3-es是怎么跟数据库关联起来的\" class=\"headerlink\" title=\"3  es是怎么跟数据库关联起来的\"></a>3  es是怎么跟数据库关联起来的</h3><p>Logstash是一个开源数据收集引擎，具有实时管道功能。可以动态得将来自不同数据源的数据统一起来，并将数据标准化到你所选择的目的地</p>\n<h3 id=\"4-es倒排索引和常用API\"><a href=\"#4-es倒排索引和常用API\" class=\"headerlink\" title=\"4  es倒排索引和常用API\"></a>4  es倒排索引和常用API</h3><p>倒排索引：也称反向索引，根据单词查找文档</p>\n<p>正向索引：存储每个文档单词的列表</p>\n<ul>\n<li>es常用的api<ul>\n<li><a href=\"https://handout-1300728887.cos.ap-beijing.myqcloud.com/%E8%AE%B2%E4%B9%89/%E9%BB%91%E9%A9%AC%E5%A4%B4%E6%9D%A1%E9%A1%B9%E7%9B%AE%E8%AF%BE%E4%BB%B6/C10-Elasticsearch/Query.html\" target=\"_blank\" rel=\"noopener\">查询</a></li>\n</ul>\n</li>\n</ul>\n<h1 id=\"（八）首页静态化、定时任务\"><a href=\"#（八）首页静态化、定时任务\" class=\"headerlink\" title=\"（八）首页静态化、定时任务\"></a>（八）首页静态化、定时任务</h1><p><strong>静态化与缓存的主要区别</strong></p>\n<ul>\n<li><p>静态化：将数据静态化到页面，客户端访问时不查询数据库，存储与硬盘</p>\n</li>\n<li><p>缓存：将数据存储于服务器内存</p>\n</li>\n</ul>\n<p><strong>定时任务的原理</strong></p>\n<ul>\n<li><p>由<strong>crond守护进程</strong>和<strong>crontab文件（任务表）</strong>组成</p>\n</li>\n<li><p>守护进程在系统启动时由init进程启动，受init监视，如果它挂了，init会重启它守护进程每分钟唤醒一次，通过检查crontab文件判断需要做什么</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 添加定时任务到系统中</span></span><br><span class=\"line\">$ python manage.py crontab add</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 显示已激活的定时任务</span></span><br><span class=\"line\">$ python manage.py crontab show</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 移除定时任务</span></span><br><span class=\"line\">$ python manage.py crontab remove</span><br></pre></td></tr></table></figure>\n\n</li>\n</ul>\n<p><strong>支付宝接入：</strong> </p>\n<ul>\n<li>Python支付宝SDK：<a href=\"https://github.com/fzlee/alipay/blob/master/README.zh-hans.md\" target=\"_blank\" rel=\"noopener\">https://github.com/fzlee/alipay/blob/master/README.zh-hans.md</a> </li>\n</ul>\n<h1 id=\"（九）部署相关\"><a href=\"#（九）部署相关\" class=\"headerlink\" title=\"（九）部署相关\"></a>（九）部署相关</h1><h2 id=\"1-nginx\"><a href=\"#1-nginx\" class=\"headerlink\" title=\"1  nginx\"></a>1  <a href=\"https://handout-1300728887.cos.ap-beijing.myqcloud.com/%E8%AE%B2%E4%B9%89/%E9%A1%B9%E7%9B%AE%E9%83%A8%E7%BD%B2/nginx/Advanced.html\" target=\"_blank\" rel=\"noopener\">nginx</a></h2><p><strong>是一个高性能的HTTP和反向代理服务器，主要处理静态资源</strong></p>\n<h3 id=\"1-1-反向代理\"><a href=\"#1-1-反向代理\" class=\"headerlink\" title=\"1.1  反向代理\"></a>1.1  <a href=\"https://handout-1300728887.cos.ap-beijing.myqcloud.com/%E8%AE%B2%E4%B9%89/%E9%A1%B9%E7%9B%AE%E9%83%A8%E7%BD%B2/nginx/nginx-reverse.html\" target=\"_blank\" rel=\"noopener\">反向代理</a></h3><p>正向代理： 为局域网<strong>客户端</strong>向外访问Internet服务<strong>（代理用户，隐藏客户端）</strong></p>\n<p>反向代理： 为局域网<strong>服务器</strong>向外提供Internet服务<strong>（代理服务器，隐藏服务器）</strong></p>\n<h3 id=\"1-2-负载均衡\"><a href=\"#1-2-负载均衡\" class=\"headerlink\" title=\"1.2  负载均衡\"></a>1.2  <a href=\"https://handout-1300728887.cos.ap-beijing.myqcloud.com/%E8%AE%B2%E4%B9%89/%E9%A1%B9%E7%9B%AE%E9%83%A8%E7%BD%B2/nginx/nginx-load.html\" target=\"_blank\" rel=\"noopener\">负载均衡</a></h3><p>有一台服务器充当调度者的身份（负载均衡器），请求先到达它，再根据每台服务器的负载情况分配请求</p>\n<ol>\n<li>内置策略：nginx自带算法<ul>\n<li>雨露均沾型：轮训（默认）、加权轮训、哈希<ul>\n<li>轮训：按顺序逐一分配</li>\n<li>加权轮训：权重越大，被分配几率越高，适用于服务器性能不均衡情况</li>\n</ul>\n</li>\n<li>定向服务型：ip_hash、least_conn、cookie、route、lean<ul>\n<li>ip_hash：按访问IP的哈希结果分配请求，分配后访客访问固定后端服务器，有效的解决动态网页会话共享问题。</li>\n</ul>\n</li>\n<li>商业类型：ntlm、least_time、queue、stick</li>\n</ul>\n</li>\n<li>第三方算法：fair、url_hash<ul>\n<li>fair：基于后端服务器的响应时间来分配请求，响应时间短的优先分配。</li>\n<li>url_hash：按访问的哈希结果分配请求，使同定向到同一台后端服务器，可提高后端缓存服务器的效率。</li>\n</ul>\n</li>\n</ol>\n<h3 id=\"1-3-提供静态文件\"><a href=\"#1-3-提供静态文件\" class=\"headerlink\" title=\"1.3  提供静态文件\"></a>1.3  提供静态文件</h3><p>静态文件收集命令：<code>python mange.py collectstatic</code></p>\n<h3 id=\"1-4-WSGI\"><a href=\"#1-4-WSGI\" class=\"headerlink\" title=\"1.4  WSGI\"></a>1.4  WSGI</h3><ul>\n<li>WSGI是一种通信协议， Web 服务器(uWSGI)与 Web 应用程序或应用框架(Django)之间的一种低级别的接口</li>\n<li>uwsgi是一种线路协议我不是一种通信协议，常用于在uWSGI服务器于其他网络服务器的数据通信</li>\n<li>uWSGI是实现了uwsgi和WSGI两种协议的Web服务器，<strong>主要处理动态资源</strong></li>\n</ul>\n<h2 id=\"2-gunicorn\"><a href=\"#2-gunicorn\" class=\"headerlink\" title=\"2  gunicorn\"></a>2  <a href=\"https://handout-1300728887.cos.ap-beijing.myqcloud.com/%E8%AE%B2%E4%B9%89/%E9%BB%91%E9%A9%AC%E5%A4%B4%E6%9D%A1%E9%A1%B9%E7%9B%AE%E8%AF%BE%E4%BB%B6/C12-Deployment/Gunicorn.html\" target=\"_blank\" rel=\"noopener\">gunicorn</a></h2><p>安装：<code>pip install gunicorn</code></p>\n<p>查看使用信息：<code>$gunicorn -h</code></p>\n<p>直接运行：<code>gunicorn 运行文件名称：flask程序实例名</code></p>\n<p>指定进程和端口号：<code>$gunicorn -w 4 -b 127.0.0.1:5001 运行文件名称:Flask程序实例名</code></p>\n<h1 id=\"支付流程\"><a href=\"#支付流程\" class=\"headerlink\" title=\"支付流程\"></a>支付流程</h1><p><img src=\"https://tupian-1300728887.cos.ap-chengdu.myqcloud.com/%E5%85%AC%E7%A7%81%E9%92%A5.png\" alt=\"\"></p>\n<ul>\n<li>生成密钥</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">openssl\t\t<span class=\"comment\"># 进入环境</span></span><br><span class=\"line\">genrsa -out app_private_key.pem 2048\t<span class=\"comment\"># 私钥</span></span><br><span class=\"line\">rsa -<span class=\"keyword\">in</span> app_private_key.pem -pubout -out app_pubout_key.pem\t\t<span class=\"comment\"># 公钥</span></span><br></pre></td></tr></table></figure>\n\n<h1 id=\"极睿科技总结\"><a href=\"#极睿科技总结\" class=\"headerlink\" title=\"极睿科技总结\"></a>极睿科技总结</h1><h2 id=\"一、装饰器\"><a href=\"#一、装饰器\" class=\"headerlink\" title=\"一、装饰器\"></a>一、装饰器</h2><p>作用：在不改变已有函数源代码及调用方式的前提下，对已有函数进行功能的扩展</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 不改变原有函数__name__\\备注信息</span></span><br><span class=\"line\"><span class=\"keyword\">from</span> functools <span class=\"keyword\">import</span> wraps</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">check</span><span class=\"params\">(fu)</span>:</span>  <span class=\"comment\"># fu:目标函数</span></span><br><span class=\"line\">    </span><br><span class=\"line\"><span class=\"meta\">    @wraps(fu)</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">inner</span><span class=\"params\">()</span>:</span></span><br><span class=\"line\">        <span class=\"string\">'''执行函数之前'''</span></span><br><span class=\"line\">        fu()</span><br><span class=\"line\">        <span class=\"string\">'''执行函数之后'''</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> inner</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 语法糖写法</span></span><br><span class=\"line\"><span class=\"meta\">@check</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">comment</span><span class=\"params\">()</span>:</span></span><br><span class=\"line\">    print(<span class=\"string\">'发表评论'</span>)</span><br><span class=\"line\">    </span><br><span class=\"line\">comment()</span><br><span class=\"line\"><span class=\"comment\"># check等价与  comment = check(comment)</span></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"二、数据结构与算法\"><a href=\"#二、数据结构与算法\" class=\"headerlink\" title=\"二、数据结构与算法\"></a>二、数据结构与算法</h2><p>数据：能够被计算机处理的符号或符号集</p>\n<p>数据元素（节点、记录）：数据的基本单位。例：学生统计表</p>\n<p>数据项（字段、域）：组成数据元素的最小单位。例：编号、姓名、性别等</p>\n<h3 id=\"1-数据结构\"><a href=\"#1-数据结构\" class=\"headerlink\" title=\"1  数据结构\"></a>1  数据结构</h3><p><strong>相互之间存在的一种或多种特定的数据元素的集合用于计算机存储、组织数据的方式</strong></p>\n<p><img src=\"https://img2018.cnblogs.com/blog/1672612/201906/1672612-20190607153718002-1151308139.jpg\" alt=\"\"></p>\n<h4 id=\"1-1-逻辑结构\"><a href=\"#1-1-逻辑结构\" class=\"headerlink\" title=\"1.1  逻辑结构\"></a>1.1  逻辑结构</h4><p><strong>数据元素间的抽象关系（如近邻关系、从属关系等），分为线性结构与非线性结构，</strong>抽象出来的，与机器无关</p>\n<p><img src=\"https://img2018.cnblogs.com/blog/1672612/201906/1672612-20190607154347579-543280178.png\" alt=\"\"></p>\n<table>\n<thead>\n<tr>\n<th align=\"center\">结构类型</th>\n<th align=\"center\">数据元素间的相互关系</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\">集合</td>\n<td align=\"center\">无</td>\n</tr>\n<tr>\n<td align=\"center\">线性</td>\n<td align=\"center\">一对一</td>\n</tr>\n<tr>\n<td align=\"center\">树形</td>\n<td align=\"center\">一对多</td>\n</tr>\n<tr>\n<td align=\"center\">图</td>\n<td align=\"center\">多对多</td>\n</tr>\n</tbody></table>\n<h4 id=\"1-2-（存储）物理结构\"><a href=\"#1-2-（存储）物理结构\" class=\"headerlink\" title=\"1.2  （存储）物理结构\"></a>1.2  （存储）物理结构</h4><p><strong>数据在计算机中的存放方式，反应数据元素间的逻辑关系</strong></p>\n<ul>\n<li>顺序存储（向量存储）：把数据元素存放在一组存储地址连续的存储单元里，逻辑关系和物理关系是一致的</li>\n<li>链式存储（动态存储）：通过指针反应数据间的逻辑关系</li>\n<li>索引存储：建立一个附加的索引表</li>\n<li>散列存储：根据节点的关键字直接计算出该节点的存储地址</li>\n</ul>\n<blockquote>\n<p>同一逻辑结构可以对应不同的存储结构，算法的设计取决于数据的逻辑结构，而算法实现依赖于指定的存储结构</p>\n</blockquote>\n<h3 id=\"2-算法\"><a href=\"#2-算法\" class=\"headerlink\" title=\"2  算法\"></a>2  算法</h3><p><strong>解决特定问题的一种方法或一种描述</strong></p>\n<h4 id=\"2-1-数据结构和算法的联系\"><a href=\"#2-1-数据结构和算法的联系\" class=\"headerlink\" title=\"2.1  数据结构和算法的联系\"></a>2.1  数据结构和算法的联系</h4><p>程序=算法+数据结构</p>\n<ul>\n<li>算法设计: 取决于选定的逻辑结构</li>\n<li>算法实现: 依赖于采用的存储结构</li>\n</ul>\n<p>区别：</p>\n<ul>\n<li>数据结构关注的是<strong>数据的逻辑结构、存储结构的基本操作</strong></li>\n<li>算法关注的是<strong>在数据结构的基础上解决实际问题</strong></li>\n</ul>\n<p>算法的五大特性：</p>\n<ol>\n<li>可行性：解决具体问题，完成期望功能</li>\n<li>确定性：每一步在一定条件下只有一条执行路径</li>\n<li>有穷性： 算法执行的步骤（或规则）是有限的</li>\n<li>输入：具有零或多个输入</li>\n<li>输出：至少有一个或多个输出</li>\n</ol>\n<p>评价算法好坏的方法：</p>\n<ul>\n<li>正确性：运行正确是一个算法的前提。</li>\n<li>可读性：容易理解、容易编程和调试、容易维护。</li>\n<li>健壮性：考虑情况全面，不容以出现运行错误。</li>\n<li>时间效率高：算法消耗的时间少。</li>\n<li>储存量低：占用较少的存储空间。</li>\n</ul>\n<h4 id=\"2-2-时间复杂度O-n\"><a href=\"#2-2-时间复杂度O-n\" class=\"headerlink\" title=\"2.2  时间复杂度O(n)\"></a>2.2  时间复杂度O(n)</h4><p>计算规则</p>\n<ol>\n<li>基本操作，只有<strong>常数项O(1)</strong></li>\n<li>顺序结构，按<strong>加法计算</strong></li>\n<li>循环结构，按<strong>乘法计算</strong></li>\n<li>分支结构，<strong>取最大值</strong></li>\n</ol>\n<h4 id=\"2-3-空间复杂度S-n\"><a href=\"#2-3-空间复杂度S-n\" class=\"headerlink\" title=\"2.3  空间复杂度S(n)\"></a>2.3  空间复杂度S(n)</h4><p><strong>一个算法在运行过程中临时占用存储空间大小的度量</strong></p>\n<h2 id=\"三、线性数据结构\"><a href=\"#三、线性数据结构\" class=\"headerlink\" title=\"三、线性数据结构\"></a>三、线性数据结构</h2><p>特点：在数据元素的非空有限集合中</p>\n<ul>\n<li>存在唯一的（第一个–最后一个）数据元素</li>\n<li>且第一个元素没有直接前驱元素，最后一个元素没有直接后继元素，其他元素都有唯一的前驱和后继元素</li>\n</ul>\n<h3 id=\"1-线性表\"><a href=\"#1-线性表\" class=\"headerlink\" title=\"1  线性表\"></a>1  线性表</h3><ul>\n<li>线性表有顺序存储结构和链式存储结构。</li>\n</ul>\n<h4 id=\"1-1-顺序存储结构（顺序表）\"><a href=\"#1-1-顺序存储结构（顺序表）\" class=\"headerlink\" title=\"1.1  顺序存储结构（顺序表）\"></a>1.1  顺序存储结构（顺序表）</h4><p><strong>是指将线性表中的各个元素依次存放在一组地址连续的存储单元中，通常将这种方法存储的线性表称为顺序表。</strong><br>顺序表的优缺点：</p>\n<ul>\n<li>优：无须关心表中元素之间的关系，所以不用增加额外的存储空间；可以快速地取表中任意位置的元素。</li>\n<li>缺：插入和删除需要移动大量元素</li>\n</ul>\n<h4 id=\"1-2-线性表的链式存储（链表）\"><a href=\"#1-2-线性表的链式存储（链表）\" class=\"headerlink\" title=\"1.2  线性表的链式存储（链表）\"></a>1.2  线性表的链式存储（链表）</h4><p>一组任意的连续或非连续存储单元存储线性表的元素，存储元素本身（数据域）和后继元素地址（指针域)    </p>\n<ul>\n<li><p>链表与顺序表的对比</p>\n<table>\n<thead>\n<tr>\n<th align=\"center\"></th>\n<th align=\"center\">存储方式</th>\n<th align=\"center\">时间性能</th>\n<th align=\"center\">空间性能</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\">顺序表</td>\n<td align=\"center\">连续的存储单元</td>\n<td align=\"center\">查找：O(1)；插入、删除：O(n)</td>\n<td align=\"center\">预先分配空间</td>\n</tr>\n<tr>\n<td align=\"center\">单链表</td>\n<td align=\"center\">任意的存储单元</td>\n<td align=\"center\">查找：O(n)；插入、删除：O(1)</td>\n<td align=\"center\">不用估计预用空间大小</td>\n</tr>\n</tbody></table>\n</li>\n</ul>\n<p>循环单链表：首尾相连的一种单链表，最后一个结点称为：尾指针：rear</p>\n<p>双向链表： 链表中的每个结点有两个指针域，一个指向直接前驱结点，另一个指向直接后继结点。 data – prior – next </p>\n<h3 id=\"2-栈和队列\"><a href=\"#2-栈和队列\" class=\"headerlink\" title=\"2  栈和队列\"></a>2  栈和队列</h3><h4 id=\"2-1-栈\"><a href=\"#2-1-栈\" class=\"headerlink\" title=\"2.1  栈\"></a>2.1  栈</h4><p><strong>限制在表一端进行插入（入栈）和删除（出栈）操作的线性表</strong></p>\n<ul>\n<li><p>栈顶：允许操作端</p>\n</li>\n<li><p>栈底：固定端</p>\n</li>\n</ul>\n<blockquote>\n<p>先进后出</p>\n</blockquote>\n<h5 id=\"2-1-1-栈的存储结构\"><a href=\"#2-1-1-栈的存储结构\" class=\"headerlink\" title=\"2.1.1  栈的存储结构\"></a>2.1.1  栈的存储结构</h5><p>栈是运算受限的线性表，线性表的存储结构对栈也适用</p>\n<ol>\n<li>顺序栈</li>\n<li>链栈</li>\n</ol>\n<h4 id=\"2-2-队列\"><a href=\"#2-2-队列\" class=\"headerlink\" title=\"2.2  队列\"></a>2.2  队列</h4><p><strong>插入（队尾）在表一段，删除（对头）在表的另一端</strong></p>\n<blockquote>\n<p>先进先出</p>\n</blockquote>\n<h5 id=\"2-2-1-队列的存储结构\"><a href=\"#2-2-1-队列的存储结构\" class=\"headerlink\" title=\"2.2.1  队列的存储结构\"></a>2.2.1  队列的存储结构</h5><p>队列也是一种运算受限的线性表</p>\n<ul>\n<li>顺序队列</li>\n<li>链队列</li>\n</ul>\n<p>小结：</p>\n<ol>\n<li>链式栈的栈顶应在链头，插入与删除操作都在链头进行。</li>\n<li>循环队列要注意对空条件和对满条件；而对于链队列，需要特别注意出队仅对队头指针操作，当只有一个元素时，出队需要修改队尾指针。</li>\n<li>递归实质上是通过栈来实现函数调用，只不过是调用自身而已。</li>\n</ol>\n<h3 id=\"3-字符串和数组\"><a href=\"#3-字符串和数组\" class=\"headerlink\" title=\"3  字符串和数组\"></a>3  字符串和数组</h3><h4 id=\"3-1-字符串\"><a href=\"#3-1-字符串\" class=\"headerlink\" title=\"3.1  字符串\"></a>3.1  字符串</h4><p> 串（String）是由零个或多个任意字符串组成的字符序列。 </p>\n<h5 id=\"3-1-1-串的存储结构\"><a href=\"#3-1-1-串的存储结构\" class=\"headerlink\" title=\"3.1.1  串的存储结构\"></a>3.1.1  串的存储结构</h5><ul>\n<li>定长顺序存储结构（顺序串）<ul>\n<li>定长是指按预定义的大小为每一个串变量分配固定长度的存储区。 最大不能超过256</li>\n</ul>\n</li>\n<li>堆分配存储结构</li>\n</ul>\n<h4 id=\"3-2-数组\"><a href=\"#3-2-数组\" class=\"headerlink\" title=\"3.2 数组\"></a>3.2 数组</h4><p> <strong>结构中的元素本身可以是具有某种结构的数据，但属于同一数据类型，一般线性表的扩充</strong></p>\n<p>是一个具有固定格式和数量的数据有续集，一旦被定义就不再改变，两种基本运算：</p>\n<ol>\n<li>取值操作：给定一组下标，读其对应的数据元素。</li>\n<li>赋值操作：给定一组下标，存储或修改与其相对应的数据元素。</li>\n</ol>\n<h5 id=\"3-2-1-数组的存储结构\"><a href=\"#3-2-1-数组的存储结构\" class=\"headerlink\" title=\"3.2.1  数组的存储结构\"></a>3.2.1  数组的存储结构</h5><p>一维：顺序存储结构，直接按其下标顺序分配存储空间</p>\n<p>多维：按某种次序将数组中元素排成一个线性序列，再作存储</p>\n<p>存二维数组：</p>\n<ol>\n<li>先行后列</li>\n<li>先列后行</li>\n</ol>\n<h5 id=\"3-2-2-稀疏矩阵\"><a href=\"#3-2-2-稀疏矩阵\" class=\"headerlink\" title=\"3.2.2  稀疏矩阵\"></a>3.2.2  稀疏矩阵</h5><p><strong>矩阵中大多数元素为零元素的矩阵，按常规分配方法浪费内存</strong></p>\n<p>三元组表存储</p>\n<ul>\n<li>非零元素所在行、列及值构成一个三元组（i,j,v）</li>\n</ul>\n<h2 id=\"四、非线性结构\"><a href=\"#四、非线性结构\" class=\"headerlink\" title=\"四、非线性结构\"></a>四、非线性结构</h2><h3 id=\"1-树和二叉树\"><a href=\"#1-树和二叉树\" class=\"headerlink\" title=\"1  树和二叉树\"></a>1  树和二叉树</h3><p>前驱唯一而后继不唯一，一对多</p>\n<p>定义：树（tree）是n（n&gt;=0）个结点的有限集合。当n=0时，该集合满足以下条件：</p>\n<ul>\n<li><p>只有一个特殊节点称为根节点（root）</p>\n</li>\n<li><p>当n&gt;1时，其余n-1个结点被分成m(m&gt;0)个互相不相交的集合，称为根节点的<strong>子树</strong></p>\n<p>树的定义用了递归概念，其算法也常常使用递归</p>\n</li>\n</ul>\n<h4 id=\"1-1-二叉树\"><a href=\"#1-1-二叉树\" class=\"headerlink\" title=\"1.1  二叉树\"></a>1.1  二叉树</h4><p>二叉树是每个节点最多有两个子树的树结构。通常子树被称作“左子树”（left subtree）和“右子树”（right subtree）</p>\n<p>满二叉树：除了叶结点外每一个结点都有左右子叶且叶子结点都处在最底层的二叉树。 </p>\n<h5 id=\"1-1-1-存储结构\"><a href=\"#1-1-1-存储结构\" class=\"headerlink\" title=\"1.1.1  存储结构\"></a>1.1.1  存储结构</h5><p>顺序存储结构：按照二叉树结点从上至下、从左到右的顺序存储。</p>\n<p>链式存储结构：每个节点由三个域组成：数据域和左、右指针域。</p>\n<p><img src=\"https://img-blog.csdnimg.cn/20181214150636793.jpeg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2NzZG5fYWl5YW5n,size_16,color_FFFFFF,t_70\" alt=\"\"></p>\n<h5 id=\"1-1-2-二叉树遍历\"><a href=\"#1-1-2-二叉树遍历\" class=\"headerlink\" title=\"1.1.2  二叉树遍历\"></a>1.1.2  二叉树遍历</h5><p><strong>深度优先一般用递归，广度优先一般用队列。一般情况下能用递归实现的算法大部分也能用堆栈来实现。</strong></p>\n<ol>\n<li>深度优先遍历<ol>\n<li>先序遍历    <code>根节点-&gt;左子树-&gt;右子树</code></li>\n<li>中序遍历    <code>左子树-&gt;根节点-&gt;右子树</code></li>\n<li>后序遍历    <code>左子树-&gt;右子树-&gt;根节点</code></li>\n</ol>\n</li>\n<li>广度优先遍历（层次遍历）<ul>\n<li>从树的root开始，从上到下从从左到右遍历整个树的节点 </li>\n</ul>\n</li>\n</ol>\n<h3 id=\"2-图\"><a href=\"#2-图\" class=\"headerlink\" title=\"2  图\"></a>2  图</h3><p>任意两个结点之间都可能相关，即结点之间的邻接关系可以是任意的。</p>\n<h2 id=\"五、排序和搜索\"><a href=\"#五、排序和搜索\" class=\"headerlink\" title=\"五、排序和搜索\"></a>五、排序和搜索</h2><h3 id=\"1-冒泡排序\"><a href=\"#1-冒泡排序\" class=\"headerlink\" title=\"1  冒泡排序\"></a>1  冒泡排序</h3><p><strong>重复遍历数列，一次比较两个元素</strong></p>\n<p><img src=\"https://tupian-1300728887.cos.ap-chengdu.myqcloud.com/%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F.gif\" alt=\"冒泡排序\"></p>\n<h3 id=\"2-选择排序\"><a href=\"#2-选择排序\" class=\"headerlink\" title=\"2  选择排序\"></a>2  选择排序</h3><p><strong>找到最大或最小的元素，把它排在队前或队尾，循而往复， 放到已排序序列的末尾</strong></p>\n<p><img src=\"https://tupian-1300728887.cos.ap-chengdu.myqcloud.com/%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F.gif\" alt=\"选择排序\"></p>\n<h3 id=\"3-插入排序\"><a href=\"#3-插入排序\" class=\"headerlink\" title=\"3  插入排序\"></a>3  插入排序</h3><p><strong>通过构建有序序列，对于未排序数据，在已排序序列中从后向前扫描，找到相应位置并插入。</strong></p>\n<p><img src=\"https://tupian-1300728887.cos.ap-chengdu.myqcloud.com/%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F.gif\" alt=\"插入排序\"></p>\n<h3 id=\"4-希尔排序\"><a href=\"#4-希尔排序\" class=\"headerlink\" title=\"4  希尔排序\"></a>4  希尔排序</h3><p><strong>希尔排序是插入排序的一种，将数据分成几组，分别使用插入排序</strong></p>\n<p><img src=\"https://tupian-1300728887.cos.ap-chengdu.myqcloud.com/%E5%B8%8C%E5%B0%94%E6%8E%92%E5%BA%8F.jpg\" alt=\"希尔排序\"></p>\n<h3 id=\"5-快速排序\"><a href=\"#5-快速排序\" class=\"headerlink\" title=\"5  快速排序\"></a>5  快速排序</h3><p><strong>从序列中挑出一个元素（基准），把小于（大于）基准的元素放在基准前边（后边）</strong></p>\n<p><img src=\"https://tupian-1300728887.cos.ap-chengdu.myqcloud.com/%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F.gif\" alt=\"快速排序\"></p>\n<h3 id=\"6-归并排序\"><a href=\"#6-归并排序\" class=\"headerlink\" title=\"6  归并排序\"></a>6  归并排序</h3><p> <strong>分治法，先递归分解数据，在合并数组；比较两个数组最前边的数，谁小谁先取</strong></p>\n<p><img src=\"https://tupian-1300728887.cos.ap-chengdu.myqcloud.com/%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F.gif\" alt=\"归并排序\"></p>\n<h3 id=\"7-搜索\"><a href=\"#7-搜索\" class=\"headerlink\" title=\"7  搜索\"></a>7  搜索</h3><h4 id=\"7-1-顺序查找\"><a href=\"#7-1-顺序查找\" class=\"headerlink\" title=\"7.1  顺序查找\"></a>7.1  顺序查找</h4><h4 id=\"7-2-二分法查找\"><a href=\"#7-2-二分法查找\" class=\"headerlink\" title=\"7.2  二分法查找\"></a>7.2  二分法查找</h4><h4 id=\"7-3-二叉树查找\"><a href=\"#7-3-二叉树查找\" class=\"headerlink\" title=\"7.3  二叉树查找\"></a>7.3  二叉树查找</h4><h4 id=\"7-4-哈希查找\"><a href=\"#7-4-哈希查找\" class=\"headerlink\" title=\"7.4  哈希查找\"></a>7.4  哈希查找</h4><h1 id=\"（十）大数据\"><a href=\"#（十）大数据\" class=\"headerlink\" title=\"（十）大数据\"></a>（十）大数据</h1><h1 id=\"奇点控股\"><a href=\"#奇点控股\" class=\"headerlink\" title=\"奇点控股\"></a>奇点控股</h1><p>面试题</p>\n<p>一、python的语言特性</p>\n<ul>\n<li>简单、易学、免费、开源、高级语言、可移植性、解释型语言、面向对象、可扩展性、丰富的库、规范的代码<ul>\n<li>高级语言：不用考虑内存一类的底层细节</li>\n<li>可移植性：无需修改，可在多平台上运行</li>\n<li>解释型语言： 在运行程序的时候才翻译，专门有一个解释器去进行翻译，每个语句都是执行的时候才翻译。效率比较低，依赖解释器，跨 平台性好 </li>\n<li>编译型语言： 程序在执行之前需要一个专门的编译过程，把程序编译成 为机器语言的文件，运行时不需要重新翻译，直接使用编译的结果就行了。程序执行效率高，依赖编译器，跨平台性差些</li>\n<li>可扩展性： 如果你需要你的一段关键代码运行得更快或者希望某些算法不公开，你可以把你的部分程序用C或C++编写，然后在你的Python程序中使用它们 </li>\n</ul>\n</li>\n</ul>\n<p>二、<em>args和*</em>kwargs的区别</p>\n<ul>\n<li><p>都是不定长参数</p>\n<ul>\n<li><p>*args：将参数打包成元组进行传参</p>\n</li>\n<li><p>**kwargs：将参数打包成字典进行传参</p>\n</li>\n</ul>\n</li>\n</ul>\n<p>三、</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">main</span><span class=\"params\">()</span>:</span>    </span><br><span class=\"line\">\ta = <span class=\"string\">'hello'</span>    </span><br><span class=\"line\">\tb = a    </span><br><span class=\"line\">\ta = b + <span class=\"string\">'world'</span>    </span><br><span class=\"line\">\tprint(a)    </span><br><span class=\"line\">\tprint(b)</span><br><span class=\"line\">main()</span><br><span class=\"line\"><span class=\"comment\"># helloworld</span></span><br><span class=\"line\"><span class=\"comment\"># hello</span></span><br></pre></td></tr></table></figure>\n\n<p>四、TCP/IP协议分几层，TCP、UDP、HTTP分别在哪一层</p>\n<ul>\n<li>四层：网络接口层、网络层、传输层（TCP、UDP）、应用层（HTTP）</li>\n</ul>\n<p>五、</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">main</span><span class=\"params\">()</span>:</span>    </span><br><span class=\"line\">    <span class=\"keyword\">try</span>:        </span><br><span class=\"line\">        a = <span class=\"string\">'str'</span>        </span><br><span class=\"line\">        b = <span class=\"number\">123</span>        </span><br><span class=\"line\">        print(a + b)    </span><br><span class=\"line\">    <span class=\"keyword\">except</span>:        </span><br><span class=\"line\">        print(<span class=\"string\">'except'</span>)    </span><br><span class=\"line\">    <span class=\"keyword\">else</span>:        </span><br><span class=\"line\">        print(<span class=\"string\">'else'</span>)    </span><br><span class=\"line\">    <span class=\"keyword\">finally</span>:        </span><br><span class=\"line\">        print(<span class=\"string\">'finally'</span>)</span><br><span class=\"line\">main()</span><br><span class=\"line\"><span class=\"comment\"># except</span></span><br><span class=\"line\"><span class=\"comment\"># finally</span></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><ul>\n<li><p><strong>python中的魔法方法</strong></p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">__init__(self)\t<span class=\"comment\"># 在创建一个对象是默认被调用，不需要手动调用</span></span><br><span class=\"line\">__str__(self)\t<span class=\"comment\"># 用来显示信息，需要return一个数据</span></span><br><span class=\"line\">__del__(self)\t<span class=\"comment\"># 当删除对象时，默认被调用</span></span><br><span class=\"line\">__new__(self)\t<span class=\"comment\"># 才是实例化对象调用的第一个方法，它只取下 cls 参数，并把 其他参数传给 __init__</span></span><br><span class=\"line\">__call__(self)\t<span class=\"comment\"># 允许一个类的实例像函数一样被调用 。</span></span><br><span class=\"line\">__getitem__(self)\t\t<span class=\"comment\"># 定义获取容器中指定元素的行为，相当于 self[key] 。</span></span><br><span class=\"line\">__getattr__(self) \t<span class=\"comment\"># 定义当用户试图访问一个不存在属性的时候的行为 。</span></span><br><span class=\"line\">__setattr__(self) \t<span class=\"comment\"># 定义当一个属性被设置的时候的行为 。</span></span><br><span class=\"line\">__getattribute__(self) \t<span class=\"comment\"># 定义当一个属性被访问的时候的行为 。</span></span><br></pre></td></tr></table></figure>\n</li>\n<li><p><strong>可变与不可变类型</strong></p>\n<ul>\n<li><strong>指内存中的那块内容（value）是否可以发生改变</strong></li>\n<li>可变类型：不需要申请新内存，在原有基础上改变</li>\n<li>不可变类型：必须在内存中新申请一块区域</li>\n</ul>\n</li>\n<li><p><strong>冒泡排序</strong></p>\n</li>\n</ul>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">bubble_sort</span><span class=\"params\">(alist)</span>:</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> j <span class=\"keyword\">in</span> range(len(alist)<span class=\"number\">-1</span>, <span class=\"number\">0</span>, <span class=\"number\">-1</span>):</span><br><span class=\"line\">        <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> range(j):</span><br><span class=\"line\">            <span class=\"keyword\">if</span> alist[i] &gt; alist[i+<span class=\"number\">1</span>]:</span><br><span class=\"line\">                alist[i], alist[i+<span class=\"number\">1</span>] = alist[i+<span class=\"number\">1</span>], alist[i]</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li><p><strong>is和==的区别</strong></p>\n<ul>\n<li>都是对对象进行比较判断作用的</li>\n<li>==（比较运算法），用来判断两个对象的value值</li>\n<li>is（同一性运算符），用来判断两个对象的唯一身份标识，id地址</li>\n</ul>\n<p>只有<strong>数值型（-5~256）和字符串</strong>型的情况下，a is b才为True，当a和b是<strong>tuple，list，dict</strong>或<strong>set</strong>型时，a is b为False。 </p>\n</li>\n<li><p><strong>python默认递归限制1000or998</strong></p>\n<ul>\n<li><p>修改限制</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> sys</span><br><span class=\"line\">sys.setrecursionlimit(<span class=\"number\">1500</span>)</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n</li>\n<li><p><strong>数据量大情况下Paginator的缺点</strong></p>\n<ul>\n<li>查询效率慢的问题</li>\n<li><strong>PageHelper的分页功能是通过Limit拼接SQL实现的</strong> </li>\n</ul>\n</li>\n</ul>\n<h1 id=\"中科软总结\"><a href=\"#中科软总结\" class=\"headerlink\" title=\"中科软总结\"></a>中科软总结</h1><ul>\n<li><p>项目用了几台服务器</p>\n<table>\n<thead>\n<tr>\n<th align=\"center\">用途</th>\n<th align=\"center\">服务器</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\">Nginx反向代理和静态文件</td>\n<td align=\"center\">1</td>\n</tr>\n<tr>\n<td align=\"center\">主业务服务器</td>\n<td align=\"center\">1</td>\n</tr>\n<tr>\n<td align=\"center\">celery异步任务broker和worker</td>\n<td align=\"center\">2</td>\n</tr>\n<tr>\n<td align=\"center\">MySQL读写分离</td>\n<td align=\"center\">2</td>\n</tr>\n<tr>\n<td align=\"center\">redis</td>\n<td align=\"center\">1</td>\n</tr>\n<tr>\n<td align=\"center\"><strong>共计</strong>：</td>\n<td align=\"center\"><strong>7</strong></td>\n</tr>\n</tbody></table>\n</li>\n</ul>"}],"PostAsset":[],"PostCategory":[],"PostTag":[{"post_id":"ckfp5akee0001n8jhhqxb4qbx","tag_id":"ckfp5akei0003n8jhcumi390s","_id":"ckfp5akf00008n8jh7vylhiqd"},{"post_id":"ckfp5akf10009n8jhemmu272u","tag_id":"ckfp5akei0003n8jhcumi390s","_id":"ckfp5akf3000cn8jh1g3l7dsk"},{"post_id":"ckfp5akeg0002n8jh8n971q0s","tag_id":"ckfp5akez0007n8jh43azgazd","_id":"ckfp5akf4000en8jhbz907pem"},{"post_id":"ckfp5akf3000dn8jh2dge4ed3","tag_id":"ckfp5akei0003n8jhcumi390s","_id":"ckfp5akfe000hn8jh3yhp7xr0"},{"post_id":"ckfp5akej0004n8jh963s0v3f","tag_id":"ckfp5akf3000bn8jhf53o1tkf","_id":"ckfp5akff000jn8jhe1dbcpm9"},{"post_id":"ckfp5aker0005n8jh63ya2xtq","tag_id":"ckfp5akfe000gn8jh0pxy29r2","_id":"ckfp5akfk000nn8jh0gjv0n7w"},{"post_id":"ckfp5akff000kn8jhddcm5ujn","tag_id":"ckfp5akei0003n8jhcumi390s","_id":"ckfp5akfl000pn8jhgjuw1nzy"},{"post_id":"ckfp5akey0006n8jh6g0ja3ju","tag_id":"ckfp5akfg000ln8jhhpqb9iqe","_id":"ckfp5akfn000rn8jhd5bv0o8k"},{"post_id":"ckfp5akf2000an8jhh0bjavzl","tag_id":"ckfp5akfl000qn8jhf3pl4g27","_id":"ckfp5akfo000tn8jhf47q9o4k"},{"post_id":"ckfp5akf4000fn8jh48zqf762","tag_id":"ckfp5akfn000sn8jh87r09vj9","_id":"ckfp5akfq000vn8jhevj7bndc"},{"post_id":"ckfp5akfe000in8jhh8b893n3","tag_id":"ckfp5akfl000qn8jhf3pl4g27","_id":"ckfp5akfr000xn8jhgtupc4qd"},{"post_id":"ckfp5akfh000mn8jh44c2f4ka","tag_id":"ckfp5akfq000wn8jhc42u670t","_id":"ckfp5akfs000zn8jhggb1gdur"},{"post_id":"ckfp5akfk000on8jh12zo70sx","tag_id":"ckfp5akfs000yn8jh8nxsd9x8","_id":"ckfp5akfs0010n8jh0oj4aq50"},{"post_id":"ckfp5akg20011n8jhgr3sg5qe","tag_id":"ckfp5akez0007n8jh43azgazd","_id":"ckfp5akg70013n8jhetzs20zm"},{"post_id":"ckfp5akg50012n8jhciowes1w","tag_id":"ckfp5akf3000bn8jhf53o1tkf","_id":"ckfp5akg80015n8jh26zmfpvr"},{"post_id":"ckfp5akg70014n8jhe2ktcagp","tag_id":"ckfp5akei0003n8jhcumi390s","_id":"ckfp5akga0017n8jhh1tw0uyj"},{"post_id":"ckfp5akg80016n8jhewdb1kp8","tag_id":"ckfp5akf3000bn8jhf53o1tkf","_id":"ckfp5akgc0019n8jh7tr74967"},{"post_id":"ckfp5akga0018n8jhakiz12b6","tag_id":"ckfp5akgc001an8jh5vspbw5z","_id":"ckfp5akgd001bn8jhbgnkf06s"}],"Tag":[{"name":"Python","_id":"ckfp5akei0003n8jhcumi390s"},{"name":"tool","_id":"ckfp5akez0007n8jh43azgazd"},{"name":"Web","_id":"ckfp5akf3000bn8jhf53o1tkf"},{"name":"Linux","_id":"ckfp5akfe000gn8jh0pxy29r2"},{"name":"ES","_id":"ckfp5akfg000ln8jhhpqb9iqe"},{"name":"NoSQL","_id":"ckfp5akfl000qn8jhf3pl4g27"},{"name":"SQL","_id":"ckfp5akfn000sn8jh87r09vj9"},{"name":"Luck","_id":"ckfp5akfq000wn8jhc42u670t"},{"name":"测试","_id":"ckfp5akfs000yn8jh8nxsd9x8"},{"name":"web","_id":"ckfp5akgc001an8jh5vspbw5z"}]}}