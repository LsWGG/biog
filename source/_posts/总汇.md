---
title: 总汇
date: 2020-2-28 19:56:28
tags: web
top: 0
---

# （一）Flask与Django

- **轻量、简洁、扩展性强，，原生不支持数据库**
- 核心：werkzeug和jinja2

<!--more-->

|   房有居   | 用户模块、主页渲染、搜索房源信息功能及数据库的优化 |
| :--------: | :------------------------------------------------: |
| **食天下** |              **现菜谱展示、用户模块**              |
| **书香阁** |         **书刊列表展示、用户历史记录保存**         |

---

### Flask与Django对比

- 与Django对比
  - 不同点：
    1. Django：支持 ORM、认证、CSRF/模板、后台管理等。 
    2. Flask：自带jinja2模板，实现其它功能需要调用扩展包
  - 相同点：
    1.  性能都不⾼，都是单进程服务器。 

### MVT设计模式

设计模式：解决一类问题而总结出来的经验和套路

**MVC：**核心思想：分工、解耦，让不同代码之间降低耦合，增强代码的可扩展性和可移植性

**MVT：**

- M：模型 Model
- V：视图 View
- T：模板 Template

### 前后端不分离的区别

前后端不分离：

- 页面的控制和渲染是由后端实现的
  - 优点：页面展示无延迟，因为响应给用户的就是页面；方便实现搜索引擎排名，帮助爬虫服务器更高效率的爬取数据，即SEO
  - 缺点：对后端程序员要求高

前后端分离：

- 页面的控制和渲染是由前端实现的
  - 优点：后端程序员只需专注数据和业务即可
  - 缺点：有延迟，先加载页面 -- 发请求获取数据 -- 渲染
- 补充：前后端不分离，一般不做页面静态化，因为用户先拿到的就是静态页面

### Django信号

**Django 提供一个“信号分发器”，允许解耦的应用在框架的其它地方发生操作时会被通知到。信号允许特定的sender（发送者）通知一组receiver（接收者）某些操作已经发生。**

信号遵守的设计模式：**观察者设计模式（通知机制、监听机制）**

- [使用](https://handout-1300728887.cos.ap-beijing.myqcloud.com/%E8%AE%B2%E4%B9%89/%E6%80%9D%E7%BB%B4%E5%AF%BC%E5%9B%BE/Django%E4%BF%A1%E5%8F%B7.jpg)

### Django项目中的社会化分享

结合项目中使用：

- MobTech平台创建应用：https://www.mob.com/

  1. 注册登录
  2. 产品中心 --> 开发者平台
  3. 创建应用并添加产品和SDK
  4. 进入到<应用管理>查看App Key和App Secret

- 创建Django项目

- 根据开发文档集成ShareSDK

  - 进入文档中心，打开web集成文档

    https://www.mob.com/wiki/list

  - 根据开发文档集成ShareSDK，实现社会化分享功能

### Django自带的缓存cache和redis的区别

cache是python实现缓存的一种工具

redis是一种存放缓存数据的数据库

可以使用cache这个缓存工具，将缓存数据缓存到redis数据库

### 如何对Django框架进行二次开发，增大并发数

可能造成并发降低的原因：

1. 数据库操作变慢
2. python语言执行速度变慢

Django二次开发方向：

- 扩展Django Models使其支持Sharding（一种数据库分片技术）
- 手动关闭GC（垃圾回收）
- **把那些稳定且对性能最敏感的组件，使用c或c++来重写**

### 中间件的定义方式、结构

```python
def middleware_name(get_response):
    # 这个节点表示请求初始化：在最开始的时候补充额外逻辑
    def middleware(request):
        # 这个节点表示请求被执行前：在请求执行的时候补充额外逻辑
        response = get_response(request)
        # z这个节点表示响应之前：在响应之前补充额外逻辑
        return response
    return middleware
```

### [ORM（ **object-relation-mapping** ）](https://handout-1300728887.cos.ap-beijing.myqcloud.com/%E8%AE%B2%E4%B9%89/%E9%BB%91%E9%A9%AC%E5%A4%B4%E6%9D%A1%E9%A1%B9%E7%9B%AE%E8%AF%BE%E4%BB%B6/C02-Database/ORM.html)

- 对象关系映射 本质上就是将数据从一种形式转换到另外一种形式，定义的类相当于数据库中的表，在类中的定义的属性相当于是表中的字段，实例化的每一个对象，相当于的每一条数据。
  - 类 -> 表
  - 类属性 -> 字段
  - 类对象 -> 数据

- 作用：

  1. 省去编写sql语句，提⾼开发效率；

  2. 防注⼊攻击

  3. 适配不同的数据库。
- 缺点：查询效率较低，需要手动的优化。
- 操作方式：

  1. 先创建模型类，再迁移到数据库中：不能对数据库表的字段的定义，实现精确控制。 
  2. 使⽤sql创建数据库的表，定义模型类，通过模型类，实现ORM操作。 

---

#  （二）熟练 MySQL、Redis 等数据库的使用

### 1  [复制集与分布式](https://handout-1300728887.cos.ap-beijing.myqcloud.com/%E8%AE%B2%E4%B9%89/%E9%BB%91%E9%A9%AC%E5%A4%B4%E6%9D%A1%E9%A1%B9%E7%9B%AE%E8%AF%BE%E4%BB%B6/C02-Database/DatabaseTheory.html)

- 复制集：
  1. 数据库中数据相同，起到备份作用
  2. 高可用

- 分布式：
  1. 数据库中数据不同，共同组成完整的数据集合
  2. 高吞吐

### 2  主从复制

1. 主服务器的数据发生改变时，会将改变的记录写在本地二进制log日志中
2. 从服务器的一个线程会把更新的数据拷贝中继log日志中
3. 从服务器读取中继文件并执行，达到主从一致

 **利用主从在达到高可用的同时，也可以通过读写分离提供吞吐量。** 

### 3  [事务](https://handout-1300728887.cos.ap-beijing.myqcloud.com/%E8%AE%B2%E4%B9%89/python-web%E5%9F%BA%E7%A1%80(5.1.2%E7%89%88%E6%9C%AC)/mysqlhigh/%E4%BA%8B%E5%8A%A1.html)

- 四大特性：
  - 原子性：强调事务中的多个操作时一个整体
  - 一致性：强调数据库中不会保存不一致状态
  - 隔离性：强调数据库中事务之间相互不可见
  - 持久性：强调数据库能永久保存数据，一旦提交就不可撤销
- 隔离级别：
  - 读已提交：一个事务要等另一个事务提交后才能读取数据，可避免脏读的发生。
  - 读未提交：一个事务可以读取另一个未提交事务的数据，最低级别，任何情况都无法保证。
  - **可重复读(MySQL默认)**：就是在开始读取数据（事务开启）时，不再允许修改操作，可避免脏读、不可重复读的发生。
  - 串行化：最高的事务隔离级别，事务串行化顺序执行，可以避免脏读、不可重复读与幻读。效率抵消，耗性能

## 一、Mysql

### 1  [索引](https://handout-1300728887.cos.ap-beijing.myqcloud.com/%E8%AE%B2%E4%B9%89/python-web%E5%9F%BA%E7%A1%80(5.1.2%E7%89%88%E6%9C%AC)/mysqlhigh/%E7%B4%A2%E5%BC%95.html)

也叫“键”，保存数据库中所有记录的位置信息，相比于目录

优点：加快查询速度

缺点：耗费时间空间（不是越多越好）

**优化**

1. 不是越多越好，而是需要自己合理的使用

### 2  [sql语句优化](https://handout-1300728887.cos.ap-beijing.myqcloud.com/%E8%AE%B2%E4%B9%89/%E9%BB%91%E9%A9%AC%E5%A4%B4%E6%9D%A1%E9%A1%B9%E7%9B%AE%E8%AF%BE%E4%BB%B6/C02-Database/DatabaseOptimize.html)

- 1.避免全表扫描 
- 2.查询时使⽤select明确指明所要查询的字段，避免使⽤ select * 的操作； 
- 3.SQL语句尽量⼤写 
- 4.尽量避免在 where ⼦句中使⽤!=或<>操作符， 
- 5.遵循最左原则，在where⼦句中写查询条件时把索引字段放在前⾯ 
- 6.能使⽤关联查询解决的，尽量不要使⽤⼦查询 
- 7.能不使⽤关联查询的尽量不要使⽤关联查询 
- 8.不需要获取全表数据的时候，不要查询全表数据，使⽤LIMIT来限制数据 

### 3  数据库的优化

- 在进⾏表设计时，可适度增加冗余字段(反范式设计)，减少JOIN操作；
- 多字段表可以进⾏垂直分表优化，多数据表可以进⾏⽔平分表优化；
- 选择恰当的数据类型，如整型的选择；
- 对于强调快速读取的操作，可以考虑使⽤MyISAM数据库引擎；
- 对较频繁的作为查询条件的字段创建索引；唯⼀性太差的字段不适合单独创建索引，即使频繁作为查询条件；更新⾮常频繁的字段不适合创建索引；
- 编写SQL时使⽤上⾯的⽅式对SQL语句进⾏优化；
- 使⽤慢查询⼯具找出效率低下的SQL语句进⾏优化；
- 构建缓存，减少数据库磁盘操作；
- 可以考虑结合使⽤内存型数据库，如Redis，进⾏混合存储。

### 4  数据库存储过程与触发器

存储过程：完成特定功能的SOL语句集

触发器：对表进行（插入、删除、更新）触发一系列预定好的SQL语句

### 5  [数据库设计](https://handout-1300728887.cos.ap-beijing.myqcloud.com/%E8%AE%B2%E4%B9%89/%E9%BB%91%E9%A9%AC%E5%A4%B4%E6%9D%A1%E9%A1%B9%E7%9B%AE%E8%AF%BE%E4%BB%B6/C02-Database/DatabaseDesign.html)

库设计：

1. 数据库名要明确
2. 不同类型的数据分开管理

表设计：

1. 命名，业务表跟基础表区分，驼峰命名法
2. 词性分析法，**名词体现表或字段，动词体现关系**
   - 一对一、一对多、多对多
3. 不要用物理删除，以防后悔
4. 三范式：
   - 字段不可分割、原子性
   - 满足范式一，表有主键依赖
   - 满足范式二，表非主字段之间没有依赖关系。
5. 反范式：**利用冗余字段存储数据，节省数据查询的时间，本质是空间换时间。**
6. 字段类型、是否允许为null、是否有默认值
   - 整形：int长度并不影响精度，长度只和显示有关
     - **存储范围相同**
   - 字符串：char和varchar
     - char不可变，查询效率高，可能造成存储浪费
     - varchar可变，查询效率不如char，节省空间
7. 索引设计
   - 主键、外键、唯一约束；
   - key/value，提高查询效率的字段；
   - **外键：作用是维护数据的完整性。**
     - 应用：在实际开发项目过程中，用不用外键？
     - 建议：项目开发初期可以利用外键帮助维护数据的完整性，但是，项目的中后期，建议移除外键。
8. 数据库引擎（MySQL的核心）的选择：决定数据存储和增删改查方式，争对表
   - **InnoDB**（事务、安全能力）
     1. **支持事务，安全性级别较高，查询效率相对较低。**
     2. 为处理巨大数据量的最大性能设计
     3. **InnoDB支持外键完整性约束**
   - **MyISAM**（主要用来插入和查询）
     1. **不支持事务，插入、查询效率较高，增删改效率较低。**
     2. 产生三个文件（名字一表名字开始）：
        1. frm：文件存储表定义
        2. .MYD：数据文件
        3. .MYI：索引文件
   - **MEMORY**（存放临时数据）
     1. 将表中数据存储到内存中，未查询和引用其他表数据提供快速访问

#### 5.1  分库分表

**垂直拆分**

- 垂直分表："大表拆小表"，基于列字段进行，将不常用，数据较大，长度较长拆分
- 垂直分库：根据业务切分成不同的库

**水平拆分**

- 水平分表：针对数据量巨大的单张表， 按照某种规则（RANGE,HASH取模等），切分到多张表里面去,有IO瓶颈
- 水平分库分表：将表数据切分到多个服务器上，分布式，有效解决瓶颈、突破IO

**先垂直分在水平分**

##### 分库分表后面临的问题

- 事务支持
- 多库结果集合并
- 跨库join

**分库分表方案产品中间件**：官方MySQL Fabric、阿里TDDL，Cobar、360Atlas

### 6  SQL语句中where和having那个执行更快

SQL语句执行顺序：

`from -> where -> group by -> having -> select -> order by`

两者区别：

where：是一个约束声明，结果返回之前起作用，不能使用聚合函数

having：是一个过滤声明，过滤分组数据，只能用于group by，可以使用聚合函数

---

## 二、Redis

### 1  [Redis特点](https://handout-1300728887.cos.ap-beijing.myqcloud.com/%E8%AE%B2%E4%B9%89/%E9%BB%91%E9%A9%AC%E5%A4%B4%E6%9D%A1%E9%A1%B9%E7%9B%AE%E8%AF%BE%E4%BB%B6/C02-Database/Redis.html)

1. 速度快：C语言实现，存储在内存中以键值对形式保存
2. **持久化:**
   - redis可以将数据写入到磁盘中，在停机后，再次启动redis时，将磁盘中的备份数据加载到redis中
   - 两种机制：
     1. RDB快照持久化（默认开启）
        - 将内存中的数据存入磁盘
        - 缺点：一旦数据库出现问题，rdb文件数据不是全新的
     2. AOF追加文件持久化
        - 文件会变大，自动压缩
3. 多种数据结构：string  hash  list  set  zset
4. 支持多种编程语言
5. 支持事务、流水线、消息队列
6. [主从复制](https://handout-1300728887.cos.ap-beijing.myqcloud.com/%E8%AE%B2%E4%B9%89/redis%E8%AE%B2%E4%B9%89/redis%E8%AE%B2%E4%B9%89/redis/da-jian-zhu-cong.html)
7. 高可用、分布式

### 2  redis宕机

- slave从宕机

  - 重启后会自动加入到主从架构中，完成数据同步

- master主宕机（主从都没持久化）

  1. 不要立马重启服务
  2. slave执行`SLAVEOF ON ONE`断开主从关系并升级为主库
  3. 重启主，`SLAVEOF`设为从

  可使用简单方法：**哨兵**

### 3  redis高可用

**提供了主从同步＋哨兵机制（ Sentinel ）**

- 哨兵机制：实现故障转移，当检测到主服务器发生故障时，把从服务器升级为主，保证数据正常使用
  - 原理：心跳机制＋投票裁决＋故障转移
    - 定时给master/slave发送消息，若指定时间内无响应（主观宕机 SDOWN）
    - Sentinel群都报告某一master无响应（客观宕机 SDOWN）
    - 通过一定vote算法，将从升为主

### 4  为什么Redis比MySQL快

|            |     Redis      |          MySQL           |
| :--------: | :------------: | :----------------------: |
|  数据格式  |      k-v       |          B+TREE          |
| 时间复杂度 | 0(1)（常数阶） |    0(logn)（对数阶）     |
|  存储位置  | 从内存直接取出 | 磁盘表（全局扫或索引查） |

Redis是单线程的多路复用IO，单线程避免线程切换开销；多路复用避免IO等待开销；多核处理器下对数据进行分区，各处理器处理不同的数据（分着干）

## 三、缓存

### 1  有效期TTL（Time to live）

- 作用：
  - 节省空间
  - 做到数据有效性，失效后，做到数据一致性

#### 1.1  过期策略

- 定时过期：时间一到立即清除，对内存友好，但会占用大量CPU资源
- 惰性过期：当访问时才去判断是否过期，节省CPU，占用内存
- 定期过期：每隔一段时间，随机清除

 **Redis中同时使用了惰性过期和定期过期两种过期策略。** 

#### 1.2  缓存淘汰 （eviction）

-  LRU（Least recently used，最近最少使用）
   -  新数据插入到表头部
   -  缓存命中时，将其移到头部
   -  缓存满的时候将尾部的数据丢掉
-  LFU（Least Frequently Used 最近最少使用算法）
   -  如果数据在一段时间内使用次数很少，那么将来也会很少

### 2  缓存模式

- **先更新数据库，再删除缓存** 

#### 2.1  缓存穿透

- 频繁请求缓存中不存在的数据，增大数据库压力

  - 解决方案：
    1. 返回缓存伪造数据
    2. 限制请求参数
    3. 借助第三方过滤器：布隆过滤器...

- 布隆过滤器

  本质上是一种**概率型数据结构， 由一个很长的bit数组和一系列哈希函数组成的 **

  特点：**高效地插入和查询**

  算法的核心： **某样东西一定不存在或者可能存在**

  缺点：**数据只能插入不能删除**

  - 存储原理：经过多次不同维度的hash计算，将数据映射到二进制向量里
  - 服务流程：
    1. 当用户访问时，去布隆过滤器中判断key值是否存在，否则直接返回
    2. 如果key值存在，则访问redis，由于存在误判率，redis中也可能不存在
    3. 再访问数据库，若也不存在，直接返回空

![](https://img-blog.csdnimg.cn/20190306043938625.?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0lUX3Rvd25sZXQ=,size_16,color_FFFFFF,t_70)

#### 2.2  缓存雪崩

- 同一时间内，大量缓存失效，造成数据库压力剧增
  - 解决方案：
    1. 设置不同的有效期值
    2. 采用多级缓存
    3. 利用加锁或者队列

---

#  （三）[版本控制管理工具 Git](https://learngitbranching.js.org/)

### 一、常用命令

- 克隆远程库	`git clone 地址`
- 添加到暂存    `git add .`
- 提交暂存区的文件到本地仓库    `git commit -m 'test'`
- 拉取    `git pull origin <name>`
- 推送    `git push origin <name>`
- 查看仓库当前的状态    `git status`
- 查看远程库信息    `git remote`
- 查看当前分支    `git branch` 
- 切换分支    `git checkout <name>`
- 合并分支到当前分支    `git merge <name>`

---

# （四）熟悉 Celery 异步方案，多线程、多进程的使用

celery是异步任务的调度工具，主要解决耗时任务，通过**消息队列**在客户端与消费者间协调

- 消息中间件（消息队列Broker）：客户端把任务放入队列中，消费者从队列中取出任务执行，第三方队列服务：RabbitMQ\redis\kafka\MetaMQ\RocketMQ
  - **RabbitMQ：**是一个消息代理。工作是接收和转发消息类似邮局，处理消息
    - 异步消息：支持多种传递协议，消息排队，传递确认，到队列的灵活路由，多种交换类型
    - 分布式部署：部署为集群以实现高可用和吞吐量
    - 可靠性：可在性能和可靠性之间进行权衡
    - 灵活的路由：通过交换机进行路由
    - 多协议：多种消息协议的消息传递
    - 管理与监控：HTTP-API，命令行工具
  - **基本慨念：**
    - Producer：生产者，投递消息的程序：创建消息（消息体和标签），RabbitMQ会根据标签把消息发送给消费者
    - Consumer：消费者，接收消息的程序：丢弃标签，消费消息体
    - Broker：消息中间件的服务节点：RabbitMQ服务实例
    - Queue：队列：内部对象，用于存储信息，生产者投递，消费者取出消费
    - Xchange：交换器。指定消息按什么规则，路由到哪个队列，如果路由不到或返回或丢弃
    - RoutingKey：路由键关键字，Xchange根据此来进行邮递，需要与交换器类型和绑定键联合使用，决定消息流向哪里
    - Binding：绑定，把Xchange和Queue按照路由规则绑定起来，指定绑定键（BindingKey）
- 任务执行单元（消费者worker）：可以有多个并发，实时监控消息队列，获取任务并执行它
- 任务执行结果存储（task result store）：由于是由主任务中解耦出来的，主任务想要知道执行结果，必须通过中间件存储

### 1  消息队列的理解

**消息队列**：保存消息的容器

消息:传输的数据单位

消息源与目标间的中间人，主要目的是**提供路由保证消息的传递**，

### 2  为什么使用消息队列

在高并发情况下，来不及同步处理，请求会发生堵塞。通过消息队列，可以异步处理请求，缓解系统压力

应用场景：

- 异步处理、应用解耦、流量削锋和消息通讯等  

**使用消息队列，把不是必须的业务逻辑，异步处理**

消息队列的缺点：

- 系统可用性降低
- 系统复杂性提高
- 一致性问题

### 3  多线程在web中的使用

一般在使用IO操作时

使用场景：

- 需要并行操作几个文件的读写，同步不能异步的情况下
- 视图中需要多个第三方接口
- 订单提交后，修改库存销量

### 4  为什么使用celery而不使用线程发送耗时任务

因为并发量较大的时候，线程切换会有开销时间，也会降低并发的数量、共享数据维护麻烦

celery是通过消息队列进行异步任务处理，不用担心并发量高是负载过大，也可以处理复杂系统性能问题，相对灵活

### 5  处理抢购高并发

1. 将请求尽量拦截在上游
2. 充分利用缓存

前端方面：

- 把详情页部署到CDN节点上，做页面静态化处理
  - CDN：内容分发网络，将源站内容分发到离用户最近的节点，提高访问速度
- 禁止重复提交请求、对用户请求限流

后端方面：

- 根据用户id限制访问频率
- 缓存的应用

### 6  如何解决celery队列阻塞问题

- 队列阻塞的原因：

  1. 队列中有耗时任务，且任务量大于celery并发数（Celery没有足够的worker去执行耗时任务）
  2. 队列中有耗时任务，且Celery启动了**预取机制**
     - 任务会有指定的worker去执行，就算其worker是空闲状态，也不会执行其它任务

- 解决：

  - **指定进程数**

    `celery -A project worker --concurrency=4`

  - **改变进程池方式为协程方式**

    `pip install eventlet `
  
    `celery -A project worker -P eventlet -c 1000`
  
  - **增加并发数**
  
  `celery -A project worker -n 进程名字 --concurrencu=并发数 -l info`
  
  - **取消预取机制**
  
    ```python
    # 任务发送完成时是否需要确认，对性能会稍有影响
    celery_app.conf.CELERY_LATE = True
    # Celery worker每次去队列取任务的数量，默认值为4
    celery_app.conf.CELERY_PREFETCH_MULTIPLIER = 1
    ```
  
    `celery -A project worker -n 进程名字 -Ofair -l info`
  
  - **错误重试机制**
  
    ```python
    # 重连时间间隔
    @celery_app.task(bind=True, retry_backoff=3)
    try:
        ...
    except Exception as e:
        # 有异常自动重连三次
        raise self.retry(exc=e, max_retries=3)
    ```

### 7  [进程和线程的对比](https://handout-1300728887.cos.ap-beijing.myqcloud.com/%E8%AE%B2%E4%B9%89/python-web%E5%9F%BA%E7%A1%80(5.1.2%E7%89%88%E6%9C%AC)/multitasking/%E8%BF%9B%E7%A8%8B%E5%92%8C%E7%BA%BF%E7%A8%8B%E5%AF%B9%E6%AF%94.html)

进程：CPU的一种执行单元

- 密集CPU任务（大量并行计算）

线程：进程执行程序的最小调度单位

- 密集I/O任务

协程：微线程，可以在单线程上执行多个任务，用函数切换，开销极小

#### 关系对比

1. 线程是依附在进程里面的，没有进程就没有线程
2. 一个进程默认提供一条线程，进程可以创建多个线程

#### 区别对比

1. 进程之间不共享全局变量
2. 线程之间共享全局变量，但是要注意资源竞争的问题，解决办法: 互斥锁或者线程同步
3. 创建进程的资源开销要比创建线程的资源开销要大
4. 进程是操作系统资源分配的基本单位，线程是CPU调度的基本单位
5. 线程不能够独立执行，必须依存在进程中
6. 多进程开发比单进程多线程开发稳定性要强

#### 优缺点

- 进程优缺点:
  - 优点：可以用多核
  - 缺点：资源开销大
- 线程优缺点:
  - 优点：资源开销小
  - 缺点：不能使用多核做到高并行

---

#  （五）熟悉 TCP/[HTTP](https://handout-1300728887.cos.ap-beijing.myqcloud.com/%E8%AE%B2%E4%B9%89/python-web%E5%9F%BA%E7%A1%80(5.1.2%E7%89%88%E6%9C%AC)/http/HTTP%E5%8D%8F%E8%AE%AE.html) 协议等网络知识

TDP：用户数据报协议，无连接的

**TCP：传输控制协议，面向连接的、可靠的、基于字节流的传输层通信协议**

HTTP：超文本传输协议，浏览器和web服务器通信需要HTTP协议 

RPC：远程过程调用，向另一台计算机上的程序请求服务，不需要了解底层网络技术的协议。

## 一、[网络协议分层](https://www.jianshu.com/p/30fb2b0bcfd8)

![](https://tupian-1300728887.cos.ap-chengdu.myqcloud.com/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE%E5%88%86%E5%B1%82.png)

### 1  乐观锁

每次拿数据的时候都认为别人不会修改，所以不会上锁

在更新的时候判断此时的库存是否是之前查询出的库存，如果相同，表示没人修改，可以更新库存，否则表示别人抢过资源，不再执行库存更新

**实现方式：**利用时间戳、数据版本version字段，数据被修改＋1

使用场景：高并发，减少数据冲突，保证数据一致性

### 2  高并发，分布式

处理网站并发量

1. 减少数据库访问次数
2. 文件和数据库分离（静态化页面）
3. 大数据分布式存储（主从配置读写分离）
4. 服务器集群，负载均衡
5. 页面缓存的使用
6. 内存数据库代替关系型数据库

例子：省市区三级联动、首页部分数据（广告）局部缓存

分布式案例

1. MySQL主从配置读写分离

### 3  长连接与短连接

长连接：连接 -> 传输数据 -> 保持连接 -> 传输数据 -> 直到一方断开

- 操作频繁、点对点的通讯、数据库连接
  - TCP三握手时间
  - 不安全

短连接：连接 -> 传输数据-> 断开连接

- http服务

### 4  token和jwt存在什么区别

token需要查库验证，JWT直接在服务端进行，不需要查库

### 5  [三次握手和四次挥手](https://blog.csdn.net/qq_38950316/article/details/81087809)

三次挥手：

1. 建立连接时，客户端发送syn包（seq=x）到服务器，并进入SYN_SENT（发送）状态，等待服务器确认；
2. 服务器收到syn包，必须确认客户的SYN（ack=x+1），同时自己也发送一个SYN包（seq=y），即SYN+ACK包，此时服务器进入SYN_RECV（收到）状态；
3. 客户端收到服务器的SYN+ACK包，向服务器发送确认包ACK(ack=y+1），此包发送完毕，客户端和服务器进入ESTABLISHED（TCP连接成功）状态，完成三次握手。

四次挥手：

### 6  [CSRF攻击](https://handout-1300728887.cos.ap-beijing.myqcloud.com/%E8%AE%B2%E4%B9%89/Django%E6%A1%86%E6%9E%B6/Django%E6%A1%86%E6%9E%B6/C05-Template/csrf.html)

1. 浏览并登录信任网站A
2. 验证通过，产生A的Cookie
3. 再没登出的情况下，浏览**攻击网站B**
4. B要求访问第三方网站A
5. 根据B的请求，浏览器带着A的Cookie访问A
6. A不知道请求源，因为浏览器会自动携带用户的Cookie，按需处理请求，达到模拟用户操作csrf攻击

**防止csrf攻击**

1. 在后端响应的cookie写入csrf_token值
2. 前端from表单中也写入csrf_token值
3. 获取两个csrf_token，看是否一致

Django自带的防csrf中间间

**跨站请求伪造**：攻击者盗用你的身份，发送恶意请求

### 7  RESTFul思想

- 每一个URI代表1种资源；

- 客户端使用GET、POST、PUT、DELETE4个表示操作方式的动词对服务端资源进行操作：GET用来获取资源，POST用来新建资源（也可以用于更新资源），PUT用来更新资源，DELETE用来删除资源；

- 通过操作资源的表现形式来操作资源；

- 资源的表现形式是XML或者HTML；

- 客户端与服务端之间的交互在请求之间是无状态的，从客户端到服务端的每个请求都必须包含理解请求所必需的信息。

---

# （六）[使用腾讯云存储方案](https://cloud.tencent.com/document/product/436)

腾讯对象存储服务（COS）通过网络随时存储和调用各种数据文件

1. 创建一个或多个存储同，上传文件
2. 根据地址可上传和下载
3. 可设置相应属性及访问权限
4. 下载SDK包，执行相应操作

# （七）[熟悉 Linux 系统](https://handout-1300728887.cos.ap-beijing.myqcloud.com/%E8%AE%B2%E4%B9%89/%E7%AC%94%E8%AE%B0/Linux%E5%9F%BA%E7%A1%80%E5%91%BD%E4%BB%A4.html)，了解 Docker、Elasticsearch

### 1  [Docker](http://www.docker.org.cn/index.html)

**开源的软件部署解决方案、轻量级的应用容器框架，采用C/S架构，其可以轻松的为任何应用创建一个轻量级的、可移植的、自给自足的容器。**

> 是一种快速解决生产问题的一种技术手段。

优缺点：

- 优：
  - 多： 适用场景多
  - 快： 环境部署快、更新快
  - 好： 好多人在用，东西好
  - 省： 省钱省力省人工(123原则)
- 缺：
  - 太腻歪人： 依赖操作系统
  - 不善于沟通：依赖网络
  - 不善理财： 银行U盾等场景不能用

**镜像**

- 类似虚拟机的镜像，可以创建新的容器

```dockerfile
# 镜像
docker search [image_name]			# 搜索镜像
docker pull [image_name]			# 获取镜像
docker images						# 查看镜像
docker history [image_name]			# 查看镜像历史
docker tag [old_image]:[old_version]	# 重命名
docker rm [image_name]				# 删除
docker save -o [包文件] [镜像]		# 导出镜像
docker load -i [image.tar_name]		# 导入镜像
```

**容器**

- 由镜像创建的运行实例，类似虚拟机

```dockerfile
# 容器
docker ps								# 查看容器
docker start [container_id]				# 启动已终止的容器
docker stop [container_id]				# 关闭
docker rm [container_id]				# 删除
		-f		# 强制删除
docker run [docker_image] /bin/bash
		--name	# 给容器定义一个名称
		-i 		# 让容器的标准输入保持打开。
		-t		# 分配一个伪终端,并绑定到容器的标准输入上
		-d 		# 守护进程开启
		-v		# 本地:容器 --映射
		-p  	# 端口映射
docker exec -it 容器id /bin/bash			# 进入后台运行容器
docker commit [container_id] [new_image:tag]	# 基于容器创建镜像
		-m 		# '改动信息' 
		-a 		# "作者信息"
docker logs [容器id]					# 查看运行日志
docker inspect  [容器id]				# 查看详细信息
```

**仓库（公有、私有、本地）**

- 托管镜像

#### 1.1 dockerflie

 Dockerfile类似于我们学习过的脚本，将我们在上面学到的镜像，使用自动化的方式实现出来。

```dockerfile
# 基础指令
FROM <image>					# 第一条指令（除首行注释外）
MAINTAINER <name>				# 作者信息
RUN <command>					# 镜像构建时候运行的命令
EXPOSE <port>					# 对外开发端口
ENTRYPOINT python3 manage.py runserver 0.0.0.0:8000
								# 运行Django项目，只能有一个

# 文件编辑指令
ADD <src>... <dest>		# 将指定的 <src> 文件复制到容器文件系统中的 <dest>
COPY <src>... <dest>			# 复制文件

# 环境指令
ENV <key> <value>				# 设置环境变量
WORKDIR /path/to/workdir		# 切换目录
```

### 2  es的存储底层原理

**集群：**es可以作为独立的单个搜索引擎，为了处理大型数据集，实现容错和高可用性，es可以运行在许多合作的服务器上，这些服务器的集合称为集群

**节点：**形成集群的每个服务器

**分片：**数据可以分为较小的分片，放到不同的服务器上，分布式处理。而应用程序并不知道分片的存在

**副本：**复制集原理，其中之一被选择更改索引操作（主分片），主废副升，不能在同一个节点上

**es扩容：**

- 垂直：采购更强大的服务器
- 水平：采购更多的不同服务器

### 3  [使用 Haystack 调用 Elasticsearch](https://handout-1300728887.cos.ap-beijing.myqcloud.com/%E8%AE%B2%E4%B9%89/%E7%BE%8E%E5%A4%9A%E5%95%86%E5%9F%8E%E8%AE%B2%E4%B9%89/goods/goods-search/haystack-create-index.html)

**Elasticsearch是基于Lucene库实时的分布式搜索分析引擎，全文检索、结构化搜索、分析这三功能的组合**

**全文检索引擎：对数据库里的数据先进行一遍预处理，从而生成索引结构数据（类似于字典那样的结构数据），再使用关键字在索引数据中检索数据**

属于面向文档的数据库

Elasticsearch是远端服务器开启的服务

需要用Haystack调用搜索引擎

1. 安装：

   `pip install django-haystack`

   `pip install elasticsearch==2.4.1`

2. 注册到应用

```python
INSTALLED_APPS = [
    'haystack', # 全文检索
]
url(r'^search/', include('haystack.urls')),
```

3.  配置

```python
# Haystack
HAYSTACK_CONNECTIONS = {
    'default': {
        'ENGINE': 'haystack.backends.elasticsearch_backend.ElasticsearchSearchEngine',
        'URL': 'http://192.168.103.158:9200/', # Elasticsearch服务器ip地址，端口号固定为9200
        'INDEX_NAME': 'meiduo_mall', # Elasticsearch建立的索引库的名称
    },
}

# 当添加、修改、删除数据时，自动生成索引
HAYSTACK_SIGNAL_PROCESSOR = 'haystack.signals.RealtimeSignalProcessor'
```

4. 创建索引类：search_indexes.py

5. 创建txt字段索引值模板文件

6. 手动生成索引（仅第一次）

   `python manage.py rebuild_index`

- 常见问题：

  1. 如何实现分页功能
     - HAYSTACK_SEARCH_RESULTS_PER_PAGE = 5

  2. No module named haystack
     - 是否安装/注册了haystack模板

  3. 在html页面出现No serults found
     - 是否创建了search_indexes.py文件
     - 数据库中是否有数据

### 3  es是怎么跟数据库关联起来的

Logstash是一个开源数据收集引擎，具有实时管道功能。可以动态得将来自不同数据源的数据统一起来，并将数据标准化到你所选择的目的地

### 4  es倒排索引和常用API

倒排索引：也称反向索引，根据单词查找文档

正向索引：存储每个文档单词的列表

- es常用的api
  - [查询](https://handout-1300728887.cos.ap-beijing.myqcloud.com/%E8%AE%B2%E4%B9%89/%E9%BB%91%E9%A9%AC%E5%A4%B4%E6%9D%A1%E9%A1%B9%E7%9B%AE%E8%AF%BE%E4%BB%B6/C10-Elasticsearch/Query.html)

# （八）首页静态化、定时任务

**静态化与缓存的主要区别**

- 静态化：将数据静态化到页面，客户端访问时不查询数据库，存储与硬盘

- 缓存：将数据存储于服务器内存

**定时任务的原理**

- 由**crond守护进程**和**crontab文件（任务表）**组成

- 守护进程在系统启动时由init进程启动，受init监视，如果它挂了，init会重启它守护进程每分钟唤醒一次，通过检查crontab文件判断需要做什么

  ```bash
  # 添加定时任务到系统中
  $ python manage.py crontab add
  
  # 显示已激活的定时任务
  $ python manage.py crontab show
  
  # 移除定时任务
  $ python manage.py crontab remove
  ```

**支付宝接入：** 

- Python支付宝SDK：https://github.com/fzlee/alipay/blob/master/README.zh-hans.md 

# （九）部署相关

## 1  [nginx](https://handout-1300728887.cos.ap-beijing.myqcloud.com/%E8%AE%B2%E4%B9%89/%E9%A1%B9%E7%9B%AE%E9%83%A8%E7%BD%B2/nginx/Advanced.html)

**是一个高性能的HTTP和反向代理服务器，主要处理静态资源**

### 1.1  [反向代理](https://handout-1300728887.cos.ap-beijing.myqcloud.com/%E8%AE%B2%E4%B9%89/%E9%A1%B9%E7%9B%AE%E9%83%A8%E7%BD%B2/nginx/nginx-reverse.html)

正向代理： 为局域网**客户端**向外访问Internet服务**（代理用户，隐藏客户端）**

反向代理： 为局域网**服务器**向外提供Internet服务**（代理服务器，隐藏服务器）**

### 1.2  [负载均衡](https://handout-1300728887.cos.ap-beijing.myqcloud.com/%E8%AE%B2%E4%B9%89/%E9%A1%B9%E7%9B%AE%E9%83%A8%E7%BD%B2/nginx/nginx-load.html)

有一台服务器充当调度者的身份（负载均衡器），请求先到达它，再根据每台服务器的负载情况分配请求

1. 内置策略：nginx自带算法
   - 雨露均沾型：轮训（默认）、加权轮训、哈希
     - 轮训：按顺序逐一分配
     - 加权轮训：权重越大，被分配几率越高，适用于服务器性能不均衡情况
   - 定向服务型：ip_hash、least_conn、cookie、route、lean
     - ip_hash：按访问IP的哈希结果分配请求，分配后访客访问固定后端服务器，有效的解决动态网页会话共享问题。
   - 商业类型：ntlm、least_time、queue、stick
3. 第三方算法：fair、url_hash
   - fair：基于后端服务器的响应时间来分配请求，响应时间短的优先分配。
   - url_hash：按访问的哈希结果分配请求，使同定向到同一台后端服务器，可提高后端缓存服务器的效率。

### 1.3  提供静态文件

静态文件收集命令：`python mange.py collectstatic`

### 1.4  WSGI

- WSGI是一种通信协议， Web 服务器(uWSGI)与 Web 应用程序或应用框架(Django)之间的一种低级别的接口
- uwsgi是一种线路协议我不是一种通信协议，常用于在uWSGI服务器于其他网络服务器的数据通信
- uWSGI是实现了uwsgi和WSGI两种协议的Web服务器，**主要处理动态资源**

## 2  [gunicorn](https://handout-1300728887.cos.ap-beijing.myqcloud.com/%E8%AE%B2%E4%B9%89/%E9%BB%91%E9%A9%AC%E5%A4%B4%E6%9D%A1%E9%A1%B9%E7%9B%AE%E8%AF%BE%E4%BB%B6/C12-Deployment/Gunicorn.html)

安装：`pip install gunicorn`

查看使用信息：`$gunicorn -h`

直接运行：`gunicorn 运行文件名称：flask程序实例名`

指定进程和端口号：`$gunicorn -w 4 -b 127.0.0.1:5001 运行文件名称:Flask程序实例名`

# 支付流程

![](https://tupian-1300728887.cos.ap-chengdu.myqcloud.com/%E5%85%AC%E7%A7%81%E9%92%A5.png)

- 生成密钥

```bash
openssl		# 进入环境
genrsa -out app_private_key.pem 2048	# 私钥
rsa -in app_private_key.pem -pubout -out app_pubout_key.pem		# 公钥
```

# 极睿科技总结

## 一、装饰器

作用：在不改变已有函数源代码及调用方式的前提下，对已有函数进行功能的扩展

```python
# 不改变原有函数__name__\备注信息
from functools import wraps
def check(fu):  # fu:目标函数
    
    @wraps(fu)
    def inner():
        '''执行函数之前'''
        fu()
        '''执行函数之后'''
    return inner

# 语法糖写法
@check
def comment():
    print('发表评论')
    
comment()
# check等价与  comment = check(comment)
```

## 二、数据结构与算法

数据：能够被计算机处理的符号或符号集

数据元素（节点、记录）：数据的基本单位。例：学生统计表

数据项（字段、域）：组成数据元素的最小单位。例：编号、姓名、性别等

### 1  数据结构

**相互之间存在的一种或多种特定的数据元素的集合用于计算机存储、组织数据的方式**

![](https://tupian-1300728887.cos.ap-chengdu.myqcloud.com/1.jpg)

#### 1.1  逻辑结构

**数据元素间的抽象关系（如近邻关系、从属关系等），分为线性结构与非线性结构，**抽象出来的，与机器无关

![](https://tupian-1300728887.cos.ap-chengdu.myqcloud.com/2.png)

| 结构类型 | 数据元素间的相互关系 |
| :------: | :------------------: |
|   集合   |          无          |
|   线性   |        一对一        |
|   树形   |        一对多        |
|    图    |        多对多        |

#### 1.2  （存储）物理结构

**数据在计算机中的存放方式，反应数据元素间的逻辑关系**

- 顺序存储（向量存储）：把数据元素存放在一组存储地址连续的存储单元里，逻辑关系和物理关系是一致的
- 链式存储（动态存储）：通过指针反应数据间的逻辑关系
- 索引存储：建立一个附加的索引表
- 散列存储：根据节点的关键字直接计算出该节点的存储地址

> 同一逻辑结构可以对应不同的存储结构，算法的设计取决于数据的逻辑结构，而算法实现依赖于指定的存储结构

### 2  算法

**解决特定问题的一种方法或一种描述**

#### 2.1  数据结构和算法的联系

程序=算法+数据结构

- 算法设计: 取决于选定的逻辑结构
- 算法实现: 依赖于采用的存储结构

区别：

- 数据结构关注的是**数据的逻辑结构、存储结构的基本操作**
- 算法关注的是**在数据结构的基础上解决实际问题**

算法的五大特性：

1. 可行性：解决具体问题，完成期望功能
2. 确定性：每一步在一定条件下只有一条执行路径
3. 有穷性： 算法执行的步骤（或规则）是有限的
4. 输入：具有零或多个输入
5. 输出：至少有一个或多个输出

评价算法好坏的方法：

- 正确性：运行正确是一个算法的前提。
- 可读性：容易理解、容易编程和调试、容易维护。
- 健壮性：考虑情况全面，不容以出现运行错误。
- 时间效率高：算法消耗的时间少。
- 储存量低：占用较少的存储空间。

#### 2.2  时间复杂度O(n)

计算规则

1. 基本操作，只有**常数项O(1)**
2. 顺序结构，按**加法计算**
3. 循环结构，按**乘法计算**
4. 分支结构，**取最大值**

#### 2.3  空间复杂度S(n)

**一个算法在运行过程中临时占用存储空间大小的度量**

## 三、线性数据结构

特点：在数据元素的非空有限集合中

- 存在唯一的（第一个--最后一个）数据元素
- 且第一个元素没有直接前驱元素，最后一个元素没有直接后继元素，其他元素都有唯一的前驱和后继元素

### 1  线性表

- 线性表有顺序存储结构和链式存储结构。

#### 1.1  顺序存储结构（顺序表）

**是指将线性表中的各个元素依次存放在一组地址连续的存储单元中，通常将这种方法存储的线性表称为顺序表。**
顺序表的优缺点：

- 优：无须关心表中元素之间的关系，所以不用增加额外的存储空间；可以快速地取表中任意位置的元素。
- 缺：插入和删除需要移动大量元素

#### 1.2  线性表的链式存储（链表）

一组任意的连续或非连续存储单元存储线性表的元素，存储元素本身（数据域）和后继元素地址（指针域)	

- 链表与顺序表的对比

  |        |    存储方式    |           时间性能           |       空间性能       |
  | :----: | :------------: | :--------------------------: | :------------------: |
  | 顺序表 | 连续的存储单元 | 查找：O(1)；插入、删除：O(n) |     预先分配空间     |
  | 单链表 | 任意的存储单元 | 查找：O(n)；插入、删除：O(1) | 不用估计预用空间大小 |

循环单链表：首尾相连的一种单链表，最后一个结点称为：尾指针：rear

双向链表： 链表中的每个结点有两个指针域，一个指向直接前驱结点，另一个指向直接后继结点。 data -- prior -- next 

### 2  栈和队列

#### 2.1  栈

**限制在表一端进行插入（入栈）和删除（出栈）操作的线性表**

- 栈顶：允许操作端

- 栈底：固定端

> 先进后出

##### 2.1.1  栈的存储结构

栈是运算受限的线性表，线性表的存储结构对栈也适用

1. 顺序栈
2. 链栈

#### 2.2  队列

**插入（队尾）在表一段，删除（对头）在表的另一端**

> 先进先出

##### 2.2.1  队列的存储结构

队列也是一种运算受限的线性表

- 顺序队列
- 链队列

小结：

1. 链式栈的栈顶应在链头，插入与删除操作都在链头进行。
2. 循环队列要注意对空条件和对满条件；而对于链队列，需要特别注意出队仅对队头指针操作，当只有一个元素时，出队需要修改队尾指针。
3. 递归实质上是通过栈来实现函数调用，只不过是调用自身而已。

### 3  字符串和数组

#### 3.1  字符串

 串（String）是由零个或多个任意字符串组成的字符序列。 

##### 3.1.1  串的存储结构

- 定长顺序存储结构（顺序串）
  - 定长是指按预定义的大小为每一个串变量分配固定长度的存储区。 最大不能超过256
- 堆分配存储结构

#### 3.2 数组

 **结构中的元素本身可以是具有某种结构的数据，但属于同一数据类型，一般线性表的扩充**

是一个具有固定格式和数量的数据有续集，一旦被定义就不再改变，两种基本运算：

1. 取值操作：给定一组下标，读其对应的数据元素。
2. 赋值操作：给定一组下标，存储或修改与其相对应的数据元素。

##### 3.2.1  数组的存储结构

一维：顺序存储结构，直接按其下标顺序分配存储空间

多维：按某种次序将数组中元素排成一个线性序列，再作存储

存二维数组：

1. 先行后列
2. 先列后行

##### 3.2.2  稀疏矩阵

**矩阵中大多数元素为零元素的矩阵，按常规分配方法浪费内存**

三元组表存储

- 非零元素所在行、列及值构成一个三元组（i,j,v）

## 四、非线性结构

### 1  树和二叉树

前驱唯一而后继不唯一，一对多

定义：树（tree）是n（n>=0）个结点的有限集合。当n=0时，该集合满足以下条件：

- 只有一个特殊节点称为根节点（root）

- 当n>1时，其余n-1个结点被分成m(m>0)个互相不相交的集合，称为根节点的**子树**

  树的定义用了递归概念，其算法也常常使用递归

#### 1.1  二叉树

二叉树是每个节点最多有两个子树的树结构。通常子树被称作“左子树”（left subtree）和“右子树”（right subtree）

满二叉树：除了叶结点外每一个结点都有左右子叶且叶子结点都处在最底层的二叉树。 

##### 1.1.1  存储结构

顺序存储结构：按照二叉树结点从上至下、从左到右的顺序存储。

链式存储结构：每个节点由三个域组成：数据域和左、右指针域。

![](https://img-blog.csdnimg.cn/20181214150636793.jpeg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2NzZG5fYWl5YW5n,size_16,color_FFFFFF,t_70)

##### 1.1.2  二叉树遍历

**深度优先一般用递归，广度优先一般用队列。一般情况下能用递归实现的算法大部分也能用堆栈来实现。**

1. 深度优先遍历
   1. 先序遍历	` 根节点->左子树->右子树 `
   2. 中序遍历    ` 左子树->根节点->右子树 `
   3. 后序遍历    ` 左子树->右子树->根节点 `
2. 广度优先遍历（层次遍历）
   -  从树的root开始，从上到下从从左到右遍历整个树的节点 

### 2  图

任意两个结点之间都可能相关，即结点之间的邻接关系可以是任意的。

## 五、排序和搜索

### 1  冒泡排序

**重复遍历数列，一次比较两个元素**

![冒泡排序](https://tupian-1300728887.cos.ap-chengdu.myqcloud.com/%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F.gif)

### 2  选择排序

**找到最大或最小的元素，把它排在队前或队尾，循而往复， 放到已排序序列的末尾**

![选择排序](https://tupian-1300728887.cos.ap-chengdu.myqcloud.com/%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F.gif)

### 3  插入排序

**通过构建有序序列，对于未排序数据，在已排序序列中从后向前扫描，找到相应位置并插入。**

![插入排序](https://tupian-1300728887.cos.ap-chengdu.myqcloud.com/%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F.gif)

### 4  希尔排序

**希尔排序是插入排序的一种，将数据分成几组，分别使用插入排序**

![希尔排序](https://tupian-1300728887.cos.ap-chengdu.myqcloud.com/%E5%B8%8C%E5%B0%94%E6%8E%92%E5%BA%8F.jpg)

### 5  快速排序

**从序列中挑出一个元素（基准），把小于（大于）基准的元素放在基准前边（后边）**

![快速排序](https://tupian-1300728887.cos.ap-chengdu.myqcloud.com/%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F.gif)

### 6  归并排序

 **分治法，先递归分解数据，在合并数组；比较两个数组最前边的数，谁小谁先取**

![归并排序](https://tupian-1300728887.cos.ap-chengdu.myqcloud.com/%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F.gif)

### 7  搜索

#### 7.1  顺序查找

#### 7.2  二分法查找

#### 7.3  二叉树查找

#### 7.4  哈希查找

# （十）大数据

# 奇点控股

面试题

一、python的语言特性

- 简单、易学、免费、开源、高级语言、可移植性、解释型语言、面向对象、可扩展性、丰富的库、规范的代码
  - 高级语言：不用考虑内存一类的底层细节
  - 可移植性：无需修改，可在多平台上运行
  - 解释型语言： 在运行程序的时候才翻译，专门有一个解释器去进行翻译，每个语句都是执行的时候才翻译。效率比较低，依赖解释器，跨 平台性好 
  - 编译型语言： 程序在执行之前需要一个专门的编译过程，把程序编译成 为机器语言的文件，运行时不需要重新翻译，直接使用编译的结果就行了。程序执行效率高，依赖编译器，跨平台性差些
  - 可扩展性： 如果你需要你的一段关键代码运行得更快或者希望某些算法不公开，你可以把你的部分程序用C或C++编写，然后在你的Python程序中使用它们 

二、*args和**kwargs的区别

- 都是不定长参数

  - *args：将参数打包成元组进行传参

  - **kwargs：将参数打包成字典进行传参

三、

```python
def main():    
	a = 'hello'    
	b = a    
	a = b + 'world'    
	print(a)    
	print(b)
main()
# helloworld
# hello
```

四、TCP/IP协议分几层，TCP、UDP、HTTP分别在哪一层

- 四层：网络接口层、网络层、传输层（TCP、UDP）、应用层（HTTP）

五、

```python
def main():    
    try:        
        a = 'str'        
        b = 123        
        print(a + b)    
    except:        
        print('except')    
    else:        
        print('else')    
    finally:        
        print('finally')
main()
# except
# finally
```

## 总结

- **python中的魔法方法**

  ```python
  __init__(self)	# 在创建一个对象是默认被调用，不需要手动调用
  __str__(self)	# 用来显示信息，需要return一个数据
  __del__(self)	# 当删除对象时，默认被调用
  __new__(self)	# 才是实例化对象调用的第一个方法，它只取下 cls 参数，并把 其他参数传给 __init__
  __call__(self)	# 允许一个类的实例像函数一样被调用 。
  __getitem__(self)		# 定义获取容器中指定元素的行为，相当于 self[key] 。
  __getattr__(self) 	# 定义当用户试图访问一个不存在属性的时候的行为 。
  __setattr__(self) 	# 定义当一个属性被设置的时候的行为 。
  __getattribute__(self) 	# 定义当一个属性被访问的时候的行为 。
  ```

- **可变与不可变类型**

  - **指内存中的那块内容（value）是否可以发生改变**
  - 可变类型：不需要申请新内存，在原有基础上改变
  - 不可变类型：必须在内存中新申请一块区域

- **冒泡排序**

```python
def bubble_sort(alist):
    for j in range(len(alist)-1, 0, -1):
        for i in range(j):
            if alist[i] > alist[i+1]:
                alist[i], alist[i+1] = alist[i+1], alist[i]
```

- **is和==的区别**

  -  都是对对象进行比较判断作用的
  -  ==（比较运算法），用来判断两个对象的value值
  -  is（同一性运算符），用来判断两个对象的唯一身份标识，id地址

  只有**数值型（-5~256）和字符串**型的情况下，a is b才为True，当a和b是**tuple，list，dict**或**set**型时，a is b为False。 

- **python默认递归限制1000or998**

  - 修改限制

    ```python
    import sys
    sys.setrecursionlimit(1500)
    ```

- **数据量大情况下Paginator的缺点**

  - 查询效率慢的问题
  - **PageHelper的分页功能是通过Limit拼接SQL实现的** 

# 中科软总结

- 项目用了几台服务器

  |             用途             | 服务器 |
  | :--------------------------: | :----: |
  |   Nginx反向代理和静态文件    |   1    |
  |         主业务服务器         |   1    |
  | celery异步任务broker和worker |   2    |
  |        MySQL读写分离         |   2    |
  |            redis             |   1    |
  |          **共计**：          | **7**  |
